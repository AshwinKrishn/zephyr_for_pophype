#include <zephyr.h>
#include <drivers/virtualization/ivshmem.h>
#include <stdio.h>
enum request_type{
        COMPUTE_VRANLC,
        COMPUTE_RANDLC,
        COMPUTE_LOG,

};
enum arg_type {
        CHAR,
        CHAR_P,
        DOUBLE,
        DOUBLE_P,
	INT

};
struct argument {
        uint32_t * location;
        uint32_t size;
        enum arg_type type;
};

typedef union
{
    double d;
    unsigned char s[8];
} Union_t;

// reverse little to big endian or vice versa as per requirement
double reverse_endian(double in)
{
    int i, j;
    unsigned char t;
    Union_t val;

    val.d = in;
    // swap MSB with LSB etc.
    for(i=0, j=7; i < j; i++, j--)
    {
        t = val.s[i];
        val.s[i] = val.s[j];
        val.s[j] = t;
    }
    return val.d;
}

struct offload_struct{
        uint32_t new_request ;
	enum request_type type;
        struct argument args[8];
};
struct handshake
{
        uint32_t present;
        char arch[10];
};
struct shared_area
{
        volatile void * write_area;
        volatile void * read_area;
};
  typedef struct {
      unsigned int mantissa_low:32;     
      unsigned int mantissa_high:20;
      unsigned int exponent:11;        
      unsigned int sign:1;
    } tDoubleStruct;
void main()
{
	printf("arm64 app started\n");
	volatile struct shared_area rw_buf = {
                .write_area = (void*)0x9f000000,
                .read_area  = (void*)0x90000000
        };
	*((uint32_t*)rw_buf.write_area) = 0x00000000 ;
	struct handshake hnsk = {
                .present = 0xE00E0EE0,
        };
	struct handshake in_hnsk;
	memcpy(hnsk.arch, "ARM",4);
	memcpy((void*)&in_hnsk,rw_buf.read_area,sizeof(struct shared_area)); 	
	if(in_hnsk.present  == 0x1FF1F11F)
        {
        	printf("Already other core %s present in memory.\n",in_hnsk.arch);
		memcpy(rw_buf.write_area,(void*)&hnsk,sizeof(struct shared_area));
	}
	else{
                printf("Attempting connection with other core ::\n");
                 static uint64_t l = 0;
		while(1)
                {
                        volatile struct handshake * other = (struct handshake*)rw_buf.read_area;
			if(other->present == 0x1FF1F11F)
			{
                                printf("Other core of type x86 now conected \n");
                        	break;
			}
			else
			{
				if(l % 9000000 == 0){
                                        printf("waiting for other core\n");
                        		memcpy((void*)rw_buf.write_area,(void*)&hnsk,sizeof(struct shared_area));
				}
                                l++;
			}
                }
        }
	while(1)
	{
		struct offload_struct *  inp = (struct offload_struct *)rw_buf.read_area ;
		if(inp->new_request == 0xF00F0FF0)
		{
			printf("A request came\n");
			double arg = *((double*)inp->args[1].location) ;
			printf("arg value is %f\n",arg);
			arg = reverse_endian(arg);
			printf("Size of float is %d\n",sizeof(double));
			printf("Args are %d , %f , %f and %f\n", *inp->args[0].location,*(double*)inp->args[1].location,*(double*)inp->args[2].location,(double*)*inp->args[3].location);
			break;	

		}
	}
	printf("ARM_kernel_exiting\n");
     	*((uint32_t*)rw_buf.read_area) = 0x00000000 ;
     	*((uint32_t*)rw_buf.write_area) = 0x00000000 ;
	while(1);
}
