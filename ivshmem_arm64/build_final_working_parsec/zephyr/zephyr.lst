
zephyr.elf:     file format elf64-littleaarch64


Disassembly of section text:

00000000a0000000 <__text_region_start>:
#define HEADER_FLAGS	(HEADER_PGSIZE << 1)

_ASM_FILE_PROLOGUE

SECTION_SUBSEC_FUNC(image_header,_image_header_section,_image_header)
	b	__start				// branch to kernel start
    a0000000:	140003ff 	b	a0000ffc <__reset>
	...
    a0000010:	a009b158 	.word	0xa009b158
    a0000014:	00000000 	.word	0x00000000
    a0000018:	00000002 	.word	0x00000002
	...
    a0000038:	644d5241 	.word	0x644d5241
    a000003c:	00000000 	.word	0x00000000

00000000a0000040 <_vector_start>:
	...

00000000a00000a0 <_kobject_text_area_used>:
	...

00000000a0000800 <_vector_table>:
	/* The whole table must be 2K aligned */
	.align 11

	/* Current EL with SP0 / Synchronous */
	.align 7
	z_arm64_enter_exc x0, x1
    a0000800:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    a0000810:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    a0000820:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    a0000830:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    a0000840:	927ff800 8b010000 d51bd060 140023cd     ........`....#..
	b	z_arm64_sync_exc
    a0000850:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000860:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000870:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Current EL with SP0 / IRQ */
	.align 7
	z_arm64_enter_exc x0, x1
    a0000880:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    a0000890:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    a00008a0:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    a00008b0:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    a00008c0:	927ff800 8b010000 d51bd060 14000205     ........`.......
#ifdef CONFIG_GEN_SW_ISR_TABLE
	b 	_isr_wrapper
    a00008d0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a00008e0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a00008f0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
	b	z_irq_spurious
#endif

	/* Current EL with SP0 / FIQ */
	.align 7
	b 	.
    a0000900:	14000000 d503201f d503201f d503201f     ..... ... ... ..
    a0000910:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000920:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000930:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000940:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000950:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000960:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000970:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Current EL with SP0 / SError */
	.align 7
	z_arm64_enter_exc x0, x1
    a0000980:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    a0000990:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    a00009a0:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    a00009b0:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    a00009c0:	927ff800 8b010000 d51bd060 1400240e     ........`....$..
	b	z_arm64_serror
    a00009d0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a00009e0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a00009f0:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Current EL with SPx / Synchronous */
	.align 7
	z_arm64_enter_exc x0, x1
    a0000a00:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    a0000a10:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    a0000a20:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    a0000a30:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    a0000a40:	927ff800 8b010000 d51bd060 1400234d     ........`...M#..
	b	z_arm64_sync_exc
    a0000a50:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000a60:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000a70:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Current EL with SPx / IRQ */
	.align 7
	z_arm64_enter_exc x0, x1
    a0000a80:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    a0000a90:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    a0000aa0:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    a0000ab0:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    a0000ac0:	927ff800 8b010000 d51bd060 14000185     ........`.......
#ifdef CONFIG_GEN_SW_ISR_TABLE
	b 	_isr_wrapper
    a0000ad0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000ae0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000af0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
	b	z_irq_spurious
#endif

	/* Current EL with SPx / FIQ */
	.align 7
	b	.
    a0000b00:	14000000 d503201f d503201f d503201f     ..... ... ... ..
    a0000b10:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000b20:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000b30:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000b40:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000b50:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000b60:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000b70:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Current EL with SPx / SError */
	.align 7
	z_arm64_enter_exc x0, x1
    a0000b80:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    a0000b90:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    a0000ba0:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    a0000bb0:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    a0000bc0:	927ff800 8b010000 d51bd060 1400238e     ........`....#..
	b	z_arm64_serror
    a0000bd0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000be0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000bf0:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Lower EL using AArch64 / Synchronous */
	.align 7
	z_arm64_enter_exc x0, x1
    a0000c00:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    a0000c10:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    a0000c20:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    a0000c30:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    a0000c40:	927ff800 8b010000 d51bd060 140022cd     ........`...."..
	b	z_arm64_sync_exc
    a0000c50:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000c60:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000c70:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Lower EL using AArch64 / IRQ */
	.align 7
	z_arm64_enter_exc x0, x1
    a0000c80:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    a0000c90:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    a0000ca0:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    a0000cb0:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    a0000cc0:	927ff800 8b010000 d51bd060 14000105     ........`.......
#ifdef CONFIG_GEN_SW_ISR_TABLE
	b 	_isr_wrapper
    a0000cd0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000ce0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000cf0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
	b	z_irq_spurious
#endif

	/* Lower EL using AArch64 / FIQ */
	.align 7
	b	.
    a0000d00:	14000000 d503201f d503201f d503201f     ..... ... ... ..
    a0000d10:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000d20:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000d30:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000d40:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000d50:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000d60:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000d70:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Lower EL using AArch64 / SError */
	.align 7
	z_arm64_enter_exc x0, x1
    a0000d80:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    a0000d90:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    a0000da0:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    a0000db0:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    a0000dc0:	927ff800 8b010000 d51bd060 1400230e     ........`....#..
	b	z_arm64_serror
    a0000dd0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000de0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000df0:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Lower EL using AArch32 / Synchronous */
	.align 7
	b	.
    a0000e00:	14000000 d503201f d503201f d503201f     ..... ... ... ..
    a0000e10:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000e20:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000e30:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000e40:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000e50:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000e60:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000e70:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Lower EL using AArch32 / IRQ */
	.align 7
	b	.
    a0000e80:	14000000 d503201f d503201f d503201f     ..... ... ... ..
    a0000e90:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000ea0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000eb0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000ec0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000ed0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000ee0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000ef0:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Lower EL using AArch32 / FIQ */
	.align 7
	b	.
    a0000f00:	14000000 d503201f d503201f d503201f     ..... ... ... ..
    a0000f10:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000f20:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000f30:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000f40:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000f50:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000f60:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    a0000f70:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Lower EL using AArch32 / SError */
	.align 7
	b	.
    a0000f80:	14000000                                ....

00000000a0000f84 <_vector_end>:
    a0000f84:	00000000 	udf	#0

00000000a0000f88 <__reset_prep_c>:
 */

GTEXT(__reset_prep_c)
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__reset_prep_c)
	/* return address: x23 */
	mov	x23, x30
    a0000f88:	aa1e03f7 	mov	x23, x30

	switch_el x0, 3f, 2f, 1f
    a0000f8c:	d5384240 	mrs	x0, currentel
    a0000f90:	f100301f 	cmp	x0, #0xc
    a0000f94:	540000a0 	b.eq	a0000fa8 <__reset_prep_c+0x20>  // b.none
    a0000f98:	f100201f 	cmp	x0, #0x8
    a0000f9c:	54000100 	b.eq	a0000fbc <__reset_prep_c+0x34>  // b.none
    a0000fa0:	f100101f 	cmp	x0, #0x4
    a0000fa4:	54000180 	b.eq	a0000fd4 <__reset_prep_c+0x4c>  // b.none
3:
	/* Reinitialize SCTLR from scratch in EL3 */
	ldr	w0, =(SCTLR_EL3_RES1 | SCTLR_I_BIT | SCTLR_SA_BIT)
    a0000fa8:	18000600 	ldr	w0, a0001068 <switch_el+0x58>
	msr	sctlr_el3, x0
    a0000fac:	d51e1000 	msr	sctlr_el3, x0

	/* Custom plat prep_c init */
	bl	z_arm64_el3_plat_prep_c
    a0000fb0:	940020b0 	bl	a0009270 <z_arm64_el3_plat_prep_c>

	/* Set SP_EL1 */
	msr     sp_el1, x24
    a0000fb4:	d51c4118 	msr	sp_el1, x24

	b	out
    a0000fb8:	1400000d 	b	a0000fec <out>
2:
	/* Disable alignment fault checking */
	mrs	x0, sctlr_el2
    a0000fbc:	d53c1000 	mrs	x0, sctlr_el2
	bic	x0, x0, SCTLR_A_BIT
    a0000fc0:	927ef800 	and	x0, x0, #0xfffffffffffffffd
	msr	sctlr_el2, x0
    a0000fc4:	d51c1000 	msr	sctlr_el2, x0

	/* Custom plat prep_c init */
	bl	z_arm64_el2_plat_prep_c
    a0000fc8:	940020ab 	bl	a0009274 <z_arm64_el2_plat_prep_c>

	/* Set SP_EL1 */
	msr     sp_el1, x24
    a0000fcc:	d51c4118 	msr	sp_el1, x24

	b	out
    a0000fd0:	14000007 	b	a0000fec <out>
1:
	/* Disable alignment fault checking */
	mrs	x0, sctlr_el1
    a0000fd4:	d5381000 	mrs	x0, sctlr_el1
	bic	x0, x0, SCTLR_A_BIT
    a0000fd8:	927ef800 	and	x0, x0, #0xfffffffffffffffd
	msr	sctlr_el1, x0
    a0000fdc:	d5181000 	msr	sctlr_el1, x0

	/* Custom plat prep_c init */
	bl	z_arm64_el1_plat_prep_c
    a0000fe0:	940020a6 	bl	a0009278 <z_arm64_el1_plat_prep_c>

	/* Set SP_EL1. We cannot use sp_el1 at EL1 */
	msr     SPSel, #1
    a0000fe4:	d50041bf 	msr	spsel, #0x1
	mov     sp, x24
    a0000fe8:	9100031f 	mov	sp, x24

00000000a0000fec <out>:
out:
	isb
    a0000fec:	d5033fdf 	isb

	/* Select SP_EL0 */
	msr	SPSel, #0
    a0000ff0:	d50040bf 	msr	spsel, #0x0

	/* Initialize stack */
	mov	sp, x24
    a0000ff4:	9100031f 	mov	sp, x24

	ret	x23
    a0000ff8:	d65f02e0 	ret	x23

00000000a0000ffc <__reset>:
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__reset)

GTEXT(__start)
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__start)
	/* Mask all exceptions */
	msr	DAIFSet, #0xf
    a0000ffc:	d5034fdf 	msr	daifset, #0xf
primary_core:
	/* advertise ourself */
	str	x1, [x0, #BOOT_PARAM_MPID_OFFSET]
#endif
	/* load primary stack and entry point */
	ldr	x24, =(z_interrupt_stacks + CONFIG_ISR_STACK_SIZE)
    a0001000:	58000398 	ldr	x24, a0001070 <switch_el+0x60>
	ldr	x25, =z_arm64_prep_c
    a0001004:	580003b9 	ldr	x25, a0001078 <switch_el+0x68>
2:
	/* Prepare for calling C code */
	bl	__reset_prep_c
    a0001008:	97ffffe0 	bl	a0000f88 <__reset_prep_c>

	/* Platform hook for highest EL */
	bl	z_arm64_el_highest_init
    a000100c:	940020e4 	bl	a000939c <z_arm64_el_highest_init>

00000000a0001010 <switch_el>:

switch_el:
	switch_el x0, 3f, 2f, 1f
    a0001010:	d5384240 	mrs	x0, currentel
    a0001014:	f100301f 	cmp	x0, #0xc
    a0001018:	540000a0 	b.eq	a000102c <switch_el+0x1c>  // b.none
    a000101c:	f100201f 	cmp	x0, #0x8
    a0001020:	540000e0 	b.eq	a000103c <switch_el+0x2c>  // b.none
    a0001024:	f100101f 	cmp	x0, #0x4
    a0001028:	54000180 	b.eq	a0001058 <switch_el+0x48>  // b.none
3:
	/* EL3 init */
	bl	z_arm64_el3_init
    a000102c:	94002107 	bl	a0009448 <z_arm64_el3_init>

	/* Get next EL */
	adr	x0, switch_el
    a0001030:	10ffff00 	adr	x0, a0001010 <switch_el>
	bl	z_arm64_el3_get_next_el
    a0001034:	9400219a 	bl	a000969c <z_arm64_el3_get_next_el>
	eret
    a0001038:	d69f03e0 	eret

2:
	/* EL2 init */
	bl	z_arm64_el2_init
    a000103c:	94002135 	bl	a0009510 <z_arm64_el2_init>

	/* Move to EL1 with all exceptions masked */
	mov_imm	x0, (SPSR_DAIF_MASK | SPSR_MODE_EL1T)
    a0001040:	d2a00000 	movz	x0, #0x0, lsl #16
    a0001044:	f2807880 	movk	x0, #0x3c4
	msr	spsr_el2, x0
    a0001048:	d51c4000 	msr	spsr_el2, x0

	adr	x0, 1f
    a000104c:	10000060 	adr	x0, a0001058 <switch_el+0x48>
	msr	elr_el2, x0
    a0001050:	d51c4020 	msr	elr_el2, x0
	eret
    a0001054:	d69f03e0 	eret

1:
	/* EL1 init */
	bl	z_arm64_el1_init
    a0001058:	94002166 	bl	a00095f0 <z_arm64_el1_init>

	/* Enable SError interrupts */
	msr	DAIFClr, #(DAIFCLR_ABT_BIT)
    a000105c:	d50344ff 	msr	daifclr, #0x4
	isb
    a0001060:	d5033fdf 	isb

	ret	x25  /* either z_arm64_prep_c or z_arm64_secondary_prep_c */
    a0001064:	d65f0320 	ret	x25
    a0001068:	30c51838 	.word	0x30c51838
    a000106c:	00000000 	udf	#0
    a0001070:	a0093000 	.word	0xa0093000
    a0001074:	00000000 	.word	0x00000000
    a0001078:	a000923c 	.word	0xa000923c
    a000107c:	00000000 	.word	0x00000000

00000000a0001080 <z_arm64_do_syscall>:
 */

GTEXT(z_arm64_do_syscall)
SECTION_FUNC(TEXT, z_arm64_do_syscall)
	/* Recover the syscall parameters from the ESF */
	ldp	x0, x1, [sp, ___esf_t_x0_x1_OFFSET]
    a0001080:	a94007e0 	ldp	x0, x1, [sp]
	ldp	x2, x3, [sp, ___esf_t_x2_x3_OFFSET]
    a0001084:	a9410fe2 	ldp	x2, x3, [sp, #16]
	ldp	x4, x5, [sp, ___esf_t_x4_x5_OFFSET]
    a0001088:	a94217e4 	ldp	x4, x5, [sp, #32]

	/* Use the ESF as SSF */
	mov	x6, sp
    a000108c:	910003e6 	mov	x6, sp

	/* Recover the syscall ID */
	ldr	x8, [sp, ___esf_t_x8_x9_OFFSET]
    a0001090:	f94023e8 	ldr	x8, [sp, #64]

	/* Check whether the ID is valid */
	ldr	x9, =K_SYSCALL_LIMIT
    a0001094:	580001a9 	ldr	x9, a00010c8 <valid_syscall_id+0x20>
	cmp	x8, x9
    a0001098:	eb09011f 	cmp	x8, x9
	blo	valid_syscall_id
    a000109c:	54000063 	b.cc	a00010a8 <valid_syscall_id>  // b.lo, b.ul, b.last

	/* Save the bad ID for handler_bad_syscall() */
	mov	x0, x8
    a00010a0:	aa0803e0 	mov	x0, x8
	ldr	x8, =K_SYSCALL_BAD
    a00010a4:	58000168 	ldr	x8, a00010d0 <valid_syscall_id+0x28>

00000000a00010a8 <valid_syscall_id>:

valid_syscall_id:
	ldr	x9, =_k_syscall_table
    a00010a8:	58000189 	ldr	x9, a00010d8 <valid_syscall_id+0x30>
	ldr	x9, [x9, x8, lsl #3]
    a00010ac:	f8687929 	ldr	x9, [x9, x8, lsl #3]

	/* Jump into the syscall */
	msr	daifclr, #(DAIFSET_IRQ_BIT)
    a00010b0:	d50342ff 	msr	daifclr, #0x2
	blr	x9
    a00010b4:	d63f0120 	blr	x9
	msr	daifset, #(DAIFSET_IRQ_BIT)
    a00010b8:	d50342df 	msr	daifset, #0x2

	/* Save the return value into the ESF */
	str	x0, [sp, ___esf_t_x0_x1_OFFSET]
    a00010bc:	f90003e0 	str	x0, [sp]

	/* Return from exception */
	b	z_arm64_exit_exc
    a00010c0:	14002255 	b	a0009a14 <z_arm64_exit_exc>
    a00010c4:	00000000 	udf	#0
    a00010c8:	00000164 	.word	0x00000164
    a00010cc:	00000000 	.word	0x00000000
    a00010d0:	00000163 	.word	0x00000163
    a00010d4:	00000000 	.word	0x00000000
    a00010d8:	a0024838 	.word	0xa0024838
    a00010dc:	00000000 	.word	0x00000000

00000000a00010e0 <_isr_wrapper>:

GTEXT(_isr_wrapper)
SECTION_FUNC(TEXT, _isr_wrapper)

	/* ++(_kernel->nested) to be checked by arch_is_in_isr() */
	inc_nest_counter x0, x1
    a00010e0:	d53bd060 	mrs	x0, tpidrro_el0
    a00010e4:	927db000 	and	x0, x0, #0xfffffffffff8
    a00010e8:	f9400001 	ldr	x1, [x0]
    a00010ec:	91000421 	add	x1, x1, #0x1
    a00010f0:	f9000001 	str	x1, [x0]
	bl	sys_trace_isr_enter
#endif

	/* Get active IRQ number from the interrupt controller */
#if !defined(CONFIG_ARM_CUSTOM_INTERRUPT_CONTROLLER)
	bl	arm_gic_get_active
    a00010f4:	940030b1 	bl	a000d3b8 <arm_gic_get_active>
#if CONFIG_GIC_VER >= 3
	/*
	 * Ignore Special INTIDs 1020..1023 see 2.2.1 of Arm Generic Interrupt Controller
	 * Architecture Specification GIC architecture version 3 and version 4
	 */
	cmp	x0, 1019
    a00010f8:	f10fec1f 	cmp	x0, #0x3fb
	b.le	oob
    a00010fc:	5400008d 	b.le	a000110c <oob>
	cmp	x0, 1023
    a0001100:	f10ffc1f 	cmp	x0, #0x3ff
	b.gt	oob
    a0001104:	5400004c 	b.gt	a000110c <oob>
	b	spurious_continue
    a0001108:	1400000c 	b	a0001138 <spurious_continue>

00000000a000110c <oob>:

oob:
#endif
	/* IRQ out of bounds */
	mov	x1, #(CONFIG_NUM_IRQS - 1)
    a000110c:	d2801b61 	mov	x1, #0xdb                  	// #219
	cmp	x0, x1
    a0001110:	eb01001f 	cmp	x0, x1
	b.hi	spurious_continue
    a0001114:	54000128 	b.hi	a0001138 <spurious_continue>  // b.pmore

	stp	x0, xzr, [sp, #-16]!
    a0001118:	a9bf7fe0 	stp	x0, xzr, [sp, #-16]!

	/* Retrieve the interrupt service routine */
	ldr	x1, =_sw_isr_table
    a000111c:	580002e1 	ldr	x1, a0001178 <exit+0x8>
	add	x1, x1, x0, lsl #4	/* table is 16-byte wide */
    a0001120:	8b001021 	add	x1, x1, x0, lsl #4
	ldp	x0, x3, [x1] /* arg in x0, ISR in x3 */
    a0001124:	a9400c20 	ldp	x0, x3, [x1]

	/*
	 * Call the ISR. Unmask and mask again the IRQs to support nested
	 * exception handlers
	 */
	msr	daifclr, #(DAIFCLR_IRQ_BIT)
    a0001128:	d50342ff 	msr	daifclr, #0x2
	blr	x3
    a000112c:	d63f0060 	blr	x3
	msr	daifset, #(DAIFSET_IRQ_BIT)
    a0001130:	d50342df 	msr	daifset, #0x2

	/* Signal end-of-interrupt */
	ldp	x0, xzr, [sp], #16
    a0001134:	a8c17fe0 	ldp	x0, xzr, [sp], #16

00000000a0001138 <spurious_continue>:

spurious_continue:
#if !defined(CONFIG_ARM_CUSTOM_INTERRUPT_CONTROLLER)
	bl	arm_gic_eoi
    a0001138:	940030a8 	bl	a000d3d8 <arm_gic_eoi>
#ifdef CONFIG_TRACING
	bl	sys_trace_isr_exit
#endif

	/* if (--(_kernel->nested) != 0) exit */
	dec_nest_counter x0, x1
    a000113c:	d53bd060 	mrs	x0, tpidrro_el0
    a0001140:	927db000 	and	x0, x0, #0xfffffffffff8
    a0001144:	f9400001 	ldr	x1, [x0]
    a0001148:	f1000421 	subs	x1, x1, #0x1
    a000114c:	f9000001 	str	x1, [x0]

	bne	exit
    a0001150:	54000101 	b.ne	a0001170 <exit>  // b.any
	 * - The next thread to schedule in x0
	 * - The current thread in x1. This value is returned using the
	 *   **old_thread parameter, so we need to make space on the stack for
	 *   that.
	 */
	sub	sp, sp, #16
    a0001154:	d10043ff 	sub	sp, sp, #0x10
	mov	x0, sp
    a0001158:	910003e0 	mov	x0, sp
	bl	z_arch_get_next_switch_handle
    a000115c:	940021e7 	bl	a00098f8 <z_arch_get_next_switch_handle>
	ldp	x1, xzr, [sp], #16
    a0001160:	a8c17fe1 	ldp	x1, xzr, [sp], #16
	 */
	mov	x0, x1
	b	exit
switch:
#else
	cmp	x0, x1
    a0001164:	eb01001f 	cmp	x0, x1
	beq	exit
    a0001168:	54000040 	b.eq	a0001170 <exit>  // b.none
#endif
	/* Switch thread */
	bl	z_arm64_context_switch
    a000116c:	94002168 	bl	a000970c <z_arm64_context_switch>

00000000a0001170 <exit>:

exit:
#ifdef CONFIG_STACK_SENTINEL
	bl	z_check_stack_sentinel
#endif
	b	z_arm64_exit_exc
    a0001170:	14002229 	b	a0009a14 <z_arm64_exit_exc>
    a0001174:	00000000 	udf	#0
    a0001178:	a00230c0 	.word	0xa00230c0
    a000117c:	00000000 	.word	0x00000000

00000000a0001180 <_OffsetAbsSyms>:
GEN_NAMED_OFFSET_SYM(arm_smccc_res_t, a4, a4_a5);
GEN_NAMED_OFFSET_SYM(arm_smccc_res_t, a6, a6_a7);

#endif /* CONFIG_HAS_ARM_SMCCC */

GEN_ABS_SYM_END
    a0001180:	d503201f 	nop
    a0001184:	d65f03c0 	ret

00000000a0001188 <vranlc>:
int tid;



void vranlc( int n, double *x, double a, double y[] )
{
    a0001188:	d10243ff 	sub	sp, sp, #0x90
    a000118c:	b9001fe0 	str	w0, [sp, #28]
    a0001190:	f9000be1 	str	x1, [sp, #16]
    a0001194:	fd0007e0 	str	d0, [sp, #8]
    a0001198:	f90003e2 	str	x2, [sp]
  const double r23 = 1.1920928955078125e-07;
    a000119c:	d2e7d000 	mov	x0, #0x3e80000000000000    	// #4503599627370496000
    a00011a0:	9e670000 	fmov	d0, x0
    a00011a4:	fd0043e0 	str	d0, [sp, #128]
  const double r46 = r23 * r23;
    a00011a8:	fd4043e0 	ldr	d0, [sp, #128]
    a00011ac:	1e600800 	fmul	d0, d0, d0
    a00011b0:	fd003fe0 	str	d0, [sp, #120]
  const double t23 = 8.388608e+06;
    a00011b4:	d2e82c00 	mov	x0, #0x4160000000000000    	// #4710765210229538816
    a00011b8:	9e670000 	fmov	d0, x0
    a00011bc:	fd003be0 	str	d0, [sp, #112]
  const double t46 = t23 * t23;
    a00011c0:	fd403be0 	ldr	d0, [sp, #112]
    a00011c4:	1e600800 	fmul	d0, d0, d0
    a00011c8:	fd0037e0 	str	d0, [sp, #104]
  int i;

  //--------------------------------------------------------------------
  //  Break A into two parts such that A = 2^23 * A1 + A2.
  //--------------------------------------------------------------------
  t1 = r23 * a;
    a00011cc:	fd4043e1 	ldr	d1, [sp, #128]
    a00011d0:	fd4007e0 	ldr	d0, [sp, #8]
    a00011d4:	1e600820 	fmul	d0, d1, d0
    a00011d8:	fd0033e0 	str	d0, [sp, #96]
  a1 = (int) t1;
    a00011dc:	fd4033e0 	ldr	d0, [sp, #96]
    a00011e0:	1e780000 	fcvtzs	w0, d0
    a00011e4:	1e620000 	scvtf	d0, w0
    a00011e8:	fd002fe0 	str	d0, [sp, #88]
  a2 = a - t23 * a1;
    a00011ec:	fd403be1 	ldr	d1, [sp, #112]
    a00011f0:	fd402fe0 	ldr	d0, [sp, #88]
    a00011f4:	1e600820 	fmul	d0, d1, d0
    a00011f8:	fd4007e1 	ldr	d1, [sp, #8]
    a00011fc:	1e603820 	fsub	d0, d1, d0
    a0001200:	fd002be0 	str	d0, [sp, #80]

  //--------------------------------------------------------------------
  //  Generate N results.   This loop is not vectorizable.
  //--------------------------------------------------------------------
  for ( i = 0; i < n; i++ ) {
    a0001204:	b9008fff 	str	wzr, [sp, #140]
    a0001208:	14000044 	b	a0001318 <vranlc+0x190>
    //--------------------------------------------------------------------
    //  Break X into two parts such that X = 2^23 * X1 + X2, compute
    //  Z = A1 * X2 + A2 * X1  (mod 2^23), and then
    //  X = 2^23 * Z + A2 * X2  (mod 2^46).
    //--------------------------------------------------------------------
    t1 = r23 * (*x);
    a000120c:	f9400be0 	ldr	x0, [sp, #16]
    a0001210:	fd400000 	ldr	d0, [x0]
    a0001214:	fd4043e1 	ldr	d1, [sp, #128]
    a0001218:	1e600820 	fmul	d0, d1, d0
    a000121c:	fd0033e0 	str	d0, [sp, #96]
    x1 = (int) t1;
    a0001220:	fd4033e0 	ldr	d0, [sp, #96]
    a0001224:	1e780000 	fcvtzs	w0, d0
    a0001228:	1e620000 	scvtf	d0, w0
    a000122c:	fd0027e0 	str	d0, [sp, #72]
    x2 = *x - t23 * x1;
    a0001230:	f9400be0 	ldr	x0, [sp, #16]
    a0001234:	fd400001 	ldr	d1, [x0]
    a0001238:	fd403be2 	ldr	d2, [sp, #112]
    a000123c:	fd4027e0 	ldr	d0, [sp, #72]
    a0001240:	1e600840 	fmul	d0, d2, d0
    a0001244:	1e603820 	fsub	d0, d1, d0
    a0001248:	fd0023e0 	str	d0, [sp, #64]
    t1 = a1 * x2 + a2 * x1;
    a000124c:	fd402fe1 	ldr	d1, [sp, #88]
    a0001250:	fd4023e0 	ldr	d0, [sp, #64]
    a0001254:	1e600821 	fmul	d1, d1, d0
    a0001258:	fd402be2 	ldr	d2, [sp, #80]
    a000125c:	fd4027e0 	ldr	d0, [sp, #72]
    a0001260:	1e600840 	fmul	d0, d2, d0
    a0001264:	1e602820 	fadd	d0, d1, d0
    a0001268:	fd0033e0 	str	d0, [sp, #96]
    t2 = (int) (r23 * t1);
    a000126c:	fd4043e1 	ldr	d1, [sp, #128]
    a0001270:	fd4033e0 	ldr	d0, [sp, #96]
    a0001274:	1e600820 	fmul	d0, d1, d0
    a0001278:	1e780000 	fcvtzs	w0, d0
    a000127c:	1e620000 	scvtf	d0, w0
    a0001280:	fd001fe0 	str	d0, [sp, #56]
    z = t1 - t23 * t2;
    a0001284:	fd403be1 	ldr	d1, [sp, #112]
    a0001288:	fd401fe0 	ldr	d0, [sp, #56]
    a000128c:	1e600820 	fmul	d0, d1, d0
    a0001290:	fd4033e1 	ldr	d1, [sp, #96]
    a0001294:	1e603820 	fsub	d0, d1, d0
    a0001298:	fd001be0 	str	d0, [sp, #48]
    t3 = t23 * z + a2 * x2;
    a000129c:	fd403be1 	ldr	d1, [sp, #112]
    a00012a0:	fd401be0 	ldr	d0, [sp, #48]
    a00012a4:	1e600821 	fmul	d1, d1, d0
    a00012a8:	fd402be2 	ldr	d2, [sp, #80]
    a00012ac:	fd4023e0 	ldr	d0, [sp, #64]
    a00012b0:	1e600840 	fmul	d0, d2, d0
    a00012b4:	1e602820 	fadd	d0, d1, d0
    a00012b8:	fd0017e0 	str	d0, [sp, #40]
    t4 = (int) (r46 * t3) ;
    a00012bc:	fd403fe1 	ldr	d1, [sp, #120]
    a00012c0:	fd4017e0 	ldr	d0, [sp, #40]
    a00012c4:	1e600820 	fmul	d0, d1, d0
    a00012c8:	1e780000 	fcvtzs	w0, d0
    a00012cc:	1e620000 	scvtf	d0, w0
    a00012d0:	fd0013e0 	str	d0, [sp, #32]
    *x = t3 - t46 * t4;
    a00012d4:	fd4037e1 	ldr	d1, [sp, #104]
    a00012d8:	fd4013e0 	ldr	d0, [sp, #32]
    a00012dc:	1e600820 	fmul	d0, d1, d0
    a00012e0:	fd4017e1 	ldr	d1, [sp, #40]
    a00012e4:	1e603820 	fsub	d0, d1, d0
    a00012e8:	f9400be0 	ldr	x0, [sp, #16]
    a00012ec:	fd000000 	str	d0, [x0]
    y[1] = r46 * (*x);
    a00012f0:	f9400be0 	ldr	x0, [sp, #16]
    a00012f4:	fd400001 	ldr	d1, [x0]
    a00012f8:	f94003e0 	ldr	x0, [sp]
    a00012fc:	91002000 	add	x0, x0, #0x8
    a0001300:	fd403fe0 	ldr	d0, [sp, #120]
    a0001304:	1e600820 	fmul	d0, d1, d0
    a0001308:	fd000000 	str	d0, [x0]
  for ( i = 0; i < n; i++ ) {
    a000130c:	b9408fe0 	ldr	w0, [sp, #140]
    a0001310:	11000400 	add	w0, w0, #0x1
    a0001314:	b9008fe0 	str	w0, [sp, #140]
    a0001318:	b9408fe1 	ldr	w1, [sp, #140]
    a000131c:	b9401fe0 	ldr	w0, [sp, #28]
    a0001320:	6b00003f 	cmp	w1, w0
    a0001324:	54fff74b 	b.lt	a000120c <vranlc+0x84>  // b.tstop
  }

  return;
    a0001328:	d503201f 	nop
}
    a000132c:	910243ff 	add	sp, sp, #0x90
    a0001330:	d65f03c0 	ret

00000000a0001334 <main>:


void main()
{
    a0001334:	a9ad7bfd 	stp	x29, x30, [sp, #-304]!
    a0001338:	910003fd 	mov	x29, sp
    a000133c:	a90157f4 	stp	x20, x21, [sp, #16]
	printf("arm64 app started\n");
    a0001340:	d0000100 	adrp	x0, a0023000 <__rodata_region_start>
    a0001344:	913a6000 	add	x0, x0, #0xe98
    a0001348:	94002c25 	bl	a000c3dc <printf>
	volatile struct shared_area rw_buf = {
    a000134c:	d2b3e014 	mov	x20, #0x9f000000            	// #2667577344
    a0001350:	d2b20015 	mov	x21, #0x90000000            	// #2415919104
    a0001354:	a91057f4 	stp	x20, x21, [sp, #256]
                .write_area = (void*)0x9f000000,
                .read_area  = (void*)0x90000000
        };
	*((uint32_t*)rw_buf.write_area) = 0x00000000 ;
    a0001358:	f94083e0 	ldr	x0, [sp, #256]
    a000135c:	b900001f 	str	wzr, [x0]
	struct handshake hnsk = {
    a0001360:	a90f7fff 	stp	xzr, xzr, [sp, #240]
    a0001364:	5281dc00 	mov	w0, #0xee0                 	// #3808
    a0001368:	72bc01c0 	movk	w0, #0xe00e, lsl #16
    a000136c:	b900f3e0 	str	w0, [sp, #240]
                .present = 0xE00E0EE0,
        };
	struct handshake in_hnsk;
	memcpy(hnsk.arch, "ARM",4);
    a0001370:	9103c3e0 	add	x0, sp, #0xf0
    a0001374:	91001003 	add	x3, x0, #0x4
    a0001378:	d2800082 	mov	x2, #0x4                   	// #4
    a000137c:	d0000100 	adrp	x0, a0023000 <__rodata_region_start>
    a0001380:	913ac001 	add	x1, x0, #0xeb0
    a0001384:	aa0303e0 	mov	x0, x3
    a0001388:	94002ac4 	bl	a000be98 <memcpy>
	memcpy((void*)&in_hnsk,rw_buf.read_area,sizeof(struct shared_area)); 	
    a000138c:	f94087e1 	ldr	x1, [sp, #264]
    a0001390:	910383e0 	add	x0, sp, #0xe0
    a0001394:	d2800202 	mov	x2, #0x10                  	// #16
    a0001398:	94002ac0 	bl	a000be98 <memcpy>
	if(in_hnsk.present  == 0x1FF1F11F)
    a000139c:	b940e3e1 	ldr	w1, [sp, #224]
    a00013a0:	529e23e0 	mov	w0, #0xf11f                	// #61727
    a00013a4:	72a3fe20 	movk	w0, #0x1ff1, lsl #16
    a00013a8:	6b00003f 	cmp	w1, w0
    a00013ac:	54000181 	b.ne	a00013dc <main+0xa8>  // b.any
        {
        	printf("Already other core %s present in memory.\n",in_hnsk.arch);
    a00013b0:	910383e0 	add	x0, sp, #0xe0
    a00013b4:	91001000 	add	x0, x0, #0x4
    a00013b8:	aa0003e1 	mov	x1, x0
    a00013bc:	d0000100 	adrp	x0, a0023000 <__rodata_region_start>
    a00013c0:	913ae000 	add	x0, x0, #0xeb8
    a00013c4:	94002c06 	bl	a000c3dc <printf>
		memcpy(rw_buf.write_area,(void*)&hnsk,sizeof(struct shared_area));
    a00013c8:	f94083e0 	ldr	x0, [sp, #256]
    a00013cc:	9103c3e1 	add	x1, sp, #0xf0
    a00013d0:	d2800202 	mov	x2, #0x10                  	// #16
    a00013d4:	94002ab1 	bl	a000be98 <memcpy>
    a00013d8:	1400002e 	b	a0001490 <main+0x15c>
	}
	else{
                printf("Attempting connection with other core ::\n");
    a00013dc:	d0000100 	adrp	x0, a0023000 <__rodata_region_start>
    a00013e0:	913ba000 	add	x0, x0, #0xee8
    a00013e4:	94002bfe 	bl	a000c3dc <printf>
                 static uint64_t l = 0;
		while(1)
                {
                        volatile struct handshake * other = (struct handshake*)rw_buf.read_area;
    a00013e8:	f94087e0 	ldr	x0, [sp, #264]
    a00013ec:	f90097e0 	str	x0, [sp, #296]
			if(other->present == 0x1FF1F11F)
    a00013f0:	f94097e0 	ldr	x0, [sp, #296]
    a00013f4:	b9400001 	ldr	w1, [x0]
    a00013f8:	529e23e0 	mov	w0, #0xf11f                	// #61727
    a00013fc:	72a3fe20 	movk	w0, #0x1ff1, lsl #16
    a0001400:	6b00003f 	cmp	w1, w0
    a0001404:	540000a1 	b.ne	a0001418 <main+0xe4>  // b.any
			{
                                printf("Other core of type x86 now conected \n");
    a0001408:	d0000100 	adrp	x0, a0023000 <__rodata_region_start>
    a000140c:	913c6000 	add	x0, x0, #0xf18
    a0001410:	94002bf3 	bl	a000c3dc <printf>
                        	break;
    a0001414:	1400001f 	b	a0001490 <main+0x15c>
			}
			else
			{
				if(l % 9000000 == 0){
    a0001418:	d00001e0 	adrp	x0, a003f000 <l.0>
    a000141c:	91000000 	add	x0, x0, #0x0
    a0001420:	f9400001 	ldr	x1, [x0]
    a0001424:	d2822860 	mov	x0, #0x1143                	// #4419
    a0001428:	f2b8c2c0 	movk	x0, #0xc616, lsl #16
    a000142c:	f2df5680 	movk	x0, #0xfab4, lsl #32
    a0001430:	f2fdd360 	movk	x0, #0xee9b, lsl #48
    a0001434:	9bc07c20 	umulh	x0, x1, x0
    a0001438:	d357fc00 	lsr	x0, x0, #23
    a000143c:	d28a8802 	mov	x2, #0x5440                	// #21568
    a0001440:	f2a01122 	movk	x2, #0x89, lsl #16
    a0001444:	9b027c00 	mul	x0, x0, x2
    a0001448:	cb000020 	sub	x0, x1, x0
    a000144c:	f100001f 	cmp	x0, #0x0
    a0001450:	54000101 	b.ne	a0001470 <main+0x13c>  // b.any
                                        printf("waiting for other core\n");
    a0001454:	d0000100 	adrp	x0, a0023000 <__rodata_region_start>
    a0001458:	913d0000 	add	x0, x0, #0xf40
    a000145c:	94002be0 	bl	a000c3dc <printf>
                        		memcpy((void*)rw_buf.write_area,(void*)&hnsk,sizeof(struct shared_area));
    a0001460:	f94083e0 	ldr	x0, [sp, #256]
    a0001464:	9103c3e1 	add	x1, sp, #0xf0
    a0001468:	d2800202 	mov	x2, #0x10                  	// #16
    a000146c:	94002a8b 	bl	a000be98 <memcpy>
				}
                                l++;
    a0001470:	d00001e0 	adrp	x0, a003f000 <l.0>
    a0001474:	91000000 	add	x0, x0, #0x0
    a0001478:	f9400000 	ldr	x0, [x0]
    a000147c:	91000401 	add	x1, x0, #0x1
    a0001480:	d00001e0 	adrp	x0, a003f000 <l.0>
    a0001484:	91000000 	add	x0, x0, #0x0
    a0001488:	f9000001 	str	x1, [x0]
                {
    a000148c:	17ffffd7 	b	a00013e8 <main+0xb4>
			}
                }
        }
	blackscholes_main();
    a0001490:	9400026d 	bl	a0001e44 <blackscholes_main>
	while(1)
	{
		struct offload_struct *  inp = (struct offload_struct *)rw_buf.read_area ;
    a0001494:	f94087e0 	ldr	x0, [sp, #264]
    a0001498:	f90093e0 	str	x0, [sp, #288]
		if(inp->new_request == 0xF00F0FF0)
    a000149c:	f94093e0 	ldr	x0, [sp, #288]
    a00014a0:	b9400001 	ldr	w1, [x0]
    a00014a4:	5281fe00 	mov	w0, #0xff0                 	// #4080
    a00014a8:	72be01e0 	movk	w0, #0xf00f, lsl #16
    a00014ac:	6b00003f 	cmp	w1, w0
    a00014b0:	54ffff21 	b.ne	a0001494 <main+0x160>  // b.any
		{
		   if(inp->type == COMPUTE_VRANLC)	{	
    a00014b4:	f94093e0 	ldr	x0, [sp, #288]
    a00014b8:	b9400400 	ldr	w0, [x0, #4]
    a00014bc:	7100001f 	cmp	w0, #0x0
    a00014c0:	54001081 	b.ne	a00016d0 <main+0x39c>  // b.any
			printf("A request of type COMPUTE_VRANLC came\n");
    a00014c4:	d0000100 	adrp	x0, a0023000 <__rodata_region_start>
    a00014c8:	913d6000 	add	x0, x0, #0xf58
    a00014cc:	94002bc4 	bl	a000c3dc <printf>
			printf("Args are %d , %f , %f and %f\n", *inp->args[0].location,*(double*)inp->args[1].location,*(double*)inp->args[2].location,*(double*)inp->args[3].location);
    a00014d0:	f94093e0 	ldr	x0, [sp, #288]
    a00014d4:	f9400400 	ldr	x0, [x0, #8]
    a00014d8:	b9400001 	ldr	w1, [x0]
    a00014dc:	f94093e0 	ldr	x0, [sp, #288]
    a00014e0:	f9400c00 	ldr	x0, [x0, #24]
    a00014e4:	fd400000 	ldr	d0, [x0]
    a00014e8:	f94093e0 	ldr	x0, [sp, #288]
    a00014ec:	f9401400 	ldr	x0, [x0, #40]
    a00014f0:	fd400001 	ldr	d1, [x0]
    a00014f4:	f94093e0 	ldr	x0, [sp, #288]
    a00014f8:	f9401c00 	ldr	x0, [x0, #56]
    a00014fc:	fd400002 	ldr	d2, [x0]
    a0001500:	d0000100 	adrp	x0, a0023000 <__rodata_region_start>
    a0001504:	913e0000 	add	x0, x0, #0xf80
    a0001508:	94002bb5 	bl	a000c3dc <printf>
			vranlc(*(int*)inp->args[0].location,(double*)inp->args[1].location,*(double*)inp->args[2].location , (double*)inp->args[3].location);
    a000150c:	f94093e0 	ldr	x0, [sp, #288]
    a0001510:	f9400400 	ldr	x0, [x0, #8]
    a0001514:	b9400003 	ldr	w3, [x0]
    a0001518:	f94093e0 	ldr	x0, [sp, #288]
    a000151c:	f9400c01 	ldr	x1, [x0, #24]
    a0001520:	f94093e0 	ldr	x0, [sp, #288]
    a0001524:	f9401400 	ldr	x0, [x0, #40]
    a0001528:	fd400000 	ldr	d0, [x0]
    a000152c:	f94093e0 	ldr	x0, [sp, #288]
    a0001530:	f9401c00 	ldr	x0, [x0, #56]
    a0001534:	aa0003e2 	mov	x2, x0
    a0001538:	2a0303e0 	mov	w0, w3
    a000153c:	97ffff13 	bl	a0001188 <vranlc>
			printf("Post computation value of y is %f and value of x is %f\n",*((double*)inp->args[3].location), *((double*)inp->args[1].location));			
    a0001540:	f94093e0 	ldr	x0, [sp, #288]
    a0001544:	f9401c00 	ldr	x0, [x0, #56]
    a0001548:	fd400000 	ldr	d0, [x0]
    a000154c:	f94093e0 	ldr	x0, [sp, #288]
    a0001550:	f9400c00 	ldr	x0, [x0, #24]
    a0001554:	fd400001 	ldr	d1, [x0]
    a0001558:	d0000100 	adrp	x0, a0023000 <__rodata_region_start>
    a000155c:	913e8000 	add	x0, x0, #0xfa0
    a0001560:	94002b9f 	bl	a000c3dc <printf>
			
			//indicate that you have consumed the message
			*(uint32_t*)inp = ~(0xF00F0FF0);
    a0001564:	f94093e0 	ldr	x0, [sp, #288]
    a0001568:	529e01e1 	mov	w1, #0xf00f                	// #61455
    a000156c:	72a1fe01 	movk	w1, #0xff0, lsl #16
    a0001570:	b9000001 	str	w1, [x0]

			//Start replying
			struct offload_struct ofld_vranlc ;

			ofld_vranlc.new_request = 0xF00F0FF0;
    a0001574:	5281fe00 	mov	w0, #0xff0                 	// #4080
    a0001578:	72be01e0 	movk	w0, #0xf00f, lsl #16
    a000157c:	b9005be0 	str	w0, [sp, #88]
			void * write_pointer = (void*)((char*)rw_buf.write_area + 0x1000);
    a0001580:	f94083e0 	ldr	x0, [sp, #256]
    a0001584:	91400400 	add	x0, x0, #0x1, lsl #12
    a0001588:	f9008be0 	str	x0, [sp, #272]
			
			*((int*)write_pointer)  = *(int*)inp->args[0].location;
    a000158c:	f94093e0 	ldr	x0, [sp, #288]
    a0001590:	f9400400 	ldr	x0, [x0, #8]
    a0001594:	b9400001 	ldr	w1, [x0]
    a0001598:	f9408be0 	ldr	x0, [sp, #272]
    a000159c:	b9000001 	str	w1, [x0]
		        ofld_vranlc.args[0].location =  (uint32_t*)((char*)write_pointer - 0x40000000);
    a00015a0:	f9408be1 	ldr	x1, [sp, #272]
    a00015a4:	b26287e0 	mov	x0, #0xffffffffc0000000    	// #-1073741824
    a00015a8:	8b000020 	add	x0, x1, x0
    a00015ac:	f90033e0 	str	x0, [sp, #96]
        		printf("Location of the int is %p\n",ofld_vranlc.args[0].location);
    a00015b0:	f94033e0 	ldr	x0, [sp, #96]
    a00015b4:	aa0003e1 	mov	x1, x0
    a00015b8:	d0000100 	adrp	x0, a0023000 <__rodata_region_start>
    a00015bc:	913f6000 	add	x0, x0, #0xfd8
    a00015c0:	94002b87 	bl	a000c3dc <printf>
      			write_pointer =  (void*)((char*)write_pointer +  sizeof(int));
    a00015c4:	f9408be0 	ldr	x0, [sp, #272]
    a00015c8:	91001000 	add	x0, x0, #0x4
    a00015cc:	f9008be0 	str	x0, [sp, #272]

        		*((double*)write_pointer) = *(int*)inp->args[1].location;
    a00015d0:	f94093e0 	ldr	x0, [sp, #288]
    a00015d4:	f9400c00 	ldr	x0, [x0, #24]
    a00015d8:	b9400000 	ldr	w0, [x0]
    a00015dc:	1e620000 	scvtf	d0, w0
    a00015e0:	f9408be0 	ldr	x0, [sp, #272]
    a00015e4:	fd000000 	str	d0, [x0]
        		ofld_vranlc.args[1].location =  (uint32_t*)((char*)write_pointer - 0x40000000) ;
    a00015e8:	f9408be1 	ldr	x1, [sp, #272]
    a00015ec:	b26287e0 	mov	x0, #0xffffffffc0000000    	// #-1073741824
    a00015f0:	8b000020 	add	x0, x1, x0
    a00015f4:	f9003be0 	str	x0, [sp, #112]
        		printf("Location of the float pointer is %p\n",ofld_vranlc.args[1].location);
    a00015f8:	f9403be0 	ldr	x0, [sp, #112]
    a00015fc:	aa0003e1 	mov	x1, x0
    a0001600:	d0000100 	adrp	x0, a0023000 <__rodata_region_start>
    a0001604:	913fe000 	add	x0, x0, #0xff8
    a0001608:	94002b75 	bl	a000c3dc <printf>
        		write_pointer  =  (void*)((char*)write_pointer +  sizeof(double));
    a000160c:	f9408be0 	ldr	x0, [sp, #272]
    a0001610:	91002000 	add	x0, x0, #0x8
    a0001614:	f9008be0 	str	x0, [sp, #272]

        		*((double*)write_pointer) = *(int*)inp->args[2].location;
    a0001618:	f94093e0 	ldr	x0, [sp, #288]
    a000161c:	f9401400 	ldr	x0, [x0, #40]
    a0001620:	b9400000 	ldr	w0, [x0]
    a0001624:	1e620000 	scvtf	d0, w0
    a0001628:	f9408be0 	ldr	x0, [sp, #272]
    a000162c:	fd000000 	str	d0, [x0]
        		ofld_vranlc.args[2].location =  (uint32_t*)((char*)write_pointer - 0x40000000) ;
    a0001630:	f9408be1 	ldr	x1, [sp, #272]
    a0001634:	b26287e0 	mov	x0, #0xffffffffc0000000    	// #-1073741824
    a0001638:	8b000020 	add	x0, x1, x0
    a000163c:	f90043e0 	str	x0, [sp, #128]
        		write_pointer  =  (void*)((char*)write_pointer +  sizeof(double));
    a0001640:	f9408be0 	ldr	x0, [sp, #272]
    a0001644:	91002000 	add	x0, x0, #0x8
    a0001648:	f9008be0 	str	x0, [sp, #272]

        		*((double*)write_pointer) = *(int*)inp->args[3].location;
    a000164c:	f94093e0 	ldr	x0, [sp, #288]
    a0001650:	f9401c00 	ldr	x0, [x0, #56]
    a0001654:	b9400000 	ldr	w0, [x0]
    a0001658:	1e620000 	scvtf	d0, w0
    a000165c:	f9408be0 	ldr	x0, [sp, #272]
    a0001660:	fd000000 	str	d0, [x0]
        		ofld_vranlc.args[3].location = (uint32_t*)((char*)write_pointer - 0x40000000)   ;
    a0001664:	f9408be1 	ldr	x1, [sp, #272]
    a0001668:	b26287e0 	mov	x0, #0xffffffffc0000000    	// #-1073741824
    a000166c:	8b000020 	add	x0, x1, x0
    a0001670:	f9004be0 	str	x0, [sp, #144]


        		ofld_vranlc.type = RESPOND_VRANLC;
    a0001674:	52800060 	mov	w0, #0x3                   	// #3
    a0001678:	b9005fe0 	str	w0, [sp, #92]
        		ofld_vranlc.args[0].size = 1;
    a000167c:	52800020 	mov	w0, #0x1                   	// #1
    a0001680:	b9006be0 	str	w0, [sp, #104]
        		ofld_vranlc.args[0].type = INT;
    a0001684:	52800080 	mov	w0, #0x4                   	// #4
    a0001688:	b9006fe0 	str	w0, [sp, #108]
        		ofld_vranlc.args[1].size = 1;
    a000168c:	52800020 	mov	w0, #0x1                   	// #1
    a0001690:	b9007be0 	str	w0, [sp, #120]
			ofld_vranlc.args[1].type = DOUBLE;
    a0001694:	52800040 	mov	w0, #0x2                   	// #2
    a0001698:	b9007fe0 	str	w0, [sp, #124]
        		ofld_vranlc.args[2].size = 1;
    a000169c:	52800020 	mov	w0, #0x1                   	// #1
    a00016a0:	b9008be0 	str	w0, [sp, #136]
        		ofld_vranlc.args[2].type = DOUBLE;
    a00016a4:	52800040 	mov	w0, #0x2                   	// #2
    a00016a8:	b9008fe0 	str	w0, [sp, #140]
        		ofld_vranlc.args[3].size = 1;
    a00016ac:	52800020 	mov	w0, #0x1                   	// #1
    a00016b0:	b9009be0 	str	w0, [sp, #152]
        		ofld_vranlc.args[3].type = DOUBLE;
    a00016b4:	52800040 	mov	w0, #0x2                   	// #2
    a00016b8:	b9009fe0 	str	w0, [sp, #156]

        		memcpy((void*)rw_buf.write_area , (void*)&ofld_vranlc , sizeof(struct offload_struct) );				
    a00016bc:	f94083e0 	ldr	x0, [sp, #256]
    a00016c0:	910163e1 	add	x1, sp, #0x58
    a00016c4:	d2801102 	mov	x2, #0x88                  	// #136
    a00016c8:	940029f4 	bl	a000be98 <memcpy>
    a00016cc:	17ffff72 	b	a0001494 <main+0x160>

		   }
		  else if(inp->type == BLACKSCHOLES_REQ)	{	
    a00016d0:	f94093e0 	ldr	x0, [sp, #288]
    a00016d4:	b9400400 	ldr	w0, [x0, #4]
    a00016d8:	7100101f 	cmp	w0, #0x4
    a00016dc:	54000781 	b.ne	a00017cc <main+0x498>  // b.any
			printf("A request of type BLACKSCHOLES_REQ came\n");
    a00016e0:	f0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a00016e4:	91008000 	add	x0, x0, #0x20
    a00016e8:	94002b3d 	bl	a000c3dc <printf>
			printf("Locations are %x , %x , %x and %x\n", (void*)inp->args[0].location);
    a00016ec:	f94093e0 	ldr	x0, [sp, #288]
    a00016f0:	f9400400 	ldr	x0, [x0, #8]
    a00016f4:	aa0003e1 	mov	x1, x0
    a00016f8:	f0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a00016fc:	91014000 	add	x0, x0, #0x50
    a0001700:	94002b37 	bl	a000c3dc <printf>
			printf("values needed only arg 4 %d\n",*(int*)inp->args[0].location);
    a0001704:	f94093e0 	ldr	x0, [sp, #288]
    a0001708:	f9400400 	ldr	x0, [x0, #8]
    a000170c:	b9400000 	ldr	w0, [x0]
    a0001710:	2a0003e1 	mov	w1, w0
    a0001714:	f0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a0001718:	9101e000 	add	x0, x0, #0x78
    a000171c:	94002b30 	bl	a000c3dc <printf>
				
			//do the work here
			pthread_attr_t attr;
			pthread_t threadid;
			pthread_attr_init(&attr);
    a0001720:	9100a3e0 	add	x0, sp, #0x28
    a0001724:	94002b6d 	bl	a000c4d8 <pthread_attr_init>
			pthread_attr_setstack(&attr, &blasch_stacks[0], STACKSIZ);
    a0001728:	9100a3e3 	add	x3, sp, #0x28
    a000172c:	d2890002 	mov	x2, #0x4800                	// #18432
    a0001730:	d0000480 	adrp	x0, a0093000 <blasch_stacks>
    a0001734:	91000001 	add	x1, x0, #0x0
    a0001738:	aa0303e0 	mov	x0, x3
    a000173c:	94002b55 	bl	a000c490 <pthread_attr_setstack>
//			pthread_create(&threadid,&attr,(void *(*)(void *))bs_thread,(void *)inp->args[0].location);			
			bs_thread((void *)inp->args[0].location);
    a0001740:	f94093e0 	ldr	x0, [sp, #288]
    a0001744:	f9400400 	ldr	x0, [x0, #8]
    a0001748:	94000134 	bl	a0001c18 <bs_thread>
			
			//indicate that you have consumed the message
			*(uint32_t*)inp = ~(0xF00F0FF0);
    a000174c:	f94093e0 	ldr	x0, [sp, #288]
    a0001750:	529e01e1 	mov	w1, #0xf00f                	// #61455
    a0001754:	72a1fe01 	movk	w1, #0xff0, lsl #16
    a0001758:	b9000001 	str	w1, [x0]

			//Start replying
			struct offload_struct ofld_vranlc ;

			ofld_vranlc.new_request = 0xF00F0FF0;
    a000175c:	5281fe00 	mov	w0, #0xff0                 	// #4080
    a0001760:	72be01e0 	movk	w0, #0xf00f, lsl #16
    a0001764:	b9005be0 	str	w0, [sp, #88]
			void * write_pointer = (void*)((char*)rw_buf.write_area + 0x1000);
    a0001768:	f94083e0 	ldr	x0, [sp, #256]
    a000176c:	91400400 	add	x0, x0, #0x1, lsl #12
    a0001770:	f9008fe0 	str	x0, [sp, #280]
			


        		ofld_vranlc.type = COMPUTE_VRANLC;
    a0001774:	b9005fff 	str	wzr, [sp, #92]
        		ofld_vranlc.args[0].size = 1;
    a0001778:	52800020 	mov	w0, #0x1                   	// #1
    a000177c:	b9006be0 	str	w0, [sp, #104]
        		ofld_vranlc.args[0].type = INT;
    a0001780:	52800080 	mov	w0, #0x4                   	// #4
    a0001784:	b9006fe0 	str	w0, [sp, #108]
        		ofld_vranlc.args[1].size = 1;
    a0001788:	52800020 	mov	w0, #0x1                   	// #1
    a000178c:	b9007be0 	str	w0, [sp, #120]
			ofld_vranlc.args[1].type = DOUBLE;
    a0001790:	52800040 	mov	w0, #0x2                   	// #2
    a0001794:	b9007fe0 	str	w0, [sp, #124]
        		ofld_vranlc.args[2].size = 1;
    a0001798:	52800020 	mov	w0, #0x1                   	// #1
    a000179c:	b9008be0 	str	w0, [sp, #136]
        		ofld_vranlc.args[2].type = DOUBLE;
    a00017a0:	52800040 	mov	w0, #0x2                   	// #2
    a00017a4:	b9008fe0 	str	w0, [sp, #140]
        		ofld_vranlc.args[3].size = 1;
    a00017a8:	52800020 	mov	w0, #0x1                   	// #1
    a00017ac:	b9009be0 	str	w0, [sp, #152]
        		ofld_vranlc.args[3].type = DOUBLE;
    a00017b0:	52800040 	mov	w0, #0x2                   	// #2
    a00017b4:	b9009fe0 	str	w0, [sp, #156]

        		memcpy((void*)rw_buf.write_area , (void*)&ofld_vranlc , sizeof(struct offload_struct) );				
    a00017b8:	f94083e0 	ldr	x0, [sp, #256]
    a00017bc:	910163e1 	add	x1, sp, #0x58
    a00017c0:	d2801102 	mov	x2, #0x88                  	// #136
    a00017c4:	940029b5 	bl	a000be98 <memcpy>
    a00017c8:	17ffff33 	b	a0001494 <main+0x160>
		   }
		  else if (inp->type == 0xDE)
    a00017cc:	f94093e0 	ldr	x0, [sp, #288]
    a00017d0:	b9400400 	ldr	w0, [x0, #4]
    a00017d4:	7103781f 	cmp	w0, #0xde
    a00017d8:	54ffe5e1 	b.ne	a0001494 <main+0x160>  // b.any
		  {
			printf("x86 wants to go away , I am leaving too\n");
    a00017dc:	f0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a00017e0:	91026000 	add	x0, x0, #0x98
    a00017e4:	94002afe 	bl	a000c3dc <printf>
			break;
    a00017e8:	d503201f 	nop
		  }
	     }
	}
	tid = 1;
    a00017ec:	f0000460 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a00017f0:	91116000 	add	x0, x0, #0x458
    a00017f4:	52800021 	mov	w1, #0x1                   	// #1
    a00017f8:	b9000001 	str	w1, [x0]
	//bs_thread((void*)&tid);
	printf("ARM_kernel_exiting\n");
    a00017fc:	f0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a0001800:	91032000 	add	x0, x0, #0xc8
    a0001804:	94002af6 	bl	a000c3dc <printf>
     	*((uint32_t*)rw_buf.read_area) = 0x00000000 ;
    a0001808:	f94087e0 	ldr	x0, [sp, #264]
    a000180c:	b900001f 	str	wzr, [x0]
     	*((uint32_t*)rw_buf.write_area) = 0x00000000 ;
    a0001810:	f94083e0 	ldr	x0, [sp, #256]
    a0001814:	b900001f 	str	wzr, [x0]
	while(1);
    a0001818:	14000000 	b	a0001818 <main+0x4e4>

00000000a000181c <pthread_mutexattr_init>:
 * See IEEE 1003.1
 *
 * Note that pthread attribute structs are currently noops in Zephyr.
 */
static inline int pthread_mutexattr_init(pthread_mutexattr_t *m)
{
    a000181c:	d10043ff 	sub	sp, sp, #0x10
    a0001820:	f90007e0 	str	x0, [sp, #8]
	ARG_UNUSED(m);

	return 0;
    a0001824:	52800000 	mov	w0, #0x0                   	// #0
}
    a0001828:	910043ff 	add	sp, sp, #0x10
    a000182c:	d65f03c0 	ret

00000000a0001830 <CNDF>:
// Cumulative Normal Distribution Function
// See Hull, Section 11.8, P.243-244
#define inv_sqrt_2xPI 0.39894228040143270286

fptype CNDF ( fptype InputX ) 
{
    a0001830:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a0001834:	910003fd 	mov	x29, sp
    a0001838:	bd001fe0 	str	s0, [sp, #28]
    fptype xK2_4, xK2_5;
    fptype xLocal, xLocal_1;
    fptype xLocal_2, xLocal_3;

    // Check for negative value of InputX
    if (InputX < 0.0) {
    a000183c:	bd401fe0 	ldr	s0, [sp, #28]
    a0001840:	1e202018 	fcmpe	s0, #0.0
    a0001844:	54000044 	b.mi	a000184c <CNDF+0x1c>  // b.first
    a0001848:	14000007 	b	a0001864 <CNDF+0x34>
        InputX = -InputX;
    a000184c:	bd401fe0 	ldr	s0, [sp, #28]
    a0001850:	1e214000 	fneg	s0, s0
    a0001854:	bd001fe0 	str	s0, [sp, #28]
        sign = 1;
    a0001858:	52800020 	mov	w0, #0x1                   	// #1
    a000185c:	b9005fe0 	str	w0, [sp, #92]
    a0001860:	14000002 	b	a0001868 <CNDF+0x38>
    } else 
        sign = 0;
    a0001864:	b9005fff 	str	wzr, [sp, #92]

    xInput = InputX;
    a0001868:	bd401fe0 	ldr	s0, [sp, #28]
    a000186c:	bd0057e0 	str	s0, [sp, #84]
 
    // Compute NPrimeX term common to both four & six decimal accuracy calcs
    expValues = exp(-0.5f * InputX * InputX);
    a0001870:	bd401fe1 	ldr	s1, [sp, #28]
    a0001874:	1e3c1000 	fmov	s0, #-5.000000000000000000e-01
    a0001878:	1e200821 	fmul	s1, s1, s0
    a000187c:	bd401fe0 	ldr	s0, [sp, #28]
    a0001880:	1e200820 	fmul	s0, s1, s0
    a0001884:	1e22c000 	fcvt	d0, s0
    a0001888:	9400065e 	bl	a0003200 <exp>
    a000188c:	1e220000 	scvtf	s0, w0
    a0001890:	bd0053e0 	str	s0, [sp, #80]
    xNPrimeofX = expValues;
    a0001894:	bd4053e0 	ldr	s0, [sp, #80]
    a0001898:	bd004fe0 	str	s0, [sp, #76]
    xNPrimeofX = xNPrimeofX * inv_sqrt_2xPI;
    a000189c:	bd404fe0 	ldr	s0, [sp, #76]
    a00018a0:	1e22c000 	fcvt	d0, s0
    a00018a4:	f0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a00018a8:	fd410c01 	ldr	d1, [x0, #536]
    a00018ac:	1e610800 	fmul	d0, d0, d1
    a00018b0:	1e624000 	fcvt	s0, d0
    a00018b4:	bd004fe0 	str	s0, [sp, #76]

    xK2 = 0.2316419 * xInput;
    a00018b8:	bd4057e0 	ldr	s0, [sp, #84]
    a00018bc:	1e22c000 	fcvt	d0, s0
    a00018c0:	f0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a00018c4:	fd411001 	ldr	d1, [x0, #544]
    a00018c8:	1e610800 	fmul	d0, d0, d1
    a00018cc:	1e624000 	fcvt	s0, d0
    a00018d0:	bd004be0 	str	s0, [sp, #72]
    xK2 = 1.0 + xK2;
    a00018d4:	bd404be1 	ldr	s1, [sp, #72]
    a00018d8:	1e2e1000 	fmov	s0, #1.000000000000000000e+00
    a00018dc:	1e202820 	fadd	s0, s1, s0
    a00018e0:	bd004be0 	str	s0, [sp, #72]
    xK2 = 1.0 / xK2;
    a00018e4:	bd404be0 	ldr	s0, [sp, #72]
    a00018e8:	1e2e1001 	fmov	s1, #1.000000000000000000e+00
    a00018ec:	1e201820 	fdiv	s0, s1, s0
    a00018f0:	bd004be0 	str	s0, [sp, #72]
    xK2_2 = xK2 * xK2;
    a00018f4:	bd404be0 	ldr	s0, [sp, #72]
    a00018f8:	1e200800 	fmul	s0, s0, s0
    a00018fc:	bd0047e0 	str	s0, [sp, #68]
    xK2_3 = xK2_2 * xK2;
    a0001900:	bd4047e1 	ldr	s1, [sp, #68]
    a0001904:	bd404be0 	ldr	s0, [sp, #72]
    a0001908:	1e200820 	fmul	s0, s1, s0
    a000190c:	bd0043e0 	str	s0, [sp, #64]
    xK2_4 = xK2_3 * xK2;
    a0001910:	bd4043e1 	ldr	s1, [sp, #64]
    a0001914:	bd404be0 	ldr	s0, [sp, #72]
    a0001918:	1e200820 	fmul	s0, s1, s0
    a000191c:	bd003fe0 	str	s0, [sp, #60]
    xK2_5 = xK2_4 * xK2;
    a0001920:	bd403fe1 	ldr	s1, [sp, #60]
    a0001924:	bd404be0 	ldr	s0, [sp, #72]
    a0001928:	1e200820 	fmul	s0, s1, s0
    a000192c:	bd003be0 	str	s0, [sp, #56]
    
    xLocal_1 = xK2 * 0.319381530;
    a0001930:	bd404be0 	ldr	s0, [sp, #72]
    a0001934:	1e22c000 	fcvt	d0, s0
    a0001938:	f0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a000193c:	fd411401 	ldr	d1, [x0, #552]
    a0001940:	1e610800 	fmul	d0, d0, d1
    a0001944:	1e624000 	fcvt	s0, d0
    a0001948:	bd0037e0 	str	s0, [sp, #52]
    xLocal_2 = xK2_2 * (-0.356563782);
    a000194c:	bd4047e0 	ldr	s0, [sp, #68]
    a0001950:	1e22c000 	fcvt	d0, s0
    a0001954:	f0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a0001958:	fd411801 	ldr	d1, [x0, #560]
    a000195c:	1e610800 	fmul	d0, d0, d1
    a0001960:	1e624000 	fcvt	s0, d0
    a0001964:	bd0033e0 	str	s0, [sp, #48]
    xLocal_3 = xK2_3 * 1.781477937;
    a0001968:	bd4043e0 	ldr	s0, [sp, #64]
    a000196c:	1e22c000 	fcvt	d0, s0
    a0001970:	f0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a0001974:	fd411c01 	ldr	d1, [x0, #568]
    a0001978:	1e610800 	fmul	d0, d0, d1
    a000197c:	1e624000 	fcvt	s0, d0
    a0001980:	bd002fe0 	str	s0, [sp, #44]
    xLocal_2 = xLocal_2 + xLocal_3;
    a0001984:	bd4033e1 	ldr	s1, [sp, #48]
    a0001988:	bd402fe0 	ldr	s0, [sp, #44]
    a000198c:	1e202820 	fadd	s0, s1, s0
    a0001990:	bd0033e0 	str	s0, [sp, #48]
    xLocal_3 = xK2_4 * (-1.821255978);
    a0001994:	bd403fe0 	ldr	s0, [sp, #60]
    a0001998:	1e22c000 	fcvt	d0, s0
    a000199c:	f0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a00019a0:	fd412001 	ldr	d1, [x0, #576]
    a00019a4:	1e610800 	fmul	d0, d0, d1
    a00019a8:	1e624000 	fcvt	s0, d0
    a00019ac:	bd002fe0 	str	s0, [sp, #44]
    xLocal_2 = xLocal_2 + xLocal_3;
    a00019b0:	bd4033e1 	ldr	s1, [sp, #48]
    a00019b4:	bd402fe0 	ldr	s0, [sp, #44]
    a00019b8:	1e202820 	fadd	s0, s1, s0
    a00019bc:	bd0033e0 	str	s0, [sp, #48]
    xLocal_3 = xK2_5 * 1.330274429;
    a00019c0:	bd403be0 	ldr	s0, [sp, #56]
    a00019c4:	1e22c000 	fcvt	d0, s0
    a00019c8:	f0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a00019cc:	fd412401 	ldr	d1, [x0, #584]
    a00019d0:	1e610800 	fmul	d0, d0, d1
    a00019d4:	1e624000 	fcvt	s0, d0
    a00019d8:	bd002fe0 	str	s0, [sp, #44]
    xLocal_2 = xLocal_2 + xLocal_3;
    a00019dc:	bd4033e1 	ldr	s1, [sp, #48]
    a00019e0:	bd402fe0 	ldr	s0, [sp, #44]
    a00019e4:	1e202820 	fadd	s0, s1, s0
    a00019e8:	bd0033e0 	str	s0, [sp, #48]

    xLocal_1 = xLocal_2 + xLocal_1;
    a00019ec:	bd4037e1 	ldr	s1, [sp, #52]
    a00019f0:	bd4033e0 	ldr	s0, [sp, #48]
    a00019f4:	1e202820 	fadd	s0, s1, s0
    a00019f8:	bd0037e0 	str	s0, [sp, #52]
    xLocal   = xLocal_1 * xNPrimeofX;
    a00019fc:	bd4037e1 	ldr	s1, [sp, #52]
    a0001a00:	bd404fe0 	ldr	s0, [sp, #76]
    a0001a04:	1e200820 	fmul	s0, s1, s0
    a0001a08:	bd002be0 	str	s0, [sp, #40]
    xLocal   = 1.0 - xLocal;
    a0001a0c:	1e2e1001 	fmov	s1, #1.000000000000000000e+00
    a0001a10:	bd402be0 	ldr	s0, [sp, #40]
    a0001a14:	1e203820 	fsub	s0, s1, s0
    a0001a18:	bd002be0 	str	s0, [sp, #40]

    OutputX  = xLocal;
    a0001a1c:	bd402be0 	ldr	s0, [sp, #40]
    a0001a20:	bd005be0 	str	s0, [sp, #88]
    
    if (sign) {
    a0001a24:	b9405fe0 	ldr	w0, [sp, #92]
    a0001a28:	7100001f 	cmp	w0, #0x0
    a0001a2c:	540000a0 	b.eq	a0001a40 <CNDF+0x210>  // b.none
        OutputX = 1.0 - OutputX;
    a0001a30:	1e2e1001 	fmov	s1, #1.000000000000000000e+00
    a0001a34:	bd405be0 	ldr	s0, [sp, #88]
    a0001a38:	1e203820 	fsub	s0, s1, s0
    a0001a3c:	bd005be0 	str	s0, [sp, #88]
    }
    
    return OutputX;
    a0001a40:	bd405be0 	ldr	s0, [sp, #88]
} 
    a0001a44:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a0001a48:	d65f03c0 	ret

00000000a0001a4c <BlkSchlsEqEuroNoDiv>:
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
fptype BlkSchlsEqEuroNoDiv( fptype sptprice,
                            fptype strike, fptype rate, fptype volatility,
                            fptype time, int otype, float timet )
{
    a0001a4c:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
    a0001a50:	910003fd 	mov	x29, sp
    a0001a54:	bd002fe0 	str	s0, [sp, #44]
    a0001a58:	bd002be1 	str	s1, [sp, #40]
    a0001a5c:	bd0027e2 	str	s2, [sp, #36]
    a0001a60:	bd0023e3 	str	s3, [sp, #32]
    a0001a64:	bd001fe4 	str	s4, [sp, #28]
    a0001a68:	b9001be0 	str	w0, [sp, #24]
    a0001a6c:	bd0017e5 	str	s5, [sp, #20]
    fptype NofXd1;
    fptype NofXd2;
    fptype NegNofXd1;
    fptype NegNofXd2;    
    
    xStockPrice = sptprice;
    a0001a70:	bd402fe0 	ldr	s0, [sp, #44]
    a0001a74:	bd007be0 	str	s0, [sp, #120]
    xStrikePrice = strike;
    a0001a78:	bd402be0 	ldr	s0, [sp, #40]
    a0001a7c:	bd0077e0 	str	s0, [sp, #116]
    xRiskFreeRate = rate;
    a0001a80:	bd4027e0 	ldr	s0, [sp, #36]
    a0001a84:	bd0073e0 	str	s0, [sp, #112]
    xVolatility = volatility;
    a0001a88:	bd4023e0 	ldr	s0, [sp, #32]
    a0001a8c:	bd006fe0 	str	s0, [sp, #108]

    xTime = time;
    a0001a90:	bd401fe0 	ldr	s0, [sp, #28]
    a0001a94:	bd006be0 	str	s0, [sp, #104]
    xSqrtTime = sqrt(xTime);
    a0001a98:	bd406be0 	ldr	s0, [sp, #104]
    a0001a9c:	1e22c000 	fcvt	d0, s0
    a0001aa0:	9400036e 	bl	a0002858 <sqrt>
    a0001aa4:	1e220000 	scvtf	s0, w0
    a0001aa8:	bd0067e0 	str	s0, [sp, #100]

    logValues = log( sptprice / strike );
    a0001aac:	bd402be0 	ldr	s0, [sp, #40]
    a0001ab0:	bd402fe1 	ldr	s1, [sp, #44]
    a0001ab4:	1e201820 	fdiv	s0, s1, s0
    a0001ab8:	1e22c000 	fcvt	d0, s0
    a0001abc:	940004b2 	bl	a0002d84 <log>
    a0001ac0:	1e220000 	scvtf	s0, w0
    a0001ac4:	bd0063e0 	str	s0, [sp, #96]
        
    xLogTerm = logValues;
    a0001ac8:	bd4063e0 	ldr	s0, [sp, #96]
    a0001acc:	bd005fe0 	str	s0, [sp, #92]
        
    
    xPowerTerm = xVolatility * xVolatility;
    a0001ad0:	bd406fe0 	ldr	s0, [sp, #108]
    a0001ad4:	1e200800 	fmul	s0, s0, s0
    a0001ad8:	bd005be0 	str	s0, [sp, #88]
    xPowerTerm = xPowerTerm * 0.5;
    a0001adc:	bd405be1 	ldr	s1, [sp, #88]
    a0001ae0:	1e2c1000 	fmov	s0, #5.000000000000000000e-01
    a0001ae4:	1e200820 	fmul	s0, s1, s0
    a0001ae8:	bd005be0 	str	s0, [sp, #88]
        
    xD1 = xRiskFreeRate + xPowerTerm;
    a0001aec:	bd4073e1 	ldr	s1, [sp, #112]
    a0001af0:	bd405be0 	ldr	s0, [sp, #88]
    a0001af4:	1e202820 	fadd	s0, s1, s0
    a0001af8:	bd0057e0 	str	s0, [sp, #84]
    xD1 = xD1 * xTime;
    a0001afc:	bd4057e1 	ldr	s1, [sp, #84]
    a0001b00:	bd406be0 	ldr	s0, [sp, #104]
    a0001b04:	1e200820 	fmul	s0, s1, s0
    a0001b08:	bd0057e0 	str	s0, [sp, #84]
    xD1 = xD1 + xLogTerm;
    a0001b0c:	bd4057e1 	ldr	s1, [sp, #84]
    a0001b10:	bd405fe0 	ldr	s0, [sp, #92]
    a0001b14:	1e202820 	fadd	s0, s1, s0
    a0001b18:	bd0057e0 	str	s0, [sp, #84]

    xDen = xVolatility * xSqrtTime;
    a0001b1c:	bd406fe1 	ldr	s1, [sp, #108]
    a0001b20:	bd4067e0 	ldr	s0, [sp, #100]
    a0001b24:	1e200820 	fmul	s0, s1, s0
    a0001b28:	bd0053e0 	str	s0, [sp, #80]
    xD1 = xD1 / xDen;
    a0001b2c:	bd4053e0 	ldr	s0, [sp, #80]
    a0001b30:	bd4057e1 	ldr	s1, [sp, #84]
    a0001b34:	1e201820 	fdiv	s0, s1, s0
    a0001b38:	bd0057e0 	str	s0, [sp, #84]
    xD2 = xD1 -  xDen;
    a0001b3c:	bd4057e1 	ldr	s1, [sp, #84]
    a0001b40:	bd4053e0 	ldr	s0, [sp, #80]
    a0001b44:	1e203820 	fsub	s0, s1, s0
    a0001b48:	bd004fe0 	str	s0, [sp, #76]

    d1 = xD1;
    a0001b4c:	bd4057e0 	ldr	s0, [sp, #84]
    a0001b50:	bd004be0 	str	s0, [sp, #72]
    d2 = xD2;
    a0001b54:	bd404fe0 	ldr	s0, [sp, #76]
    a0001b58:	bd0047e0 	str	s0, [sp, #68]
    
    NofXd1 = CNDF( d1 );
    a0001b5c:	bd404be0 	ldr	s0, [sp, #72]
    a0001b60:	97ffff34 	bl	a0001830 <CNDF>
    a0001b64:	bd0043e0 	str	s0, [sp, #64]
    NofXd2 = CNDF( d2 );
    a0001b68:	bd4047e0 	ldr	s0, [sp, #68]
    a0001b6c:	97ffff31 	bl	a0001830 <CNDF>
    a0001b70:	bd003fe0 	str	s0, [sp, #60]

    FutureValueX = strike * ( exp( -(rate)*(time) ) );        
    a0001b74:	bd4027e0 	ldr	s0, [sp, #36]
    a0001b78:	1e214001 	fneg	s1, s0
    a0001b7c:	bd401fe0 	ldr	s0, [sp, #28]
    a0001b80:	1e200820 	fmul	s0, s1, s0
    a0001b84:	1e22c000 	fcvt	d0, s0
    a0001b88:	9400059e 	bl	a0003200 <exp>
    a0001b8c:	1e220000 	scvtf	s0, w0
    a0001b90:	bd402be1 	ldr	s1, [sp, #40]
    a0001b94:	1e200820 	fmul	s0, s1, s0
    a0001b98:	bd003be0 	str	s0, [sp, #56]
    if (otype == 0) {            
    a0001b9c:	b9401be0 	ldr	w0, [sp, #24]
    a0001ba0:	7100001f 	cmp	w0, #0x0
    a0001ba4:	54000141 	b.ne	a0001bcc <BlkSchlsEqEuroNoDiv+0x180>  // b.any
        OptionPrice = (sptprice * NofXd1) - (FutureValueX * NofXd2);
    a0001ba8:	bd402fe1 	ldr	s1, [sp, #44]
    a0001bac:	bd4043e0 	ldr	s0, [sp, #64]
    a0001bb0:	1e200821 	fmul	s1, s1, s0
    a0001bb4:	bd403be2 	ldr	s2, [sp, #56]
    a0001bb8:	bd403fe0 	ldr	s0, [sp, #60]
    a0001bbc:	1e200840 	fmul	s0, s2, s0
    a0001bc0:	1e203820 	fsub	s0, s1, s0
    a0001bc4:	bd007fe0 	str	s0, [sp, #124]
    a0001bc8:	14000011 	b	a0001c0c <BlkSchlsEqEuroNoDiv+0x1c0>
    } else { 
        NegNofXd1 = (1.0 - NofXd1);
    a0001bcc:	1e2e1001 	fmov	s1, #1.000000000000000000e+00
    a0001bd0:	bd4043e0 	ldr	s0, [sp, #64]
    a0001bd4:	1e203820 	fsub	s0, s1, s0
    a0001bd8:	bd0037e0 	str	s0, [sp, #52]
        NegNofXd2 = (1.0 - NofXd2);
    a0001bdc:	1e2e1001 	fmov	s1, #1.000000000000000000e+00
    a0001be0:	bd403fe0 	ldr	s0, [sp, #60]
    a0001be4:	1e203820 	fsub	s0, s1, s0
    a0001be8:	bd0033e0 	str	s0, [sp, #48]
        OptionPrice = (FutureValueX * NegNofXd2) - (sptprice * NegNofXd1);
    a0001bec:	bd403be1 	ldr	s1, [sp, #56]
    a0001bf0:	bd4033e0 	ldr	s0, [sp, #48]
    a0001bf4:	1e200821 	fmul	s1, s1, s0
    a0001bf8:	bd402fe2 	ldr	s2, [sp, #44]
    a0001bfc:	bd4037e0 	ldr	s0, [sp, #52]
    a0001c00:	1e200840 	fmul	s0, s2, s0
    a0001c04:	1e203820 	fsub	s0, s1, s0
    a0001c08:	bd007fe0 	str	s0, [sp, #124]
    }
    
    return OptionPrice;
    a0001c0c:	bd407fe0 	ldr	s0, [sp, #124]
}
    a0001c10:	a8c87bfd 	ldp	x29, x30, [sp], #128
    a0001c14:	d65f03c0 	ret

00000000a0001c18 <bs_thread>:
#else // !ENABLE_TBB

#ifdef WIN32
DWORD WINAPI bs_thread(LPVOID tid_ptr){
#else
int bs_thread(void *tid_ptr) {
    a0001c18:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    a0001c1c:	910003fd 	mov	x29, sp
    a0001c20:	f9000fe0 	str	x0, [sp, #24]
#endif
    int i, j;
    fptype price;
    fptype priceDelta;
    int tid = *(int *)tid_ptr;
    a0001c24:	f9400fe0 	ldr	x0, [sp, #24]
    a0001c28:	b9400000 	ldr	w0, [x0]
    a0001c2c:	b90037e0 	str	w0, [sp, #52]
    int start = tid * (numOptions / nThreads);
    a0001c30:	f0000460 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a0001c34:	91117000 	add	x0, x0, #0x45c
    a0001c38:	b9400001 	ldr	w1, [x0]
    a0001c3c:	f0000460 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a0001c40:	91118000 	add	x0, x0, #0x460
    a0001c44:	b9400000 	ldr	w0, [x0]
    a0001c48:	1ac00c20 	sdiv	w0, w1, w0
    a0001c4c:	b94037e1 	ldr	w1, [sp, #52]
    a0001c50:	1b007c20 	mul	w0, w1, w0
    a0001c54:	b90033e0 	str	w0, [sp, #48]
    int end = start + (numOptions / nThreads);
    a0001c58:	f0000460 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a0001c5c:	91117000 	add	x0, x0, #0x45c
    a0001c60:	b9400001 	ldr	w1, [x0]
    a0001c64:	f0000460 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a0001c68:	91118000 	add	x0, x0, #0x460
    a0001c6c:	b9400000 	ldr	w0, [x0]
    a0001c70:	1ac00c20 	sdiv	w0, w1, w0
    a0001c74:	b94033e1 	ldr	w1, [sp, #48]
    a0001c78:	0b000020 	add	w0, w1, w0
    a0001c7c:	b9002fe0 	str	w0, [sp, #44]
    
	printf("Thread %d/%d %d %d\n", tid, nThreads, start, end);
    a0001c80:	f0000460 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a0001c84:	91118000 	add	x0, x0, #0x460
    a0001c88:	b9400000 	ldr	w0, [x0]
    a0001c8c:	b9402fe4 	ldr	w4, [sp, #44]
    a0001c90:	b94033e3 	ldr	w3, [sp, #48]
    a0001c94:	2a0003e2 	mov	w2, w0
    a0001c98:	b94037e1 	ldr	w1, [sp, #52]
    a0001c9c:	f0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a0001ca0:	91038000 	add	x0, x0, #0xe0
    a0001ca4:	940029ce 	bl	a000c3dc <printf>

//	__bsHold = 1;
//	while (__bsHold)
//	  ;

    for (j=0; j<NUM_RUNS; j++) {
    a0001ca8:	b9003bff 	str	wzr, [sp, #56]
    a0001cac:	14000043 	b	a0001db8 <bs_thread+0x1a0>
#ifdef ENABLE_OPENMP
#pragma omp parallel for private(i, price, priceDelta)
        for (i=0; i<numOptions; i++) {
#else  //ENABLE_OPENMP
        for (i=start; i<end; i++) {
    a0001cb0:	b94033e0 	ldr	w0, [sp, #48]
    a0001cb4:	b9003fe0 	str	w0, [sp, #60]
    a0001cb8:	14000039 	b	a0001d9c <bs_thread+0x184>
#endif //ENABLE_OPENMP
            /* Calling main function to calculate option value based on 
             * Black & Scholes's equation.
             */
            price = BlkSchlsEqEuroNoDiv( sptprice[i], strike[i],
    a0001cbc:	d0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0001cc0:	913b2000 	add	x0, x0, #0xec8
    a0001cc4:	f9400001 	ldr	x1, [x0]
    a0001cc8:	b9803fe0 	ldrsw	x0, [sp, #60]
    a0001ccc:	d37ef400 	lsl	x0, x0, #2
    a0001cd0:	8b000020 	add	x0, x1, x0
    a0001cd4:	bd400000 	ldr	s0, [x0]
    a0001cd8:	d0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0001cdc:	913b4000 	add	x0, x0, #0xed0
    a0001ce0:	f9400001 	ldr	x1, [x0]
    a0001ce4:	b9803fe0 	ldrsw	x0, [sp, #60]
    a0001ce8:	d37ef400 	lsl	x0, x0, #2
    a0001cec:	8b000020 	add	x0, x1, x0
    a0001cf0:	bd400001 	ldr	s1, [x0]
                                         rate[i], volatility[i], otime[i], 
    a0001cf4:	d0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0001cf8:	913b6000 	add	x0, x0, #0xed8
    a0001cfc:	f9400001 	ldr	x1, [x0]
    a0001d00:	b9803fe0 	ldrsw	x0, [sp, #60]
    a0001d04:	d37ef400 	lsl	x0, x0, #2
    a0001d08:	8b000020 	add	x0, x1, x0
            price = BlkSchlsEqEuroNoDiv( sptprice[i], strike[i],
    a0001d0c:	bd400002 	ldr	s2, [x0]
                                         rate[i], volatility[i], otime[i], 
    a0001d10:	d0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0001d14:	913b8000 	add	x0, x0, #0xee0
    a0001d18:	f9400001 	ldr	x1, [x0]
    a0001d1c:	b9803fe0 	ldrsw	x0, [sp, #60]
    a0001d20:	d37ef400 	lsl	x0, x0, #2
    a0001d24:	8b000020 	add	x0, x1, x0
            price = BlkSchlsEqEuroNoDiv( sptprice[i], strike[i],
    a0001d28:	bd400003 	ldr	s3, [x0]
                                         rate[i], volatility[i], otime[i], 
    a0001d2c:	d0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0001d30:	913ba000 	add	x0, x0, #0xee8
    a0001d34:	f9400001 	ldr	x1, [x0]
    a0001d38:	b9803fe0 	ldrsw	x0, [sp, #60]
    a0001d3c:	d37ef400 	lsl	x0, x0, #2
    a0001d40:	8b000020 	add	x0, x1, x0
            price = BlkSchlsEqEuroNoDiv( sptprice[i], strike[i],
    a0001d44:	bd400004 	ldr	s4, [x0]
                                         otype[i], 0);
    a0001d48:	d0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0001d4c:	913b0000 	add	x0, x0, #0xec0
    a0001d50:	f9400001 	ldr	x1, [x0]
    a0001d54:	b9803fe0 	ldrsw	x0, [sp, #60]
    a0001d58:	d37ef400 	lsl	x0, x0, #2
    a0001d5c:	8b000020 	add	x0, x1, x0
            price = BlkSchlsEqEuroNoDiv( sptprice[i], strike[i],
    a0001d60:	b9400000 	ldr	w0, [x0]
    a0001d64:	0f000405 	movi	v5.2s, #0x0
    a0001d68:	97ffff39 	bl	a0001a4c <BlkSchlsEqEuroNoDiv>
    a0001d6c:	bd002be0 	str	s0, [sp, #40]
           prices[i] = price;
    a0001d70:	d0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0001d74:	913ae000 	add	x0, x0, #0xeb8
    a0001d78:	f9400001 	ldr	x1, [x0]
    a0001d7c:	b9803fe0 	ldrsw	x0, [sp, #60]
    a0001d80:	d37ef400 	lsl	x0, x0, #2
    a0001d84:	8b000020 	add	x0, x1, x0
    a0001d88:	bd402be0 	ldr	s0, [sp, #40]
    a0001d8c:	bd000000 	str	s0, [x0]
        for (i=start; i<end; i++) {
    a0001d90:	b9403fe0 	ldr	w0, [sp, #60]
    a0001d94:	11000400 	add	w0, w0, #0x1
    a0001d98:	b9003fe0 	str	w0, [sp, #60]
    a0001d9c:	b9403fe1 	ldr	w1, [sp, #60]
    a0001da0:	b9402fe0 	ldr	w0, [sp, #44]
    a0001da4:	6b00003f 	cmp	w1, w0
    a0001da8:	54fff8ab 	b.lt	a0001cbc <bs_thread+0xa4>  // b.tstop
    for (j=0; j<NUM_RUNS; j++) {
    a0001dac:	b9403be0 	ldr	w0, [sp, #56]
    a0001db0:	11000400 	add	w0, w0, #0x1
    a0001db4:	b9003be0 	str	w0, [sp, #56]
    a0001db8:	b9403be0 	ldr	w0, [sp, #56]
    a0001dbc:	7107cc1f 	cmp	w0, #0x1f3
    a0001dc0:	54fff78d 	b.le	a0001cb0 <bs_thread+0x98>
            }
#endif
        }
    }
	
    printf("%d\n", numOptions);
    a0001dc4:	f0000460 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a0001dc8:	91117000 	add	x0, x0, #0x45c
    a0001dcc:	b9400000 	ldr	w0, [x0]
    a0001dd0:	2a0003e1 	mov	w1, w0
    a0001dd4:	f0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a0001dd8:	9103e000 	add	x0, x0, #0xf8
    a0001ddc:	94002980 	bl	a000c3dc <printf>
    for(i=0; i<numOptions; i++) {
    a0001de0:	b9003fff 	str	wzr, [sp, #60]
    a0001de4:	1400000f 	b	a0001e20 <bs_thread+0x208>
      printf("%.18f\n", prices[i]);
    a0001de8:	d0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0001dec:	913ae000 	add	x0, x0, #0xeb8
    a0001df0:	f9400001 	ldr	x1, [x0]
    a0001df4:	b9803fe0 	ldrsw	x0, [sp, #60]
    a0001df8:	d37ef400 	lsl	x0, x0, #2
    a0001dfc:	8b000020 	add	x0, x1, x0
    a0001e00:	bd400000 	ldr	s0, [x0]
    a0001e04:	1e22c000 	fcvt	d0, s0
    a0001e08:	f0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a0001e0c:	91040000 	add	x0, x0, #0x100
    a0001e10:	94002973 	bl	a000c3dc <printf>
    for(i=0; i<numOptions; i++) {
    a0001e14:	b9403fe0 	ldr	w0, [sp, #60]
    a0001e18:	11000400 	add	w0, w0, #0x1
    a0001e1c:	b9003fe0 	str	w0, [sp, #60]
    a0001e20:	f0000460 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a0001e24:	91117000 	add	x0, x0, #0x45c
    a0001e28:	b9400000 	ldr	w0, [x0]
    a0001e2c:	b9403fe1 	ldr	w1, [sp, #60]
    a0001e30:	6b00003f 	cmp	w1, w0
    a0001e34:	54fffdab 	b.lt	a0001de8 <bs_thread+0x1d0>  // b.tstop
    }
//	if (tid % 2) migrate(0, NULL, NULL);
	//pthread_exit(tid_ptr);
    return 0;
    a0001e38:	52800000 	mov	w0, #0x0                   	// #0
}
    a0001e3c:	a8c47bfd 	ldp	x29, x30, [sp], #64
    a0001e40:	d65f03c0 	ret

00000000a0001e44 <blackscholes_main>:
#endif //ENABLE_TBB

int blackscholes_main ()
{
    a0001e44:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
    a0001e48:	910003fd 	mov	x29, sp
    a0001e4c:	fd000be8 	str	d8, [sp, #16]
    int i;
    int loopnum;
    fptype * buffer;
    int * buffer2;
    int rv;
    init_data_init();
    a0001e50:	940001d8 	bl	a00025b0 <init_data_init>
#ifdef PARSEC_VERSION
#define __PARSEC_STRING(x) #x
#define __PARSEC_XSTRING(x) __PARSEC_STRING(x)
        printf("PARSEC Benchmark Suite Version "__PARSEC_XSTRING(PARSEC_VERSION)"\n");
#else
        printf("PARSEC Benchmark Suite\n");
    a0001e54:	f0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a0001e58:	91042000 	add	x0, x0, #0x108
    a0001e5c:	94002960 	bl	a000c3dc <printf>
#endif //PARSEC_VERSION
#ifdef ENABLE_PARSEC_HOOKS
   __parsec_bench_begin(__parsec_blackscholes);
#endif
		
	for(int i = 0 ; i < 250 ; i++)
    a0001e60:	b900abff 	str	wzr, [sp, #168]
    a0001e64:	14000011 	b	a0001ea8 <blackscholes_main+0x64>
	{
		memcpy((void*)&data_compute[i*4], (void*)datainit , 4*sizeof(OptionData));
    a0001e68:	b940abe0 	ldr	w0, [sp, #168]
    a0001e6c:	531e7400 	lsl	w0, w0, #2
    a0001e70:	93407c01 	sxtw	x1, w0
    a0001e74:	d2800480 	mov	x0, #0x24                  	// #36
    a0001e78:	9b007c21 	mul	x1, x1, x0
    a0001e7c:	d00001e0 	adrp	x0, a003f000 <l.0>
    a0001e80:	91084000 	add	x0, x0, #0x210
    a0001e84:	8b000023 	add	x3, x1, x0
    a0001e88:	d2801202 	mov	x2, #0x90                  	// #144
    a0001e8c:	d0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0001e90:	913bc001 	add	x1, x0, #0xef0
    a0001e94:	aa0303e0 	mov	x0, x3
    a0001e98:	94002800 	bl	a000be98 <memcpy>
	for(int i = 0 ; i < 250 ; i++)
    a0001e9c:	b940abe0 	ldr	w0, [sp, #168]
    a0001ea0:	11000400 	add	w0, w0, #0x1
    a0001ea4:	b900abe0 	str	w0, [sp, #168]
    a0001ea8:	b940abe0 	ldr	w0, [sp, #168]
    a0001eac:	7103e41f 	cmp	w0, #0xf9
    a0001eb0:	54fffdcd 	b.le	a0001e68 <blackscholes_main+0x24>
	}
	for(int i = 0 ; i<4; i++)
    a0001eb4:	b900a7ff 	str	wzr, [sp, #164]
    a0001eb8:	14000053 	b	a0002004 <blackscholes_main+0x1c0>
	{
	printf("i copied %f %f %f %f %f %f %c %f %f\n", data_compute[i].s, data_compute[i].strike, data_compute[i].r, data_compute[i].divq, data_compute[i].v, data_compute[i].t, data_compute[i].OptionType, data_compute[i].divs, data_compute[i].DGrefval);
    a0001ebc:	d00001e0 	adrp	x0, a003f000 <l.0>
    a0001ec0:	91084001 	add	x1, x0, #0x210
    a0001ec4:	b980a7e2 	ldrsw	x2, [sp, #164]
    a0001ec8:	d2800480 	mov	x0, #0x24                  	// #36
    a0001ecc:	9b007c40 	mul	x0, x2, x0
    a0001ed0:	8b000020 	add	x0, x1, x0
    a0001ed4:	bd400000 	ldr	s0, [x0]
    a0001ed8:	1e22c008 	fcvt	d8, s0
    a0001edc:	d00001e0 	adrp	x0, a003f000 <l.0>
    a0001ee0:	91084001 	add	x1, x0, #0x210
    a0001ee4:	b980a7e2 	ldrsw	x2, [sp, #164]
    a0001ee8:	d2800480 	mov	x0, #0x24                  	// #36
    a0001eec:	9b007c40 	mul	x0, x2, x0
    a0001ef0:	8b000020 	add	x0, x1, x0
    a0001ef4:	bd400400 	ldr	s0, [x0, #4]
    a0001ef8:	1e22c001 	fcvt	d1, s0
    a0001efc:	d00001e0 	adrp	x0, a003f000 <l.0>
    a0001f00:	91084001 	add	x1, x0, #0x210
    a0001f04:	b980a7e2 	ldrsw	x2, [sp, #164]
    a0001f08:	d2800480 	mov	x0, #0x24                  	// #36
    a0001f0c:	9b007c40 	mul	x0, x2, x0
    a0001f10:	8b000020 	add	x0, x1, x0
    a0001f14:	bd400800 	ldr	s0, [x0, #8]
    a0001f18:	1e22c002 	fcvt	d2, s0
    a0001f1c:	d00001e0 	adrp	x0, a003f000 <l.0>
    a0001f20:	91084001 	add	x1, x0, #0x210
    a0001f24:	b980a7e2 	ldrsw	x2, [sp, #164]
    a0001f28:	d2800480 	mov	x0, #0x24                  	// #36
    a0001f2c:	9b007c40 	mul	x0, x2, x0
    a0001f30:	8b000020 	add	x0, x1, x0
    a0001f34:	bd400c00 	ldr	s0, [x0, #12]
    a0001f38:	1e22c003 	fcvt	d3, s0
    a0001f3c:	d00001e0 	adrp	x0, a003f000 <l.0>
    a0001f40:	91084001 	add	x1, x0, #0x210
    a0001f44:	b980a7e2 	ldrsw	x2, [sp, #164]
    a0001f48:	d2800480 	mov	x0, #0x24                  	// #36
    a0001f4c:	9b007c40 	mul	x0, x2, x0
    a0001f50:	8b000020 	add	x0, x1, x0
    a0001f54:	bd401000 	ldr	s0, [x0, #16]
    a0001f58:	1e22c004 	fcvt	d4, s0
    a0001f5c:	d00001e0 	adrp	x0, a003f000 <l.0>
    a0001f60:	91084001 	add	x1, x0, #0x210
    a0001f64:	b980a7e2 	ldrsw	x2, [sp, #164]
    a0001f68:	d2800480 	mov	x0, #0x24                  	// #36
    a0001f6c:	9b007c40 	mul	x0, x2, x0
    a0001f70:	8b000020 	add	x0, x1, x0
    a0001f74:	bd401400 	ldr	s0, [x0, #20]
    a0001f78:	1e22c005 	fcvt	d5, s0
    a0001f7c:	d00001e0 	adrp	x0, a003f000 <l.0>
    a0001f80:	91084001 	add	x1, x0, #0x210
    a0001f84:	b980a7e2 	ldrsw	x2, [sp, #164]
    a0001f88:	d2800480 	mov	x0, #0x24                  	// #36
    a0001f8c:	9b007c40 	mul	x0, x2, x0
    a0001f90:	8b000020 	add	x0, x1, x0
    a0001f94:	39406000 	ldrb	w0, [x0, #24]
    a0001f98:	12001c00 	and	w0, w0, #0xff
    a0001f9c:	2a0003e3 	mov	w3, w0
    a0001fa0:	d00001e0 	adrp	x0, a003f000 <l.0>
    a0001fa4:	91084001 	add	x1, x0, #0x210
    a0001fa8:	b980a7e2 	ldrsw	x2, [sp, #164]
    a0001fac:	d2800480 	mov	x0, #0x24                  	// #36
    a0001fb0:	9b007c40 	mul	x0, x2, x0
    a0001fb4:	8b000020 	add	x0, x1, x0
    a0001fb8:	bd401c00 	ldr	s0, [x0, #28]
    a0001fbc:	1e22c006 	fcvt	d6, s0
    a0001fc0:	d00001e0 	adrp	x0, a003f000 <l.0>
    a0001fc4:	91084001 	add	x1, x0, #0x210
    a0001fc8:	b980a7e2 	ldrsw	x2, [sp, #164]
    a0001fcc:	d2800480 	mov	x0, #0x24                  	// #36
    a0001fd0:	9b007c40 	mul	x0, x2, x0
    a0001fd4:	8b000020 	add	x0, x1, x0
    a0001fd8:	bd402000 	ldr	s0, [x0, #32]
    a0001fdc:	1e22c000 	fcvt	d0, s0
    a0001fe0:	1e604007 	fmov	d7, d0
    a0001fe4:	2a0303e1 	mov	w1, w3
    a0001fe8:	1e604100 	fmov	d0, d8
    a0001fec:	f0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a0001ff0:	91048000 	add	x0, x0, #0x120
    a0001ff4:	940028fa 	bl	a000c3dc <printf>
	for(int i = 0 ; i<4; i++)
    a0001ff8:	b940a7e0 	ldr	w0, [sp, #164]
    a0001ffc:	11000400 	add	w0, w0, #0x1
    a0002000:	b900a7e0 	str	w0, [sp, #164]
    a0002004:	b940a7e0 	ldr	w0, [sp, #164]
    a0002008:	71000c1f 	cmp	w0, #0x3
    a000200c:	54fff58d 	b.le	a0001ebc <blackscholes_main+0x78>
        {
                printf("Usage:\n\t%s <nthreads> <inputFile> <outputFile>\n", argv[0]);
                exit(1);
        }
*/
    nThreads = 4;
    a0002010:	d0000460 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a0002014:	91118000 	add	x0, x0, #0x460
    a0002018:	52800081 	mov	w1, #0x4                   	// #4
    a000201c:	b9000001 	str	w1, [x0]
//    char *inputFile = argv[2];
//    char *outputFile = argv[3];

    //Read input data from file
    numOptions = 20;
    a0002020:	d0000460 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a0002024:	91117000 	add	x0, x0, #0x45c
    a0002028:	52800281 	mov	w1, #0x14                  	// #20
    a000202c:	b9000001 	str	w1, [x0]
    if(nThreads > numOptions) {
    a0002030:	d0000460 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a0002034:	91118000 	add	x0, x0, #0x460
    a0002038:	b9400001 	ldr	w1, [x0]
    a000203c:	d0000460 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a0002040:	91117000 	add	x0, x0, #0x45c
    a0002044:	b9400000 	ldr	w0, [x0]
    a0002048:	6b00003f 	cmp	w1, w0
    a000204c:	5400014d 	b.le	a0002074 <blackscholes_main+0x230>
      printf("WARNING: Not enough work, reducing number of threads to match number of options.\n");
    a0002050:	d0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a0002054:	91052000 	add	x0, x0, #0x148
    a0002058:	940028e1 	bl	a000c3dc <printf>
      nThreads = numOptions;
    a000205c:	d0000460 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a0002060:	91117000 	add	x0, x0, #0x45c
    a0002064:	b9400001 	ldr	w1, [x0]
    a0002068:	d0000460 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a000206c:	91118000 	add	x0, x0, #0x460
    a0002070:	b9000001 	str	w1, [x0]
        exit(1);
    }
#endif

    // alloc spaces for the option data
	data = data_compute;
    a0002074:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0002078:	913ac000 	add	x0, x0, #0xeb0
    a000207c:	b00001e1 	adrp	x1, a003f000 <l.0>
    a0002080:	91084021 	add	x1, x1, #0x210
    a0002084:	f9000001 	str	x1, [x0]
    prices = (fptype*)malloc(numOptions*sizeof(fptype));
    a0002088:	d0000460 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a000208c:	91117000 	add	x0, x0, #0x45c
    a0002090:	b9400000 	ldr	w0, [x0]
    a0002094:	93407c00 	sxtw	x0, w0
    a0002098:	d37ef400 	lsl	x0, x0, #2
    a000209c:	9400270e 	bl	a000bcd4 <malloc>
    a00020a0:	aa0003e1 	mov	x1, x0
    a00020a4:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00020a8:	913ae000 	add	x0, x0, #0xeb8
    a00020ac:	f9000001 	str	x1, [x0]
//    data = (OptionData*)malloc(numOptions*sizeof(OptionData));


#ifdef ENABLE_THREADS
    
    pthread_mutexattr_init( &_M4_normalMutexAttr);
    a00020b0:	b00001e0 	adrp	x0, a003f000 <l.0>
    a00020b4:	91082000 	add	x0, x0, #0x208
    a00020b8:	97fffdd9 	bl	a000181c <pthread_mutexattr_init>
//    pthread_mutexattr_settype( &_M4_normalMutexAttr, PTHREAD_MUTEX_NORMAL);
    _M4_numThreads = nThreads;
    a00020bc:	d0000460 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a00020c0:	91118000 	add	x0, x0, #0x460
    a00020c4:	b9400001 	ldr	w1, [x0]
    a00020c8:	b00004c0 	adrp	x0, a009b000 <twom1000.10>
    a00020cc:	9102a000 	add	x0, x0, #0xa8
    a00020d0:	b9000001 	str	w1, [x0]
    {
        int _M4_i;
        for ( _M4_i = 0; _M4_i < MAX_THREADS; _M4_i++) {
    a00020d4:	b900a3ff 	str	wzr, [sp, #160]
    a00020d8:	14000008 	b	a00020f8 <blackscholes_main+0x2b4>
            _M4_threadsTableAllocated[_M4_i] = 0;
    a00020dc:	b00001e0 	adrp	x0, a003f000 <l.0>
    a00020e0:	91002000 	add	x0, x0, #0x8
    a00020e4:	b980a3e1 	ldrsw	x1, [sp, #160]
    a00020e8:	b821781f 	str	wzr, [x0, x1, lsl #2]
        for ( _M4_i = 0; _M4_i < MAX_THREADS; _M4_i++) {
    a00020ec:	b940a3e0 	ldr	w0, [sp, #160]
    a00020f0:	11000400 	add	w0, w0, #0x1
    a00020f4:	b900a3e0 	str	w0, [sp, #160]
    a00020f8:	b940a3e0 	ldr	w0, [sp, #160]
    a00020fc:	7101fc1f 	cmp	w0, #0x7f
    a0002100:	54fffeed 	b.le	a00020dc <blackscholes_main+0x298>
        }
    }
;
#endif
    printf("Num of Options: %d\n", numOptions);
    a0002104:	d0000460 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a0002108:	91117000 	add	x0, x0, #0x45c
    a000210c:	b9400000 	ldr	w0, [x0]
    a0002110:	2a0003e1 	mov	w1, w0
    a0002114:	d0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a0002118:	91068000 	add	x0, x0, #0x1a0
    a000211c:	940028b0 	bl	a000c3dc <printf>
    printf("Num of Runs: %d\n", NUM_RUNS);
    a0002120:	52803e81 	mov	w1, #0x1f4                 	// #500
    a0002124:	d0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a0002128:	9106e000 	add	x0, x0, #0x1b8
    a000212c:	940028ac 	bl	a000c3dc <printf>

#define PAD 256
#define LINESIZE 64

    buffer = (fptype *) malloc(5 * numOptions * sizeof(fptype) + PAD);
    a0002130:	d0000460 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a0002134:	91117000 	add	x0, x0, #0x45c
    a0002138:	b9400001 	ldr	w1, [x0]
    a000213c:	2a0103e0 	mov	w0, w1
    a0002140:	531e7400 	lsl	w0, w0, #2
    a0002144:	0b010000 	add	w0, w0, w1
    a0002148:	93407c00 	sxtw	x0, w0
    a000214c:	91010000 	add	x0, x0, #0x40
    a0002150:	d37ef400 	lsl	x0, x0, #2
    a0002154:	940026e0 	bl	a000bcd4 <malloc>
    a0002158:	f9004be0 	str	x0, [sp, #144]
    sptprice = (fptype *) (((unsigned long long)buffer + PAD) & ~(LINESIZE - 1));
    a000215c:	f9404be0 	ldr	x0, [sp, #144]
    a0002160:	91040000 	add	x0, x0, #0x100
    a0002164:	927ae400 	and	x0, x0, #0xffffffffffffffc0
    a0002168:	aa0003e1 	mov	x1, x0
    a000216c:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0002170:	913b2000 	add	x0, x0, #0xec8
    a0002174:	f9000001 	str	x1, [x0]
    strike = sptprice + numOptions;
    a0002178:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000217c:	913b2000 	add	x0, x0, #0xec8
    a0002180:	f9400001 	ldr	x1, [x0]
    a0002184:	d0000460 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a0002188:	91117000 	add	x0, x0, #0x45c
    a000218c:	b9400000 	ldr	w0, [x0]
    a0002190:	93407c00 	sxtw	x0, w0
    a0002194:	d37ef400 	lsl	x0, x0, #2
    a0002198:	8b000021 	add	x1, x1, x0
    a000219c:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00021a0:	913b4000 	add	x0, x0, #0xed0
    a00021a4:	f9000001 	str	x1, [x0]
    rate = strike + numOptions;
    a00021a8:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00021ac:	913b4000 	add	x0, x0, #0xed0
    a00021b0:	f9400001 	ldr	x1, [x0]
    a00021b4:	d0000460 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a00021b8:	91117000 	add	x0, x0, #0x45c
    a00021bc:	b9400000 	ldr	w0, [x0]
    a00021c0:	93407c00 	sxtw	x0, w0
    a00021c4:	d37ef400 	lsl	x0, x0, #2
    a00021c8:	8b000021 	add	x1, x1, x0
    a00021cc:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00021d0:	913b6000 	add	x0, x0, #0xed8
    a00021d4:	f9000001 	str	x1, [x0]
    volatility = rate + numOptions;
    a00021d8:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00021dc:	913b6000 	add	x0, x0, #0xed8
    a00021e0:	f9400001 	ldr	x1, [x0]
    a00021e4:	d0000460 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a00021e8:	91117000 	add	x0, x0, #0x45c
    a00021ec:	b9400000 	ldr	w0, [x0]
    a00021f0:	93407c00 	sxtw	x0, w0
    a00021f4:	d37ef400 	lsl	x0, x0, #2
    a00021f8:	8b000021 	add	x1, x1, x0
    a00021fc:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0002200:	913b8000 	add	x0, x0, #0xee0
    a0002204:	f9000001 	str	x1, [x0]
    otime = volatility + numOptions;
    a0002208:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000220c:	913b8000 	add	x0, x0, #0xee0
    a0002210:	f9400001 	ldr	x1, [x0]
    a0002214:	d0000460 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a0002218:	91117000 	add	x0, x0, #0x45c
    a000221c:	b9400000 	ldr	w0, [x0]
    a0002220:	93407c00 	sxtw	x0, w0
    a0002224:	d37ef400 	lsl	x0, x0, #2
    a0002228:	8b000021 	add	x1, x1, x0
    a000222c:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0002230:	913ba000 	add	x0, x0, #0xee8
    a0002234:	f9000001 	str	x1, [x0]

    buffer2 = (int *) malloc(numOptions * sizeof(fptype) + PAD);
    a0002238:	d0000460 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a000223c:	91117000 	add	x0, x0, #0x45c
    a0002240:	b9400000 	ldr	w0, [x0]
    a0002244:	93407c00 	sxtw	x0, w0
    a0002248:	91010000 	add	x0, x0, #0x40
    a000224c:	d37ef400 	lsl	x0, x0, #2
    a0002250:	940026a1 	bl	a000bcd4 <malloc>
    a0002254:	f90047e0 	str	x0, [sp, #136]
    otype = (int *) (((unsigned long long)buffer2 + PAD) & ~(LINESIZE - 1));
    a0002258:	f94047e0 	ldr	x0, [sp, #136]
    a000225c:	91040000 	add	x0, x0, #0x100
    a0002260:	927ae400 	and	x0, x0, #0xffffffffffffffc0
    a0002264:	aa0003e1 	mov	x1, x0
    a0002268:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000226c:	913b0000 	add	x0, x0, #0xec0
    a0002270:	f9000001 	str	x1, [x0]

    for (i=0; i<numOptions; i++) {
    a0002274:	b900afff 	str	wzr, [sp, #172]
    a0002278:	1400006f 	b	a0002434 <blackscholes_main+0x5f0>
        otype[i]      = (data[i].OptionType == 'P') ? 1 : 0;
    a000227c:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0002280:	913ac000 	add	x0, x0, #0xeb0
    a0002284:	f9400001 	ldr	x1, [x0]
    a0002288:	b980afe2 	ldrsw	x2, [sp, #172]
    a000228c:	d2800480 	mov	x0, #0x24                  	// #36
    a0002290:	9b007c40 	mul	x0, x2, x0
    a0002294:	8b000020 	add	x0, x1, x0
    a0002298:	39406000 	ldrb	w0, [x0, #24]
    a000229c:	12001c00 	and	w0, w0, #0xff
    a00022a0:	7101401f 	cmp	w0, #0x50
    a00022a4:	1a9f17e0 	cset	w0, eq  // eq = none
    a00022a8:	12001c02 	and	w2, w0, #0xff
    a00022ac:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00022b0:	913b0000 	add	x0, x0, #0xec0
    a00022b4:	f9400001 	ldr	x1, [x0]
    a00022b8:	b980afe0 	ldrsw	x0, [sp, #172]
    a00022bc:	d37ef400 	lsl	x0, x0, #2
    a00022c0:	8b000020 	add	x0, x1, x0
    a00022c4:	2a0203e1 	mov	w1, w2
    a00022c8:	b9000001 	str	w1, [x0]
     	printf("option type was P id %d is 1 for count %d\n",otype[i],i );
    a00022cc:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00022d0:	913b0000 	add	x0, x0, #0xec0
    a00022d4:	f9400001 	ldr	x1, [x0]
    a00022d8:	b980afe0 	ldrsw	x0, [sp, #172]
    a00022dc:	d37ef400 	lsl	x0, x0, #2
    a00022e0:	8b000020 	add	x0, x1, x0
    a00022e4:	b9400000 	ldr	w0, [x0]
    a00022e8:	b940afe2 	ldr	w2, [sp, #172]
    a00022ec:	2a0003e1 	mov	w1, w0
    a00022f0:	d0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a00022f4:	91074000 	add	x0, x0, #0x1d0
    a00022f8:	94002839 	bl	a000c3dc <printf>
	sptprice[i]   = data[i].s;
    a00022fc:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0002300:	913ac000 	add	x0, x0, #0xeb0
    a0002304:	f9400001 	ldr	x1, [x0]
    a0002308:	b980afe2 	ldrsw	x2, [sp, #172]
    a000230c:	d2800480 	mov	x0, #0x24                  	// #36
    a0002310:	9b007c40 	mul	x0, x2, x0
    a0002314:	8b000021 	add	x1, x1, x0
    a0002318:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000231c:	913b2000 	add	x0, x0, #0xec8
    a0002320:	f9400002 	ldr	x2, [x0]
    a0002324:	b980afe0 	ldrsw	x0, [sp, #172]
    a0002328:	d37ef400 	lsl	x0, x0, #2
    a000232c:	8b000040 	add	x0, x2, x0
    a0002330:	bd400020 	ldr	s0, [x1]
    a0002334:	bd000000 	str	s0, [x0]
        strike[i]     = data[i].strike;
    a0002338:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000233c:	913ac000 	add	x0, x0, #0xeb0
    a0002340:	f9400001 	ldr	x1, [x0]
    a0002344:	b980afe2 	ldrsw	x2, [sp, #172]
    a0002348:	d2800480 	mov	x0, #0x24                  	// #36
    a000234c:	9b007c40 	mul	x0, x2, x0
    a0002350:	8b000021 	add	x1, x1, x0
    a0002354:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0002358:	913b4000 	add	x0, x0, #0xed0
    a000235c:	f9400002 	ldr	x2, [x0]
    a0002360:	b980afe0 	ldrsw	x0, [sp, #172]
    a0002364:	d37ef400 	lsl	x0, x0, #2
    a0002368:	8b000040 	add	x0, x2, x0
    a000236c:	bd400420 	ldr	s0, [x1, #4]
    a0002370:	bd000000 	str	s0, [x0]
        rate[i]       = data[i].r;
    a0002374:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0002378:	913ac000 	add	x0, x0, #0xeb0
    a000237c:	f9400001 	ldr	x1, [x0]
    a0002380:	b980afe2 	ldrsw	x2, [sp, #172]
    a0002384:	d2800480 	mov	x0, #0x24                  	// #36
    a0002388:	9b007c40 	mul	x0, x2, x0
    a000238c:	8b000021 	add	x1, x1, x0
    a0002390:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0002394:	913b6000 	add	x0, x0, #0xed8
    a0002398:	f9400002 	ldr	x2, [x0]
    a000239c:	b980afe0 	ldrsw	x0, [sp, #172]
    a00023a0:	d37ef400 	lsl	x0, x0, #2
    a00023a4:	8b000040 	add	x0, x2, x0
    a00023a8:	bd400820 	ldr	s0, [x1, #8]
    a00023ac:	bd000000 	str	s0, [x0]
        volatility[i] = data[i].v;    
    a00023b0:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00023b4:	913ac000 	add	x0, x0, #0xeb0
    a00023b8:	f9400001 	ldr	x1, [x0]
    a00023bc:	b980afe2 	ldrsw	x2, [sp, #172]
    a00023c0:	d2800480 	mov	x0, #0x24                  	// #36
    a00023c4:	9b007c40 	mul	x0, x2, x0
    a00023c8:	8b000021 	add	x1, x1, x0
    a00023cc:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00023d0:	913b8000 	add	x0, x0, #0xee0
    a00023d4:	f9400002 	ldr	x2, [x0]
    a00023d8:	b980afe0 	ldrsw	x0, [sp, #172]
    a00023dc:	d37ef400 	lsl	x0, x0, #2
    a00023e0:	8b000040 	add	x0, x2, x0
    a00023e4:	bd401020 	ldr	s0, [x1, #16]
    a00023e8:	bd000000 	str	s0, [x0]
        otime[i]      = data[i].t;
    a00023ec:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00023f0:	913ac000 	add	x0, x0, #0xeb0
    a00023f4:	f9400001 	ldr	x1, [x0]
    a00023f8:	b980afe2 	ldrsw	x2, [sp, #172]
    a00023fc:	d2800480 	mov	x0, #0x24                  	// #36
    a0002400:	9b007c40 	mul	x0, x2, x0
    a0002404:	8b000021 	add	x1, x1, x0
    a0002408:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000240c:	913ba000 	add	x0, x0, #0xee8
    a0002410:	f9400002 	ldr	x2, [x0]
    a0002414:	b980afe0 	ldrsw	x0, [sp, #172]
    a0002418:	d37ef400 	lsl	x0, x0, #2
    a000241c:	8b000040 	add	x0, x2, x0
    a0002420:	bd401420 	ldr	s0, [x1, #20]
    a0002424:	bd000000 	str	s0, [x0]
    for (i=0; i<numOptions; i++) {
    a0002428:	b940afe0 	ldr	w0, [sp, #172]
    a000242c:	11000400 	add	w0, w0, #0x1
    a0002430:	b900afe0 	str	w0, [sp, #172]
    a0002434:	d0000460 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a0002438:	91117000 	add	x0, x0, #0x45c
    a000243c:	b9400000 	ldr	w0, [x0]
    a0002440:	b940afe1 	ldr	w1, [sp, #172]
    a0002444:	6b00003f 	cmp	w1, w0
    a0002448:	54fff1ab 	b.lt	a000227c <blackscholes_main+0x438>  // b.tstop
    }

    printf("Size of data: %d\n", numOptions * (sizeof(OptionData) + sizeof(int)));
    a000244c:	d0000460 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a0002450:	91117000 	add	x0, x0, #0x45c
    a0002454:	b9400000 	ldr	w0, [x0]
    a0002458:	93407c01 	sxtw	x1, w0
    a000245c:	d2800500 	mov	x0, #0x28                  	// #40
    a0002460:	9b007c20 	mul	x0, x1, x0
    a0002464:	aa0003e1 	mov	x1, x0
    a0002468:	d0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a000246c:	91080000 	add	x0, x0, #0x200
    a0002470:	940027db 	bl	a000c3dc <printf>
        threads[i] = CreateThread(0, 0, bs_thread, &nums[i], 0, 0);
    }
    WaitForMultipleObjects(nThreads, threads, TRUE, INFINITE);
#else
    int *tids;
    tids = (int *) malloc (nThreads * sizeof(int));
    a0002474:	d0000460 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a0002478:	91118000 	add	x0, x0, #0x460
    a000247c:	b9400000 	ldr	w0, [x0]
    a0002480:	93407c00 	sxtw	x0, w0
    a0002484:	d37ef400 	lsl	x0, x0, #2
    a0002488:	94002613 	bl	a000bcd4 <malloc>
    a000248c:	f90043e0 	str	x0, [sp, #128]
    pthread_attr_t attr[2];
    for(i=0; i<nThreads; i++) {
    a0002490:	b900afff 	str	wzr, [sp, #172]
    a0002494:	1400001f 	b	a0002510 <blackscholes_main+0x6cc>
        tids[i]=i;
    a0002498:	b980afe0 	ldrsw	x0, [sp, #172]
    a000249c:	d37ef400 	lsl	x0, x0, #2
    a00024a0:	f94043e1 	ldr	x1, [sp, #128]
    a00024a4:	8b000020 	add	x0, x1, x0
    a00024a8:	b940afe1 	ldr	w1, [sp, #172]
    a00024ac:	b9000001 	str	w1, [x0]
//	pthread_attr_init(&attr[i]);
//	pthread_attr_setstack(&attr[i], &blasch_stacks[i][0], STACKSIZ);
        
    {
        int _M4_i;
        for ( _M4_i = 0; _M4_i < MAX_THREADS; _M4_i++) {
    a00024b0:	b9009fff 	str	wzr, [sp, #156]
    a00024b4:	1400000a 	b	a00024dc <blackscholes_main+0x698>
            if ( _M4_threadsTableAllocated[_M4_i] == 0)    break;
    a00024b8:	b00001e0 	adrp	x0, a003f000 <l.0>
    a00024bc:	91002000 	add	x0, x0, #0x8
    a00024c0:	b9809fe1 	ldrsw	x1, [sp, #156]
    a00024c4:	b8617800 	ldr	w0, [x0, x1, lsl #2]
    a00024c8:	7100001f 	cmp	w0, #0x0
    a00024cc:	54000100 	b.eq	a00024ec <blackscholes_main+0x6a8>  // b.none
        for ( _M4_i = 0; _M4_i < MAX_THREADS; _M4_i++) {
    a00024d0:	b9409fe0 	ldr	w0, [sp, #156]
    a00024d4:	11000400 	add	w0, w0, #0x1
    a00024d8:	b9009fe0 	str	w0, [sp, #156]
    a00024dc:	b9409fe0 	ldr	w0, [sp, #156]
    a00024e0:	7101fc1f 	cmp	w0, #0x7f
    a00024e4:	54fffead 	b.le	a00024b8 <blackscholes_main+0x674>
    a00024e8:	14000002 	b	a00024f0 <blackscholes_main+0x6ac>
            if ( _M4_threadsTableAllocated[_M4_i] == 0)    break;
    a00024ec:	d503201f 	nop
        }
//        pthread_create(&_M4_threadsTable[_M4_i],&attr[i],(void *(*)(void *))bs_thread,(void *)&tids[i]);
        _M4_threadsTableAllocated[_M4_i] = 1;
    a00024f0:	b00001e0 	adrp	x0, a003f000 <l.0>
    a00024f4:	91002000 	add	x0, x0, #0x8
    a00024f8:	b9809fe1 	ldrsw	x1, [sp, #156]
    a00024fc:	52800022 	mov	w2, #0x1                   	// #1
    a0002500:	b8217802 	str	w2, [x0, x1, lsl #2]
    for(i=0; i<nThreads; i++) {
    a0002504:	b940afe0 	ldr	w0, [sp, #172]
    a0002508:	11000400 	add	w0, w0, #0x1
    a000250c:	b900afe0 	str	w0, [sp, #172]
    a0002510:	d0000460 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a0002514:	91118000 	add	x0, x0, #0x460
    a0002518:	b9400000 	ldr	w0, [x0]
    a000251c:	b940afe1 	ldr	w1, [sp, #172]
    a0002520:	6b00003f 	cmp	w1, w0
    a0002524:	54fffbab 	b.lt	a0002498 <blackscholes_main+0x654>  // b.tstop
    }
;
    }
   	usleep(USEC_PER_MSEC * 100U); 
    a0002528:	d290d400 	mov	x0, #0x86a0                	// #34464
    a000252c:	f2a00020 	movk	x0, #0x1, lsl #16
    a0002530:	94002ab0 	bl	a000cff0 <usleep>
    {
        int _M4_i;
        void *_M4_ret;
        for ( _M4_i = 0; _M4_i < MAX_THREADS;_M4_i++) {
    a0002534:	b9009bff 	str	wzr, [sp, #152]
    a0002538:	1400000a 	b	a0002560 <blackscholes_main+0x71c>
            if ( _M4_threadsTableAllocated[_M4_i] == 0)    break;
    a000253c:	b00001e0 	adrp	x0, a003f000 <l.0>
    a0002540:	91002000 	add	x0, x0, #0x8
    a0002544:	b9809be1 	ldrsw	x1, [sp, #152]
    a0002548:	b8617800 	ldr	w0, [x0, x1, lsl #2]
    a000254c:	7100001f 	cmp	w0, #0x0
    a0002550:	54000100 	b.eq	a0002570 <blackscholes_main+0x72c>  // b.none
        for ( _M4_i = 0; _M4_i < MAX_THREADS;_M4_i++) {
    a0002554:	b9409be0 	ldr	w0, [sp, #152]
    a0002558:	11000400 	add	w0, w0, #0x1
    a000255c:	b9009be0 	str	w0, [sp, #152]
    a0002560:	b9409be0 	ldr	w0, [sp, #152]
    a0002564:	7101fc1f 	cmp	w0, #0x7f
    a0002568:	54fffead 	b.le	a000253c <blackscholes_main+0x6f8>
    a000256c:	14000002 	b	a0002574 <blackscholes_main+0x730>
            if ( _M4_threadsTableAllocated[_M4_i] == 0)    break;
    a0002570:	d503201f 	nop
    __parsec_roi_end();
#endif

    //Write prices to output file
//    printf("%d\n", numOptions);
    for(i=0; i<numOptions; i++) {
    a0002574:	b900afff 	str	wzr, [sp, #172]
    a0002578:	14000004 	b	a0002588 <blackscholes_main+0x744>
    a000257c:	b940afe0 	ldr	w0, [sp, #172]
    a0002580:	11000400 	add	w0, w0, #0x1
    a0002584:	b900afe0 	str	w0, [sp, #172]
    a0002588:	d0000460 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a000258c:	91117000 	add	x0, x0, #0x45c
    a0002590:	b9400000 	ldr	w0, [x0]
    a0002594:	b940afe1 	ldr	w1, [sp, #172]
    a0002598:	6b00003f 	cmp	w1, w0
    a000259c:	54ffff0b 	b.lt	a000257c <blackscholes_main+0x738>  // b.tstop

#ifdef ENABLE_PARSEC_HOOKS
    __parsec_bench_end();
#endif

    return 0;
    a00025a0:	52800000 	mov	w0, #0x0                   	// #0
}
    a00025a4:	fd400be8 	ldr	d8, [sp, #16]
    a00025a8:	a8cb7bfd 	ldp	x29, x30, [sp], #176
    a00025ac:	d65f03c0 	ret

00000000a00025b0 <init_data_init>:
#include "inc.h"
OptionData datainit[4];


void init_data_init(){
datainit[0].s            = 42.0;
    a00025b0:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00025b4:	913bc000 	add	x0, x0, #0xef0
    a00025b8:	52a84501 	mov	w1, #0x42280000            	// #1109917696
    a00025bc:	1e270020 	fmov	s0, w1
    a00025c0:	bd000000 	str	s0, [x0]
datainit[0].strike       = 40.00;
    a00025c4:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00025c8:	913bc000 	add	x0, x0, #0xef0
    a00025cc:	52a84401 	mov	w1, #0x42200000            	// #1109393408
    a00025d0:	1e270020 	fmov	s0, w1
    a00025d4:	bd000400 	str	s0, [x0, #4]
datainit[0].r            = 0.1000;
    a00025d8:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00025dc:	913bc000 	add	x0, x0, #0xef0
    a00025e0:	529999a1 	mov	w1, #0xcccd                	// #52429
    a00025e4:	72a7b981 	movk	w1, #0x3dcc, lsl #16
    a00025e8:	1e270020 	fmov	s0, w1
    a00025ec:	bd000800 	str	s0, [x0, #8]
datainit[0].divq         = 0.00;
    a00025f0:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00025f4:	913bc000 	add	x0, x0, #0xef0
    a00025f8:	b9000c1f 	str	wzr, [x0, #12]
datainit[0].v            = 0.20;
    a00025fc:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0002600:	913bc000 	add	x0, x0, #0xef0
    a0002604:	529999a1 	mov	w1, #0xcccd                	// #52429
    a0002608:	72a7c981 	movk	w1, #0x3e4c, lsl #16
    a000260c:	1e270020 	fmov	s0, w1
    a0002610:	bd001000 	str	s0, [x0, #16]
datainit[0].t            = 0.50;
    a0002614:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0002618:	913bc000 	add	x0, x0, #0xef0
    a000261c:	1e2c1000 	fmov	s0, #5.000000000000000000e-01
    a0002620:	bd001400 	str	s0, [x0, #20]
datainit[0].OptionType   = 'C';
    a0002624:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0002628:	913bc000 	add	x0, x0, #0xef0
    a000262c:	52800861 	mov	w1, #0x43                  	// #67
    a0002630:	39006001 	strb	w1, [x0, #24]
datainit[0].divs         = 0.00;
    a0002634:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0002638:	913bc000 	add	x0, x0, #0xef0
    a000263c:	b9001c1f 	str	wzr, [x0, #28]
datainit[0].DGrefval     = 4.759423036851750055;
    a0002640:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0002644:	913bc000 	add	x0, x0, #0xef0
    a0002648:	5289a641 	mov	w1, #0x4d32                	// #19762
    a000264c:	72a81301 	movk	w1, #0x4098, lsl #16
    a0002650:	1e270020 	fmov	s0, w1
    a0002654:	bd002000 	str	s0, [x0, #32]

datainit[1].s		= 42.00;
    a0002658:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000265c:	913bc000 	add	x0, x0, #0xef0
    a0002660:	52a84501 	mov	w1, #0x42280000            	// #1109917696
    a0002664:	1e270020 	fmov	s0, w1
    a0002668:	bd002400 	str	s0, [x0, #36]
datainit[1].strike	= 40.00;
    a000266c:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0002670:	913bc000 	add	x0, x0, #0xef0
    a0002674:	52a84401 	mov	w1, #0x42200000            	// #1109393408
    a0002678:	1e270020 	fmov	s0, w1
    a000267c:	bd002800 	str	s0, [x0, #40]
datainit[1].r		= 0.1000;
    a0002680:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0002684:	913bc000 	add	x0, x0, #0xef0
    a0002688:	529999a1 	mov	w1, #0xcccd                	// #52429
    a000268c:	72a7b981 	movk	w1, #0x3dcc, lsl #16
    a0002690:	1e270020 	fmov	s0, w1
    a0002694:	bd002c00 	str	s0, [x0, #44]
datainit[1].divq	= 0.00 ;
    a0002698:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000269c:	913bc000 	add	x0, x0, #0xef0
    a00026a0:	b900301f 	str	wzr, [x0, #48]
datainit[1].v		= 0.20;
    a00026a4:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00026a8:	913bc000 	add	x0, x0, #0xef0
    a00026ac:	529999a1 	mov	w1, #0xcccd                	// #52429
    a00026b0:	72a7c981 	movk	w1, #0x3e4c, lsl #16
    a00026b4:	1e270020 	fmov	s0, w1
    a00026b8:	bd003400 	str	s0, [x0, #52]
datainit[1].t		= 0.50;
    a00026bc:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00026c0:	913bc000 	add	x0, x0, #0xef0
    a00026c4:	1e2c1000 	fmov	s0, #5.000000000000000000e-01
    a00026c8:	bd003800 	str	s0, [x0, #56]
datainit[1].OptionType	= 'P';
    a00026cc:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00026d0:	913bc000 	add	x0, x0, #0xef0
    a00026d4:	52800a01 	mov	w1, #0x50                  	// #80
    a00026d8:	3900f001 	strb	w1, [x0, #60]
datainit[1].divs	= 0.00; 
    a00026dc:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00026e0:	913bc000 	add	x0, x0, #0xef0
    a00026e4:	b900401f 	str	wzr, [x0, #64]
datainit[1].DGrefval	= 0.808600016880314021;
    a00026e8:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00026ec:	913bc000 	add	x0, x0, #0xef0
    a00026f0:	52800d21 	mov	w1, #0x69                  	// #105
    a00026f4:	72a7e9e1 	movk	w1, #0x3f4f, lsl #16
    a00026f8:	1e270020 	fmov	s0, w1
    a00026fc:	bd004400 	str	s0, [x0, #68]


datainit[2].s		= 100.00 ;
    a0002700:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0002704:	913bc000 	add	x0, x0, #0xef0
    a0002708:	52a85901 	mov	w1, #0x42c80000            	// #1120403456
    a000270c:	1e270020 	fmov	s0, w1
    a0002710:	bd004800 	str	s0, [x0, #72]
datainit[2].strike	= 100.00;
    a0002714:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0002718:	913bc000 	add	x0, x0, #0xef0
    a000271c:	52a85901 	mov	w1, #0x42c80000            	// #1120403456
    a0002720:	1e270020 	fmov	s0, w1
    a0002724:	bd004c00 	str	s0, [x0, #76]
datainit[2].r		= 0.0500;
    a0002728:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000272c:	913bc000 	add	x0, x0, #0xef0
    a0002730:	529999a1 	mov	w1, #0xcccd                	// #52429
    a0002734:	72a7a981 	movk	w1, #0x3d4c, lsl #16
    a0002738:	1e270020 	fmov	s0, w1
    a000273c:	bd005000 	str	s0, [x0, #80]
datainit[2].divq	= 0.00;
    a0002740:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0002744:	913bc000 	add	x0, x0, #0xef0
    a0002748:	b900541f 	str	wzr, [x0, #84]
datainit[2].v		= 0.15;
    a000274c:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0002750:	913bc000 	add	x0, x0, #0xef0
    a0002754:	52933341 	mov	w1, #0x999a                	// #39322
    a0002758:	72a7c321 	movk	w1, #0x3e19, lsl #16
    a000275c:	1e270020 	fmov	s0, w1
    a0002760:	bd005800 	str	s0, [x0, #88]
datainit[2].t		= 1.00;
    a0002764:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0002768:	913bc000 	add	x0, x0, #0xef0
    a000276c:	1e2e1000 	fmov	s0, #1.000000000000000000e+00
    a0002770:	bd005c00 	str	s0, [x0, #92]
datainit[2].OptionType	= 'P';
    a0002774:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0002778:	913bc000 	add	x0, x0, #0xef0
    a000277c:	52800a01 	mov	w1, #0x50                  	// #80
    a0002780:	39018001 	strb	w1, [x0, #96]
datainit[2].divs	= 0.00;
    a0002784:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0002788:	913bc000 	add	x0, x0, #0xef0
    a000278c:	b900641f 	str	wzr, [x0, #100]
datainit[2].DGrefval	= 3.714602051381290071;
    a0002790:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0002794:	913bc000 	add	x0, x0, #0xef0
    a0002798:	52978141 	mov	w1, #0xbc0a                	// #48138
    a000279c:	72a80da1 	movk	w1, #0x406d, lsl #16
    a00027a0:	1e270020 	fmov	s0, w1
    a00027a4:	bd006800 	str	s0, [x0, #104]


datainit[3].s		= 100.00;
    a00027a8:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00027ac:	913bc000 	add	x0, x0, #0xef0
    a00027b0:	52a85901 	mov	w1, #0x42c80000            	// #1120403456
    a00027b4:	1e270020 	fmov	s0, w1
    a00027b8:	bd006c00 	str	s0, [x0, #108]
datainit[3].strike	= 100.00;
    a00027bc:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00027c0:	913bc000 	add	x0, x0, #0xef0
    a00027c4:	52a85901 	mov	w1, #0x42c80000            	// #1120403456
    a00027c8:	1e270020 	fmov	s0, w1
    a00027cc:	bd007000 	str	s0, [x0, #112]
datainit[3].r		= 0.0500;
    a00027d0:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00027d4:	913bc000 	add	x0, x0, #0xef0
    a00027d8:	529999a1 	mov	w1, #0xcccd                	// #52429
    a00027dc:	72a7a981 	movk	w1, #0x3d4c, lsl #16
    a00027e0:	1e270020 	fmov	s0, w1
    a00027e4:	bd007400 	str	s0, [x0, #116]
datainit[3].divq	= 0.00;
    a00027e8:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00027ec:	913bc000 	add	x0, x0, #0xef0
    a00027f0:	b900781f 	str	wzr, [x0, #120]
datainit[3].v		= 0.15;
    a00027f4:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00027f8:	913bc000 	add	x0, x0, #0xef0
    a00027fc:	52933341 	mov	w1, #0x999a                	// #39322
    a0002800:	72a7c321 	movk	w1, #0x3e19, lsl #16
    a0002804:	1e270020 	fmov	s0, w1
    a0002808:	bd007c00 	str	s0, [x0, #124]
datainit[3].t		= 1.00;
    a000280c:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0002810:	913bc000 	add	x0, x0, #0xef0
    a0002814:	1e2e1000 	fmov	s0, #1.000000000000000000e+00
    a0002818:	bd008000 	str	s0, [x0, #128]
datainit[3].OptionType	= 'C';
    a000281c:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0002820:	913bc000 	add	x0, x0, #0xef0
    a0002824:	52800861 	mov	w1, #0x43                  	// #67
    a0002828:	39021001 	strb	w1, [x0, #132]
datainit[3].divs	= 0.00;
    a000282c:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0002830:	913bc000 	add	x0, x0, #0xef0
    a0002834:	b900881f 	str	wzr, [x0, #136]
datainit[3].DGrefval	= 8.591659601309890704;
    a0002838:	b0000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000283c:	913bc000 	add	x0, x0, #0xef0
    a0002840:	528eee01 	mov	w1, #0x7770                	// #30576
    a0002844:	72a82121 	movk	w1, #0x4109, lsl #16
    a0002848:	1e270020 	fmov	s0, w1
    a000284c:	bd008c00 	str	s0, [x0, #140]
}
    a0002850:	d503201f 	nop
    a0002854:	d65f03c0 	ret

00000000a0002858 <sqrt>:
        SET_HIGH_WORD(x,high&0x7fffffff);
        return x;
}

double sqrt(double x)
{
    a0002858:	d10183ff 	sub	sp, sp, #0x60
    a000285c:	fd0007e0 	str	d0, [sp, #8]
	double z;
	int32_t sign = (int)0x80000000;
    a0002860:	52b00000 	mov	w0, #0x80000000            	// #-2147483648
    a0002864:	b9003be0 	str	w0, [sp, #56]
	int32_t ix0,s0,q,m,t,i;
	u_int32_t r,t1,s1,ix1,q1;

	EXTRACT_WORDS(ix0,ix1,x);
    a0002868:	fd4007e0 	ldr	d0, [sp, #8]
    a000286c:	fd0013e0 	str	d0, [sp, #32]
    a0002870:	b94023e0 	ldr	w0, [sp, #32]
    a0002874:	b9005fe0 	str	w0, [sp, #92]
    a0002878:	b94027e0 	ldr	w0, [sp, #36]
    a000287c:	b90043e0 	str	w0, [sp, #64]

    /* take care of Inf and NaN */
	if((ix0&0x7ff00000)==0x7ff00000) {			
    a0002880:	b9405fe0 	ldr	w0, [sp, #92]
    a0002884:	120c2801 	and	w1, w0, #0x7ff00000
    a0002888:	52affe00 	mov	w0, #0x7ff00000            	// #2146435072
    a000288c:	6b00003f 	cmp	w1, w0
    a0002890:	540000c1 	b.ne	a00028a8 <sqrt+0x50>  // b.any
	    return x*x+x;		/* sqrt(NaN)=NaN, sqrt(+inf)=+inf
    a0002894:	fd4007e0 	ldr	d0, [sp, #8]
    a0002898:	1e600801 	fmul	d1, d0, d0
    a000289c:	fd4007e0 	ldr	d0, [sp, #8]
    a00028a0:	1e602820 	fadd	d0, d1, d0
    a00028a4:	14000136 	b	a0002d7c <sqrt+0x524>
					   sqrt(-inf)=sNaN */
	} 
    /* take care of zero */
	if(ix0<=0) {
    a00028a8:	b9405fe0 	ldr	w0, [sp, #92]
    a00028ac:	7100001f 	cmp	w0, #0x0
    a00028b0:	540002ac 	b.gt	a0002904 <sqrt+0xac>
	    if(((ix0&(~sign))|ix1)==0) return x;/* sqrt(+-0) = +-0 */
    a00028b4:	b9403be0 	ldr	w0, [sp, #56]
    a00028b8:	2a2003e1 	mvn	w1, w0
    a00028bc:	b9405fe0 	ldr	w0, [sp, #92]
    a00028c0:	0a000020 	and	w0, w1, w0
    a00028c4:	2a0003e1 	mov	w1, w0
    a00028c8:	b94043e0 	ldr	w0, [sp, #64]
    a00028cc:	2a000020 	orr	w0, w1, w0
    a00028d0:	7100001f 	cmp	w0, #0x0
    a00028d4:	54000061 	b.ne	a00028e0 <sqrt+0x88>  // b.any
    a00028d8:	fd4007e0 	ldr	d0, [sp, #8]
    a00028dc:	14000128 	b	a0002d7c <sqrt+0x524>
	    else if(ix0<0)
    a00028e0:	b9405fe0 	ldr	w0, [sp, #92]
    a00028e4:	7100001f 	cmp	w0, #0x0
    a00028e8:	540000ea 	b.ge	a0002904 <sqrt+0xac>  // b.tcont
		return (x-x)/(x-x);		/* sqrt(-ve) = sNaN */
    a00028ec:	fd4007e0 	ldr	d0, [sp, #8]
    a00028f0:	1e603801 	fsub	d1, d0, d0
    a00028f4:	fd4007e0 	ldr	d0, [sp, #8]
    a00028f8:	1e603800 	fsub	d0, d0, d0
    a00028fc:	1e601820 	fdiv	d0, d1, d0
    a0002900:	1400011f 	b	a0002d7c <sqrt+0x524>
	}
    /* normalize x */
	m = (ix0>>20);
    a0002904:	b9405fe0 	ldr	w0, [sp, #92]
    a0002908:	13147c00 	asr	w0, w0, #20
    a000290c:	b90053e0 	str	w0, [sp, #80]
	if(m==0) {				/* subnormal x */
    a0002910:	b94053e0 	ldr	w0, [sp, #80]
    a0002914:	7100001f 	cmp	w0, #0x0
    a0002918:	540005a1 	b.ne	a00029cc <sqrt+0x174>  // b.any
	    while(ix0==0) {
    a000291c:	1400000c 	b	a000294c <sqrt+0xf4>
		m -= 21;
    a0002920:	b94053e0 	ldr	w0, [sp, #80]
    a0002924:	51005400 	sub	w0, w0, #0x15
    a0002928:	b90053e0 	str	w0, [sp, #80]
		ix0 |= (ix1>>11); ix1 <<= 21;
    a000292c:	b94043e0 	ldr	w0, [sp, #64]
    a0002930:	530b7c01 	lsr	w1, w0, #11
    a0002934:	b9405fe0 	ldr	w0, [sp, #92]
    a0002938:	2a000020 	orr	w0, w1, w0
    a000293c:	b9005fe0 	str	w0, [sp, #92]
    a0002940:	b94043e0 	ldr	w0, [sp, #64]
    a0002944:	530b2800 	lsl	w0, w0, #21
    a0002948:	b90043e0 	str	w0, [sp, #64]
	    while(ix0==0) {
    a000294c:	b9405fe0 	ldr	w0, [sp, #92]
    a0002950:	7100001f 	cmp	w0, #0x0
    a0002954:	54fffe60 	b.eq	a0002920 <sqrt+0xc8>  // b.none
	    }
	    for(i=0;(ix0&0x00100000)==0;i++) ix0<<=1;
    a0002958:	b9004fff 	str	wzr, [sp, #76]
    a000295c:	14000007 	b	a0002978 <sqrt+0x120>
    a0002960:	b9405fe0 	ldr	w0, [sp, #92]
    a0002964:	0b000000 	add	w0, w0, w0
    a0002968:	b9005fe0 	str	w0, [sp, #92]
    a000296c:	b9404fe0 	ldr	w0, [sp, #76]
    a0002970:	11000400 	add	w0, w0, #0x1
    a0002974:	b9004fe0 	str	w0, [sp, #76]
    a0002978:	b9405fe0 	ldr	w0, [sp, #92]
    a000297c:	120c0000 	and	w0, w0, #0x100000
    a0002980:	7100001f 	cmp	w0, #0x0
    a0002984:	54fffee0 	b.eq	a0002960 <sqrt+0x108>  // b.none
	    m -= i-1;
    a0002988:	b9404fe0 	ldr	w0, [sp, #76]
    a000298c:	51000400 	sub	w0, w0, #0x1
    a0002990:	b94053e1 	ldr	w1, [sp, #80]
    a0002994:	4b000020 	sub	w0, w1, w0
    a0002998:	b90053e0 	str	w0, [sp, #80]
	    ix0 |= (ix1>>(32-i));
    a000299c:	52800401 	mov	w1, #0x20                  	// #32
    a00029a0:	b9404fe0 	ldr	w0, [sp, #76]
    a00029a4:	4b000020 	sub	w0, w1, w0
    a00029a8:	b94043e1 	ldr	w1, [sp, #64]
    a00029ac:	1ac02421 	lsr	w1, w1, w0
    a00029b0:	b9405fe0 	ldr	w0, [sp, #92]
    a00029b4:	2a000020 	orr	w0, w1, w0
    a00029b8:	b9005fe0 	str	w0, [sp, #92]
	    ix1 <<= i;
    a00029bc:	b9404fe0 	ldr	w0, [sp, #76]
    a00029c0:	b94043e1 	ldr	w1, [sp, #64]
    a00029c4:	1ac02020 	lsl	w0, w1, w0
    a00029c8:	b90043e0 	str	w0, [sp, #64]
	}
	m -= 1023;	/* unbias exponent */
    a00029cc:	b94053e0 	ldr	w0, [sp, #80]
    a00029d0:	510ffc00 	sub	w0, w0, #0x3ff
    a00029d4:	b90053e0 	str	w0, [sp, #80]
	ix0 = (ix0&0x000fffff)|0x00100000;
    a00029d8:	b9405fe0 	ldr	w0, [sp, #92]
    a00029dc:	12004c00 	and	w0, w0, #0xfffff
    a00029e0:	320c0000 	orr	w0, w0, #0x100000
    a00029e4:	b9005fe0 	str	w0, [sp, #92]
	if(m&1){	/* odd m, double x to make it even */
    a00029e8:	b94053e0 	ldr	w0, [sp, #80]
    a00029ec:	12000000 	and	w0, w0, #0x1
    a00029f0:	7100001f 	cmp	w0, #0x0
    a00029f4:	540001a0 	b.eq	a0002a28 <sqrt+0x1d0>  // b.none
	    ix0 += ix0 + ((ix1&sign)>>31);
    a00029f8:	b9403be1 	ldr	w1, [sp, #56]
    a00029fc:	b94043e0 	ldr	w0, [sp, #64]
    a0002a00:	0a000020 	and	w0, w1, w0
    a0002a04:	531f7c01 	lsr	w1, w0, #31
    a0002a08:	b9405fe0 	ldr	w0, [sp, #92]
    a0002a0c:	0b000021 	add	w1, w1, w0
    a0002a10:	b9405fe0 	ldr	w0, [sp, #92]
    a0002a14:	0b000020 	add	w0, w1, w0
    a0002a18:	b9005fe0 	str	w0, [sp, #92]
	    ix1 += ix1;
    a0002a1c:	b94043e0 	ldr	w0, [sp, #64]
    a0002a20:	0b000000 	add	w0, w0, w0
    a0002a24:	b90043e0 	str	w0, [sp, #64]
	}
	m >>= 1;	/* m = [m/2] */
    a0002a28:	b94053e0 	ldr	w0, [sp, #80]
    a0002a2c:	13017c00 	asr	w0, w0, #1
    a0002a30:	b90053e0 	str	w0, [sp, #80]

    /* generate sqrt(x) bit by bit */
	ix0 += ix0 + ((ix1&sign)>>31);
    a0002a34:	b9403be1 	ldr	w1, [sp, #56]
    a0002a38:	b94043e0 	ldr	w0, [sp, #64]
    a0002a3c:	0a000020 	and	w0, w1, w0
    a0002a40:	531f7c01 	lsr	w1, w0, #31
    a0002a44:	b9405fe0 	ldr	w0, [sp, #92]
    a0002a48:	0b000021 	add	w1, w1, w0
    a0002a4c:	b9405fe0 	ldr	w0, [sp, #92]
    a0002a50:	0b000020 	add	w0, w1, w0
    a0002a54:	b9005fe0 	str	w0, [sp, #92]
	ix1 += ix1;
    a0002a58:	b94043e0 	ldr	w0, [sp, #64]
    a0002a5c:	0b000000 	add	w0, w0, w0
    a0002a60:	b90043e0 	str	w0, [sp, #64]
	q = q1 = s0 = s1 = 0;	/* [q,q1] = sqrt(x) */
    a0002a64:	b90047ff 	str	wzr, [sp, #68]
    a0002a68:	b9005bff 	str	wzr, [sp, #88]
    a0002a6c:	b9405be0 	ldr	w0, [sp, #88]
    a0002a70:	b9003fe0 	str	w0, [sp, #60]
    a0002a74:	b9403fe0 	ldr	w0, [sp, #60]
    a0002a78:	b90057e0 	str	w0, [sp, #84]
	r = 0x00200000;		/* r = moving bit from right to left */
    a0002a7c:	52a00400 	mov	w0, #0x200000              	// #2097152
    a0002a80:	b9004be0 	str	w0, [sp, #72]

	while(r!=0) {
    a0002a84:	14000024 	b	a0002b14 <sqrt+0x2bc>
	    t = s0+r; 
    a0002a88:	b9405be1 	ldr	w1, [sp, #88]
    a0002a8c:	b9404be0 	ldr	w0, [sp, #72]
    a0002a90:	0b000020 	add	w0, w1, w0
    a0002a94:	b9002be0 	str	w0, [sp, #40]
	    if(t<=ix0) { 
    a0002a98:	b9402be1 	ldr	w1, [sp, #40]
    a0002a9c:	b9405fe0 	ldr	w0, [sp, #92]
    a0002aa0:	6b00003f 	cmp	w1, w0
    a0002aa4:	540001ac 	b.gt	a0002ad8 <sqrt+0x280>
		s0   = t+r; 
    a0002aa8:	b9402be1 	ldr	w1, [sp, #40]
    a0002aac:	b9404be0 	ldr	w0, [sp, #72]
    a0002ab0:	0b000020 	add	w0, w1, w0
    a0002ab4:	b9005be0 	str	w0, [sp, #88]
		ix0 -= t; 
    a0002ab8:	b9405fe1 	ldr	w1, [sp, #92]
    a0002abc:	b9402be0 	ldr	w0, [sp, #40]
    a0002ac0:	4b000020 	sub	w0, w1, w0
    a0002ac4:	b9005fe0 	str	w0, [sp, #92]
		q   += r; 
    a0002ac8:	b94057e1 	ldr	w1, [sp, #84]
    a0002acc:	b9404be0 	ldr	w0, [sp, #72]
    a0002ad0:	0b000020 	add	w0, w1, w0
    a0002ad4:	b90057e0 	str	w0, [sp, #84]
	    } 
	    ix0 += ix0 + ((ix1&sign)>>31);
    a0002ad8:	b9403be1 	ldr	w1, [sp, #56]
    a0002adc:	b94043e0 	ldr	w0, [sp, #64]
    a0002ae0:	0a000020 	and	w0, w1, w0
    a0002ae4:	531f7c01 	lsr	w1, w0, #31
    a0002ae8:	b9405fe0 	ldr	w0, [sp, #92]
    a0002aec:	0b000021 	add	w1, w1, w0
    a0002af0:	b9405fe0 	ldr	w0, [sp, #92]
    a0002af4:	0b000020 	add	w0, w1, w0
    a0002af8:	b9005fe0 	str	w0, [sp, #92]
	    ix1 += ix1;
    a0002afc:	b94043e0 	ldr	w0, [sp, #64]
    a0002b00:	0b000000 	add	w0, w0, w0
    a0002b04:	b90043e0 	str	w0, [sp, #64]
	    r>>=1;
    a0002b08:	b9404be0 	ldr	w0, [sp, #72]
    a0002b0c:	53017c00 	lsr	w0, w0, #1
    a0002b10:	b9004be0 	str	w0, [sp, #72]
	while(r!=0) {
    a0002b14:	b9404be0 	ldr	w0, [sp, #72]
    a0002b18:	7100001f 	cmp	w0, #0x0
    a0002b1c:	54fffb61 	b.ne	a0002a88 <sqrt+0x230>  // b.any
	}

	r = sign;
    a0002b20:	b9403be0 	ldr	w0, [sp, #56]
    a0002b24:	b9004be0 	str	w0, [sp, #72]
	while(r!=0) {
    a0002b28:	14000047 	b	a0002c44 <sqrt+0x3ec>
	    t1 = s1+r; 
    a0002b2c:	b94047e1 	ldr	w1, [sp, #68]
    a0002b30:	b9404be0 	ldr	w0, [sp, #72]
    a0002b34:	0b000020 	add	w0, w1, w0
    a0002b38:	b9002fe0 	str	w0, [sp, #44]
	    t  = s0;
    a0002b3c:	b9405be0 	ldr	w0, [sp, #88]
    a0002b40:	b9002be0 	str	w0, [sp, #40]
	    if((t<ix0)||((t==ix0)&&(t1<=ix1))) { 
    a0002b44:	b9402be1 	ldr	w1, [sp, #40]
    a0002b48:	b9405fe0 	ldr	w0, [sp, #92]
    a0002b4c:	6b00003f 	cmp	w1, w0
    a0002b50:	5400012b 	b.lt	a0002b74 <sqrt+0x31c>  // b.tstop
    a0002b54:	b9402be1 	ldr	w1, [sp, #40]
    a0002b58:	b9405fe0 	ldr	w0, [sp, #92]
    a0002b5c:	6b00003f 	cmp	w1, w0
    a0002b60:	54000541 	b.ne	a0002c08 <sqrt+0x3b0>  // b.any
    a0002b64:	b9402fe1 	ldr	w1, [sp, #44]
    a0002b68:	b94043e0 	ldr	w0, [sp, #64]
    a0002b6c:	6b00003f 	cmp	w1, w0
    a0002b70:	540004c8 	b.hi	a0002c08 <sqrt+0x3b0>  // b.pmore
		s1  = t1+r;
    a0002b74:	b9402fe1 	ldr	w1, [sp, #44]
    a0002b78:	b9404be0 	ldr	w0, [sp, #72]
    a0002b7c:	0b000020 	add	w0, w1, w0
    a0002b80:	b90047e0 	str	w0, [sp, #68]
		if(((t1&sign)==sign)&&(s1&sign)==0) s0 += 1;
    a0002b84:	b9403be1 	ldr	w1, [sp, #56]
    a0002b88:	b9402fe0 	ldr	w0, [sp, #44]
    a0002b8c:	0a000021 	and	w1, w1, w0
    a0002b90:	b9403be0 	ldr	w0, [sp, #56]
    a0002b94:	6b00003f 	cmp	w1, w0
    a0002b98:	54000121 	b.ne	a0002bbc <sqrt+0x364>  // b.any
    a0002b9c:	b9403be1 	ldr	w1, [sp, #56]
    a0002ba0:	b94047e0 	ldr	w0, [sp, #68]
    a0002ba4:	0a000020 	and	w0, w1, w0
    a0002ba8:	7100001f 	cmp	w0, #0x0
    a0002bac:	54000081 	b.ne	a0002bbc <sqrt+0x364>  // b.any
    a0002bb0:	b9405be0 	ldr	w0, [sp, #88]
    a0002bb4:	11000400 	add	w0, w0, #0x1
    a0002bb8:	b9005be0 	str	w0, [sp, #88]
		ix0 -= t;
    a0002bbc:	b9405fe1 	ldr	w1, [sp, #92]
    a0002bc0:	b9402be0 	ldr	w0, [sp, #40]
    a0002bc4:	4b000020 	sub	w0, w1, w0
    a0002bc8:	b9005fe0 	str	w0, [sp, #92]
		if (ix1 < t1) ix0 -= 1;
    a0002bcc:	b94043e1 	ldr	w1, [sp, #64]
    a0002bd0:	b9402fe0 	ldr	w0, [sp, #44]
    a0002bd4:	6b00003f 	cmp	w1, w0
    a0002bd8:	54000082 	b.cs	a0002be8 <sqrt+0x390>  // b.hs, b.nlast
    a0002bdc:	b9405fe0 	ldr	w0, [sp, #92]
    a0002be0:	51000400 	sub	w0, w0, #0x1
    a0002be4:	b9005fe0 	str	w0, [sp, #92]
		ix1 -= t1;
    a0002be8:	b94043e1 	ldr	w1, [sp, #64]
    a0002bec:	b9402fe0 	ldr	w0, [sp, #44]
    a0002bf0:	4b000020 	sub	w0, w1, w0
    a0002bf4:	b90043e0 	str	w0, [sp, #64]
		q1  += r;
    a0002bf8:	b9403fe1 	ldr	w1, [sp, #60]
    a0002bfc:	b9404be0 	ldr	w0, [sp, #72]
    a0002c00:	0b000020 	add	w0, w1, w0
    a0002c04:	b9003fe0 	str	w0, [sp, #60]
	    }
	    ix0 += ix0 + ((ix1&sign)>>31);
    a0002c08:	b9403be1 	ldr	w1, [sp, #56]
    a0002c0c:	b94043e0 	ldr	w0, [sp, #64]
    a0002c10:	0a000020 	and	w0, w1, w0
    a0002c14:	531f7c01 	lsr	w1, w0, #31
    a0002c18:	b9405fe0 	ldr	w0, [sp, #92]
    a0002c1c:	0b000021 	add	w1, w1, w0
    a0002c20:	b9405fe0 	ldr	w0, [sp, #92]
    a0002c24:	0b000020 	add	w0, w1, w0
    a0002c28:	b9005fe0 	str	w0, [sp, #92]
	    ix1 += ix1;
    a0002c2c:	b94043e0 	ldr	w0, [sp, #64]
    a0002c30:	0b000000 	add	w0, w0, w0
    a0002c34:	b90043e0 	str	w0, [sp, #64]
	    r>>=1;
    a0002c38:	b9404be0 	ldr	w0, [sp, #72]
    a0002c3c:	53017c00 	lsr	w0, w0, #1
    a0002c40:	b9004be0 	str	w0, [sp, #72]
	while(r!=0) {
    a0002c44:	b9404be0 	ldr	w0, [sp, #72]
    a0002c48:	7100001f 	cmp	w0, #0x0
    a0002c4c:	54fff701 	b.ne	a0002b2c <sqrt+0x2d4>  // b.any
	}

    /* use floating add to find out rounding direction */
	if((ix0|ix1)!=0) {
    a0002c50:	b9405fe1 	ldr	w1, [sp, #92]
    a0002c54:	b94043e0 	ldr	w0, [sp, #64]
    a0002c58:	2a000020 	orr	w0, w1, w0
    a0002c5c:	7100001f 	cmp	w0, #0x0
    a0002c60:	54000560 	b.eq	a0002d0c <sqrt+0x4b4>  // b.none
	    z = one-tiny; /* trigger inexact flag */
    a0002c64:	1e6e1000 	fmov	d0, #1.000000000000000000e+00
    a0002c68:	d0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a0002c6c:	fd412801 	ldr	d1, [x0, #592]
    a0002c70:	1e613800 	fsub	d0, d0, d1
    a0002c74:	fd001be0 	str	d0, [sp, #48]
	    if (z>=one) {
    a0002c78:	1e6e1000 	fmov	d0, #1.000000000000000000e+00
    a0002c7c:	fd401be1 	ldr	d1, [sp, #48]
    a0002c80:	1e602030 	fcmpe	d1, d0
    a0002c84:	5400004a 	b.ge	a0002c8c <sqrt+0x434>  // b.tcont
    a0002c88:	14000021 	b	a0002d0c <sqrt+0x4b4>
	        z = one+tiny;
    a0002c8c:	1e6e1000 	fmov	d0, #1.000000000000000000e+00
    a0002c90:	d0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a0002c94:	fd412801 	ldr	d1, [x0, #592]
    a0002c98:	1e612800 	fadd	d0, d0, d1
    a0002c9c:	fd001be0 	str	d0, [sp, #48]
	        if (q1==(u_int32_t)0xffffffff) { q1=0; q += 1;}
    a0002ca0:	b9403fe0 	ldr	w0, [sp, #60]
    a0002ca4:	3100041f 	cmn	w0, #0x1
    a0002ca8:	540000c1 	b.ne	a0002cc0 <sqrt+0x468>  // b.any
    a0002cac:	b9003fff 	str	wzr, [sp, #60]
    a0002cb0:	b94057e0 	ldr	w0, [sp, #84]
    a0002cb4:	11000400 	add	w0, w0, #0x1
    a0002cb8:	b90057e0 	str	w0, [sp, #84]
    a0002cbc:	14000014 	b	a0002d0c <sqrt+0x4b4>
		else if (z>one) {
    a0002cc0:	1e6e1000 	fmov	d0, #1.000000000000000000e+00
    a0002cc4:	fd401be1 	ldr	d1, [sp, #48]
    a0002cc8:	1e602030 	fcmpe	d1, d0
    a0002ccc:	5400004c 	b.gt	a0002cd4 <sqrt+0x47c>
    a0002cd0:	1400000b 	b	a0002cfc <sqrt+0x4a4>
		    if (q1==(u_int32_t)0xfffffffe) q+=1;
    a0002cd4:	b9403fe0 	ldr	w0, [sp, #60]
    a0002cd8:	3100081f 	cmn	w0, #0x2
    a0002cdc:	54000081 	b.ne	a0002cec <sqrt+0x494>  // b.any
    a0002ce0:	b94057e0 	ldr	w0, [sp, #84]
    a0002ce4:	11000400 	add	w0, w0, #0x1
    a0002ce8:	b90057e0 	str	w0, [sp, #84]
		    q1+=2; 
    a0002cec:	b9403fe0 	ldr	w0, [sp, #60]
    a0002cf0:	11000800 	add	w0, w0, #0x2
    a0002cf4:	b9003fe0 	str	w0, [sp, #60]
    a0002cf8:	14000005 	b	a0002d0c <sqrt+0x4b4>
		} else
	            q1 += (q1&1);
    a0002cfc:	b9403fe0 	ldr	w0, [sp, #60]
    a0002d00:	11000400 	add	w0, w0, #0x1
    a0002d04:	121f7800 	and	w0, w0, #0xfffffffe
    a0002d08:	b9003fe0 	str	w0, [sp, #60]
	    }
	}
	ix0 = (q>>1)+0x3fe00000;
    a0002d0c:	b94057e0 	ldr	w0, [sp, #84]
    a0002d10:	13017c01 	asr	w1, w0, #1
    a0002d14:	52a7fc00 	mov	w0, #0x3fe00000            	// #1071644672
    a0002d18:	0b000020 	add	w0, w1, w0
    a0002d1c:	b9005fe0 	str	w0, [sp, #92]
	ix1 =  q1>>1;
    a0002d20:	b9403fe0 	ldr	w0, [sp, #60]
    a0002d24:	53017c00 	lsr	w0, w0, #1
    a0002d28:	b90043e0 	str	w0, [sp, #64]
	if ((q&1)==1) ix1 |= sign;
    a0002d2c:	b94057e0 	ldr	w0, [sp, #84]
    a0002d30:	12000000 	and	w0, w0, #0x1
    a0002d34:	7100001f 	cmp	w0, #0x0
    a0002d38:	540000a0 	b.eq	a0002d4c <sqrt+0x4f4>  // b.none
    a0002d3c:	b9403be0 	ldr	w0, [sp, #56]
    a0002d40:	b94043e1 	ldr	w1, [sp, #64]
    a0002d44:	2a000020 	orr	w0, w1, w0
    a0002d48:	b90043e0 	str	w0, [sp, #64]
	ix0 += (m <<20);
    a0002d4c:	b94053e0 	ldr	w0, [sp, #80]
    a0002d50:	530c2c00 	lsl	w0, w0, #20
    a0002d54:	b9405fe1 	ldr	w1, [sp, #92]
    a0002d58:	0b000020 	add	w0, w1, w0
    a0002d5c:	b9005fe0 	str	w0, [sp, #92]
	INSERT_WORDS(z,ix0,ix1);
    a0002d60:	b9405fe0 	ldr	w0, [sp, #92]
    a0002d64:	b9001be0 	str	w0, [sp, #24]
    a0002d68:	b94043e0 	ldr	w0, [sp, #64]
    a0002d6c:	b9001fe0 	str	w0, [sp, #28]
    a0002d70:	fd400fe0 	ldr	d0, [sp, #24]
    a0002d74:	fd001be0 	str	d0, [sp, #48]
	return z;
    a0002d78:	fd401be0 	ldr	d0, [sp, #48]
}
    a0002d7c:	910183ff 	add	sp, sp, #0x60
    a0002d80:	d65f03c0 	ret

00000000a0002d84 <log>:
	else SET_HIGH_WORD(z,j);
	return s*z;
}

double log(double x)
{
    a0002d84:	d10243ff 	sub	sp, sp, #0x90
    a0002d88:	fd0007e0 	str	d0, [sp, #8]
	double hfsq,f,s,z,R,w,t1,t2,dk;
	int32_t k,hx,i,j;
	u_int32_t lx;

	EXTRACT_WORDS(hx,lx,x);
    a0002d8c:	fd4007e0 	ldr	d0, [sp, #8]
    a0002d90:	fd0017e0 	str	d0, [sp, #40]
    a0002d94:	b9402be0 	ldr	w0, [sp, #40]
    a0002d98:	b9008be0 	str	w0, [sp, #136]
    a0002d9c:	b9402fe0 	ldr	w0, [sp, #44]
    a0002da0:	b90087e0 	str	w0, [sp, #132]

	k=0;
    a0002da4:	b9008fff 	str	wzr, [sp, #140]
	if (hx < 0x00100000) {			/* x < 2**-1022  */
    a0002da8:	b9408be1 	ldr	w1, [sp, #136]
    a0002dac:	12bffe00 	mov	w0, #0xfffff               	// #1048575
    a0002db0:	6b00003f 	cmp	w1, w0
    a0002db4:	5400042c 	b.gt	a0002e38 <log+0xb4>
	    if (((hx&0x7fffffff)|lx)==0) 
    a0002db8:	b9408be0 	ldr	w0, [sp, #136]
    a0002dbc:	12007801 	and	w1, w0, #0x7fffffff
    a0002dc0:	b94087e0 	ldr	w0, [sp, #132]
    a0002dc4:	2a000020 	orr	w0, w1, w0
    a0002dc8:	7100001f 	cmp	w0, #0x0
    a0002dcc:	540000e1 	b.ne	a0002de8 <log+0x64>  // b.any
		return -two54/zero;		/* log(+-0)=-inf */
    a0002dd0:	d2e86a00 	mov	x0, #0x4350000000000000    	// #4850376798678024192
    a0002dd4:	9e670000 	fmov	d0, x0
    a0002dd8:	1e614000 	fneg	d0, d0
    a0002ddc:	2f00e401 	movi	d1, #0x0
    a0002de0:	1e611800 	fdiv	d0, d0, d1
    a0002de4:	14000105 	b	a00031f8 <log+0x474>
	    if (hx<0) return (x-x)/zero;	/* log(-#) = NaN */
    a0002de8:	b9408be0 	ldr	w0, [sp, #136]
    a0002dec:	7100001f 	cmp	w0, #0x0
    a0002df0:	540000ca 	b.ge	a0002e08 <log+0x84>  // b.tcont
    a0002df4:	fd4007e0 	ldr	d0, [sp, #8]
    a0002df8:	1e603800 	fsub	d0, d0, d0
    a0002dfc:	2f00e401 	movi	d1, #0x0
    a0002e00:	1e611800 	fdiv	d0, d0, d1
    a0002e04:	140000fd 	b	a00031f8 <log+0x474>
	    k -= 54; x *= two54; /* subnormal number, scale up x */
    a0002e08:	b9408fe0 	ldr	w0, [sp, #140]
    a0002e0c:	5100d800 	sub	w0, w0, #0x36
    a0002e10:	b9008fe0 	str	w0, [sp, #140]
    a0002e14:	d2e86a00 	mov	x0, #0x4350000000000000    	// #4850376798678024192
    a0002e18:	9e670001 	fmov	d1, x0
    a0002e1c:	fd4007e0 	ldr	d0, [sp, #8]
    a0002e20:	1e610800 	fmul	d0, d0, d1
    a0002e24:	fd0007e0 	str	d0, [sp, #8]
	    GET_HIGH_WORD(hx,x);
    a0002e28:	fd4007e0 	ldr	d0, [sp, #8]
    a0002e2c:	fd0013e0 	str	d0, [sp, #32]
    a0002e30:	b94023e0 	ldr	w0, [sp, #32]
    a0002e34:	b9008be0 	str	w0, [sp, #136]
	} 
	if (hx >= 0x7ff00000) return x+x;
    a0002e38:	b9408be1 	ldr	w1, [sp, #136]
    a0002e3c:	12b00200 	mov	w0, #0x7fefffff            	// #2146435071
    a0002e40:	6b00003f 	cmp	w1, w0
    a0002e44:	5400008d 	b.le	a0002e54 <log+0xd0>
    a0002e48:	fd4007e0 	ldr	d0, [sp, #8]
    a0002e4c:	1e602800 	fadd	d0, d0, d0
    a0002e50:	140000ea 	b	a00031f8 <log+0x474>
	k += (hx>>20)-1023;
    a0002e54:	b9408be0 	ldr	w0, [sp, #136]
    a0002e58:	13147c00 	asr	w0, w0, #20
    a0002e5c:	510ffc00 	sub	w0, w0, #0x3ff
    a0002e60:	b9408fe1 	ldr	w1, [sp, #140]
    a0002e64:	0b000020 	add	w0, w1, w0
    a0002e68:	b9008fe0 	str	w0, [sp, #140]
	hx &= 0x000fffff;
    a0002e6c:	b9408be0 	ldr	w0, [sp, #136]
    a0002e70:	12004c00 	and	w0, w0, #0xfffff
    a0002e74:	b9008be0 	str	w0, [sp, #136]
	i = (hx+0x95f64)&0x100000;
    a0002e78:	b9408be1 	ldr	w1, [sp, #136]
    a0002e7c:	528bec80 	mov	w0, #0x5f64                	// #24420
    a0002e80:	72a00120 	movk	w0, #0x9, lsl #16
    a0002e84:	0b000020 	add	w0, w1, w0
    a0002e88:	120c0000 	and	w0, w0, #0x100000
    a0002e8c:	b90083e0 	str	w0, [sp, #128]
	SET_HIGH_WORD(x,hx|(i^0x3ff00000));	/* normalize x or x/2 */
    a0002e90:	fd4007e0 	ldr	d0, [sp, #8]
    a0002e94:	fd000fe0 	str	d0, [sp, #24]
    a0002e98:	b94083e0 	ldr	w0, [sp, #128]
    a0002e9c:	520c2401 	eor	w1, w0, #0x3ff00000
    a0002ea0:	b9408be0 	ldr	w0, [sp, #136]
    a0002ea4:	2a000020 	orr	w0, w1, w0
    a0002ea8:	b9001be0 	str	w0, [sp, #24]
    a0002eac:	fd400fe0 	ldr	d0, [sp, #24]
    a0002eb0:	fd0007e0 	str	d0, [sp, #8]
	k += (i>>20);
    a0002eb4:	b94083e0 	ldr	w0, [sp, #128]
    a0002eb8:	13147c00 	asr	w0, w0, #20
    a0002ebc:	b9408fe1 	ldr	w1, [sp, #140]
    a0002ec0:	0b000020 	add	w0, w1, w0
    a0002ec4:	b9008fe0 	str	w0, [sp, #140]
	f = x-1.0;
    a0002ec8:	fd4007e1 	ldr	d1, [sp, #8]
    a0002ecc:	1e6e1000 	fmov	d0, #1.000000000000000000e+00
    a0002ed0:	1e603820 	fsub	d0, d1, d0
    a0002ed4:	fd003fe0 	str	d0, [sp, #120]
	if((0x000fffff&(2+hx))<3) {	/* -2**-20 <= f < 2**-20 */
    a0002ed8:	b9408be0 	ldr	w0, [sp, #136]
    a0002edc:	11000800 	add	w0, w0, #0x2
    a0002ee0:	12004c00 	and	w0, w0, #0xfffff
    a0002ee4:	7100081f 	cmp	w0, #0x2
    a0002ee8:	5400074c 	b.gt	a0002fd0 <log+0x24c>
	    if(f==zero) {
    a0002eec:	2f00e401 	movi	d1, #0x0
    a0002ef0:	fd403fe0 	ldr	d0, [sp, #120]
    a0002ef4:	1e612000 	fcmp	d0, d1
    a0002ef8:	54000261 	b.ne	a0002f44 <log+0x1c0>  // b.any
		if(k==0) {
    a0002efc:	b9408fe0 	ldr	w0, [sp, #140]
    a0002f00:	7100001f 	cmp	w0, #0x0
    a0002f04:	54000061 	b.ne	a0002f10 <log+0x18c>  // b.any
		    return zero;
    a0002f08:	2f00e400 	movi	d0, #0x0
    a0002f0c:	140000bb 	b	a00031f8 <log+0x474>
		} else {
		    dk=(double)k;
    a0002f10:	b9408fe0 	ldr	w0, [sp, #140]
    a0002f14:	1e620000 	scvtf	d0, w0
    a0002f18:	fd0037e0 	str	d0, [sp, #104]
		    return dk*ln2_hi+dk*ln2_lo;
    a0002f1c:	d0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a0002f20:	fd418001 	ldr	d1, [x0, #768]
    a0002f24:	fd4037e0 	ldr	d0, [sp, #104]
    a0002f28:	1e600821 	fmul	d1, d1, d0
    a0002f2c:	d0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a0002f30:	fd418402 	ldr	d2, [x0, #776]
    a0002f34:	fd4037e0 	ldr	d0, [sp, #104]
    a0002f38:	1e600840 	fmul	d0, d2, d0
    a0002f3c:	1e602820 	fadd	d0, d1, d0
    a0002f40:	140000ae 	b	a00031f8 <log+0x474>
		}
	    }
	    R = f*f*(0.5-0.33333333333333333*f);
    a0002f44:	fd403fe0 	ldr	d0, [sp, #120]
    a0002f48:	1e600801 	fmul	d1, d0, d0
    a0002f4c:	fd403fe0 	ldr	d0, [sp, #120]
    a0002f50:	b200f3e0 	mov	x0, #0x5555555555555555    	// #6148914691236517205
    a0002f54:	f2e7faa0 	movk	x0, #0x3fd5, lsl #48
    a0002f58:	9e670002 	fmov	d2, x0
    a0002f5c:	1e620800 	fmul	d0, d0, d2
    a0002f60:	1e6c1002 	fmov	d2, #5.000000000000000000e-01
    a0002f64:	1e603840 	fsub	d0, d2, d0
    a0002f68:	1e600820 	fmul	d0, d1, d0
    a0002f6c:	fd001fe0 	str	d0, [sp, #56]
	    if(k==0) return f-R; else {dk=(double)k;
    a0002f70:	b9408fe0 	ldr	w0, [sp, #140]
    a0002f74:	7100001f 	cmp	w0, #0x0
    a0002f78:	540000a1 	b.ne	a0002f8c <log+0x208>  // b.any
    a0002f7c:	fd403fe1 	ldr	d1, [sp, #120]
    a0002f80:	fd401fe0 	ldr	d0, [sp, #56]
    a0002f84:	1e603820 	fsub	d0, d1, d0
    a0002f88:	1400009c 	b	a00031f8 <log+0x474>
    a0002f8c:	b9408fe0 	ldr	w0, [sp, #140]
    a0002f90:	1e620000 	scvtf	d0, w0
    a0002f94:	fd0037e0 	str	d0, [sp, #104]
	    	     return dk*ln2_hi-((R-dk*ln2_lo)-f);}
    a0002f98:	d0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a0002f9c:	fd418001 	ldr	d1, [x0, #768]
    a0002fa0:	fd4037e0 	ldr	d0, [sp, #104]
    a0002fa4:	1e600821 	fmul	d1, d1, d0
    a0002fa8:	d0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a0002fac:	fd418402 	ldr	d2, [x0, #776]
    a0002fb0:	fd4037e0 	ldr	d0, [sp, #104]
    a0002fb4:	1e600840 	fmul	d0, d2, d0
    a0002fb8:	fd401fe2 	ldr	d2, [sp, #56]
    a0002fbc:	1e603842 	fsub	d2, d2, d0
    a0002fc0:	fd403fe0 	ldr	d0, [sp, #120]
    a0002fc4:	1e603840 	fsub	d0, d2, d0
    a0002fc8:	1e603820 	fsub	d0, d1, d0
    a0002fcc:	1400008b 	b	a00031f8 <log+0x474>
	}
 	s = f/(2.0+f); 
    a0002fd0:	fd403fe1 	ldr	d1, [sp, #120]
    a0002fd4:	1e601000 	fmov	d0, #2.000000000000000000e+00
    a0002fd8:	1e602820 	fadd	d0, d1, d0
    a0002fdc:	fd403fe1 	ldr	d1, [sp, #120]
    a0002fe0:	1e601820 	fdiv	d0, d1, d0
    a0002fe4:	fd003be0 	str	d0, [sp, #112]
	dk = (double)k;
    a0002fe8:	b9408fe0 	ldr	w0, [sp, #140]
    a0002fec:	1e620000 	scvtf	d0, w0
    a0002ff0:	fd0037e0 	str	d0, [sp, #104]
	z = s*s;
    a0002ff4:	fd403be0 	ldr	d0, [sp, #112]
    a0002ff8:	1e600800 	fmul	d0, d0, d0
    a0002ffc:	fd0033e0 	str	d0, [sp, #96]
	i = hx-0x6147a;
    a0003000:	b9408be1 	ldr	w1, [sp, #136]
    a0003004:	529d70c0 	mov	w0, #0xeb86                	// #60294
    a0003008:	72bfff20 	movk	w0, #0xfff9, lsl #16
    a000300c:	0b000020 	add	w0, w1, w0
    a0003010:	b90083e0 	str	w0, [sp, #128]
	w = z*z;
    a0003014:	fd4033e0 	ldr	d0, [sp, #96]
    a0003018:	1e600800 	fmul	d0, d0, d0
    a000301c:	fd002fe0 	str	d0, [sp, #88]
	j = 0x6b851-hx;
    a0003020:	52970a21 	mov	w1, #0xb851                	// #47185
    a0003024:	72a000c1 	movk	w1, #0x6, lsl #16
    a0003028:	b9408be0 	ldr	w0, [sp, #136]
    a000302c:	4b000020 	sub	w0, w1, w0
    a0003030:	b90057e0 	str	w0, [sp, #84]
	t1= w*(Lg2+w*(Lg4+w*Lg6)); 
    a0003034:	b0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a0003038:	fd418801 	ldr	d1, [x0, #784]
    a000303c:	fd402fe0 	ldr	d0, [sp, #88]
    a0003040:	1e600820 	fmul	d0, d1, d0
    a0003044:	b0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a0003048:	fd418c01 	ldr	d1, [x0, #792]
    a000304c:	1e612801 	fadd	d1, d0, d1
    a0003050:	fd402fe0 	ldr	d0, [sp, #88]
    a0003054:	1e600820 	fmul	d0, d1, d0
    a0003058:	b0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a000305c:	fd419001 	ldr	d1, [x0, #800]
    a0003060:	1e612800 	fadd	d0, d0, d1
    a0003064:	fd402fe1 	ldr	d1, [sp, #88]
    a0003068:	1e600820 	fmul	d0, d1, d0
    a000306c:	fd0027e0 	str	d0, [sp, #72]
	t2= z*(Lg1+w*(Lg3+w*(Lg5+w*Lg7))); 
    a0003070:	b0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a0003074:	fd419401 	ldr	d1, [x0, #808]
    a0003078:	fd402fe0 	ldr	d0, [sp, #88]
    a000307c:	1e600820 	fmul	d0, d1, d0
    a0003080:	b0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a0003084:	fd419801 	ldr	d1, [x0, #816]
    a0003088:	1e612801 	fadd	d1, d0, d1
    a000308c:	fd402fe0 	ldr	d0, [sp, #88]
    a0003090:	1e600820 	fmul	d0, d1, d0
    a0003094:	b0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a0003098:	fd419c01 	ldr	d1, [x0, #824]
    a000309c:	1e612801 	fadd	d1, d0, d1
    a00030a0:	fd402fe0 	ldr	d0, [sp, #88]
    a00030a4:	1e600820 	fmul	d0, d1, d0
    a00030a8:	b0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a00030ac:	fd41a001 	ldr	d1, [x0, #832]
    a00030b0:	1e612800 	fadd	d0, d0, d1
    a00030b4:	fd4033e1 	ldr	d1, [sp, #96]
    a00030b8:	1e600820 	fmul	d0, d1, d0
    a00030bc:	fd0023e0 	str	d0, [sp, #64]
	i |= j;
    a00030c0:	b94083e1 	ldr	w1, [sp, #128]
    a00030c4:	b94057e0 	ldr	w0, [sp, #84]
    a00030c8:	2a000020 	orr	w0, w1, w0
    a00030cc:	b90083e0 	str	w0, [sp, #128]
	R = t2+t1;
    a00030d0:	fd4023e1 	ldr	d1, [sp, #64]
    a00030d4:	fd4027e0 	ldr	d0, [sp, #72]
    a00030d8:	1e602820 	fadd	d0, d1, d0
    a00030dc:	fd001fe0 	str	d0, [sp, #56]
	if(i>0) {
    a00030e0:	b94083e0 	ldr	w0, [sp, #128]
    a00030e4:	7100001f 	cmp	w0, #0x0
    a00030e8:	5400050d 	b.le	a0003188 <log+0x404>
	    hfsq=0.5*f*f;
    a00030ec:	fd403fe1 	ldr	d1, [sp, #120]
    a00030f0:	1e6c1000 	fmov	d0, #5.000000000000000000e-01
    a00030f4:	1e600820 	fmul	d0, d1, d0
    a00030f8:	fd403fe1 	ldr	d1, [sp, #120]
    a00030fc:	1e600820 	fmul	d0, d1, d0
    a0003100:	fd001be0 	str	d0, [sp, #48]
	    if(k==0) return f-(hfsq-s*(hfsq+R)); else
    a0003104:	b9408fe0 	ldr	w0, [sp, #140]
    a0003108:	7100001f 	cmp	w0, #0x0
    a000310c:	54000161 	b.ne	a0003138 <log+0x3b4>  // b.any
    a0003110:	fd401be1 	ldr	d1, [sp, #48]
    a0003114:	fd401fe0 	ldr	d0, [sp, #56]
    a0003118:	1e602821 	fadd	d1, d1, d0
    a000311c:	fd403be0 	ldr	d0, [sp, #112]
    a0003120:	1e600820 	fmul	d0, d1, d0
    a0003124:	fd401be1 	ldr	d1, [sp, #48]
    a0003128:	1e603820 	fsub	d0, d1, d0
    a000312c:	fd403fe1 	ldr	d1, [sp, #120]
    a0003130:	1e603820 	fsub	d0, d1, d0
    a0003134:	14000031 	b	a00031f8 <log+0x474>
		     return dk*ln2_hi-((hfsq-(s*(hfsq+R)+dk*ln2_lo))-f);
    a0003138:	b0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a000313c:	fd418001 	ldr	d1, [x0, #768]
    a0003140:	fd4037e0 	ldr	d0, [sp, #104]
    a0003144:	1e600821 	fmul	d1, d1, d0
    a0003148:	fd401be2 	ldr	d2, [sp, #48]
    a000314c:	fd401fe0 	ldr	d0, [sp, #56]
    a0003150:	1e602842 	fadd	d2, d2, d0
    a0003154:	fd403be0 	ldr	d0, [sp, #112]
    a0003158:	1e600842 	fmul	d2, d2, d0
    a000315c:	b0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a0003160:	fd418403 	ldr	d3, [x0, #776]
    a0003164:	fd4037e0 	ldr	d0, [sp, #104]
    a0003168:	1e600860 	fmul	d0, d3, d0
    a000316c:	1e602840 	fadd	d0, d2, d0
    a0003170:	fd401be2 	ldr	d2, [sp, #48]
    a0003174:	1e603842 	fsub	d2, d2, d0
    a0003178:	fd403fe0 	ldr	d0, [sp, #120]
    a000317c:	1e603840 	fsub	d0, d2, d0
    a0003180:	1e603820 	fsub	d0, d1, d0
    a0003184:	1400001d 	b	a00031f8 <log+0x474>
	} else {
	    if(k==0) return f-s*(f-R); else
    a0003188:	b9408fe0 	ldr	w0, [sp, #140]
    a000318c:	7100001f 	cmp	w0, #0x0
    a0003190:	54000121 	b.ne	a00031b4 <log+0x430>  // b.any
    a0003194:	fd403fe1 	ldr	d1, [sp, #120]
    a0003198:	fd401fe0 	ldr	d0, [sp, #56]
    a000319c:	1e603821 	fsub	d1, d1, d0
    a00031a0:	fd403be0 	ldr	d0, [sp, #112]
    a00031a4:	1e600820 	fmul	d0, d1, d0
    a00031a8:	fd403fe1 	ldr	d1, [sp, #120]
    a00031ac:	1e603820 	fsub	d0, d1, d0
    a00031b0:	14000012 	b	a00031f8 <log+0x474>
		     return dk*ln2_hi-((s*(f-R)-dk*ln2_lo)-f);
    a00031b4:	b0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a00031b8:	fd418001 	ldr	d1, [x0, #768]
    a00031bc:	fd4037e0 	ldr	d0, [sp, #104]
    a00031c0:	1e600821 	fmul	d1, d1, d0
    a00031c4:	fd403fe2 	ldr	d2, [sp, #120]
    a00031c8:	fd401fe0 	ldr	d0, [sp, #56]
    a00031cc:	1e603842 	fsub	d2, d2, d0
    a00031d0:	fd403be0 	ldr	d0, [sp, #112]
    a00031d4:	1e600842 	fmul	d2, d2, d0
    a00031d8:	b0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a00031dc:	fd418403 	ldr	d3, [x0, #776]
    a00031e0:	fd4037e0 	ldr	d0, [sp, #104]
    a00031e4:	1e600860 	fmul	d0, d3, d0
    a00031e8:	1e603842 	fsub	d2, d2, d0
    a00031ec:	fd403fe0 	ldr	d0, [sp, #120]
    a00031f0:	1e603840 	fsub	d0, d2, d0
    a00031f4:	1e603820 	fsub	d0, d1, d0
	}
}
    a00031f8:	910243ff 	add	sp, sp, #0x90
    a00031fc:	d65f03c0 	ret

00000000a0003200 <exp>:

double exp(double x)	/* default IEEE double exp */
{
    a0003200:	d10203ff 	sub	sp, sp, #0x80
    a0003204:	fd0007e0 	str	d0, [sp, #8]

static volatile double
twom1000= 9.33263618503218878990e-302;     /* 2**-1000=0x01700000,0*/


	double y,hi=0.0,lo=0.0,c,t,twopk;
    a0003208:	f9003fff 	str	xzr, [sp, #120]
    a000320c:	f9003bff 	str	xzr, [sp, #112]
	int32_t k=0,xsb;
    a0003210:	b90067ff 	str	wzr, [sp, #100]
	u_int32_t hx;

	GET_HIGH_WORD(hx,x);
    a0003214:	fd4007e0 	ldr	d0, [sp, #8]
    a0003218:	fd001fe0 	str	d0, [sp, #56]
    a000321c:	b9403be0 	ldr	w0, [sp, #56]
    a0003220:	b90063e0 	str	w0, [sp, #96]
	xsb = (hx>>31)&1;		/* sign bit of x */
    a0003224:	b94063e0 	ldr	w0, [sp, #96]
    a0003228:	531f7c00 	lsr	w0, w0, #31
    a000322c:	b9005fe0 	str	w0, [sp, #92]
	hx &= 0x7fffffff;		/* high word of |x| */
    a0003230:	b94063e0 	ldr	w0, [sp, #96]
    a0003234:	12007800 	and	w0, w0, #0x7fffffff
    a0003238:	b90063e0 	str	w0, [sp, #96]

    /* filter out non-finite argument */
	if(hx >= 0x40862E42) {			/* if |x|>=709.78... */
    a000323c:	b94063e1 	ldr	w1, [sp, #96]
    a0003240:	5285c820 	mov	w0, #0x2e41                	// #11841
    a0003244:	72a810c0 	movk	w0, #0x4086, lsl #16
    a0003248:	6b00003f 	cmp	w1, w0
    a000324c:	540006e9 	b.ls	a0003328 <exp+0x128>  // b.plast
            if(hx>=0x7ff00000) {
    a0003250:	b94063e1 	ldr	w1, [sp, #96]
    a0003254:	12b00200 	mov	w0, #0x7fefffff            	// #2146435071
    a0003258:	6b00003f 	cmp	w1, w0
    a000325c:	540002a9 	b.ls	a00032b0 <exp+0xb0>  // b.plast
	        u_int32_t lx;
		GET_LOW_WORD(lx,x);
    a0003260:	fd4007e0 	ldr	d0, [sp, #8]
    a0003264:	fd001be0 	str	d0, [sp, #48]
    a0003268:	b94037e0 	ldr	w0, [sp, #52]
    a000326c:	b9005be0 	str	w0, [sp, #88]
		if(((hx&0xfffff)|lx)!=0)
    a0003270:	b94063e0 	ldr	w0, [sp, #96]
    a0003274:	12004c01 	and	w1, w0, #0xfffff
    a0003278:	b9405be0 	ldr	w0, [sp, #88]
    a000327c:	2a000020 	orr	w0, w1, w0
    a0003280:	7100001f 	cmp	w0, #0x0
    a0003284:	54000080 	b.eq	a0003294 <exp+0x94>  // b.none
		     return x+x; 		/* NaN */
    a0003288:	fd4007e0 	ldr	d0, [sp, #8]
    a000328c:	1e602800 	fadd	d0, d0, d0
    a0003290:	140000f4 	b	a0003660 <exp+0x460>
		else return (xsb==0)? x:0.0;	/* exp(+-inf)={inf,0} */
    a0003294:	b9405fe0 	ldr	w0, [sp, #92]
    a0003298:	7100001f 	cmp	w0, #0x0
    a000329c:	54000061 	b.ne	a00032a8 <exp+0xa8>  // b.any
    a00032a0:	fd4007e0 	ldr	d0, [sp, #8]
    a00032a4:	140000ef 	b	a0003660 <exp+0x460>
    a00032a8:	2f00e400 	movi	d0, #0x0
    a00032ac:	140000ed 	b	a0003660 <exp+0x460>
	    }
	    if(x > o_threshold) return huge*huge; /* overflow */
    a00032b0:	b0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a00032b4:	9113c000 	add	x0, x0, #0x4f0
    a00032b8:	fd400000 	ldr	d0, [x0]
    a00032bc:	fd4007e1 	ldr	d1, [sp, #8]
    a00032c0:	1e602030 	fcmpe	d1, d0
    a00032c4:	5400004c 	b.gt	a00032cc <exp+0xcc>
    a00032c8:	14000009 	b	a00032ec <exp+0xec>
    a00032cc:	b0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a00032d0:	9113e000 	add	x0, x0, #0x4f8
    a00032d4:	fd400001 	ldr	d1, [x0]
    a00032d8:	b0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a00032dc:	9113e000 	add	x0, x0, #0x4f8
    a00032e0:	fd400000 	ldr	d0, [x0]
    a00032e4:	1e600820 	fmul	d0, d1, d0
    a00032e8:	140000de 	b	a0003660 <exp+0x460>
	    if(x < u_threshold) return twom1000*twom1000; /* underflow */
    a00032ec:	b0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a00032f0:	91140000 	add	x0, x0, #0x500
    a00032f4:	fd400000 	ldr	d0, [x0]
    a00032f8:	fd4007e1 	ldr	d1, [sp, #8]
    a00032fc:	1e602030 	fcmpe	d1, d0
    a0003300:	54000044 	b.mi	a0003308 <exp+0x108>  // b.first
    a0003304:	14000009 	b	a0003328 <exp+0x128>
    a0003308:	900004c0 	adrp	x0, a009b000 <twom1000.10>
    a000330c:	91000000 	add	x0, x0, #0x0
    a0003310:	fd400001 	ldr	d1, [x0]
    a0003314:	900004c0 	adrp	x0, a009b000 <twom1000.10>
    a0003318:	91000000 	add	x0, x0, #0x0
    a000331c:	fd400000 	ldr	d0, [x0]
    a0003320:	1e600820 	fmul	d0, d1, d0
    a0003324:	140000cf 	b	a0003660 <exp+0x460>

        /* this implementation gives 2.7182818284590455 for exp(1.0),
           which is well within the allowable error. however,
           2.718281828459045 is closer to the true value so we prefer that
           answer, given that 1.0 is such an important argument value. */
        if (x == 1.0)
    a0003328:	fd4007e1 	ldr	d1, [sp, #8]
    a000332c:	1e6e1000 	fmov	d0, #1.000000000000000000e+00
    a0003330:	1e602020 	fcmp	d1, d0
    a0003334:	54000081 	b.ne	a0003344 <exp+0x144>  // b.any
            return 2.718281828459045235360;
    a0003338:	b0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a000333c:	fd41a400 	ldr	d0, [x0, #840]
    a0003340:	140000c8 	b	a0003660 <exp+0x460>

    /* argument reduction */
	if(hx > 0x3fd62e42) {		/* if  |x| > 0.5 ln2 */ 
    a0003344:	b94063e1 	ldr	w1, [sp, #96]
    a0003348:	5285c840 	mov	w0, #0x2e42                	// #11842
    a000334c:	72a7fac0 	movk	w0, #0x3fd6, lsl #16
    a0003350:	6b00003f 	cmp	w1, w0
    a0003354:	540007a9 	b.ls	a0003448 <exp+0x248>  // b.plast
	    if(hx < 0x3FF0A2B2) {	/* and |x| < 1.5 ln2 */
    a0003358:	b94063e1 	ldr	w1, [sp, #96]
    a000335c:	52945620 	mov	w0, #0xa2b1                	// #41649
    a0003360:	72a7fe00 	movk	w0, #0x3ff0, lsl #16
    a0003364:	6b00003f 	cmp	w1, w0
    a0003368:	54000288 	b.hi	a00033b8 <exp+0x1b8>  // b.pmore
		hi = x-ln2HI[xsb]; lo=ln2LO[xsb]; k = 1-xsb-xsb;
    a000336c:	b0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a0003370:	91142000 	add	x0, x0, #0x508
    a0003374:	b9805fe1 	ldrsw	x1, [sp, #92]
    a0003378:	fc617800 	ldr	d0, [x0, x1, lsl #3]
    a000337c:	fd4007e1 	ldr	d1, [sp, #8]
    a0003380:	1e603820 	fsub	d0, d1, d0
    a0003384:	fd003fe0 	str	d0, [sp, #120]
    a0003388:	b0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a000338c:	91146000 	add	x0, x0, #0x518
    a0003390:	b9805fe1 	ldrsw	x1, [sp, #92]
    a0003394:	fc617800 	ldr	d0, [x0, x1, lsl #3]
    a0003398:	fd003be0 	str	d0, [sp, #112]
    a000339c:	52800021 	mov	w1, #0x1                   	// #1
    a00033a0:	b9405fe0 	ldr	w0, [sp, #92]
    a00033a4:	4b000021 	sub	w1, w1, w0
    a00033a8:	b9405fe0 	ldr	w0, [sp, #92]
    a00033ac:	4b000020 	sub	w0, w1, w0
    a00033b0:	b90067e0 	str	w0, [sp, #100]
    a00033b4:	1400001e 	b	a000342c <exp+0x22c>
	    } else {
		k  = (int)(invln2*x+halF[xsb]);
    a00033b8:	b0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a00033bc:	9114a000 	add	x0, x0, #0x528
    a00033c0:	fd400001 	ldr	d1, [x0]
    a00033c4:	fd4007e0 	ldr	d0, [sp, #8]
    a00033c8:	1e600821 	fmul	d1, d1, d0
    a00033cc:	b0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a00033d0:	9114c000 	add	x0, x0, #0x530
    a00033d4:	b9805fe1 	ldrsw	x1, [sp, #92]
    a00033d8:	fc617800 	ldr	d0, [x0, x1, lsl #3]
    a00033dc:	1e602820 	fadd	d0, d1, d0
    a00033e0:	1e780000 	fcvtzs	w0, d0
    a00033e4:	b90067e0 	str	w0, [sp, #100]
		t  = k;
    a00033e8:	b94067e0 	ldr	w0, [sp, #100]
    a00033ec:	1e620000 	scvtf	d0, w0
    a00033f0:	fd002be0 	str	d0, [sp, #80]
		hi = x - t*ln2HI[0];	/* t*ln2HI is exact here */
    a00033f4:	b0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a00033f8:	91142000 	add	x0, x0, #0x508
    a00033fc:	fd400001 	ldr	d1, [x0]
    a0003400:	fd402be0 	ldr	d0, [sp, #80]
    a0003404:	1e600820 	fmul	d0, d1, d0
    a0003408:	fd4007e1 	ldr	d1, [sp, #8]
    a000340c:	1e603820 	fsub	d0, d1, d0
    a0003410:	fd003fe0 	str	d0, [sp, #120]
		lo = t*ln2LO[0];
    a0003414:	b0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a0003418:	91146000 	add	x0, x0, #0x518
    a000341c:	fd400000 	ldr	d0, [x0]
    a0003420:	fd402be1 	ldr	d1, [sp, #80]
    a0003424:	1e600820 	fmul	d0, d1, d0
    a0003428:	fd003be0 	str	d0, [sp, #112]
	    }
	    STRICT_ASSIGN(double, x, hi - lo);
    a000342c:	fd403fe1 	ldr	d1, [sp, #120]
    a0003430:	fd403be0 	ldr	d0, [sp, #112]
    a0003434:	1e603820 	fsub	d0, d1, d0
    a0003438:	fd0017e0 	str	d0, [sp, #40]
    a000343c:	fd4017e0 	ldr	d0, [sp, #40]
    a0003440:	fd0007e0 	str	d0, [sp, #8]
    a0003444:	14000017 	b	a00034a0 <exp+0x2a0>
	} 
	else if(hx < 0x3e300000)  {	/* when |x|<2**-28 */
    a0003448:	b94063e1 	ldr	w1, [sp, #96]
    a000344c:	12b83a00 	mov	w0, #0x3e2fffff            	// #1043333119
    a0003450:	6b00003f 	cmp	w1, w0
    a0003454:	54000248 	b.hi	a000349c <exp+0x29c>  // b.pmore
	    if(huge+x>one) return one+x;/* trigger inexact */
    a0003458:	b0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a000345c:	9113e000 	add	x0, x0, #0x4f8
    a0003460:	fd400001 	ldr	d1, [x0]
    a0003464:	fd4007e0 	ldr	d0, [sp, #8]
    a0003468:	1e602821 	fadd	d1, d1, d0
    a000346c:	b0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a0003470:	91150000 	add	x0, x0, #0x540
    a0003474:	fd400000 	ldr	d0, [x0]
    a0003478:	1e602030 	fcmpe	d1, d0
    a000347c:	5400004c 	b.gt	a0003484 <exp+0x284>
    a0003480:	14000008 	b	a00034a0 <exp+0x2a0>
    a0003484:	b0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a0003488:	91150000 	add	x0, x0, #0x540
    a000348c:	fd400001 	ldr	d1, [x0]
    a0003490:	fd4007e0 	ldr	d0, [sp, #8]
    a0003494:	1e602820 	fadd	d0, d1, d0
    a0003498:	14000072 	b	a0003660 <exp+0x460>
	}
	else k = 0;
    a000349c:	b90067ff 	str	wzr, [sp, #100]

    /* x is now in primary range */
	t  = x*x;
    a00034a0:	fd4007e0 	ldr	d0, [sp, #8]
    a00034a4:	1e600800 	fmul	d0, d0, d0
    a00034a8:	fd002be0 	str	d0, [sp, #80]
	if(k >= -1021)
    a00034ac:	b94067e0 	ldr	w0, [sp, #100]
    a00034b0:	310ff41f 	cmn	w0, #0x3fd
    a00034b4:	5400014b 	b.lt	a00034dc <exp+0x2dc>  // b.tstop
	    INSERT_WORDS(twopk,0x3ff00000+(k<<20), 0);
    a00034b8:	b94067e0 	ldr	w0, [sp, #100]
    a00034bc:	530c2c01 	lsl	w1, w0, #20
    a00034c0:	52a7fe00 	mov	w0, #0x3ff00000            	// #1072693248
    a00034c4:	0b000020 	add	w0, w1, w0
    a00034c8:	b90023e0 	str	w0, [sp, #32]
    a00034cc:	b90027ff 	str	wzr, [sp, #36]
    a00034d0:	fd4013e0 	ldr	d0, [sp, #32]
    a00034d4:	fd0037e0 	str	d0, [sp, #104]
    a00034d8:	1400000a 	b	a0003500 <exp+0x300>
	else
	    INSERT_WORDS(twopk,0x3ff00000+((k+1000)<<20), 0);
    a00034dc:	b94067e0 	ldr	w0, [sp, #100]
    a00034e0:	110fa000 	add	w0, w0, #0x3e8
    a00034e4:	530c2c01 	lsl	w1, w0, #20
    a00034e8:	52a7fe00 	mov	w0, #0x3ff00000            	// #1072693248
    a00034ec:	0b000020 	add	w0, w1, w0
    a00034f0:	b9001be0 	str	w0, [sp, #24]
    a00034f4:	b9001fff 	str	wzr, [sp, #28]
    a00034f8:	fd400fe0 	ldr	d0, [sp, #24]
    a00034fc:	fd0037e0 	str	d0, [sp, #104]
	c  = x - t*(P1+t*(P2+t*(P3+t*(P4+t*P5))));
    a0003500:	b0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a0003504:	91152000 	add	x0, x0, #0x548
    a0003508:	fd400001 	ldr	d1, [x0]
    a000350c:	fd402be0 	ldr	d0, [sp, #80]
    a0003510:	1e600821 	fmul	d1, d1, d0
    a0003514:	b0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a0003518:	91154000 	add	x0, x0, #0x550
    a000351c:	fd400000 	ldr	d0, [x0]
    a0003520:	1e602821 	fadd	d1, d1, d0
    a0003524:	fd402be0 	ldr	d0, [sp, #80]
    a0003528:	1e600821 	fmul	d1, d1, d0
    a000352c:	b0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a0003530:	91156000 	add	x0, x0, #0x558
    a0003534:	fd400000 	ldr	d0, [x0]
    a0003538:	1e602821 	fadd	d1, d1, d0
    a000353c:	fd402be0 	ldr	d0, [sp, #80]
    a0003540:	1e600821 	fmul	d1, d1, d0
    a0003544:	b0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a0003548:	91158000 	add	x0, x0, #0x560
    a000354c:	fd400000 	ldr	d0, [x0]
    a0003550:	1e602821 	fadd	d1, d1, d0
    a0003554:	fd402be0 	ldr	d0, [sp, #80]
    a0003558:	1e600821 	fmul	d1, d1, d0
    a000355c:	b0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a0003560:	9115a000 	add	x0, x0, #0x568
    a0003564:	fd400000 	ldr	d0, [x0]
    a0003568:	1e602821 	fadd	d1, d1, d0
    a000356c:	fd402be0 	ldr	d0, [sp, #80]
    a0003570:	1e600820 	fmul	d0, d1, d0
    a0003574:	fd4007e1 	ldr	d1, [sp, #8]
    a0003578:	1e603820 	fsub	d0, d1, d0
    a000357c:	fd0027e0 	str	d0, [sp, #72]
	if(k==0) 	return one-((x*c)/(c-2.0)-x); 
    a0003580:	b94067e0 	ldr	w0, [sp, #100]
    a0003584:	7100001f 	cmp	w0, #0x0
    a0003588:	540001e1 	b.ne	a00035c4 <exp+0x3c4>  // b.any
    a000358c:	b0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a0003590:	91150000 	add	x0, x0, #0x540
    a0003594:	fd400001 	ldr	d1, [x0]
    a0003598:	fd4007e2 	ldr	d2, [sp, #8]
    a000359c:	fd4027e0 	ldr	d0, [sp, #72]
    a00035a0:	1e600842 	fmul	d2, d2, d0
    a00035a4:	fd4027e3 	ldr	d3, [sp, #72]
    a00035a8:	1e601000 	fmov	d0, #2.000000000000000000e+00
    a00035ac:	1e603860 	fsub	d0, d3, d0
    a00035b0:	1e601842 	fdiv	d2, d2, d0
    a00035b4:	fd4007e0 	ldr	d0, [sp, #8]
    a00035b8:	1e603840 	fsub	d0, d2, d0
    a00035bc:	1e603820 	fsub	d0, d1, d0
    a00035c0:	14000028 	b	a0003660 <exp+0x460>
	else 		y = one-((lo-(x*c)/(2.0-c))-hi);
    a00035c4:	b0000100 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a00035c8:	91150000 	add	x0, x0, #0x540
    a00035cc:	fd400001 	ldr	d1, [x0]
    a00035d0:	fd4007e2 	ldr	d2, [sp, #8]
    a00035d4:	fd4027e0 	ldr	d0, [sp, #72]
    a00035d8:	1e600842 	fmul	d2, d2, d0
    a00035dc:	1e601003 	fmov	d3, #2.000000000000000000e+00
    a00035e0:	fd4027e0 	ldr	d0, [sp, #72]
    a00035e4:	1e603860 	fsub	d0, d3, d0
    a00035e8:	1e601840 	fdiv	d0, d2, d0
    a00035ec:	fd403be2 	ldr	d2, [sp, #112]
    a00035f0:	1e603842 	fsub	d2, d2, d0
    a00035f4:	fd403fe0 	ldr	d0, [sp, #120]
    a00035f8:	1e603840 	fsub	d0, d2, d0
    a00035fc:	1e603820 	fsub	d0, d1, d0
    a0003600:	fd0023e0 	str	d0, [sp, #64]
	if(k >= -1021) {
    a0003604:	b94067e0 	ldr	w0, [sp, #100]
    a0003608:	310ff41f 	cmn	w0, #0x3fd
    a000360c:	540001cb 	b.lt	a0003644 <exp+0x444>  // b.tstop
	    if (k==1024) return y*2.0*0x1p1023;
    a0003610:	b94067e0 	ldr	w0, [sp, #100]
    a0003614:	7110001f 	cmp	w0, #0x400
    a0003618:	540000e1 	b.ne	a0003634 <exp+0x434>  // b.any
    a000361c:	fd4023e0 	ldr	d0, [sp, #64]
    a0003620:	1e602800 	fadd	d0, d0, d0
    a0003624:	d2effc00 	mov	x0, #0x7fe0000000000000    	// #9214364837600034816
    a0003628:	9e670001 	fmov	d1, x0
    a000362c:	1e610800 	fmul	d0, d0, d1
    a0003630:	1400000c 	b	a0003660 <exp+0x460>
	    return y*twopk;
    a0003634:	fd4023e1 	ldr	d1, [sp, #64]
    a0003638:	fd4037e0 	ldr	d0, [sp, #104]
    a000363c:	1e600820 	fmul	d0, d1, d0
    a0003640:	14000008 	b	a0003660 <exp+0x460>
	} else {
	    return y*twopk*twom1000;
    a0003644:	fd4023e1 	ldr	d1, [sp, #64]
    a0003648:	fd4037e0 	ldr	d0, [sp, #104]
    a000364c:	1e600821 	fmul	d1, d1, d0
    a0003650:	900004c0 	adrp	x0, a009b000 <twom1000.10>
    a0003654:	91000000 	add	x0, x0, #0x0
    a0003658:	fd400000 	ldr	d0, [x0]
    a000365c:	1e600820 	fmul	d0, d1, d0
	}
}
    a0003660:	910203ff 	add	sp, sp, #0x80
    a0003664:	d65f03c0 	ret

00000000a0003668 <arch_syscall_invoke2>:
	return ret;
}

static inline uintptr_t arch_syscall_invoke2(uintptr_t arg1, uintptr_t arg2,
					     uintptr_t call_id)
{
    a0003668:	d10083ff 	sub	sp, sp, #0x20
    a000366c:	f9000fe0 	str	x0, [sp, #24]
    a0003670:	f9000be1 	str	x1, [sp, #16]
    a0003674:	f90007e2 	str	x2, [sp, #8]
	register uint64_t ret __asm__("x0") = arg1;
    a0003678:	f9400fe0 	ldr	x0, [sp, #24]
	register uint64_t r1 __asm__("x1") = arg2;
    a000367c:	f9400be1 	ldr	x1, [sp, #16]
	register uint64_t r8 __asm__("x8") = call_id;
    a0003680:	f94007e8 	ldr	x8, [sp, #8]

	__asm__ volatile("svc %[svid]\n"
    a0003684:	d4000061 	svc	#0x3
			 : [svid] "i" (_SVC_CALL_SYSTEM_CALL),
			   "r" (ret), "r" (r1), "r" (r8)
			 : "memory");

	return ret;
}
    a0003688:	910083ff 	add	sp, sp, #0x20
    a000368c:	d65f03c0 	ret

00000000a0003690 <arch_is_user_context>:

	return ret;
}

static inline bool arch_is_user_context(void)
{
    a0003690:	d10043ff 	sub	sp, sp, #0x10
MAKE_REG_HELPER(daif)
MAKE_REG_HELPER(hcr_el2);
MAKE_REG_HELPER(id_aa64pfr0_el1);
MAKE_REG_HELPER(id_aa64mmfr0_el1);
MAKE_REG_HELPER(scr_el3);
MAKE_REG_HELPER(tpidrro_el0);
    a0003694:	d53bd060 	mrs	x0, tpidrro_el0
    a0003698:	f90007e0 	str	x0, [sp, #8]
    a000369c:	f94007e0 	ldr	x0, [sp, #8]
    a00036a0:	d503201f 	nop
	return (read_tpidrro_el0() & TPIDRROEL0_IN_EL0) != 0;
    a00036a4:	92400000 	and	x0, x0, #0x1
    a00036a8:	f100001f 	cmp	x0, #0x0
    a00036ac:	1a9f07e0 	cset	w0, ne  // ne = any
    a00036b0:	12001c00 	and	w0, w0, #0xff
}
    a00036b4:	910043ff 	add	sp, sp, #0x10
    a00036b8:	d65f03c0 	ret

00000000a00036bc <k_is_user_context>:
 *
 * @return true if the CPU is currently running with user permissions
 */
__pinned_func
static inline bool k_is_user_context(void)
{
    a00036bc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    a00036c0:	910003fd 	mov	x29, sp
#ifdef CONFIG_USERSPACE
	return arch_is_user_context();
    a00036c4:	97fffff3 	bl	a0003690 <arch_is_user_context>
    a00036c8:	12001c00 	and	w0, w0, #0xff
#else
	return false;
#endif
}
    a00036cc:	a8c17bfd 	ldp	x29, x30, [sp], #16
    a00036d0:	d65f03c0 	ret

00000000a00036d4 <k_str_out>:

extern void z_impl_k_str_out(char * c, size_t n);

__pinned_func
static inline void k_str_out(char * c, size_t n)
{
    a00036d4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a00036d8:	910003fd 	mov	x29, sp
    a00036dc:	f9000fe0 	str	x0, [sp, #24]
    a00036e0:	f9000be1 	str	x1, [sp, #16]
	bool ret = false;
    a00036e4:	3900bfff 	strb	wzr, [sp, #47]
	ret = arch_is_user_context();
    a00036e8:	97ffffea 	bl	a0003690 <arch_is_user_context>
    a00036ec:	3900bfe0 	strb	w0, [sp, #47]
	return ret;
    a00036f0:	3940bfe0 	ldrb	w0, [sp, #47]
#ifdef CONFIG_USERSPACE
	if (z_syscall_trap()) {
    a00036f4:	7100001f 	cmp	w0, #0x0
    a00036f8:	54000140 	b.eq	a0003720 <k_str_out+0x4c>  // b.none
		/* coverity[OVERRUN] */
		arch_syscall_invoke2(*(uintptr_t *)&c, *(uintptr_t *)&n, K_SYSCALL_K_STR_OUT);
    a00036fc:	910063e0 	add	x0, sp, #0x18
    a0003700:	f9400003 	ldr	x3, [x0]
    a0003704:	910043e0 	add	x0, sp, #0x10
    a0003708:	f9400000 	ldr	x0, [x0]
    a000370c:	d28017e2 	mov	x2, #0xbf                  	// #191
    a0003710:	aa0003e1 	mov	x1, x0
    a0003714:	aa0303e0 	mov	x0, x3
    a0003718:	97ffffd4 	bl	a0003668 <arch_syscall_invoke2>
		return;
    a000371c:	14000004 	b	a000372c <k_str_out+0x58>
	}
#endif
	compiler_barrier();
	z_impl_k_str_out(c, n);
    a0003720:	f9400fe0 	ldr	x0, [sp, #24]
    a0003724:	f9400be1 	ldr	x1, [sp, #16]
    a0003728:	94000086 	bl	a0003940 <z_impl_k_str_out>
}
    a000372c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0003730:	d65f03c0 	ret

00000000a0003734 <arch_printk_char_out>:
 *
 * @return 0
 */
/* LCOV_EXCL_START */
__attribute__((weak)) int arch_printk_char_out(int c)
{
    a0003734:	d10043ff 	sub	sp, sp, #0x10
    a0003738:	b9000fe0 	str	w0, [sp, #12]
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
    a000373c:	52800000 	mov	w0, #0x0                   	// #0
}
    a0003740:	910043ff 	add	sp, sp, #0x10
    a0003744:	d65f03c0 	ret

00000000a0003748 <__printk_hook_install>:
 * To be called by the platform's console driver at init time. Installs a
 * routine that outputs one ASCII character at a time.
 * @param fn putc routine to install
 */
void __printk_hook_install(int (*fn)(int))
{
    a0003748:	d10043ff 	sub	sp, sp, #0x10
    a000374c:	f90007e0 	str	x0, [sp, #8]
	_char_out = fn;
    a0003750:	900004c0 	adrp	x0, a009b000 <twom1000.10>
    a0003754:	91002000 	add	x0, x0, #0x8
    a0003758:	f94007e1 	ldr	x1, [sp, #8]
    a000375c:	f9000001 	str	x1, [x0]
}
    a0003760:	d503201f 	nop
    a0003764:	910043ff 	add	sp, sp, #0x10
    a0003768:	d65f03c0 	ret

00000000a000376c <buf_flush>:
	unsigned int buf_count;
	char buf[CONFIG_PRINTK_BUFFER_SIZE];
};

static void buf_flush(struct buf_out_context *ctx)
{
    a000376c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0003770:	910003fd 	mov	x29, sp
    a0003774:	f9000fe0 	str	x0, [sp, #24]
	k_str_out(ctx->buf, ctx->buf_count);
    a0003778:	f9400fe0 	ldr	x0, [sp, #24]
    a000377c:	91002002 	add	x2, x0, #0x8
    a0003780:	f9400fe0 	ldr	x0, [sp, #24]
    a0003784:	b9400400 	ldr	w0, [x0, #4]
    a0003788:	2a0003e0 	mov	w0, w0
    a000378c:	aa0003e1 	mov	x1, x0
    a0003790:	aa0203e0 	mov	x0, x2
    a0003794:	97ffffd0 	bl	a00036d4 <k_str_out>
	ctx->buf_count = 0U;
    a0003798:	f9400fe0 	ldr	x0, [sp, #24]
    a000379c:	b900041f 	str	wzr, [x0, #4]
}
    a00037a0:	d503201f 	nop
    a00037a4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a00037a8:	d65f03c0 	ret

00000000a00037ac <buf_char_out>:

static int buf_char_out(int c, void *ctx_p)
{
    a00037ac:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a00037b0:	910003fd 	mov	x29, sp
    a00037b4:	b9001fe0 	str	w0, [sp, #28]
    a00037b8:	f9000be1 	str	x1, [sp, #16]
	struct buf_out_context *ctx = ctx_p;
    a00037bc:	f9400be0 	ldr	x0, [sp, #16]
    a00037c0:	f90017e0 	str	x0, [sp, #40]

	ctx->count++;
    a00037c4:	f94017e0 	ldr	x0, [sp, #40]
    a00037c8:	b9400000 	ldr	w0, [x0]
    a00037cc:	11000401 	add	w1, w0, #0x1
    a00037d0:	f94017e0 	ldr	x0, [sp, #40]
    a00037d4:	b9000001 	str	w1, [x0]
	ctx->buf[ctx->buf_count++] = c;
    a00037d8:	f94017e0 	ldr	x0, [sp, #40]
    a00037dc:	b9400400 	ldr	w0, [x0, #4]
    a00037e0:	11000402 	add	w2, w0, #0x1
    a00037e4:	f94017e1 	ldr	x1, [sp, #40]
    a00037e8:	b9000422 	str	w2, [x1, #4]
    a00037ec:	b9401fe1 	ldr	w1, [sp, #28]
    a00037f0:	12001c22 	and	w2, w1, #0xff
    a00037f4:	f94017e1 	ldr	x1, [sp, #40]
    a00037f8:	2a0003e0 	mov	w0, w0
    a00037fc:	8b000020 	add	x0, x1, x0
    a0003800:	2a0203e1 	mov	w1, w2
    a0003804:	39002001 	strb	w1, [x0, #8]
	if (ctx->buf_count == CONFIG_PRINTK_BUFFER_SIZE) {
    a0003808:	f94017e0 	ldr	x0, [sp, #40]
    a000380c:	b9400400 	ldr	w0, [x0, #4]
    a0003810:	7100801f 	cmp	w0, #0x20
    a0003814:	54000061 	b.ne	a0003820 <buf_char_out+0x74>  // b.any
		buf_flush(ctx);
    a0003818:	f94017e0 	ldr	x0, [sp, #40]
    a000381c:	97ffffd4 	bl	a000376c <buf_flush>
	}

	return c;
    a0003820:	b9401fe0 	ldr	w0, [sp, #28]
}
    a0003824:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0003828:	d65f03c0 	ret

00000000a000382c <char_out>:
struct out_context {
	int count;
};

static int char_out(int c, void *ctx_p)
{
    a000382c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0003830:	910003fd 	mov	x29, sp
    a0003834:	b9001fe0 	str	w0, [sp, #28]
    a0003838:	f9000be1 	str	x1, [sp, #16]
	struct out_context *ctx = ctx_p;
    a000383c:	f9400be0 	ldr	x0, [sp, #16]
    a0003840:	f90017e0 	str	x0, [sp, #40]

	ctx->count++;
    a0003844:	f94017e0 	ldr	x0, [sp, #40]
    a0003848:	b9400000 	ldr	w0, [x0]
    a000384c:	11000401 	add	w1, w0, #0x1
    a0003850:	f94017e0 	ldr	x0, [sp, #40]
    a0003854:	b9000001 	str	w1, [x0]
	return _char_out(c);
    a0003858:	900004c0 	adrp	x0, a009b000 <twom1000.10>
    a000385c:	91002000 	add	x0, x0, #0x8
    a0003860:	f9400001 	ldr	x1, [x0]
    a0003864:	b9401fe0 	ldr	w0, [sp, #28]
    a0003868:	d63f0020 	blr	x1
}
    a000386c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0003870:	d65f03c0 	ret

00000000a0003874 <vprintk>:

#ifdef CONFIG_USERSPACE
void vprintk(const char *fmt, va_list ap)
{
    a0003874:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
    a0003878:	910003fd 	mov	x29, sp
    a000387c:	f9000bf3 	str	x19, [sp, #16]
    a0003880:	f90027e0 	str	x0, [sp, #72]
    a0003884:	aa0103f3 	mov	x19, x1
	if (k_is_user_context()) {
    a0003888:	97ffff8d 	bl	a00036bc <k_is_user_context>
    a000388c:	12001c00 	and	w0, w0, #0xff
    a0003890:	7100001f 	cmp	w0, #0x0
    a0003894:	54000300 	b.eq	a00038f4 <vprintk+0x80>  // b.none
		struct buf_out_context ctx = { 0 };
    a0003898:	a9057fff 	stp	xzr, xzr, [sp, #80]
    a000389c:	a9067fff 	stp	xzr, xzr, [sp, #96]
    a00038a0:	f9003bff 	str	xzr, [sp, #112]

		cbvprintf(buf_char_out, &ctx, fmt, ap);
    a00038a4:	910083e2 	add	x2, sp, #0x20
    a00038a8:	aa1303e3 	mov	x3, x19
    a00038ac:	a9400460 	ldp	x0, x1, [x3]
    a00038b0:	a9000440 	stp	x0, x1, [x2]
    a00038b4:	a9410460 	ldp	x0, x1, [x3, #16]
    a00038b8:	a9010440 	stp	x0, x1, [x2, #16]
    a00038bc:	910083e1 	add	x1, sp, #0x20
    a00038c0:	910143e0 	add	x0, sp, #0x50
    a00038c4:	aa0103e3 	mov	x3, x1
    a00038c8:	f94027e2 	ldr	x2, [sp, #72]
    a00038cc:	aa0003e1 	mov	x1, x0
    a00038d0:	90000000 	adrp	x0, a0003000 <log+0x27c>
    a00038d4:	911eb000 	add	x0, x0, #0x7ac
    a00038d8:	94000f7f 	bl	a00076d4 <cbvprintf>

		if (ctx.buf_count) {
    a00038dc:	b94057e0 	ldr	w0, [sp, #84]
    a00038e0:	7100001f 	cmp	w0, #0x0
    a00038e4:	54000260 	b.eq	a0003930 <vprintk+0xbc>  // b.none
			buf_flush(&ctx);
    a00038e8:	910143e0 	add	x0, sp, #0x50
    a00038ec:	97ffffa0 	bl	a000376c <buf_flush>

#ifdef CONFIG_PRINTK_SYNC
		k_spin_unlock(&lock, key);
#endif
	}
}
    a00038f0:	14000010 	b	a0003930 <vprintk+0xbc>
		struct out_context ctx = { 0 };
    a00038f4:	b9007bff 	str	wzr, [sp, #120]
		cbvprintf(char_out, &ctx, fmt, ap);
    a00038f8:	910083e2 	add	x2, sp, #0x20
    a00038fc:	aa1303e3 	mov	x3, x19
    a0003900:	a9400460 	ldp	x0, x1, [x3]
    a0003904:	a9000440 	stp	x0, x1, [x2]
    a0003908:	a9410460 	ldp	x0, x1, [x3, #16]
    a000390c:	a9010440 	stp	x0, x1, [x2, #16]
    a0003910:	910083e1 	add	x1, sp, #0x20
    a0003914:	9101e3e0 	add	x0, sp, #0x78
    a0003918:	aa0103e3 	mov	x3, x1
    a000391c:	f94027e2 	ldr	x2, [sp, #72]
    a0003920:	aa0003e1 	mov	x1, x0
    a0003924:	90000000 	adrp	x0, a0003000 <log+0x27c>
    a0003928:	9120b000 	add	x0, x0, #0x82c
    a000392c:	94000f6a 	bl	a00076d4 <cbvprintf>
}
    a0003930:	d503201f 	nop
    a0003934:	f9400bf3 	ldr	x19, [sp, #16]
    a0003938:	a8c87bfd 	ldp	x29, x30, [sp], #128
    a000393c:	d65f03c0 	ret

00000000a0003940 <z_impl_k_str_out>:
#endif
}
#endif /* CONFIG_USERSPACE */

void z_impl_k_str_out(char *c, size_t n)
{
    a0003940:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0003944:	910003fd 	mov	x29, sp
    a0003948:	f9000fe0 	str	x0, [sp, #24]
    a000394c:	f9000be1 	str	x1, [sp, #16]
	size_t i;
#ifdef CONFIG_PRINTK_SYNC
	k_spinlock_key_t key = k_spin_lock(&lock);
#endif

	for (i = 0; i < n; i++) {
    a0003950:	f90017ff 	str	xzr, [sp, #40]
    a0003954:	1400000c 	b	a0003984 <z_impl_k_str_out+0x44>
		_char_out(c[i]);
    a0003958:	900004c0 	adrp	x0, a009b000 <twom1000.10>
    a000395c:	91002000 	add	x0, x0, #0x8
    a0003960:	f9400001 	ldr	x1, [x0]
    a0003964:	f9400fe2 	ldr	x2, [sp, #24]
    a0003968:	f94017e0 	ldr	x0, [sp, #40]
    a000396c:	8b000040 	add	x0, x2, x0
    a0003970:	39400000 	ldrb	w0, [x0]
    a0003974:	d63f0020 	blr	x1
	for (i = 0; i < n; i++) {
    a0003978:	f94017e0 	ldr	x0, [sp, #40]
    a000397c:	91000400 	add	x0, x0, #0x1
    a0003980:	f90017e0 	str	x0, [sp, #40]
    a0003984:	f94017e1 	ldr	x1, [sp, #40]
    a0003988:	f9400be0 	ldr	x0, [sp, #16]
    a000398c:	eb00003f 	cmp	x1, x0
    a0003990:	54fffe43 	b.cc	a0003958 <z_impl_k_str_out+0x18>  // b.lo, b.ul, b.last
	}

#ifdef CONFIG_PRINTK_SYNC
	k_spin_unlock(&lock, key);
#endif
}
    a0003994:	d503201f 	nop
    a0003998:	d503201f 	nop
    a000399c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a00039a0:	d65f03c0 	ret

00000000a00039a4 <z_vrfy_k_str_out>:

#ifdef CONFIG_USERSPACE
static inline void z_vrfy_k_str_out(char *c, size_t n)
{
    a00039a4:	a9a17bfd 	stp	x29, x30, [sp, #-496]!
    a00039a8:	910003fd 	mov	x29, sp
    a00039ac:	f9000fe0 	str	x0, [sp, #24]
    a00039b0:	f9000be1 	str	x1, [sp, #16]
	Z_OOPS(Z_SYSCALL_MEMORY_READ(c, n));
    a00039b4:	52800002 	mov	w2, #0x0                   	// #0
    a00039b8:	f9400be1 	ldr	x1, [sp, #16]
    a00039bc:	f9400fe0 	ldr	x0, [sp, #24]
    a00039c0:	94001fab 	bl	a000b86c <arch_buffer_validate>
    a00039c4:	7100001f 	cmp	w0, #0x0
    a00039c8:	1a9f07e0 	cset	w0, ne  // ne = any
    a00039cc:	3907bfe0 	strb	w0, [sp, #495]
    a00039d0:	3947bfe0 	ldrb	w0, [sp, #495]
    a00039d4:	7100001f 	cmp	w0, #0x0
    a00039d8:	3947bfe0 	ldrb	w0, [sp, #495]
    a00039dc:	7100001f 	cmp	w0, #0x0
    a00039e0:	540000c0 	b.eq	a00039f8 <z_vrfy_k_str_out+0x54>  // b.none
    a00039e4:	90000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00039e8:	913f8000 	add	x0, x0, #0xfe0
    a00039ec:	f9400800 	ldr	x0, [x0, #16]
    a00039f0:	f9408400 	ldr	x0, [x0, #264]
    a00039f4:	940015d9 	bl	a0009158 <arch_syscall_oops>
	z_impl_k_str_out((char *)c, n);
    a00039f8:	f9400be1 	ldr	x1, [sp, #16]
    a00039fc:	f9400fe0 	ldr	x0, [sp, #24]
    a0003a00:	97ffffd0 	bl	a0003940 <z_impl_k_str_out>
}
    a0003a04:	d503201f 	nop
    a0003a08:	a8df7bfd 	ldp	x29, x30, [sp], #496
    a0003a0c:	d65f03c0 	ret

00000000a0003a10 <z_mrsh_k_str_out>:
#include <syscalls/kernel.h>

extern void z_vrfy_k_str_out(char * c, size_t n);
uintptr_t z_mrsh_k_str_out(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a0003a10:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a0003a14:	910003fd 	mov	x29, sp
    a0003a18:	f90027e0 	str	x0, [sp, #72]
    a0003a1c:	f90023e1 	str	x1, [sp, #64]
    a0003a20:	f9001fe2 	str	x2, [sp, #56]
    a0003a24:	f9001be3 	str	x3, [sp, #48]
    a0003a28:	f90017e4 	str	x4, [sp, #40]
    a0003a2c:	f90013e5 	str	x5, [sp, #32]
    a0003a30:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a0003a34:	90000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0003a38:	913f8000 	add	x0, x0, #0xfe0
    a0003a3c:	f9400800 	ldr	x0, [x0, #16]
    a0003a40:	f9400fe1 	ldr	x1, [sp, #24]
    a0003a44:	f9008401 	str	x1, [x0, #264]
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_str_out(*(char **)&arg0, *(size_t*)&arg1)
    a0003a48:	910123e0 	add	x0, sp, #0x48
    a0003a4c:	f9400002 	ldr	x2, [x0]
    a0003a50:	910103e0 	add	x0, sp, #0x40
    a0003a54:	f9400000 	ldr	x0, [x0]
    a0003a58:	aa0003e1 	mov	x1, x0
    a0003a5c:	aa0203e0 	mov	x0, x2
    a0003a60:	97ffffd1 	bl	a00039a4 <z_vrfy_k_str_out>
;
	_current->syscall_frame = NULL;
    a0003a64:	90000220 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0003a68:	913f8000 	add	x0, x0, #0xfe0
    a0003a6c:	f9400800 	ldr	x0, [x0, #16]
    a0003a70:	f900841f 	str	xzr, [x0, #264]
	return 0;
    a0003a74:	d2800000 	mov	x0, #0x0                   	// #0
}
    a0003a78:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a0003a7c:	d65f03c0 	ret

00000000a0003a80 <printk>:
 *
 * @param fmt formatted string to output
 */

void printk(const char *fmt, ...)
{
    a0003a80:	a9ae7bfd 	stp	x29, x30, [sp, #-288]!
    a0003a84:	910003fd 	mov	x29, sp
    a0003a88:	f9001fe0 	str	x0, [sp, #56]
    a0003a8c:	f90077e1 	str	x1, [sp, #232]
    a0003a90:	f9007be2 	str	x2, [sp, #240]
    a0003a94:	f9007fe3 	str	x3, [sp, #248]
    a0003a98:	f90083e4 	str	x4, [sp, #256]
    a0003a9c:	f90087e5 	str	x5, [sp, #264]
    a0003aa0:	f9008be6 	str	x6, [sp, #272]
    a0003aa4:	f9008fe7 	str	x7, [sp, #280]
    a0003aa8:	3d801be0 	str	q0, [sp, #96]
    a0003aac:	3d801fe1 	str	q1, [sp, #112]
    a0003ab0:	3d8023e2 	str	q2, [sp, #128]
    a0003ab4:	3d8027e3 	str	q3, [sp, #144]
    a0003ab8:	3d802be4 	str	q4, [sp, #160]
    a0003abc:	3d802fe5 	str	q5, [sp, #176]
    a0003ac0:	3d8033e6 	str	q6, [sp, #192]
    a0003ac4:	3d8037e7 	str	q7, [sp, #208]
	va_list ap;

	va_start(ap, fmt);
    a0003ac8:	910483e0 	add	x0, sp, #0x120
    a0003acc:	f90023e0 	str	x0, [sp, #64]
    a0003ad0:	910483e0 	add	x0, sp, #0x120
    a0003ad4:	f90027e0 	str	x0, [sp, #72]
    a0003ad8:	910383e0 	add	x0, sp, #0xe0
    a0003adc:	f9002be0 	str	x0, [sp, #80]
    a0003ae0:	128006e0 	mov	w0, #0xffffffc8            	// #-56
    a0003ae4:	b9005be0 	str	w0, [sp, #88]
    a0003ae8:	12800fe0 	mov	w0, #0xffffff80            	// #-128
    a0003aec:	b9005fe0 	str	w0, [sp, #92]

	if (IS_ENABLED(CONFIG_LOG_PRINTK)) {
		log_printk(fmt, ap);
	} else {
		vprintk(fmt, ap);
    a0003af0:	910043e2 	add	x2, sp, #0x10
    a0003af4:	910103e3 	add	x3, sp, #0x40
    a0003af8:	a9400460 	ldp	x0, x1, [x3]
    a0003afc:	a9000440 	stp	x0, x1, [x2]
    a0003b00:	a9410460 	ldp	x0, x1, [x3, #16]
    a0003b04:	a9010440 	stp	x0, x1, [x2, #16]
    a0003b08:	910043e0 	add	x0, sp, #0x10
    a0003b0c:	aa0003e1 	mov	x1, x0
    a0003b10:	f9401fe0 	ldr	x0, [sp, #56]
    a0003b14:	97ffff58 	bl	a0003874 <vprintk>
	}
	va_end(ap);
}
    a0003b18:	d503201f 	nop
    a0003b1c:	a8d27bfd 	ldp	x29, x30, [sp], #288
    a0003b20:	d65f03c0 	ret

00000000a0003b24 <get_child>:
#include <stdbool.h>

enum rb_color { RED = 0U, BLACK = 1U };

static struct rbnode *get_child(struct rbnode *n, uint8_t side)
{
    a0003b24:	d10083ff 	sub	sp, sp, #0x20
    a0003b28:	f90007e0 	str	x0, [sp, #8]
    a0003b2c:	39001fe1 	strb	w1, [sp, #7]
	CHECK(n);
	if (side != 0U) {
    a0003b30:	39401fe0 	ldrb	w0, [sp, #7]
    a0003b34:	7100001f 	cmp	w0, #0x0
    a0003b38:	54000080 	b.eq	a0003b48 <get_child+0x24>  // b.none
		return n->children[1];
    a0003b3c:	f94007e0 	ldr	x0, [sp, #8]
    a0003b40:	f9400400 	ldr	x0, [x0, #8]
    a0003b44:	14000008 	b	a0003b64 <get_child+0x40>
	}

	uintptr_t l = (uintptr_t) n->children[0];
    a0003b48:	f94007e0 	ldr	x0, [sp, #8]
    a0003b4c:	f9400000 	ldr	x0, [x0]
    a0003b50:	f9000fe0 	str	x0, [sp, #24]

	l &= ~1UL;
    a0003b54:	f9400fe0 	ldr	x0, [sp, #24]
    a0003b58:	927ff800 	and	x0, x0, #0xfffffffffffffffe
    a0003b5c:	f9000fe0 	str	x0, [sp, #24]
	return (struct rbnode *) l;
    a0003b60:	f9400fe0 	ldr	x0, [sp, #24]
}
    a0003b64:	910083ff 	add	sp, sp, #0x20
    a0003b68:	d65f03c0 	ret

00000000a0003b6c <set_child>:

static void set_child(struct rbnode *n, uint8_t side, void *val)
{
    a0003b6c:	d100c3ff 	sub	sp, sp, #0x30
    a0003b70:	f9000fe0 	str	x0, [sp, #24]
    a0003b74:	39005fe1 	strb	w1, [sp, #23]
    a0003b78:	f90007e2 	str	x2, [sp, #8]
	CHECK(n);
	if (side != 0U) {
    a0003b7c:	39405fe0 	ldrb	w0, [sp, #23]
    a0003b80:	7100001f 	cmp	w0, #0x0
    a0003b84:	540000a0 	b.eq	a0003b98 <set_child+0x2c>  // b.none
		n->children[1] = val;
    a0003b88:	f9400fe0 	ldr	x0, [sp, #24]
    a0003b8c:	f94007e1 	ldr	x1, [sp, #8]
    a0003b90:	f9000401 	str	x1, [x0, #8]
		uintptr_t old = (uintptr_t) n->children[0];
		uintptr_t new = (uintptr_t) val;

		n->children[0] = (void *) (new | (old & 1UL));
	}
}
    a0003b94:	1400000d 	b	a0003bc8 <set_child+0x5c>
		uintptr_t old = (uintptr_t) n->children[0];
    a0003b98:	f9400fe0 	ldr	x0, [sp, #24]
    a0003b9c:	f9400000 	ldr	x0, [x0]
    a0003ba0:	f90017e0 	str	x0, [sp, #40]
		uintptr_t new = (uintptr_t) val;
    a0003ba4:	f94007e0 	ldr	x0, [sp, #8]
    a0003ba8:	f90013e0 	str	x0, [sp, #32]
		n->children[0] = (void *) (new | (old & 1UL));
    a0003bac:	f94017e0 	ldr	x0, [sp, #40]
    a0003bb0:	92400001 	and	x1, x0, #0x1
    a0003bb4:	f94013e0 	ldr	x0, [sp, #32]
    a0003bb8:	aa000020 	orr	x0, x1, x0
    a0003bbc:	aa0003e1 	mov	x1, x0
    a0003bc0:	f9400fe0 	ldr	x0, [sp, #24]
    a0003bc4:	f9000001 	str	x1, [x0]
}
    a0003bc8:	d503201f 	nop
    a0003bcc:	9100c3ff 	add	sp, sp, #0x30
    a0003bd0:	d65f03c0 	ret

00000000a0003bd4 <get_color>:

static enum rb_color get_color(struct rbnode *n)
{
    a0003bd4:	d10043ff 	sub	sp, sp, #0x10
    a0003bd8:	f90007e0 	str	x0, [sp, #8]
	CHECK(n);
	return ((uintptr_t)n->children[0]) & 1UL;
    a0003bdc:	f94007e0 	ldr	x0, [sp, #8]
    a0003be0:	f9400000 	ldr	x0, [x0]
    a0003be4:	12000000 	and	w0, w0, #0x1
}
    a0003be8:	910043ff 	add	sp, sp, #0x10
    a0003bec:	d65f03c0 	ret

00000000a0003bf0 <is_black>:

static bool is_black(struct rbnode *n)
{
    a0003bf0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0003bf4:	910003fd 	mov	x29, sp
    a0003bf8:	f9000fe0 	str	x0, [sp, #24]
	return get_color(n) == BLACK;
    a0003bfc:	f9400fe0 	ldr	x0, [sp, #24]
    a0003c00:	97fffff5 	bl	a0003bd4 <get_color>
    a0003c04:	7100041f 	cmp	w0, #0x1
    a0003c08:	1a9f17e0 	cset	w0, eq  // eq = none
    a0003c0c:	12001c00 	and	w0, w0, #0xff
}
    a0003c10:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0003c14:	d65f03c0 	ret

00000000a0003c18 <is_red>:

static bool is_red(struct rbnode *n)
{
    a0003c18:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0003c1c:	910003fd 	mov	x29, sp
    a0003c20:	f9000fe0 	str	x0, [sp, #24]
	return get_color(n) == RED;
    a0003c24:	f9400fe0 	ldr	x0, [sp, #24]
    a0003c28:	97ffffeb 	bl	a0003bd4 <get_color>
    a0003c2c:	7100001f 	cmp	w0, #0x0
    a0003c30:	1a9f17e0 	cset	w0, eq  // eq = none
    a0003c34:	12001c00 	and	w0, w0, #0xff
}
    a0003c38:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0003c3c:	d65f03c0 	ret

00000000a0003c40 <set_color>:

static void set_color(struct rbnode *n, enum rb_color color)
{
    a0003c40:	d10083ff 	sub	sp, sp, #0x20
    a0003c44:	f90007e0 	str	x0, [sp, #8]
    a0003c48:	b90007e1 	str	w1, [sp, #4]
	CHECK(n);

	uintptr_t *p = (void *) &n->children[0];
    a0003c4c:	f94007e0 	ldr	x0, [sp, #8]
    a0003c50:	f9000fe0 	str	x0, [sp, #24]

	*p = (*p & ~1UL) | (uint8_t)color;
    a0003c54:	f9400fe0 	ldr	x0, [sp, #24]
    a0003c58:	f9400000 	ldr	x0, [x0]
    a0003c5c:	927ff801 	and	x1, x0, #0xfffffffffffffffe
    a0003c60:	b94007e0 	ldr	w0, [sp, #4]
    a0003c64:	12001c00 	and	w0, w0, #0xff
    a0003c68:	92401c00 	and	x0, x0, #0xff
    a0003c6c:	aa000021 	orr	x1, x1, x0
    a0003c70:	f9400fe0 	ldr	x0, [sp, #24]
    a0003c74:	f9000001 	str	x1, [x0]
}
    a0003c78:	d503201f 	nop
    a0003c7c:	910083ff 	add	sp, sp, #0x20
    a0003c80:	d65f03c0 	ret

00000000a0003c84 <find_and_stack>:
 * contain at least tree->max_depth entries!  Returns the number of
 * entries pushed onto the stack.
 */
static int find_and_stack(struct rbtree *tree, struct rbnode *node,
			  struct rbnode **stack)
{
    a0003c84:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    a0003c88:	910003fd 	mov	x29, sp
    a0003c8c:	f90017e0 	str	x0, [sp, #40]
    a0003c90:	f90013e1 	str	x1, [sp, #32]
    a0003c94:	f9000fe2 	str	x2, [sp, #24]
	int sz = 0;
    a0003c98:	b9003fff 	str	wzr, [sp, #60]

	stack[sz++] = tree->root;
    a0003c9c:	b9403fe0 	ldr	w0, [sp, #60]
    a0003ca0:	11000401 	add	w1, w0, #0x1
    a0003ca4:	b9003fe1 	str	w1, [sp, #60]
    a0003ca8:	93407c00 	sxtw	x0, w0
    a0003cac:	d37df000 	lsl	x0, x0, #3
    a0003cb0:	f9400fe1 	ldr	x1, [sp, #24]
    a0003cb4:	8b000020 	add	x0, x1, x0
    a0003cb8:	f94017e1 	ldr	x1, [sp, #40]
    a0003cbc:	f9400021 	ldr	x1, [x1]
    a0003cc0:	f9000001 	str	x1, [x0]

	while (stack[sz - 1] != node) {
    a0003cc4:	14000025 	b	a0003d58 <find_and_stack+0xd4>
		uint8_t side = tree->lessthan_fn(node, stack[sz - 1]) ? 0U : 1U;
    a0003cc8:	f94017e0 	ldr	x0, [sp, #40]
    a0003ccc:	f9400402 	ldr	x2, [x0, #8]
    a0003cd0:	b9803fe0 	ldrsw	x0, [sp, #60]
    a0003cd4:	d37df000 	lsl	x0, x0, #3
    a0003cd8:	d1002000 	sub	x0, x0, #0x8
    a0003cdc:	f9400fe1 	ldr	x1, [sp, #24]
    a0003ce0:	8b000020 	add	x0, x1, x0
    a0003ce4:	f9400000 	ldr	x0, [x0]
    a0003ce8:	aa0003e1 	mov	x1, x0
    a0003cec:	f94013e0 	ldr	x0, [sp, #32]
    a0003cf0:	d63f0040 	blr	x2
    a0003cf4:	12001c00 	and	w0, w0, #0xff
    a0003cf8:	52000000 	eor	w0, w0, #0x1
    a0003cfc:	12001c00 	and	w0, w0, #0xff
    a0003d00:	3900efe0 	strb	w0, [sp, #59]
		struct rbnode *ch = get_child(stack[sz - 1], side);
    a0003d04:	b9803fe0 	ldrsw	x0, [sp, #60]
    a0003d08:	d37df000 	lsl	x0, x0, #3
    a0003d0c:	d1002000 	sub	x0, x0, #0x8
    a0003d10:	f9400fe1 	ldr	x1, [sp, #24]
    a0003d14:	8b000020 	add	x0, x1, x0
    a0003d18:	f9400000 	ldr	x0, [x0]
    a0003d1c:	3940efe1 	ldrb	w1, [sp, #59]
    a0003d20:	97ffff81 	bl	a0003b24 <get_child>
    a0003d24:	f9001be0 	str	x0, [sp, #48]

		if (ch != NULL) {
    a0003d28:	f9401be0 	ldr	x0, [sp, #48]
    a0003d2c:	f100001f 	cmp	x0, #0x0
    a0003d30:	54000280 	b.eq	a0003d80 <find_and_stack+0xfc>  // b.none
			stack[sz++] = ch;
    a0003d34:	b9403fe0 	ldr	w0, [sp, #60]
    a0003d38:	11000401 	add	w1, w0, #0x1
    a0003d3c:	b9003fe1 	str	w1, [sp, #60]
    a0003d40:	93407c00 	sxtw	x0, w0
    a0003d44:	d37df000 	lsl	x0, x0, #3
    a0003d48:	f9400fe1 	ldr	x1, [sp, #24]
    a0003d4c:	8b000020 	add	x0, x1, x0
    a0003d50:	f9401be1 	ldr	x1, [sp, #48]
    a0003d54:	f9000001 	str	x1, [x0]
	while (stack[sz - 1] != node) {
    a0003d58:	b9803fe0 	ldrsw	x0, [sp, #60]
    a0003d5c:	d37df000 	lsl	x0, x0, #3
    a0003d60:	d1002000 	sub	x0, x0, #0x8
    a0003d64:	f9400fe1 	ldr	x1, [sp, #24]
    a0003d68:	8b000020 	add	x0, x1, x0
    a0003d6c:	f9400000 	ldr	x0, [x0]
    a0003d70:	f94013e1 	ldr	x1, [sp, #32]
    a0003d74:	eb00003f 	cmp	x1, x0
    a0003d78:	54fffa81 	b.ne	a0003cc8 <find_and_stack+0x44>  // b.any
    a0003d7c:	14000002 	b	a0003d84 <find_and_stack+0x100>
		} else {
			break;
    a0003d80:	d503201f 	nop
		}
	}

	return sz;
    a0003d84:	b9403fe0 	ldr	w0, [sp, #60]
}
    a0003d88:	a8c47bfd 	ldp	x29, x30, [sp], #64
    a0003d8c:	d65f03c0 	ret

00000000a0003d90 <get_side>:
	}
	return n;
}

static uint8_t get_side(struct rbnode *parent, struct rbnode *child)
{
    a0003d90:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0003d94:	910003fd 	mov	x29, sp
    a0003d98:	f9000fe0 	str	x0, [sp, #24]
    a0003d9c:	f9000be1 	str	x1, [sp, #16]
	CHECK(get_child(parent, 0U) == child || get_child(parent, 1U) == child);

	return (get_child(parent, 1U) == child) ? 1U : 0U;
    a0003da0:	52800021 	mov	w1, #0x1                   	// #1
    a0003da4:	f9400fe0 	ldr	x0, [sp, #24]
    a0003da8:	97ffff5f 	bl	a0003b24 <get_child>
    a0003dac:	aa0003e1 	mov	x1, x0
    a0003db0:	f9400be0 	ldr	x0, [sp, #16]
    a0003db4:	eb01001f 	cmp	x0, x1
    a0003db8:	54000061 	b.ne	a0003dc4 <get_side+0x34>  // b.any
    a0003dbc:	52800020 	mov	w0, #0x1                   	// #1
    a0003dc0:	14000002 	b	a0003dc8 <get_side+0x38>
    a0003dc4:	52800000 	mov	w0, #0x0                   	// #0
}
    a0003dc8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0003dcc:	d65f03c0 	ret

00000000a0003dd0 <rotate>:
 *  N  c  -->  a   P
 * a b            b c
 *
 */
static void rotate(struct rbnode **stack, int stacksz)
{
    a0003dd0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a0003dd4:	910003fd 	mov	x29, sp
    a0003dd8:	f9000fe0 	str	x0, [sp, #24]
    a0003ddc:	b90017e1 	str	w1, [sp, #20]
	CHECK(stacksz >= 2);

	struct rbnode *parent = stack[stacksz - 2];
    a0003de0:	b98017e0 	ldrsw	x0, [sp, #20]
    a0003de4:	d37df000 	lsl	x0, x0, #3
    a0003de8:	d1004000 	sub	x0, x0, #0x10
    a0003dec:	f9400fe1 	ldr	x1, [sp, #24]
    a0003df0:	8b000020 	add	x0, x1, x0
    a0003df4:	f9400000 	ldr	x0, [x0]
    a0003df8:	f90027e0 	str	x0, [sp, #72]
	struct rbnode *child = stack[stacksz - 1];
    a0003dfc:	b98017e0 	ldrsw	x0, [sp, #20]
    a0003e00:	d37df000 	lsl	x0, x0, #3
    a0003e04:	d1002000 	sub	x0, x0, #0x8
    a0003e08:	f9400fe1 	ldr	x1, [sp, #24]
    a0003e0c:	8b000020 	add	x0, x1, x0
    a0003e10:	f9400000 	ldr	x0, [x0]
    a0003e14:	f90023e0 	str	x0, [sp, #64]
	uint8_t side = get_side(parent, child);
    a0003e18:	f94023e1 	ldr	x1, [sp, #64]
    a0003e1c:	f94027e0 	ldr	x0, [sp, #72]
    a0003e20:	97ffffdc 	bl	a0003d90 <get_side>
    a0003e24:	3900ffe0 	strb	w0, [sp, #63]
	struct rbnode *a = get_child(child, side);
    a0003e28:	3940ffe1 	ldrb	w1, [sp, #63]
    a0003e2c:	f94023e0 	ldr	x0, [sp, #64]
    a0003e30:	97ffff3d 	bl	a0003b24 <get_child>
    a0003e34:	f9001be0 	str	x0, [sp, #48]
	struct rbnode *b = get_child(child, (side == 0U) ? 1U : 0U);
    a0003e38:	3940ffe0 	ldrb	w0, [sp, #63]
    a0003e3c:	7100001f 	cmp	w0, #0x0
    a0003e40:	54000061 	b.ne	a0003e4c <rotate+0x7c>  // b.any
    a0003e44:	52800020 	mov	w0, #0x1                   	// #1
    a0003e48:	14000002 	b	a0003e50 <rotate+0x80>
    a0003e4c:	52800000 	mov	w0, #0x0                   	// #0
    a0003e50:	2a0003e1 	mov	w1, w0
    a0003e54:	f94023e0 	ldr	x0, [sp, #64]
    a0003e58:	97ffff33 	bl	a0003b24 <get_child>
    a0003e5c:	f90017e0 	str	x0, [sp, #40]

	if (stacksz >= 3) {
    a0003e60:	b94017e0 	ldr	w0, [sp, #20]
    a0003e64:	7100081f 	cmp	w0, #0x2
    a0003e68:	5400020d 	b.le	a0003ea8 <rotate+0xd8>
		struct rbnode *grandparent = stack[stacksz - 3];
    a0003e6c:	b98017e0 	ldrsw	x0, [sp, #20]
    a0003e70:	d37df000 	lsl	x0, x0, #3
    a0003e74:	d1006000 	sub	x0, x0, #0x18
    a0003e78:	f9400fe1 	ldr	x1, [sp, #24]
    a0003e7c:	8b000020 	add	x0, x1, x0
    a0003e80:	f9400000 	ldr	x0, [x0]
    a0003e84:	f90013e0 	str	x0, [sp, #32]

		set_child(grandparent, get_side(grandparent, parent), child);
    a0003e88:	f94027e1 	ldr	x1, [sp, #72]
    a0003e8c:	f94013e0 	ldr	x0, [sp, #32]
    a0003e90:	97ffffc0 	bl	a0003d90 <get_side>
    a0003e94:	12001c00 	and	w0, w0, #0xff
    a0003e98:	f94023e2 	ldr	x2, [sp, #64]
    a0003e9c:	2a0003e1 	mov	w1, w0
    a0003ea0:	f94013e0 	ldr	x0, [sp, #32]
    a0003ea4:	97ffff32 	bl	a0003b6c <set_child>
	}

	set_child(child, side, a);
    a0003ea8:	f9401be2 	ldr	x2, [sp, #48]
    a0003eac:	3940ffe1 	ldrb	w1, [sp, #63]
    a0003eb0:	f94023e0 	ldr	x0, [sp, #64]
    a0003eb4:	97ffff2e 	bl	a0003b6c <set_child>
	set_child(child, (side == 0U) ? 1U : 0U, parent);
    a0003eb8:	3940ffe0 	ldrb	w0, [sp, #63]
    a0003ebc:	7100001f 	cmp	w0, #0x0
    a0003ec0:	54000061 	b.ne	a0003ecc <rotate+0xfc>  // b.any
    a0003ec4:	52800020 	mov	w0, #0x1                   	// #1
    a0003ec8:	14000002 	b	a0003ed0 <rotate+0x100>
    a0003ecc:	52800000 	mov	w0, #0x0                   	// #0
    a0003ed0:	f94027e2 	ldr	x2, [sp, #72]
    a0003ed4:	2a0003e1 	mov	w1, w0
    a0003ed8:	f94023e0 	ldr	x0, [sp, #64]
    a0003edc:	97ffff24 	bl	a0003b6c <set_child>
	set_child(parent, side, b);
    a0003ee0:	f94017e2 	ldr	x2, [sp, #40]
    a0003ee4:	3940ffe1 	ldrb	w1, [sp, #63]
    a0003ee8:	f94027e0 	ldr	x0, [sp, #72]
    a0003eec:	97ffff20 	bl	a0003b6c <set_child>
	stack[stacksz - 2] = child;
    a0003ef0:	b98017e0 	ldrsw	x0, [sp, #20]
    a0003ef4:	d37df000 	lsl	x0, x0, #3
    a0003ef8:	d1004000 	sub	x0, x0, #0x10
    a0003efc:	f9400fe1 	ldr	x1, [sp, #24]
    a0003f00:	8b000020 	add	x0, x1, x0
    a0003f04:	f94023e1 	ldr	x1, [sp, #64]
    a0003f08:	f9000001 	str	x1, [x0]
	stack[stacksz - 1] = parent;
    a0003f0c:	b98017e0 	ldrsw	x0, [sp, #20]
    a0003f10:	d37df000 	lsl	x0, x0, #3
    a0003f14:	d1002000 	sub	x0, x0, #0x8
    a0003f18:	f9400fe1 	ldr	x1, [sp, #24]
    a0003f1c:	8b000020 	add	x0, x1, x0
    a0003f20:	f94027e1 	ldr	x1, [sp, #72]
    a0003f24:	f9000001 	str	x1, [x0]
}
    a0003f28:	d503201f 	nop
    a0003f2c:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a0003f30:	d65f03c0 	ret

00000000a0003f34 <fix_extra_red>:
/* The node at the top of the provided stack is red, and its parent is
 * too.  Iteratively fix the tree so it becomes a valid red black tree
 * again
 */
static void fix_extra_red(struct rbnode **stack, int stacksz)
{
    a0003f34:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a0003f38:	910003fd 	mov	x29, sp
    a0003f3c:	f9000fe0 	str	x0, [sp, #24]
    a0003f40:	b90017e1 	str	w1, [sp, #20]
	while (stacksz > 1) {
    a0003f44:	14000066 	b	a00040dc <fix_extra_red+0x1a8>
		struct rbnode *node = stack[stacksz - 1];
    a0003f48:	b98017e0 	ldrsw	x0, [sp, #20]
    a0003f4c:	d37df000 	lsl	x0, x0, #3
    a0003f50:	d1002000 	sub	x0, x0, #0x8
    a0003f54:	f9400fe1 	ldr	x1, [sp, #24]
    a0003f58:	8b000020 	add	x0, x1, x0
    a0003f5c:	f9400000 	ldr	x0, [x0]
    a0003f60:	f90027e0 	str	x0, [sp, #72]
		struct rbnode *parent = stack[stacksz - 2];
    a0003f64:	b98017e0 	ldrsw	x0, [sp, #20]
    a0003f68:	d37df000 	lsl	x0, x0, #3
    a0003f6c:	d1004000 	sub	x0, x0, #0x10
    a0003f70:	f9400fe1 	ldr	x1, [sp, #24]
    a0003f74:	8b000020 	add	x0, x1, x0
    a0003f78:	f9400000 	ldr	x0, [x0]
    a0003f7c:	f90023e0 	str	x0, [sp, #64]
		CHECK((get_child(node, 0U) == NULL) ||
		      is_black(get_child(node, 0U)));
		CHECK((get_child(node, 1U) == NULL) ||
		      is_black(get_child(node, 1U)));

		if (is_black(parent)) {
    a0003f80:	f94023e0 	ldr	x0, [sp, #64]
    a0003f84:	97ffff1b 	bl	a0003bf0 <is_black>
    a0003f88:	12001c00 	and	w0, w0, #0xff
    a0003f8c:	7100001f 	cmp	w0, #0x0
    a0003f90:	54000b61 	b.ne	a00040fc <fix_extra_red+0x1c8>  // b.any
		/* We are guaranteed to have a grandparent if our
		 * parent is red, as red nodes cannot be the root
		 */
		CHECK(stacksz >= 2);

		struct rbnode *grandparent = stack[stacksz - 3];
    a0003f94:	b98017e0 	ldrsw	x0, [sp, #20]
    a0003f98:	d37df000 	lsl	x0, x0, #3
    a0003f9c:	d1006000 	sub	x0, x0, #0x18
    a0003fa0:	f9400fe1 	ldr	x1, [sp, #24]
    a0003fa4:	8b000020 	add	x0, x1, x0
    a0003fa8:	f9400000 	ldr	x0, [x0]
    a0003fac:	f9001fe0 	str	x0, [sp, #56]
		uint8_t side = get_side(grandparent, parent);
    a0003fb0:	f94023e1 	ldr	x1, [sp, #64]
    a0003fb4:	f9401fe0 	ldr	x0, [sp, #56]
    a0003fb8:	97ffff76 	bl	a0003d90 <get_side>
    a0003fbc:	3900dfe0 	strb	w0, [sp, #55]
		struct rbnode *aunt = get_child(grandparent,
    a0003fc0:	3940dfe0 	ldrb	w0, [sp, #55]
    a0003fc4:	7100001f 	cmp	w0, #0x0
    a0003fc8:	54000061 	b.ne	a0003fd4 <fix_extra_red+0xa0>  // b.any
    a0003fcc:	52800020 	mov	w0, #0x1                   	// #1
    a0003fd0:	14000002 	b	a0003fd8 <fix_extra_red+0xa4>
    a0003fd4:	52800000 	mov	w0, #0x0                   	// #0
    a0003fd8:	2a0003e1 	mov	w1, w0
    a0003fdc:	f9401fe0 	ldr	x0, [sp, #56]
    a0003fe0:	97fffed1 	bl	a0003b24 <get_child>
    a0003fe4:	f90017e0 	str	x0, [sp, #40]
						(side == 0U) ? 1U : 0U);

		if ((aunt != NULL) && is_red(aunt)) {
    a0003fe8:	f94017e0 	ldr	x0, [sp, #40]
    a0003fec:	f100001f 	cmp	x0, #0x0
    a0003ff0:	54000260 	b.eq	a000403c <fix_extra_red+0x108>  // b.none
    a0003ff4:	f94017e0 	ldr	x0, [sp, #40]
    a0003ff8:	97ffff08 	bl	a0003c18 <is_red>
    a0003ffc:	12001c00 	and	w0, w0, #0xff
    a0004000:	7100001f 	cmp	w0, #0x0
    a0004004:	540001c0 	b.eq	a000403c <fix_extra_red+0x108>  // b.none
			set_color(grandparent, RED);
    a0004008:	52800001 	mov	w1, #0x0                   	// #0
    a000400c:	f9401fe0 	ldr	x0, [sp, #56]
    a0004010:	97ffff0c 	bl	a0003c40 <set_color>
			set_color(parent, BLACK);
    a0004014:	52800021 	mov	w1, #0x1                   	// #1
    a0004018:	f94023e0 	ldr	x0, [sp, #64]
    a000401c:	97ffff09 	bl	a0003c40 <set_color>
			set_color(aunt, BLACK);
    a0004020:	52800021 	mov	w1, #0x1                   	// #1
    a0004024:	f94017e0 	ldr	x0, [sp, #40]
    a0004028:	97ffff06 	bl	a0003c40 <set_color>

			/* We colored the grandparent red, which might
			 * have a red parent, so continue iterating
			 * from there.
			 */
			stacksz -= 2;
    a000402c:	b94017e0 	ldr	w0, [sp, #20]
    a0004030:	51000800 	sub	w0, w0, #0x2
    a0004034:	b90017e0 	str	w0, [sp, #20]
			continue;
    a0004038:	14000029 	b	a00040dc <fix_extra_red+0x1a8>

		/* We can rotate locally to fix the whole tree.  First
		 * make sure that node is on the same side of parent
		 * as parent is of grandparent.
		 */
		uint8_t parent_side = get_side(parent, node);
    a000403c:	f94027e1 	ldr	x1, [sp, #72]
    a0004040:	f94023e0 	ldr	x0, [sp, #64]
    a0004044:	97ffff53 	bl	a0003d90 <get_side>
    a0004048:	39009fe0 	strb	w0, [sp, #39]

		if (parent_side != side) {
    a000404c:	39409fe1 	ldrb	w1, [sp, #39]
    a0004050:	3940dfe0 	ldrb	w0, [sp, #55]
    a0004054:	6b00003f 	cmp	w1, w0
    a0004058:	54000160 	b.eq	a0004084 <fix_extra_red+0x150>  // b.none
			rotate(stack, stacksz);
    a000405c:	b94017e1 	ldr	w1, [sp, #20]
    a0004060:	f9400fe0 	ldr	x0, [sp, #24]
    a0004064:	97ffff5b 	bl	a0003dd0 <rotate>
			node = stack[stacksz - 1];
    a0004068:	b98017e0 	ldrsw	x0, [sp, #20]
    a000406c:	d37df000 	lsl	x0, x0, #3
    a0004070:	d1002000 	sub	x0, x0, #0x8
    a0004074:	f9400fe1 	ldr	x1, [sp, #24]
    a0004078:	8b000020 	add	x0, x1, x0
    a000407c:	f9400000 	ldr	x0, [x0]
    a0004080:	f90027e0 	str	x0, [sp, #72]
		}

		/* Rotate the grandparent with parent, swapping colors */
		rotate(stack, stacksz - 1);
    a0004084:	b94017e0 	ldr	w0, [sp, #20]
    a0004088:	51000400 	sub	w0, w0, #0x1
    a000408c:	2a0003e1 	mov	w1, w0
    a0004090:	f9400fe0 	ldr	x0, [sp, #24]
    a0004094:	97ffff4f 	bl	a0003dd0 <rotate>
		set_color(stack[stacksz - 3], BLACK);
    a0004098:	b98017e0 	ldrsw	x0, [sp, #20]
    a000409c:	d37df000 	lsl	x0, x0, #3
    a00040a0:	d1006000 	sub	x0, x0, #0x18
    a00040a4:	f9400fe1 	ldr	x1, [sp, #24]
    a00040a8:	8b000020 	add	x0, x1, x0
    a00040ac:	f9400000 	ldr	x0, [x0]
    a00040b0:	52800021 	mov	w1, #0x1                   	// #1
    a00040b4:	97fffee3 	bl	a0003c40 <set_color>
		set_color(stack[stacksz - 2], RED);
    a00040b8:	b98017e0 	ldrsw	x0, [sp, #20]
    a00040bc:	d37df000 	lsl	x0, x0, #3
    a00040c0:	d1004000 	sub	x0, x0, #0x10
    a00040c4:	f9400fe1 	ldr	x1, [sp, #24]
    a00040c8:	8b000020 	add	x0, x1, x0
    a00040cc:	f9400000 	ldr	x0, [x0]
    a00040d0:	52800001 	mov	w1, #0x0                   	// #0
    a00040d4:	97fffedb 	bl	a0003c40 <set_color>
		return;
    a00040d8:	1400000a 	b	a0004100 <fix_extra_red+0x1cc>
	while (stacksz > 1) {
    a00040dc:	b94017e0 	ldr	w0, [sp, #20]
    a00040e0:	7100041f 	cmp	w0, #0x1
    a00040e4:	54fff32c 	b.gt	a0003f48 <fix_extra_red+0x14>
	}

	/* If we exit the loop, it's because our node is now the root,
	 * which must be black.
	 */
	set_color(stack[0], BLACK);
    a00040e8:	f9400fe0 	ldr	x0, [sp, #24]
    a00040ec:	f9400000 	ldr	x0, [x0]
    a00040f0:	52800021 	mov	w1, #0x1                   	// #1
    a00040f4:	97fffed3 	bl	a0003c40 <set_color>
    a00040f8:	14000002 	b	a0004100 <fix_extra_red+0x1cc>
			return;
    a00040fc:	d503201f 	nop
}
    a0004100:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a0004104:	d65f03c0 	ret

00000000a0004108 <rb_insert>:

void rb_insert(struct rbtree *tree, struct rbnode *node)
{
    a0004108:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
    a000410c:	910003fd 	mov	x29, sp
    a0004110:	a90153f3 	stp	x19, x20, [sp, #16]
    a0004114:	a9025bf5 	stp	x21, x22, [sp, #32]
    a0004118:	a90363f7 	stp	x23, x24, [sp, #48]
    a000411c:	a9046bf9 	stp	x25, x26, [sp, #64]
    a0004120:	f9002bfb 	str	x27, [sp, #80]
    a0004124:	f90037a0 	str	x0, [x29, #104]
    a0004128:	f90033a1 	str	x1, [x29, #96]
    a000412c:	910003e0 	mov	x0, sp
    a0004130:	aa0003f3 	mov	x19, x0
	set_child(node, 0U, NULL);
    a0004134:	d2800002 	mov	x2, #0x0                   	// #0
    a0004138:	52800001 	mov	w1, #0x0                   	// #0
    a000413c:	f94033a0 	ldr	x0, [x29, #96]
    a0004140:	97fffe8b 	bl	a0003b6c <set_child>
	set_child(node, 1U, NULL);
    a0004144:	d2800002 	mov	x2, #0x0                   	// #0
    a0004148:	52800021 	mov	w1, #0x1                   	// #1
    a000414c:	f94033a0 	ldr	x0, [x29, #96]
    a0004150:	97fffe87 	bl	a0003b6c <set_child>

	if (tree->root == NULL) {
    a0004154:	f94037a0 	ldr	x0, [x29, #104]
    a0004158:	f9400000 	ldr	x0, [x0]
    a000415c:	f100001f 	cmp	x0, #0x0
    a0004160:	54000181 	b.ne	a0004190 <rb_insert+0x88>  // b.any
		tree->root = node;
    a0004164:	f94037a0 	ldr	x0, [x29, #104]
    a0004168:	f94033a1 	ldr	x1, [x29, #96]
    a000416c:	f9000001 	str	x1, [x0]
		tree->max_depth = 1;
    a0004170:	f94037a0 	ldr	x0, [x29, #104]
    a0004174:	52800021 	mov	w1, #0x1                   	// #1
    a0004178:	b9001001 	str	w1, [x0, #16]
		set_color(node, BLACK);
    a000417c:	52800021 	mov	w1, #0x1                   	// #1
    a0004180:	f94033a0 	ldr	x0, [x29, #96]
    a0004184:	97fffeaf 	bl	a0003c40 <set_color>
    a0004188:	9100027f 	mov	sp, x19
    a000418c:	14000052 	b	a00042d4 <rb_insert+0x1cc>
	}

#ifdef CONFIG_MISRA_SANE
	struct rbnode **stack = &tree->iter_stack[0];
#else
	struct rbnode *stack[tree->max_depth + 1];
    a0004190:	f94037a0 	ldr	x0, [x29, #104]
    a0004194:	b9401000 	ldr	w0, [x0, #16]
    a0004198:	11000400 	add	w0, w0, #0x1
    a000419c:	93407c01 	sxtw	x1, w0
    a00041a0:	d1000421 	sub	x1, x1, #0x1
    a00041a4:	f9004fa1 	str	x1, [x29, #152]
    a00041a8:	93407c01 	sxtw	x1, w0
    a00041ac:	aa0103fa 	mov	x26, x1
    a00041b0:	d280001b 	mov	x27, #0x0                   	// #0
    a00041b4:	d37aff41 	lsr	x1, x26, #58
    a00041b8:	d37ae777 	lsl	x23, x27, #6
    a00041bc:	aa170037 	orr	x23, x1, x23
    a00041c0:	d37ae756 	lsl	x22, x26, #6
    a00041c4:	93407c01 	sxtw	x1, w0
    a00041c8:	aa0103f8 	mov	x24, x1
    a00041cc:	d2800019 	mov	x25, #0x0                   	// #0
    a00041d0:	d37aff01 	lsr	x1, x24, #58
    a00041d4:	d37ae735 	lsl	x21, x25, #6
    a00041d8:	aa150035 	orr	x21, x1, x21
    a00041dc:	d37ae714 	lsl	x20, x24, #6
    a00041e0:	93407c00 	sxtw	x0, w0
    a00041e4:	d37df000 	lsl	x0, x0, #3
    a00041e8:	91003c00 	add	x0, x0, #0xf
    a00041ec:	d344fc00 	lsr	x0, x0, #4
    a00041f0:	d37cec00 	lsl	x0, x0, #4
    a00041f4:	cb2063ff 	sub	sp, sp, x0
    a00041f8:	910003e0 	mov	x0, sp
    a00041fc:	91001c00 	add	x0, x0, #0x7
    a0004200:	d343fc00 	lsr	x0, x0, #3
    a0004204:	d37df000 	lsl	x0, x0, #3
    a0004208:	f9004ba0 	str	x0, [x29, #144]
#endif

	int stacksz = find_and_stack(tree, node, stack);
    a000420c:	f9404ba2 	ldr	x2, [x29, #144]
    a0004210:	f94033a1 	ldr	x1, [x29, #96]
    a0004214:	f94037a0 	ldr	x0, [x29, #104]
    a0004218:	97fffe9b 	bl	a0003c84 <find_and_stack>
    a000421c:	b9008fa0 	str	w0, [x29, #140]

	struct rbnode *parent = stack[stacksz - 1];
    a0004220:	b9408fa0 	ldr	w0, [x29, #140]
    a0004224:	51000401 	sub	w1, w0, #0x1
    a0004228:	f9404ba0 	ldr	x0, [x29, #144]
    a000422c:	93407c21 	sxtw	x1, w1
    a0004230:	f8617800 	ldr	x0, [x0, x1, lsl #3]
    a0004234:	f90043a0 	str	x0, [x29, #128]

	uint8_t side = tree->lessthan_fn(node, parent) ? 0U : 1U;
    a0004238:	f94037a0 	ldr	x0, [x29, #104]
    a000423c:	f9400402 	ldr	x2, [x0, #8]
    a0004240:	f94043a1 	ldr	x1, [x29, #128]
    a0004244:	f94033a0 	ldr	x0, [x29, #96]
    a0004248:	d63f0040 	blr	x2
    a000424c:	12001c00 	and	w0, w0, #0xff
    a0004250:	52000000 	eor	w0, w0, #0x1
    a0004254:	12001c00 	and	w0, w0, #0xff
    a0004258:	3901ffa0 	strb	w0, [x29, #127]

	set_child(parent, side, node);
    a000425c:	f94033a2 	ldr	x2, [x29, #96]
    a0004260:	3941ffa1 	ldrb	w1, [x29, #127]
    a0004264:	f94043a0 	ldr	x0, [x29, #128]
    a0004268:	97fffe41 	bl	a0003b6c <set_child>
	set_color(node, RED);
    a000426c:	52800001 	mov	w1, #0x0                   	// #0
    a0004270:	f94033a0 	ldr	x0, [x29, #96]
    a0004274:	97fffe73 	bl	a0003c40 <set_color>

	stack[stacksz++] = node;
    a0004278:	b9408fa0 	ldr	w0, [x29, #140]
    a000427c:	11000401 	add	w1, w0, #0x1
    a0004280:	b9008fa1 	str	w1, [x29, #140]
    a0004284:	f9404ba1 	ldr	x1, [x29, #144]
    a0004288:	93407c00 	sxtw	x0, w0
    a000428c:	f94033a2 	ldr	x2, [x29, #96]
    a0004290:	f8207822 	str	x2, [x1, x0, lsl #3]
	fix_extra_red(stack, stacksz);
    a0004294:	b9408fa1 	ldr	w1, [x29, #140]
    a0004298:	f9404ba0 	ldr	x0, [x29, #144]
    a000429c:	97ffff26 	bl	a0003f34 <fix_extra_red>

	if (stacksz > tree->max_depth) {
    a00042a0:	f94037a0 	ldr	x0, [x29, #104]
    a00042a4:	b9401000 	ldr	w0, [x0, #16]
    a00042a8:	b9408fa1 	ldr	w1, [x29, #140]
    a00042ac:	6b00003f 	cmp	w1, w0
    a00042b0:	5400008d 	b.le	a00042c0 <rb_insert+0x1b8>
		tree->max_depth = stacksz;
    a00042b4:	f94037a0 	ldr	x0, [x29, #104]
    a00042b8:	b9408fa1 	ldr	w1, [x29, #140]
    a00042bc:	b9001001 	str	w1, [x0, #16]
	}

	/* We may have rotated up into the root! */
	tree->root = stack[0];
    a00042c0:	f9404ba0 	ldr	x0, [x29, #144]
    a00042c4:	f9400001 	ldr	x1, [x0]
    a00042c8:	f94037a0 	ldr	x0, [x29, #104]
    a00042cc:	f9000001 	str	x1, [x0]
    a00042d0:	9100027f 	mov	sp, x19
	CHECK(is_black(tree->root));
}
    a00042d4:	910003bf 	mov	sp, x29
    a00042d8:	a94153f3 	ldp	x19, x20, [sp, #16]
    a00042dc:	a9425bf5 	ldp	x21, x22, [sp, #32]
    a00042e0:	a94363f7 	ldp	x23, x24, [sp, #48]
    a00042e4:	a9446bf9 	ldp	x25, x26, [sp, #64]
    a00042e8:	f9402bfb 	ldr	x27, [sp, #80]
    a00042ec:	a8ca7bfd 	ldp	x29, x30, [sp], #160
    a00042f0:	d65f03c0 	ret

00000000a00042f4 <fix_missing_black>:
 * then clean it up (replace it with a simple NULL child in the
 * parent) when finished.
 */
static void fix_missing_black(struct rbnode **stack, int stacksz,
			      struct rbnode *null_node)
{
    a00042f4:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    a00042f8:	910003fd 	mov	x29, sp
    a00042fc:	f90017e0 	str	x0, [sp, #40]
    a0004300:	b90027e1 	str	w1, [sp, #36]
    a0004304:	f9000fe2 	str	x2, [sp, #24]
	/* Loop upward until we reach the root */
	while (stacksz > 1) {
    a0004308:	140000e8 	b	a00046a8 <fix_missing_black+0x3b4>
		struct rbnode *c0, *c1, *inner, *outer;
		struct rbnode *n = stack[stacksz - 1];
    a000430c:	b98027e0 	ldrsw	x0, [sp, #36]
    a0004310:	d37df000 	lsl	x0, x0, #3
    a0004314:	d1002000 	sub	x0, x0, #0x8
    a0004318:	f94017e1 	ldr	x1, [sp, #40]
    a000431c:	8b000020 	add	x0, x1, x0
    a0004320:	f9400000 	ldr	x0, [x0]
    a0004324:	f9002be0 	str	x0, [sp, #80]
		struct rbnode *parent = stack[stacksz - 2];
    a0004328:	b98027e0 	ldrsw	x0, [sp, #36]
    a000432c:	d37df000 	lsl	x0, x0, #3
    a0004330:	d1004000 	sub	x0, x0, #0x10
    a0004334:	f94017e1 	ldr	x1, [sp, #40]
    a0004338:	8b000020 	add	x0, x1, x0
    a000433c:	f9400000 	ldr	x0, [x0]
    a0004340:	f90033e0 	str	x0, [sp, #96]
		uint8_t n_side = get_side(parent, n);
    a0004344:	f9402be1 	ldr	x1, [sp, #80]
    a0004348:	f94033e0 	ldr	x0, [sp, #96]
    a000434c:	97fffe91 	bl	a0003d90 <get_side>
    a0004350:	39013fe0 	strb	w0, [sp, #79]
		struct rbnode *sib = get_child(parent,
    a0004354:	39413fe0 	ldrb	w0, [sp, #79]
    a0004358:	7100001f 	cmp	w0, #0x0
    a000435c:	54000061 	b.ne	a0004368 <fix_missing_black+0x74>  // b.any
    a0004360:	52800020 	mov	w0, #0x1                   	// #1
    a0004364:	14000002 	b	a000436c <fix_missing_black+0x78>
    a0004368:	52800000 	mov	w0, #0x0                   	// #0
    a000436c:	2a0003e1 	mov	w1, w0
    a0004370:	f94033e0 	ldr	x0, [sp, #96]
    a0004374:	97fffdec 	bl	a0003b24 <get_child>
    a0004378:	f9002fe0 	str	x0, [sp, #88]
		/* Guarantee the sibling is black, rotating N down a
		 * level if needed (after rotate() our parent is the
		 * child of our previous-sibling, so N is lower in the
		 * tree)
		 */
		if (!is_black(sib)) {
    a000437c:	f9402fe0 	ldr	x0, [sp, #88]
    a0004380:	97fffe1c 	bl	a0003bf0 <is_black>
    a0004384:	12001c00 	and	w0, w0, #0xff
    a0004388:	52000000 	eor	w0, w0, #0x1
    a000438c:	12001c00 	and	w0, w0, #0xff
    a0004390:	7100001f 	cmp	w0, #0x0
    a0004394:	54000560 	b.eq	a0004440 <fix_missing_black+0x14c>  // b.none
			stack[stacksz - 1] = sib;
    a0004398:	b98027e0 	ldrsw	x0, [sp, #36]
    a000439c:	d37df000 	lsl	x0, x0, #3
    a00043a0:	d1002000 	sub	x0, x0, #0x8
    a00043a4:	f94017e1 	ldr	x1, [sp, #40]
    a00043a8:	8b000020 	add	x0, x1, x0
    a00043ac:	f9402fe1 	ldr	x1, [sp, #88]
    a00043b0:	f9000001 	str	x1, [x0]
			rotate(stack, stacksz);
    a00043b4:	b94027e1 	ldr	w1, [sp, #36]
    a00043b8:	f94017e0 	ldr	x0, [sp, #40]
    a00043bc:	97fffe85 	bl	a0003dd0 <rotate>
			set_color(parent, RED);
    a00043c0:	52800001 	mov	w1, #0x0                   	// #0
    a00043c4:	f94033e0 	ldr	x0, [sp, #96]
    a00043c8:	97fffe1e 	bl	a0003c40 <set_color>
			set_color(sib, BLACK);
    a00043cc:	52800021 	mov	w1, #0x1                   	// #1
    a00043d0:	f9402fe0 	ldr	x0, [sp, #88]
    a00043d4:	97fffe1b 	bl	a0003c40 <set_color>
			stack[stacksz++] = n;
    a00043d8:	b94027e0 	ldr	w0, [sp, #36]
    a00043dc:	11000401 	add	w1, w0, #0x1
    a00043e0:	b90027e1 	str	w1, [sp, #36]
    a00043e4:	93407c00 	sxtw	x0, w0
    a00043e8:	d37df000 	lsl	x0, x0, #3
    a00043ec:	f94017e1 	ldr	x1, [sp, #40]
    a00043f0:	8b000020 	add	x0, x1, x0
    a00043f4:	f9402be1 	ldr	x1, [sp, #80]
    a00043f8:	f9000001 	str	x1, [x0]

			parent = stack[stacksz - 2];
    a00043fc:	b98027e0 	ldrsw	x0, [sp, #36]
    a0004400:	d37df000 	lsl	x0, x0, #3
    a0004404:	d1004000 	sub	x0, x0, #0x10
    a0004408:	f94017e1 	ldr	x1, [sp, #40]
    a000440c:	8b000020 	add	x0, x1, x0
    a0004410:	f9400000 	ldr	x0, [x0]
    a0004414:	f90033e0 	str	x0, [sp, #96]
			sib = get_child(parent, (n_side == 0U) ? 1U : 0U);
    a0004418:	39413fe0 	ldrb	w0, [sp, #79]
    a000441c:	7100001f 	cmp	w0, #0x0
    a0004420:	54000061 	b.ne	a000442c <fix_missing_black+0x138>  // b.any
    a0004424:	52800020 	mov	w0, #0x1                   	// #1
    a0004428:	14000002 	b	a0004430 <fix_missing_black+0x13c>
    a000442c:	52800000 	mov	w0, #0x0                   	// #0
    a0004430:	2a0003e1 	mov	w1, w0
    a0004434:	f94033e0 	ldr	x0, [sp, #96]
    a0004438:	97fffdbb 	bl	a0003b24 <get_child>
    a000443c:	f9002fe0 	str	x0, [sp, #88]
		CHECK(sib);

		/* Cases where the sibling has only black children
		 * have simple resolutions
		 */
		c0 = get_child(sib, 0U);
    a0004440:	52800001 	mov	w1, #0x0                   	// #0
    a0004444:	f9402fe0 	ldr	x0, [sp, #88]
    a0004448:	97fffdb7 	bl	a0003b24 <get_child>
    a000444c:	f90023e0 	str	x0, [sp, #64]
		c1 = get_child(sib, 1U);
    a0004450:	52800021 	mov	w1, #0x1                   	// #1
    a0004454:	f9402fe0 	ldr	x0, [sp, #88]
    a0004458:	97fffdb3 	bl	a0003b24 <get_child>
    a000445c:	f9001fe0 	str	x0, [sp, #56]
		if (((c0 == NULL) || is_black(c0)) && ((c1 == NULL) ||
    a0004460:	f94023e0 	ldr	x0, [sp, #64]
    a0004464:	f100001f 	cmp	x0, #0x0
    a0004468:	540000c0 	b.eq	a0004480 <fix_missing_black+0x18c>  // b.none
    a000446c:	f94023e0 	ldr	x0, [sp, #64]
    a0004470:	97fffde0 	bl	a0003bf0 <is_black>
    a0004474:	12001c00 	and	w0, w0, #0xff
    a0004478:	7100001f 	cmp	w0, #0x0
    a000447c:	54000420 	b.eq	a0004500 <fix_missing_black+0x20c>  // b.none
    a0004480:	f9401fe0 	ldr	x0, [sp, #56]
    a0004484:	f100001f 	cmp	x0, #0x0
    a0004488:	540000c0 	b.eq	a00044a0 <fix_missing_black+0x1ac>  // b.none
					is_black(c1))) {
    a000448c:	f9401fe0 	ldr	x0, [sp, #56]
    a0004490:	97fffdd8 	bl	a0003bf0 <is_black>
    a0004494:	12001c00 	and	w0, w0, #0xff
		if (((c0 == NULL) || is_black(c0)) && ((c1 == NULL) ||
    a0004498:	7100001f 	cmp	w0, #0x0
    a000449c:	54000320 	b.eq	a0004500 <fix_missing_black+0x20c>  // b.none
			if (n == null_node) {
    a00044a0:	f9402be1 	ldr	x1, [sp, #80]
    a00044a4:	f9400fe0 	ldr	x0, [sp, #24]
    a00044a8:	eb00003f 	cmp	x1, x0
    a00044ac:	540000a1 	b.ne	a00044c0 <fix_missing_black+0x1cc>  // b.any
				set_child(parent, n_side, NULL);
    a00044b0:	d2800002 	mov	x2, #0x0                   	// #0
    a00044b4:	39413fe1 	ldrb	w1, [sp, #79]
    a00044b8:	f94033e0 	ldr	x0, [sp, #96]
    a00044bc:	97fffdac 	bl	a0003b6c <set_child>
			}

			set_color(sib, RED);
    a00044c0:	52800001 	mov	w1, #0x0                   	// #0
    a00044c4:	f9402fe0 	ldr	x0, [sp, #88]
    a00044c8:	97fffdde 	bl	a0003c40 <set_color>
			if (is_black(parent)) {
    a00044cc:	f94033e0 	ldr	x0, [sp, #96]
    a00044d0:	97fffdc8 	bl	a0003bf0 <is_black>
    a00044d4:	12001c00 	and	w0, w0, #0xff
    a00044d8:	7100001f 	cmp	w0, #0x0
    a00044dc:	540000a0 	b.eq	a00044f0 <fix_missing_black+0x1fc>  // b.none
				/* Balance the sibling's subtree by
				 * coloring it red, then our parent
				 * has a missing black so iterate
				 * upward
				 */
				stacksz--;
    a00044e0:	b94027e0 	ldr	w0, [sp, #36]
    a00044e4:	51000400 	sub	w0, w0, #0x1
    a00044e8:	b90027e0 	str	w0, [sp, #36]
				continue;
    a00044ec:	1400006f 	b	a00046a8 <fix_missing_black+0x3b4>
			} else {
				/* Recoloring makes the whole tree OK */
				set_color(parent, BLACK);
    a00044f0:	52800021 	mov	w1, #0x1                   	// #1
    a00044f4:	f94033e0 	ldr	x0, [sp, #96]
    a00044f8:	97fffdd2 	bl	a0003c40 <set_color>
				return;
    a00044fc:	14000070 	b	a00046bc <fix_missing_black+0x3c8>

		/* We know sibling has at least one red child.  Fix it
		 * so that the far/outer position (i.e. on the
		 * opposite side from N) is definitely red.
		 */
		outer = get_child(sib, (n_side == 0U) ? 1U : 0U);
    a0004500:	39413fe0 	ldrb	w0, [sp, #79]
    a0004504:	7100001f 	cmp	w0, #0x0
    a0004508:	54000061 	b.ne	a0004514 <fix_missing_black+0x220>  // b.any
    a000450c:	52800020 	mov	w0, #0x1                   	// #1
    a0004510:	14000002 	b	a0004518 <fix_missing_black+0x224>
    a0004514:	52800000 	mov	w0, #0x0                   	// #0
    a0004518:	2a0003e1 	mov	w1, w0
    a000451c:	f9402fe0 	ldr	x0, [sp, #88]
    a0004520:	97fffd81 	bl	a0003b24 <get_child>
    a0004524:	f90037e0 	str	x0, [sp, #104]
		if (!((outer != NULL) && is_red(outer))) {
    a0004528:	f94037e0 	ldr	x0, [sp, #104]
    a000452c:	f100001f 	cmp	x0, #0x0
    a0004530:	54000100 	b.eq	a0004550 <fix_missing_black+0x25c>  // b.none
    a0004534:	f94037e0 	ldr	x0, [sp, #104]
    a0004538:	97fffdb8 	bl	a0003c18 <is_red>
    a000453c:	12001c00 	and	w0, w0, #0xff
    a0004540:	52000000 	eor	w0, w0, #0x1
    a0004544:	12001c00 	and	w0, w0, #0xff
    a0004548:	7100001f 	cmp	w0, #0x0
    a000454c:	54000720 	b.eq	a0004630 <fix_missing_black+0x33c>  // b.none
			inner = get_child(sib, n_side);
    a0004550:	39413fe1 	ldrb	w1, [sp, #79]
    a0004554:	f9402fe0 	ldr	x0, [sp, #88]
    a0004558:	97fffd73 	bl	a0003b24 <get_child>
    a000455c:	f9001be0 	str	x0, [sp, #48]

			stack[stacksz - 1] = sib;
    a0004560:	b98027e0 	ldrsw	x0, [sp, #36]
    a0004564:	d37df000 	lsl	x0, x0, #3
    a0004568:	d1002000 	sub	x0, x0, #0x8
    a000456c:	f94017e1 	ldr	x1, [sp, #40]
    a0004570:	8b000020 	add	x0, x1, x0
    a0004574:	f9402fe1 	ldr	x1, [sp, #88]
    a0004578:	f9000001 	str	x1, [x0]
			stack[stacksz++] = inner;
    a000457c:	b94027e0 	ldr	w0, [sp, #36]
    a0004580:	11000401 	add	w1, w0, #0x1
    a0004584:	b90027e1 	str	w1, [sp, #36]
    a0004588:	93407c00 	sxtw	x0, w0
    a000458c:	d37df000 	lsl	x0, x0, #3
    a0004590:	f94017e1 	ldr	x1, [sp, #40]
    a0004594:	8b000020 	add	x0, x1, x0
    a0004598:	f9401be1 	ldr	x1, [sp, #48]
    a000459c:	f9000001 	str	x1, [x0]
			rotate(stack, stacksz);
    a00045a0:	b94027e1 	ldr	w1, [sp, #36]
    a00045a4:	f94017e0 	ldr	x0, [sp, #40]
    a00045a8:	97fffe0a 	bl	a0003dd0 <rotate>
			set_color(sib, RED);
    a00045ac:	52800001 	mov	w1, #0x0                   	// #0
    a00045b0:	f9402fe0 	ldr	x0, [sp, #88]
    a00045b4:	97fffda3 	bl	a0003c40 <set_color>
			set_color(inner, BLACK);
    a00045b8:	52800021 	mov	w1, #0x1                   	// #1
    a00045bc:	f9401be0 	ldr	x0, [sp, #48]
    a00045c0:	97fffda0 	bl	a0003c40 <set_color>

			/* Restore stack state to have N on the top
			 * and make sib reflect the new sibling
			 */
			sib = stack[stacksz - 2];
    a00045c4:	b98027e0 	ldrsw	x0, [sp, #36]
    a00045c8:	d37df000 	lsl	x0, x0, #3
    a00045cc:	d1004000 	sub	x0, x0, #0x10
    a00045d0:	f94017e1 	ldr	x1, [sp, #40]
    a00045d4:	8b000020 	add	x0, x1, x0
    a00045d8:	f9400000 	ldr	x0, [x0]
    a00045dc:	f9002fe0 	str	x0, [sp, #88]
			outer = get_child(sib, (n_side == 0U) ? 1U : 0U);
    a00045e0:	39413fe0 	ldrb	w0, [sp, #79]
    a00045e4:	7100001f 	cmp	w0, #0x0
    a00045e8:	54000061 	b.ne	a00045f4 <fix_missing_black+0x300>  // b.any
    a00045ec:	52800020 	mov	w0, #0x1                   	// #1
    a00045f0:	14000002 	b	a00045f8 <fix_missing_black+0x304>
    a00045f4:	52800000 	mov	w0, #0x0                   	// #0
    a00045f8:	2a0003e1 	mov	w1, w0
    a00045fc:	f9402fe0 	ldr	x0, [sp, #88]
    a0004600:	97fffd49 	bl	a0003b24 <get_child>
    a0004604:	f90037e0 	str	x0, [sp, #104]
			stack[stacksz - 2] = n;
    a0004608:	b98027e0 	ldrsw	x0, [sp, #36]
    a000460c:	d37df000 	lsl	x0, x0, #3
    a0004610:	d1004000 	sub	x0, x0, #0x10
    a0004614:	f94017e1 	ldr	x1, [sp, #40]
    a0004618:	8b000020 	add	x0, x1, x0
    a000461c:	f9402be1 	ldr	x1, [sp, #80]
    a0004620:	f9000001 	str	x1, [x0]
			stacksz--;
    a0004624:	b94027e0 	ldr	w0, [sp, #36]
    a0004628:	51000400 	sub	w0, w0, #0x1
    a000462c:	b90027e0 	str	w0, [sp, #36]
		/* Finally, the sibling must have a red child in the
		 * far/outer slot.  We can rotate sib with our parent
		 * and recolor to produce a valid tree.
		 */
		CHECK(is_red(outer));
		set_color(sib, get_color(parent));
    a0004630:	f94033e0 	ldr	x0, [sp, #96]
    a0004634:	97fffd68 	bl	a0003bd4 <get_color>
    a0004638:	2a0003e1 	mov	w1, w0
    a000463c:	f9402fe0 	ldr	x0, [sp, #88]
    a0004640:	97fffd80 	bl	a0003c40 <set_color>
		set_color(parent, BLACK);
    a0004644:	52800021 	mov	w1, #0x1                   	// #1
    a0004648:	f94033e0 	ldr	x0, [sp, #96]
    a000464c:	97fffd7d 	bl	a0003c40 <set_color>
		set_color(outer, BLACK);
    a0004650:	52800021 	mov	w1, #0x1                   	// #1
    a0004654:	f94037e0 	ldr	x0, [sp, #104]
    a0004658:	97fffd7a 	bl	a0003c40 <set_color>
		stack[stacksz - 1] = sib;
    a000465c:	b98027e0 	ldrsw	x0, [sp, #36]
    a0004660:	d37df000 	lsl	x0, x0, #3
    a0004664:	d1002000 	sub	x0, x0, #0x8
    a0004668:	f94017e1 	ldr	x1, [sp, #40]
    a000466c:	8b000020 	add	x0, x1, x0
    a0004670:	f9402fe1 	ldr	x1, [sp, #88]
    a0004674:	f9000001 	str	x1, [x0]
		rotate(stack, stacksz);
    a0004678:	b94027e1 	ldr	w1, [sp, #36]
    a000467c:	f94017e0 	ldr	x0, [sp, #40]
    a0004680:	97fffdd4 	bl	a0003dd0 <rotate>
		if (n == null_node) {
    a0004684:	f9402be1 	ldr	x1, [sp, #80]
    a0004688:	f9400fe0 	ldr	x0, [sp, #24]
    a000468c:	eb00003f 	cmp	x1, x0
    a0004690:	54000141 	b.ne	a00046b8 <fix_missing_black+0x3c4>  // b.any
			set_child(parent, n_side, NULL);
    a0004694:	d2800002 	mov	x2, #0x0                   	// #0
    a0004698:	39413fe1 	ldrb	w1, [sp, #79]
    a000469c:	f94033e0 	ldr	x0, [sp, #96]
    a00046a0:	97fffd33 	bl	a0003b6c <set_child>
		}
		return;
    a00046a4:	14000005 	b	a00046b8 <fix_missing_black+0x3c4>
	while (stacksz > 1) {
    a00046a8:	b94027e0 	ldr	w0, [sp, #36]
    a00046ac:	7100041f 	cmp	w0, #0x1
    a00046b0:	54ffe2ec 	b.gt	a000430c <fix_missing_black+0x18>
    a00046b4:	14000002 	b	a00046bc <fix_missing_black+0x3c8>
		return;
    a00046b8:	d503201f 	nop
	}
}
    a00046bc:	a8c77bfd 	ldp	x29, x30, [sp], #112
    a00046c0:	d65f03c0 	ret

00000000a00046c4 <rb_remove>:

void rb_remove(struct rbtree *tree, struct rbnode *node)
{
    a00046c4:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
    a00046c8:	910003fd 	mov	x29, sp
    a00046cc:	f9000bf3 	str	x19, [sp, #16]
    a00046d0:	f90017a0 	str	x0, [x29, #40]
    a00046d4:	f90013a1 	str	x1, [x29, #32]
    a00046d8:	910003e0 	mov	x0, sp
    a00046dc:	aa0003f3 	mov	x19, x0
	struct rbnode *tmp;
#ifdef CONFIG_MISRA_SANE
	struct rbnode **stack = &tree->iter_stack[0];
#else
	struct rbnode *stack[tree->max_depth + 1];
    a00046e0:	f94017a0 	ldr	x0, [x29, #40]
    a00046e4:	b9401000 	ldr	w0, [x0, #16]
    a00046e8:	11000400 	add	w0, w0, #0x1
    a00046ec:	93407c01 	sxtw	x1, w0
    a00046f0:	d1000421 	sub	x1, x1, #0x1
    a00046f4:	f9003ba1 	str	x1, [x29, #112]
    a00046f8:	93407c01 	sxtw	x1, w0
    a00046fc:	aa0103e8 	mov	x8, x1
    a0004700:	d2800009 	mov	x9, #0x0                   	// #0
    a0004704:	d37afd01 	lsr	x1, x8, #58
    a0004708:	d37ae525 	lsl	x5, x9, #6
    a000470c:	aa050025 	orr	x5, x1, x5
    a0004710:	d37ae504 	lsl	x4, x8, #6
    a0004714:	93407c01 	sxtw	x1, w0
    a0004718:	aa0103e6 	mov	x6, x1
    a000471c:	d2800007 	mov	x7, #0x0                   	// #0
    a0004720:	d37afcc1 	lsr	x1, x6, #58
    a0004724:	d37ae4e3 	lsl	x3, x7, #6
    a0004728:	aa030023 	orr	x3, x1, x3
    a000472c:	d37ae4c2 	lsl	x2, x6, #6
    a0004730:	93407c00 	sxtw	x0, w0
    a0004734:	d37df000 	lsl	x0, x0, #3
    a0004738:	91003c00 	add	x0, x0, #0xf
    a000473c:	d344fc00 	lsr	x0, x0, #4
    a0004740:	d37cec00 	lsl	x0, x0, #4
    a0004744:	cb2063ff 	sub	sp, sp, x0
    a0004748:	910003e0 	mov	x0, sp
    a000474c:	91001c00 	add	x0, x0, #0x7
    a0004750:	d343fc00 	lsr	x0, x0, #3
    a0004754:	d37df000 	lsl	x0, x0, #3
    a0004758:	f90037a0 	str	x0, [x29, #104]
#endif

	int stacksz = find_and_stack(tree, node, stack);
    a000475c:	f94037a2 	ldr	x2, [x29, #104]
    a0004760:	f94013a1 	ldr	x1, [x29, #32]
    a0004764:	f94017a0 	ldr	x0, [x29, #40]
    a0004768:	97fffd47 	bl	a0003c84 <find_and_stack>
    a000476c:	b9007fa0 	str	w0, [x29, #124]

	if (node != stack[stacksz - 1]) {
    a0004770:	b9407fa0 	ldr	w0, [x29, #124]
    a0004774:	51000401 	sub	w1, w0, #0x1
    a0004778:	f94037a0 	ldr	x0, [x29, #104]
    a000477c:	93407c21 	sxtw	x1, w1
    a0004780:	f8617800 	ldr	x0, [x0, x1, lsl #3]
    a0004784:	f94013a1 	ldr	x1, [x29, #32]
    a0004788:	eb00003f 	cmp	x1, x0
    a000478c:	54001dc1 	b.ne	a0004b44 <rb_remove+0x480>  // b.any
	/* We can only remove a node with zero or one child, if we
	 * have two then pick the "biggest" child of side 0 (smallest
	 * of 1 would work too) and swap our spot in the tree with
	 * that one
	 */
	if ((get_child(node, 0U) != NULL) && (get_child(node, 1U) != NULL)) {
    a0004790:	52800001 	mov	w1, #0x0                   	// #0
    a0004794:	f94013a0 	ldr	x0, [x29, #32]
    a0004798:	97fffce3 	bl	a0003b24 <get_child>
    a000479c:	f100001f 	cmp	x0, #0x0
    a00047a0:	540012e0 	b.eq	a00049fc <rb_remove+0x338>  // b.none
    a00047a4:	52800021 	mov	w1, #0x1                   	// #1
    a00047a8:	f94013a0 	ldr	x0, [x29, #32]
    a00047ac:	97fffcde 	bl	a0003b24 <get_child>
    a00047b0:	f100001f 	cmp	x0, #0x0
    a00047b4:	54001240 	b.eq	a00049fc <rb_remove+0x338>  // b.none
		int stacksz0 = stacksz;
    a00047b8:	b9407fa0 	ldr	w0, [x29, #124]
    a00047bc:	b90067a0 	str	w0, [x29, #100]
		struct rbnode *hiparent, *loparent;
		struct rbnode *node2 = get_child(node, 0U);
    a00047c0:	52800001 	mov	w1, #0x0                   	// #0
    a00047c4:	f94013a0 	ldr	x0, [x29, #32]
    a00047c8:	97fffcd7 	bl	a0003b24 <get_child>
    a00047cc:	f90043a0 	str	x0, [x29, #128]

		hiparent = (stacksz > 1) ? stack[stacksz - 2] : NULL;
    a00047d0:	b9407fa0 	ldr	w0, [x29, #124]
    a00047d4:	7100041f 	cmp	w0, #0x1
    a00047d8:	540000ed 	b.le	a00047f4 <rb_remove+0x130>
    a00047dc:	b9407fa0 	ldr	w0, [x29, #124]
    a00047e0:	51000801 	sub	w1, w0, #0x2
    a00047e4:	f94037a0 	ldr	x0, [x29, #104]
    a00047e8:	93407c21 	sxtw	x1, w1
    a00047ec:	f8617800 	ldr	x0, [x0, x1, lsl #3]
    a00047f0:	14000002 	b	a00047f8 <rb_remove+0x134>
    a00047f4:	d2800000 	mov	x0, #0x0                   	// #0
    a00047f8:	f9002fa0 	str	x0, [x29, #88]
		stack[stacksz++] = node2;
    a00047fc:	b9407fa0 	ldr	w0, [x29, #124]
    a0004800:	11000401 	add	w1, w0, #0x1
    a0004804:	b9007fa1 	str	w1, [x29, #124]
    a0004808:	f94037a1 	ldr	x1, [x29, #104]
    a000480c:	93407c00 	sxtw	x0, w0
    a0004810:	f94043a2 	ldr	x2, [x29, #128]
    a0004814:	f8207822 	str	x2, [x1, x0, lsl #3]
		while (get_child(node2, 1U) != NULL) {
    a0004818:	1400000c 	b	a0004848 <rb_remove+0x184>
			node2 = get_child(node2, 1U);
    a000481c:	52800021 	mov	w1, #0x1                   	// #1
    a0004820:	f94043a0 	ldr	x0, [x29, #128]
    a0004824:	97fffcc0 	bl	a0003b24 <get_child>
    a0004828:	f90043a0 	str	x0, [x29, #128]
			stack[stacksz++] = node2;
    a000482c:	b9407fa0 	ldr	w0, [x29, #124]
    a0004830:	11000401 	add	w1, w0, #0x1
    a0004834:	b9007fa1 	str	w1, [x29, #124]
    a0004838:	f94037a1 	ldr	x1, [x29, #104]
    a000483c:	93407c00 	sxtw	x0, w0
    a0004840:	f94043a2 	ldr	x2, [x29, #128]
    a0004844:	f8207822 	str	x2, [x1, x0, lsl #3]
		while (get_child(node2, 1U) != NULL) {
    a0004848:	52800021 	mov	w1, #0x1                   	// #1
    a000484c:	f94043a0 	ldr	x0, [x29, #128]
    a0004850:	97fffcb5 	bl	a0003b24 <get_child>
    a0004854:	f100001f 	cmp	x0, #0x0
    a0004858:	54fffe21 	b.ne	a000481c <rb_remove+0x158>  // b.any
		}

		loparent = stack[stacksz - 2];
    a000485c:	b9407fa0 	ldr	w0, [x29, #124]
    a0004860:	51000801 	sub	w1, w0, #0x2
    a0004864:	f94037a0 	ldr	x0, [x29, #104]
    a0004868:	93407c21 	sxtw	x1, w1
    a000486c:	f8617800 	ldr	x0, [x0, x1, lsl #3]
    a0004870:	f9002ba0 	str	x0, [x29, #80]
		 * upper node.  Remember to swap the color bits of the
		 * two nodes also.  And of course we don't have parent
		 * pointers, so the stack tracking this structure
		 * needs to be swapped too!
		 */
		if (hiparent != NULL) {
    a0004874:	f9402fa0 	ldr	x0, [x29, #88]
    a0004878:	f100001f 	cmp	x0, #0x0
    a000487c:	54000140 	b.eq	a00048a4 <rb_remove+0x1e0>  // b.none
			set_child(hiparent, get_side(hiparent, node), node2);
    a0004880:	f94013a1 	ldr	x1, [x29, #32]
    a0004884:	f9402fa0 	ldr	x0, [x29, #88]
    a0004888:	97fffd42 	bl	a0003d90 <get_side>
    a000488c:	12001c00 	and	w0, w0, #0xff
    a0004890:	f94043a2 	ldr	x2, [x29, #128]
    a0004894:	2a0003e1 	mov	w1, w0
    a0004898:	f9402fa0 	ldr	x0, [x29, #88]
    a000489c:	97fffcb4 	bl	a0003b6c <set_child>
    a00048a0:	14000004 	b	a00048b0 <rb_remove+0x1ec>
		} else {
			tree->root = node2;
    a00048a4:	f94017a0 	ldr	x0, [x29, #40]
    a00048a8:	f94043a1 	ldr	x1, [x29, #128]
    a00048ac:	f9000001 	str	x1, [x0]
		}

		if (loparent == node) {
    a00048b0:	f9402ba1 	ldr	x1, [x29, #80]
    a00048b4:	f94013a0 	ldr	x0, [x29, #32]
    a00048b8:	eb00003f 	cmp	x1, x0
    a00048bc:	540001a1 	b.ne	a00048f0 <rb_remove+0x22c>  // b.any
			set_child(node, 0U, get_child(node2, 0U));
    a00048c0:	52800001 	mov	w1, #0x0                   	// #0
    a00048c4:	f94043a0 	ldr	x0, [x29, #128]
    a00048c8:	97fffc97 	bl	a0003b24 <get_child>
    a00048cc:	aa0003e2 	mov	x2, x0
    a00048d0:	52800001 	mov	w1, #0x0                   	// #0
    a00048d4:	f94013a0 	ldr	x0, [x29, #32]
    a00048d8:	97fffca5 	bl	a0003b6c <set_child>
			set_child(node2, 0U, node);
    a00048dc:	f94013a2 	ldr	x2, [x29, #32]
    a00048e0:	52800001 	mov	w1, #0x0                   	// #0
    a00048e4:	f94043a0 	ldr	x0, [x29, #128]
    a00048e8:	97fffca1 	bl	a0003b6c <set_child>
    a00048ec:	14000018 	b	a000494c <rb_remove+0x288>
		} else {
			set_child(loparent, get_side(loparent, node2), node);
    a00048f0:	f94043a1 	ldr	x1, [x29, #128]
    a00048f4:	f9402ba0 	ldr	x0, [x29, #80]
    a00048f8:	97fffd26 	bl	a0003d90 <get_side>
    a00048fc:	12001c00 	and	w0, w0, #0xff
    a0004900:	f94013a2 	ldr	x2, [x29, #32]
    a0004904:	2a0003e1 	mov	w1, w0
    a0004908:	f9402ba0 	ldr	x0, [x29, #80]
    a000490c:	97fffc98 	bl	a0003b6c <set_child>
			tmp = get_child(node, 0U);
    a0004910:	52800001 	mov	w1, #0x0                   	// #0
    a0004914:	f94013a0 	ldr	x0, [x29, #32]
    a0004918:	97fffc83 	bl	a0003b24 <get_child>
    a000491c:	f90027a0 	str	x0, [x29, #72]
			set_child(node, 0U, get_child(node2, 0U));
    a0004920:	52800001 	mov	w1, #0x0                   	// #0
    a0004924:	f94043a0 	ldr	x0, [x29, #128]
    a0004928:	97fffc7f 	bl	a0003b24 <get_child>
    a000492c:	aa0003e2 	mov	x2, x0
    a0004930:	52800001 	mov	w1, #0x0                   	// #0
    a0004934:	f94013a0 	ldr	x0, [x29, #32]
    a0004938:	97fffc8d 	bl	a0003b6c <set_child>
			set_child(node2, 0U, tmp);
    a000493c:	f94027a2 	ldr	x2, [x29, #72]
    a0004940:	52800001 	mov	w1, #0x0                   	// #0
    a0004944:	f94043a0 	ldr	x0, [x29, #128]
    a0004948:	97fffc89 	bl	a0003b6c <set_child>
		}

		set_child(node2, 1U, get_child(node, 1U));
    a000494c:	52800021 	mov	w1, #0x1                   	// #1
    a0004950:	f94013a0 	ldr	x0, [x29, #32]
    a0004954:	97fffc74 	bl	a0003b24 <get_child>
    a0004958:	aa0003e2 	mov	x2, x0
    a000495c:	52800021 	mov	w1, #0x1                   	// #1
    a0004960:	f94043a0 	ldr	x0, [x29, #128]
    a0004964:	97fffc82 	bl	a0003b6c <set_child>
		set_child(node, 1U, NULL);
    a0004968:	d2800002 	mov	x2, #0x0                   	// #0
    a000496c:	52800021 	mov	w1, #0x1                   	// #1
    a0004970:	f94013a0 	ldr	x0, [x29, #32]
    a0004974:	97fffc7e 	bl	a0003b6c <set_child>

		tmp = stack[stacksz0 - 1];
    a0004978:	b94067a0 	ldr	w0, [x29, #100]
    a000497c:	51000401 	sub	w1, w0, #0x1
    a0004980:	f94037a0 	ldr	x0, [x29, #104]
    a0004984:	93407c21 	sxtw	x1, w1
    a0004988:	f8617800 	ldr	x0, [x0, x1, lsl #3]
    a000498c:	f90027a0 	str	x0, [x29, #72]
		stack[stacksz0 - 1] = stack[stacksz - 1];
    a0004990:	b9407fa0 	ldr	w0, [x29, #124]
    a0004994:	51000401 	sub	w1, w0, #0x1
    a0004998:	b94067a0 	ldr	w0, [x29, #100]
    a000499c:	51000403 	sub	w3, w0, #0x1
    a00049a0:	f94037a0 	ldr	x0, [x29, #104]
    a00049a4:	93407c21 	sxtw	x1, w1
    a00049a8:	f8617802 	ldr	x2, [x0, x1, lsl #3]
    a00049ac:	f94037a0 	ldr	x0, [x29, #104]
    a00049b0:	93407c61 	sxtw	x1, w3
    a00049b4:	f8217802 	str	x2, [x0, x1, lsl #3]
		stack[stacksz - 1] = tmp;
    a00049b8:	b9407fa0 	ldr	w0, [x29, #124]
    a00049bc:	51000401 	sub	w1, w0, #0x1
    a00049c0:	f94037a0 	ldr	x0, [x29, #104]
    a00049c4:	93407c21 	sxtw	x1, w1
    a00049c8:	f94027a2 	ldr	x2, [x29, #72]
    a00049cc:	f8217802 	str	x2, [x0, x1, lsl #3]

		enum rb_color ctmp = get_color(node);
    a00049d0:	f94013a0 	ldr	x0, [x29, #32]
    a00049d4:	97fffc80 	bl	a0003bd4 <get_color>
    a00049d8:	b90047a0 	str	w0, [x29, #68]

		set_color(node, get_color(node2));
    a00049dc:	f94043a0 	ldr	x0, [x29, #128]
    a00049e0:	97fffc7d 	bl	a0003bd4 <get_color>
    a00049e4:	2a0003e1 	mov	w1, w0
    a00049e8:	f94013a0 	ldr	x0, [x29, #32]
    a00049ec:	97fffc95 	bl	a0003c40 <set_color>
		set_color(node2, ctmp);
    a00049f0:	b94047a1 	ldr	w1, [x29, #68]
    a00049f4:	f94043a0 	ldr	x0, [x29, #128]
    a00049f8:	97fffc92 	bl	a0003c40 <set_color>
	}

	CHECK((get_child(node, 0U) == NULL) ||
	      (get_child(node, 1U) == NULL));

	struct rbnode *child = get_child(node, 0U);
    a00049fc:	52800001 	mov	w1, #0x0                   	// #0
    a0004a00:	f94013a0 	ldr	x0, [x29, #32]
    a0004a04:	97fffc48 	bl	a0003b24 <get_child>
    a0004a08:	f90047a0 	str	x0, [x29, #136]

	if (child == NULL) {
    a0004a0c:	f94047a0 	ldr	x0, [x29, #136]
    a0004a10:	f100001f 	cmp	x0, #0x0
    a0004a14:	540000a1 	b.ne	a0004a28 <rb_remove+0x364>  // b.any
		child = get_child(node, 1U);
    a0004a18:	52800021 	mov	w1, #0x1                   	// #1
    a0004a1c:	f94013a0 	ldr	x0, [x29, #32]
    a0004a20:	97fffc41 	bl	a0003b24 <get_child>
    a0004a24:	f90047a0 	str	x0, [x29, #136]
	}

	/* Removing the root */
	if (stacksz < 2) {
    a0004a28:	b9407fa0 	ldr	w0, [x29, #124]
    a0004a2c:	7100041f 	cmp	w0, #0x1
    a0004a30:	540001cc 	b.gt	a0004a68 <rb_remove+0x3a4>
		tree->root = child;
    a0004a34:	f94017a0 	ldr	x0, [x29, #40]
    a0004a38:	f94047a1 	ldr	x1, [x29, #136]
    a0004a3c:	f9000001 	str	x1, [x0]
		if (child != NULL) {
    a0004a40:	f94047a0 	ldr	x0, [x29, #136]
    a0004a44:	f100001f 	cmp	x0, #0x0
    a0004a48:	540000a0 	b.eq	a0004a5c <rb_remove+0x398>  // b.none
			set_color(child, BLACK);
    a0004a4c:	52800021 	mov	w1, #0x1                   	// #1
    a0004a50:	f94047a0 	ldr	x0, [x29, #136]
    a0004a54:	97fffc7b 	bl	a0003c40 <set_color>
		} else {
			tree->max_depth = 0;
		}
		return;
    a0004a58:	1400003c 	b	a0004b48 <rb_remove+0x484>
			tree->max_depth = 0;
    a0004a5c:	f94017a0 	ldr	x0, [x29, #40]
    a0004a60:	b900101f 	str	wzr, [x0, #16]
		return;
    a0004a64:	14000039 	b	a0004b48 <rb_remove+0x484>
	}

	struct rbnode *parent = stack[stacksz - 2];
    a0004a68:	b9407fa0 	ldr	w0, [x29, #124]
    a0004a6c:	51000801 	sub	w1, w0, #0x2
    a0004a70:	f94037a0 	ldr	x0, [x29, #104]
    a0004a74:	93407c21 	sxtw	x1, w1
    a0004a78:	f8617800 	ldr	x0, [x0, x1, lsl #3]
    a0004a7c:	f9001fa0 	str	x0, [x29, #56]
	/* Special case: if the node to be removed is childless, then
	 * we leave it in place while we do the missing black
	 * rotations, which will replace it with a proper NULL when
	 * they isolate it.
	 */
	if (child == NULL) {
    a0004a80:	f94047a0 	ldr	x0, [x29, #136]
    a0004a84:	f100001f 	cmp	x0, #0x0
    a0004a88:	54000281 	b.ne	a0004ad8 <rb_remove+0x414>  // b.any
		if (is_black(node)) {
    a0004a8c:	f94013a0 	ldr	x0, [x29, #32]
    a0004a90:	97fffc58 	bl	a0003bf0 <is_black>
    a0004a94:	12001c00 	and	w0, w0, #0xff
    a0004a98:	7100001f 	cmp	w0, #0x0
    a0004a9c:	540000c0 	b.eq	a0004ab4 <rb_remove+0x3f0>  // b.none
			fix_missing_black(stack, stacksz, node);
    a0004aa0:	f94013a2 	ldr	x2, [x29, #32]
    a0004aa4:	b9407fa1 	ldr	w1, [x29, #124]
    a0004aa8:	f94037a0 	ldr	x0, [x29, #104]
    a0004aac:	97fffe12 	bl	a00042f4 <fix_missing_black>
    a0004ab0:	1400001f 	b	a0004b2c <rb_remove+0x468>
		} else {
			/* Red childless nodes can just be dropped */
			set_child(parent, get_side(parent, node), NULL);
    a0004ab4:	f94013a1 	ldr	x1, [x29, #32]
    a0004ab8:	f9401fa0 	ldr	x0, [x29, #56]
    a0004abc:	97fffcb5 	bl	a0003d90 <get_side>
    a0004ac0:	12001c00 	and	w0, w0, #0xff
    a0004ac4:	d2800002 	mov	x2, #0x0                   	// #0
    a0004ac8:	2a0003e1 	mov	w1, w0
    a0004acc:	f9401fa0 	ldr	x0, [x29, #56]
    a0004ad0:	97fffc27 	bl	a0003b6c <set_child>
    a0004ad4:	14000016 	b	a0004b2c <rb_remove+0x468>
		}
	} else {
		set_child(parent, get_side(parent, node), child);
    a0004ad8:	f94013a1 	ldr	x1, [x29, #32]
    a0004adc:	f9401fa0 	ldr	x0, [x29, #56]
    a0004ae0:	97fffcac 	bl	a0003d90 <get_side>
    a0004ae4:	12001c00 	and	w0, w0, #0xff
    a0004ae8:	f94047a2 	ldr	x2, [x29, #136]
    a0004aec:	2a0003e1 	mov	w1, w0
    a0004af0:	f9401fa0 	ldr	x0, [x29, #56]
    a0004af4:	97fffc1e 	bl	a0003b6c <set_child>

		/* Check colors, if one was red (at least one must have been
		 * black in a valid tree), then we're done.
		 */
		__ASSERT(is_black(node) || is_black(child), "both nodes red?!");
		if (is_red(node) || is_red(child)) {
    a0004af8:	f94013a0 	ldr	x0, [x29, #32]
    a0004afc:	97fffc47 	bl	a0003c18 <is_red>
    a0004b00:	12001c00 	and	w0, w0, #0xff
    a0004b04:	7100001f 	cmp	w0, #0x0
    a0004b08:	540000c1 	b.ne	a0004b20 <rb_remove+0x45c>  // b.any
    a0004b0c:	f94047a0 	ldr	x0, [x29, #136]
    a0004b10:	97fffc42 	bl	a0003c18 <is_red>
    a0004b14:	12001c00 	and	w0, w0, #0xff
    a0004b18:	7100001f 	cmp	w0, #0x0
    a0004b1c:	54000080 	b.eq	a0004b2c <rb_remove+0x468>  // b.none
			set_color(child, BLACK);
    a0004b20:	52800021 	mov	w1, #0x1                   	// #1
    a0004b24:	f94047a0 	ldr	x0, [x29, #136]
    a0004b28:	97fffc46 	bl	a0003c40 <set_color>
		}
	}

	/* We may have rotated up into the root! */
	tree->root = stack[0];
    a0004b2c:	f94037a0 	ldr	x0, [x29, #104]
    a0004b30:	f9400001 	ldr	x1, [x0]
    a0004b34:	f94017a0 	ldr	x0, [x29, #40]
    a0004b38:	f9000001 	str	x1, [x0]
    a0004b3c:	9100027f 	mov	sp, x19
    a0004b40:	14000003 	b	a0004b4c <rb_remove+0x488>
		return;
    a0004b44:	d503201f 	nop
    a0004b48:	9100027f 	mov	sp, x19
}
    a0004b4c:	910003bf 	mov	sp, x29
    a0004b50:	f9400bf3 	ldr	x19, [sp, #16]
    a0004b54:	a8c97bfd 	ldp	x29, x30, [sp], #144
    a0004b58:	d65f03c0 	ret

00000000a0004b5c <rb_contains>:
{
	return is_black(node);
}

bool rb_contains(struct rbtree *tree, struct rbnode *node)
{
    a0004b5c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0004b60:	910003fd 	mov	x29, sp
    a0004b64:	f9000fe0 	str	x0, [sp, #24]
    a0004b68:	f9000be1 	str	x1, [sp, #16]
	struct rbnode *n = tree->root;
    a0004b6c:	f9400fe0 	ldr	x0, [sp, #24]
    a0004b70:	f9400000 	ldr	x0, [x0]
    a0004b74:	f90017e0 	str	x0, [sp, #40]

	while ((n != NULL) && (n != node)) {
    a0004b78:	1400000b 	b	a0004ba4 <rb_contains+0x48>
		n = get_child(n, tree->lessthan_fn(n, node));
    a0004b7c:	f9400fe0 	ldr	x0, [sp, #24]
    a0004b80:	f9400402 	ldr	x2, [x0, #8]
    a0004b84:	f9400be1 	ldr	x1, [sp, #16]
    a0004b88:	f94017e0 	ldr	x0, [sp, #40]
    a0004b8c:	d63f0040 	blr	x2
    a0004b90:	12001c00 	and	w0, w0, #0xff
    a0004b94:	2a0003e1 	mov	w1, w0
    a0004b98:	f94017e0 	ldr	x0, [sp, #40]
    a0004b9c:	97fffbe2 	bl	a0003b24 <get_child>
    a0004ba0:	f90017e0 	str	x0, [sp, #40]
	while ((n != NULL) && (n != node)) {
    a0004ba4:	f94017e0 	ldr	x0, [sp, #40]
    a0004ba8:	f100001f 	cmp	x0, #0x0
    a0004bac:	540000a0 	b.eq	a0004bc0 <rb_contains+0x64>  // b.none
    a0004bb0:	f94017e1 	ldr	x1, [sp, #40]
    a0004bb4:	f9400be0 	ldr	x0, [sp, #16]
    a0004bb8:	eb00003f 	cmp	x1, x0
    a0004bbc:	54fffe01 	b.ne	a0004b7c <rb_contains+0x20>  // b.any
	}

	return n == node;
    a0004bc0:	f94017e1 	ldr	x1, [sp, #40]
    a0004bc4:	f9400be0 	ldr	x0, [sp, #16]
    a0004bc8:	eb00003f 	cmp	x1, x0
    a0004bcc:	1a9f17e0 	cset	w0, eq  // eq = none
    a0004bd0:	12001c00 	and	w0, w0, #0xff
}
    a0004bd4:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0004bd8:	d65f03c0 	ret

00000000a0004bdc <arch_syscall_invoke1>:
{
    a0004bdc:	d10043ff 	sub	sp, sp, #0x10
    a0004be0:	f90007e0 	str	x0, [sp, #8]
    a0004be4:	f90003e1 	str	x1, [sp]
	register uint64_t ret __asm__("x0") = arg1;
    a0004be8:	f94007e0 	ldr	x0, [sp, #8]
	register uint64_t r8 __asm__("x8") = call_id;
    a0004bec:	f94003e8 	ldr	x8, [sp]
	__asm__ volatile("svc %[svid]\n"
    a0004bf0:	d4000061 	svc	#0x3
}
    a0004bf4:	910043ff 	add	sp, sp, #0x10
    a0004bf8:	d65f03c0 	ret

00000000a0004bfc <arch_syscall_invoke0>:
{
    a0004bfc:	d10043ff 	sub	sp, sp, #0x10
    a0004c00:	f90007e0 	str	x0, [sp, #8]
	register uint64_t r8 __asm__("x8") = call_id;
    a0004c04:	f94007e8 	ldr	x8, [sp, #8]
	__asm__ volatile("svc %[svid]\n"
    a0004c08:	d4000061 	svc	#0x3
}
    a0004c0c:	910043ff 	add	sp, sp, #0x10
    a0004c10:	d65f03c0 	ret

00000000a0004c14 <arch_is_user_context>:
{
    a0004c14:	d10043ff 	sub	sp, sp, #0x10
    a0004c18:	d53bd060 	mrs	x0, tpidrro_el0
    a0004c1c:	f90007e0 	str	x0, [sp, #8]
    a0004c20:	f94007e0 	ldr	x0, [sp, #8]
    a0004c24:	d503201f 	nop
	return (read_tpidrro_el0() & TPIDRROEL0_IN_EL0) != 0;
    a0004c28:	92400000 	and	x0, x0, #0x1
    a0004c2c:	f100001f 	cmp	x0, #0x0
    a0004c30:	1a9f07e0 	cset	w0, ne  // ne = any
    a0004c34:	12001c00 	and	w0, w0, #0xff
}
    a0004c38:	910043ff 	add	sp, sp, #0x10
    a0004c3c:	d65f03c0 	ret

00000000a0004c40 <k_current_get>:
 * @return ID of current thread.
 *
 */
__attribute_const__
static inline k_tid_t k_current_get(void)
{
    a0004c40:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    a0004c44:	910003fd 	mov	x29, sp
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	return z_tls_current;
#else
	return z_current_get();
    a0004c48:	94000003 	bl	a0004c54 <z_current_get>
#endif
}
    a0004c4c:	a8c17bfd 	ldp	x29, x30, [sp], #16
    a0004c50:	d65f03c0 	ret

00000000a0004c54 <z_current_get>:
{
    a0004c54:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0004c58:	910003fd 	mov	x29, sp
	bool ret = false;
    a0004c5c:	39007fff 	strb	wzr, [sp, #31]
	ret = arch_is_user_context();
    a0004c60:	97ffffed 	bl	a0004c14 <arch_is_user_context>
    a0004c64:	39007fe0 	strb	w0, [sp, #31]
	return ret;
    a0004c68:	39407fe0 	ldrb	w0, [sp, #31]
	if (z_syscall_trap()) {
    a0004c6c:	7100001f 	cmp	w0, #0x0
    a0004c70:	54000080 	b.eq	a0004c80 <z_current_get+0x2c>  // b.none
		return (k_tid_t) arch_syscall_invoke0(K_SYSCALL_Z_CURRENT_GET);
    a0004c74:	d2802b40 	mov	x0, #0x15a                 	// #346
    a0004c78:	97ffffe1 	bl	a0004bfc <arch_syscall_invoke0>
    a0004c7c:	14000002 	b	a0004c84 <z_current_get+0x30>
	return z_impl_z_current_get();
    a0004c80:	94005062 	bl	a0018e08 <z_impl_z_current_get>
}
    a0004c84:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0004c88:	d65f03c0 	ret

00000000a0004c8c <k_thread_abort>:
{
    a0004c8c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0004c90:	910003fd 	mov	x29, sp
    a0004c94:	f9000fe0 	str	x0, [sp, #24]
	bool ret = false;
    a0004c98:	3900bfff 	strb	wzr, [sp, #47]
	ret = arch_is_user_context();
    a0004c9c:	97ffffde 	bl	a0004c14 <arch_is_user_context>
    a0004ca0:	3900bfe0 	strb	w0, [sp, #47]
	return ret;
    a0004ca4:	3940bfe0 	ldrb	w0, [sp, #47]
	if (z_syscall_trap()) {
    a0004ca8:	7100001f 	cmp	w0, #0x0
    a0004cac:	540000c0 	b.eq	a0004cc4 <k_thread_abort+0x38>  // b.none
		arch_syscall_invoke1(*(uintptr_t *)&thread, K_SYSCALL_K_THREAD_ABORT);
    a0004cb0:	910063e0 	add	x0, sp, #0x18
    a0004cb4:	f9400000 	ldr	x0, [x0]
    a0004cb8:	d2801801 	mov	x1, #0xc0                  	// #192
    a0004cbc:	97ffffc8 	bl	a0004bdc <arch_syscall_invoke1>
		return;
    a0004cc0:	14000003 	b	a0004ccc <k_thread_abort+0x40>
	z_impl_k_thread_abort(thread);
    a0004cc4:	f9400fe0 	ldr	x0, [sp, #24]
    a0004cc8:	9400515d 	bl	a001923c <z_impl_k_thread_abort>
}
    a0004ccc:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0004cd0:	d65f03c0 	ret

00000000a0004cd4 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
    a0004cd4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0004cd8:	910003fd 	mov	x29, sp
    a0004cdc:	f90017e0 	str	x0, [sp, #40]
    a0004ce0:	f90013e1 	str	x1, [sp, #32]
    a0004ce4:	f9000fe2 	str	x2, [sp, #24]
    a0004ce8:	f9000be3 	str	x3, [sp, #16]
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
    a0004cec:	f94017e3 	ldr	x3, [sp, #40]
    a0004cf0:	f9400be2 	ldr	x2, [sp, #16]
    a0004cf4:	f9400fe1 	ldr	x1, [sp, #24]
    a0004cf8:	f94013e0 	ldr	x0, [sp, #32]
    a0004cfc:	d63f0060 	blr	x3

	k_thread_abort(k_current_get());
    a0004d00:	97ffffd0 	bl	a0004c40 <k_current_get>
    a0004d04:	97ffffe2 	bl	a0004c8c <k_thread_abort>

00000000a0004d08 <big_heap_chunks>:
#endif
	struct z_heap_bucket buckets[0];
};

static inline bool big_heap_chunks(chunksz_t chunks)
{
    a0004d08:	d10043ff 	sub	sp, sp, #0x10
    a0004d0c:	b9000fe0 	str	w0, [sp, #12]
	if (IS_ENABLED(CONFIG_SYS_HEAP_SMALL_ONLY)) {
		return false;
	}
	if (IS_ENABLED(CONFIG_SYS_HEAP_BIG_ONLY) || sizeof(void *) > 4U) {
		return true;
    a0004d10:	52800020 	mov	w0, #0x1                   	// #1
	}
	return chunks > 0x7fffU;
}
    a0004d14:	910043ff 	add	sp, sp, #0x10
    a0004d18:	d65f03c0 	ret

00000000a0004d1c <big_heap_bytes>:

static inline bool big_heap_bytes(size_t bytes)
{
    a0004d1c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0004d20:	910003fd 	mov	x29, sp
    a0004d24:	f9000fe0 	str	x0, [sp, #24]
	return big_heap_chunks(bytes / CHUNK_UNIT);
    a0004d28:	f9400fe0 	ldr	x0, [sp, #24]
    a0004d2c:	d343fc00 	lsr	x0, x0, #3
    a0004d30:	97fffff6 	bl	a0004d08 <big_heap_chunks>
    a0004d34:	12001c00 	and	w0, w0, #0xff
}
    a0004d38:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0004d3c:	d65f03c0 	ret

00000000a0004d40 <big_heap>:

static inline bool big_heap(struct z_heap *h)
{
    a0004d40:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0004d44:	910003fd 	mov	x29, sp
    a0004d48:	f9000fe0 	str	x0, [sp, #24]
	return big_heap_chunks(h->end_chunk);
    a0004d4c:	f9400fe0 	ldr	x0, [sp, #24]
    a0004d50:	b9400800 	ldr	w0, [x0, #8]
    a0004d54:	97ffffed 	bl	a0004d08 <big_heap_chunks>
    a0004d58:	12001c00 	and	w0, w0, #0xff
}
    a0004d5c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0004d60:	d65f03c0 	ret

00000000a0004d64 <chunk_buf>:

static inline chunk_unit_t *chunk_buf(struct z_heap *h)
{
    a0004d64:	d10043ff 	sub	sp, sp, #0x10
    a0004d68:	f90007e0 	str	x0, [sp, #8]
	/* the struct z_heap matches with the first chunk */
	return (chunk_unit_t *)h;
    a0004d6c:	f94007e0 	ldr	x0, [sp, #8]
}
    a0004d70:	910043ff 	add	sp, sp, #0x10
    a0004d74:	d65f03c0 	ret

00000000a0004d78 <chunk_field>:

static inline chunkid_t chunk_field(struct z_heap *h, chunkid_t c,
				    enum chunk_fields f)
{
    a0004d78:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0004d7c:	910003fd 	mov	x29, sp
    a0004d80:	f9000fe0 	str	x0, [sp, #24]
    a0004d84:	b90017e1 	str	w1, [sp, #20]
    a0004d88:	b90013e2 	str	w2, [sp, #16]
	chunk_unit_t *buf = chunk_buf(h);
    a0004d8c:	f9400fe0 	ldr	x0, [sp, #24]
    a0004d90:	97fffff5 	bl	a0004d64 <chunk_buf>
    a0004d94:	f90017e0 	str	x0, [sp, #40]
	void *cmem = &buf[c];
    a0004d98:	b94017e0 	ldr	w0, [sp, #20]
    a0004d9c:	d37df000 	lsl	x0, x0, #3
    a0004da0:	f94017e1 	ldr	x1, [sp, #40]
    a0004da4:	8b000020 	add	x0, x1, x0
    a0004da8:	f90013e0 	str	x0, [sp, #32]

	if (big_heap(h)) {
    a0004dac:	f9400fe0 	ldr	x0, [sp, #24]
    a0004db0:	97ffffe4 	bl	a0004d40 <big_heap>
    a0004db4:	12001c00 	and	w0, w0, #0xff
    a0004db8:	7100001f 	cmp	w0, #0x0
    a0004dbc:	540000e0 	b.eq	a0004dd8 <chunk_field+0x60>  // b.none
		return ((uint32_t *)cmem)[f];
    a0004dc0:	b94013e0 	ldr	w0, [sp, #16]
    a0004dc4:	d37ef400 	lsl	x0, x0, #2
    a0004dc8:	f94013e1 	ldr	x1, [sp, #32]
    a0004dcc:	8b000020 	add	x0, x1, x0
    a0004dd0:	b9400000 	ldr	w0, [x0]
    a0004dd4:	14000007 	b	a0004df0 <chunk_field+0x78>
	} else {
		return ((uint16_t *)cmem)[f];
    a0004dd8:	b94013e0 	ldr	w0, [sp, #16]
    a0004ddc:	8b000000 	add	x0, x0, x0
    a0004de0:	aa0003e1 	mov	x1, x0
    a0004de4:	f94013e0 	ldr	x0, [sp, #32]
    a0004de8:	8b010000 	add	x0, x0, x1
    a0004dec:	79400000 	ldrh	w0, [x0]
	}
}
    a0004df0:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0004df4:	d65f03c0 	ret

00000000a0004df8 <chunk_set>:

static inline void chunk_set(struct z_heap *h, chunkid_t c,
			     enum chunk_fields f, chunkid_t val)
{
    a0004df8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    a0004dfc:	910003fd 	mov	x29, sp
    a0004e00:	f90017e0 	str	x0, [sp, #40]
    a0004e04:	b90027e1 	str	w1, [sp, #36]
    a0004e08:	b90023e2 	str	w2, [sp, #32]
    a0004e0c:	b9001fe3 	str	w3, [sp, #28]
	CHECK(c <= h->end_chunk);

	chunk_unit_t *buf = chunk_buf(h);
    a0004e10:	f94017e0 	ldr	x0, [sp, #40]
    a0004e14:	97ffffd4 	bl	a0004d64 <chunk_buf>
    a0004e18:	f9001fe0 	str	x0, [sp, #56]
	void *cmem = &buf[c];
    a0004e1c:	b94027e0 	ldr	w0, [sp, #36]
    a0004e20:	d37df000 	lsl	x0, x0, #3
    a0004e24:	f9401fe1 	ldr	x1, [sp, #56]
    a0004e28:	8b000020 	add	x0, x1, x0
    a0004e2c:	f9001be0 	str	x0, [sp, #48]

	if (big_heap(h)) {
    a0004e30:	f94017e0 	ldr	x0, [sp, #40]
    a0004e34:	97ffffc3 	bl	a0004d40 <big_heap>
    a0004e38:	12001c00 	and	w0, w0, #0xff
    a0004e3c:	7100001f 	cmp	w0, #0x0
    a0004e40:	54000100 	b.eq	a0004e60 <chunk_set+0x68>  // b.none
		CHECK(val == (uint32_t)val);
		((uint32_t *)cmem)[f] = val;
    a0004e44:	b94023e0 	ldr	w0, [sp, #32]
    a0004e48:	d37ef400 	lsl	x0, x0, #2
    a0004e4c:	f9401be1 	ldr	x1, [sp, #48]
    a0004e50:	8b000020 	add	x0, x1, x0
    a0004e54:	b9401fe1 	ldr	w1, [sp, #28]
    a0004e58:	b9000001 	str	w1, [x0]
	} else {
		CHECK(val == (uint16_t)val);
		((uint16_t *)cmem)[f] = val;
	}
}
    a0004e5c:	14000009 	b	a0004e80 <chunk_set+0x88>
		((uint16_t *)cmem)[f] = val;
    a0004e60:	b94023e0 	ldr	w0, [sp, #32]
    a0004e64:	8b000000 	add	x0, x0, x0
    a0004e68:	aa0003e1 	mov	x1, x0
    a0004e6c:	f9401be0 	ldr	x0, [sp, #48]
    a0004e70:	8b010000 	add	x0, x0, x1
    a0004e74:	b9401fe1 	ldr	w1, [sp, #28]
    a0004e78:	12003c21 	and	w1, w1, #0xffff
    a0004e7c:	79000001 	strh	w1, [x0]
}
    a0004e80:	d503201f 	nop
    a0004e84:	a8c47bfd 	ldp	x29, x30, [sp], #64
    a0004e88:	d65f03c0 	ret

00000000a0004e8c <chunk_used>:

static inline bool chunk_used(struct z_heap *h, chunkid_t c)
{
    a0004e8c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0004e90:	910003fd 	mov	x29, sp
    a0004e94:	f9000fe0 	str	x0, [sp, #24]
    a0004e98:	b90017e1 	str	w1, [sp, #20]
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
    a0004e9c:	52800022 	mov	w2, #0x1                   	// #1
    a0004ea0:	b94017e1 	ldr	w1, [sp, #20]
    a0004ea4:	f9400fe0 	ldr	x0, [sp, #24]
    a0004ea8:	97ffffb4 	bl	a0004d78 <chunk_field>
    a0004eac:	12000000 	and	w0, w0, #0x1
    a0004eb0:	7100001f 	cmp	w0, #0x0
    a0004eb4:	1a9f07e0 	cset	w0, ne  // ne = any
    a0004eb8:	12001c00 	and	w0, w0, #0xff
}
    a0004ebc:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0004ec0:	d65f03c0 	ret

00000000a0004ec4 <chunk_size>:

static inline chunksz_t chunk_size(struct z_heap *h, chunkid_t c)
{
    a0004ec4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0004ec8:	910003fd 	mov	x29, sp
    a0004ecc:	f9000fe0 	str	x0, [sp, #24]
    a0004ed0:	b90017e1 	str	w1, [sp, #20]
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
    a0004ed4:	52800022 	mov	w2, #0x1                   	// #1
    a0004ed8:	b94017e1 	ldr	w1, [sp, #20]
    a0004edc:	f9400fe0 	ldr	x0, [sp, #24]
    a0004ee0:	97ffffa6 	bl	a0004d78 <chunk_field>
    a0004ee4:	53017c00 	lsr	w0, w0, #1
}
    a0004ee8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0004eec:	d65f03c0 	ret

00000000a0004ef0 <set_chunk_used>:

static inline void set_chunk_used(struct z_heap *h, chunkid_t c, bool used)
{
    a0004ef0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0004ef4:	910003fd 	mov	x29, sp
    a0004ef8:	f9000fe0 	str	x0, [sp, #24]
    a0004efc:	b90017e1 	str	w1, [sp, #20]
    a0004f00:	39004fe2 	strb	w2, [sp, #19]
	chunk_unit_t *buf = chunk_buf(h);
    a0004f04:	f9400fe0 	ldr	x0, [sp, #24]
    a0004f08:	97ffff97 	bl	a0004d64 <chunk_buf>
    a0004f0c:	f90017e0 	str	x0, [sp, #40]
	void *cmem = &buf[c];
    a0004f10:	b94017e0 	ldr	w0, [sp, #20]
    a0004f14:	d37df000 	lsl	x0, x0, #3
    a0004f18:	f94017e1 	ldr	x1, [sp, #40]
    a0004f1c:	8b000020 	add	x0, x1, x0
    a0004f20:	f90013e0 	str	x0, [sp, #32]

	if (big_heap(h)) {
    a0004f24:	f9400fe0 	ldr	x0, [sp, #24]
    a0004f28:	97ffff86 	bl	a0004d40 <big_heap>
    a0004f2c:	12001c00 	and	w0, w0, #0xff
    a0004f30:	7100001f 	cmp	w0, #0x0
    a0004f34:	54000280 	b.eq	a0004f84 <set_chunk_used+0x94>  // b.none
		if (used) {
    a0004f38:	39404fe0 	ldrb	w0, [sp, #19]
    a0004f3c:	7100001f 	cmp	w0, #0x0
    a0004f40:	54000120 	b.eq	a0004f64 <set_chunk_used+0x74>  // b.none
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
    a0004f44:	f94013e0 	ldr	x0, [sp, #32]
    a0004f48:	91001000 	add	x0, x0, #0x4
    a0004f4c:	b9400001 	ldr	w1, [x0]
    a0004f50:	f94013e0 	ldr	x0, [sp, #32]
    a0004f54:	91001000 	add	x0, x0, #0x4
    a0004f58:	32000021 	orr	w1, w1, #0x1
    a0004f5c:	b9000001 	str	w1, [x0]
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
		} else {
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
		}
	}
}
    a0004f60:	1400001d 	b	a0004fd4 <set_chunk_used+0xe4>
			((uint32_t *)cmem)[SIZE_AND_USED] &= ~1U;
    a0004f64:	f94013e0 	ldr	x0, [sp, #32]
    a0004f68:	91001000 	add	x0, x0, #0x4
    a0004f6c:	b9400001 	ldr	w1, [x0]
    a0004f70:	f94013e0 	ldr	x0, [sp, #32]
    a0004f74:	91001000 	add	x0, x0, #0x4
    a0004f78:	121f7821 	and	w1, w1, #0xfffffffe
    a0004f7c:	b9000001 	str	w1, [x0]
}
    a0004f80:	14000015 	b	a0004fd4 <set_chunk_used+0xe4>
		if (used) {
    a0004f84:	39404fe0 	ldrb	w0, [sp, #19]
    a0004f88:	7100001f 	cmp	w0, #0x0
    a0004f8c:	54000140 	b.eq	a0004fb4 <set_chunk_used+0xc4>  // b.none
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
    a0004f90:	f94013e0 	ldr	x0, [sp, #32]
    a0004f94:	91000800 	add	x0, x0, #0x2
    a0004f98:	79400001 	ldrh	w1, [x0]
    a0004f9c:	f94013e0 	ldr	x0, [sp, #32]
    a0004fa0:	91000800 	add	x0, x0, #0x2
    a0004fa4:	32000021 	orr	w1, w1, #0x1
    a0004fa8:	12003c21 	and	w1, w1, #0xffff
    a0004fac:	79000001 	strh	w1, [x0]
}
    a0004fb0:	14000009 	b	a0004fd4 <set_chunk_used+0xe4>
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
    a0004fb4:	f94013e0 	ldr	x0, [sp, #32]
    a0004fb8:	91000800 	add	x0, x0, #0x2
    a0004fbc:	79400001 	ldrh	w1, [x0]
    a0004fc0:	f94013e0 	ldr	x0, [sp, #32]
    a0004fc4:	91000800 	add	x0, x0, #0x2
    a0004fc8:	121f7821 	and	w1, w1, #0xfffffffe
    a0004fcc:	12003c21 	and	w1, w1, #0xffff
    a0004fd0:	79000001 	strh	w1, [x0]
}
    a0004fd4:	d503201f 	nop
    a0004fd8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0004fdc:	d65f03c0 	ret

00000000a0004fe0 <set_chunk_size>:
 * Note: no need to preserve the used bit here as the chunk is never in use
 * when its size is modified, and potential set_chunk_used() is always
 * invoked after set_chunk_size().
 */
static inline void set_chunk_size(struct z_heap *h, chunkid_t c, chunksz_t size)
{
    a0004fe0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0004fe4:	910003fd 	mov	x29, sp
    a0004fe8:	f9000fe0 	str	x0, [sp, #24]
    a0004fec:	b90017e1 	str	w1, [sp, #20]
    a0004ff0:	b90013e2 	str	w2, [sp, #16]
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    a0004ff4:	b94013e0 	ldr	w0, [sp, #16]
    a0004ff8:	0b000000 	add	w0, w0, w0
    a0004ffc:	2a0003e3 	mov	w3, w0
    a0005000:	52800022 	mov	w2, #0x1                   	// #1
    a0005004:	b94017e1 	ldr	w1, [sp, #20]
    a0005008:	f9400fe0 	ldr	x0, [sp, #24]
    a000500c:	97ffff7b 	bl	a0004df8 <chunk_set>
}
    a0005010:	d503201f 	nop
    a0005014:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0005018:	d65f03c0 	ret

00000000a000501c <prev_free_chunk>:

static inline chunkid_t prev_free_chunk(struct z_heap *h, chunkid_t c)
{
    a000501c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0005020:	910003fd 	mov	x29, sp
    a0005024:	f9000fe0 	str	x0, [sp, #24]
    a0005028:	b90017e1 	str	w1, [sp, #20]
	return chunk_field(h, c, FREE_PREV);
    a000502c:	52800042 	mov	w2, #0x2                   	// #2
    a0005030:	b94017e1 	ldr	w1, [sp, #20]
    a0005034:	f9400fe0 	ldr	x0, [sp, #24]
    a0005038:	97ffff50 	bl	a0004d78 <chunk_field>
}
    a000503c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0005040:	d65f03c0 	ret

00000000a0005044 <next_free_chunk>:

static inline chunkid_t next_free_chunk(struct z_heap *h, chunkid_t c)
{
    a0005044:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0005048:	910003fd 	mov	x29, sp
    a000504c:	f9000fe0 	str	x0, [sp, #24]
    a0005050:	b90017e1 	str	w1, [sp, #20]
	return chunk_field(h, c, FREE_NEXT);
    a0005054:	52800062 	mov	w2, #0x3                   	// #3
    a0005058:	b94017e1 	ldr	w1, [sp, #20]
    a000505c:	f9400fe0 	ldr	x0, [sp, #24]
    a0005060:	97ffff46 	bl	a0004d78 <chunk_field>
}
    a0005064:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0005068:	d65f03c0 	ret

00000000a000506c <set_prev_free_chunk>:

static inline void set_prev_free_chunk(struct z_heap *h, chunkid_t c,
				       chunkid_t prev)
{
    a000506c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0005070:	910003fd 	mov	x29, sp
    a0005074:	f9000fe0 	str	x0, [sp, #24]
    a0005078:	b90017e1 	str	w1, [sp, #20]
    a000507c:	b90013e2 	str	w2, [sp, #16]
	chunk_set(h, c, FREE_PREV, prev);
    a0005080:	b94013e3 	ldr	w3, [sp, #16]
    a0005084:	52800042 	mov	w2, #0x2                   	// #2
    a0005088:	b94017e1 	ldr	w1, [sp, #20]
    a000508c:	f9400fe0 	ldr	x0, [sp, #24]
    a0005090:	97ffff5a 	bl	a0004df8 <chunk_set>
}
    a0005094:	d503201f 	nop
    a0005098:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a000509c:	d65f03c0 	ret

00000000a00050a0 <set_next_free_chunk>:

static inline void set_next_free_chunk(struct z_heap *h, chunkid_t c,
				       chunkid_t next)
{
    a00050a0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a00050a4:	910003fd 	mov	x29, sp
    a00050a8:	f9000fe0 	str	x0, [sp, #24]
    a00050ac:	b90017e1 	str	w1, [sp, #20]
    a00050b0:	b90013e2 	str	w2, [sp, #16]
	chunk_set(h, c, FREE_NEXT, next);
    a00050b4:	b94013e3 	ldr	w3, [sp, #16]
    a00050b8:	52800062 	mov	w2, #0x3                   	// #3
    a00050bc:	b94017e1 	ldr	w1, [sp, #20]
    a00050c0:	f9400fe0 	ldr	x0, [sp, #24]
    a00050c4:	97ffff4d 	bl	a0004df8 <chunk_set>
}
    a00050c8:	d503201f 	nop
    a00050cc:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a00050d0:	d65f03c0 	ret

00000000a00050d4 <left_chunk>:

static inline chunkid_t left_chunk(struct z_heap *h, chunkid_t c)
{
    a00050d4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a00050d8:	910003fd 	mov	x29, sp
    a00050dc:	f9000fe0 	str	x0, [sp, #24]
    a00050e0:	b90017e1 	str	w1, [sp, #20]
	return c - chunk_field(h, c, LEFT_SIZE);
    a00050e4:	52800002 	mov	w2, #0x0                   	// #0
    a00050e8:	b94017e1 	ldr	w1, [sp, #20]
    a00050ec:	f9400fe0 	ldr	x0, [sp, #24]
    a00050f0:	97ffff22 	bl	a0004d78 <chunk_field>
    a00050f4:	2a0003e1 	mov	w1, w0
    a00050f8:	b94017e0 	ldr	w0, [sp, #20]
    a00050fc:	4b010000 	sub	w0, w0, w1
}
    a0005100:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0005104:	d65f03c0 	ret

00000000a0005108 <right_chunk>:

static inline chunkid_t right_chunk(struct z_heap *h, chunkid_t c)
{
    a0005108:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a000510c:	910003fd 	mov	x29, sp
    a0005110:	f9000fe0 	str	x0, [sp, #24]
    a0005114:	b90017e1 	str	w1, [sp, #20]
	return c + chunk_size(h, c);
    a0005118:	b94017e1 	ldr	w1, [sp, #20]
    a000511c:	f9400fe0 	ldr	x0, [sp, #24]
    a0005120:	97ffff69 	bl	a0004ec4 <chunk_size>
    a0005124:	2a0003e1 	mov	w1, w0
    a0005128:	b94017e0 	ldr	w0, [sp, #20]
    a000512c:	0b000020 	add	w0, w1, w0
}
    a0005130:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0005134:	d65f03c0 	ret

00000000a0005138 <set_left_chunk_size>:

static inline void set_left_chunk_size(struct z_heap *h, chunkid_t c,
				       chunksz_t size)
{
    a0005138:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a000513c:	910003fd 	mov	x29, sp
    a0005140:	f9000fe0 	str	x0, [sp, #24]
    a0005144:	b90017e1 	str	w1, [sp, #20]
    a0005148:	b90013e2 	str	w2, [sp, #16]
	chunk_set(h, c, LEFT_SIZE, size);
    a000514c:	b94013e3 	ldr	w3, [sp, #16]
    a0005150:	52800002 	mov	w2, #0x0                   	// #0
    a0005154:	b94017e1 	ldr	w1, [sp, #20]
    a0005158:	f9400fe0 	ldr	x0, [sp, #24]
    a000515c:	97ffff27 	bl	a0004df8 <chunk_set>
}
    a0005160:	d503201f 	nop
    a0005164:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0005168:	d65f03c0 	ret

00000000a000516c <solo_free_header>:

static inline bool solo_free_header(struct z_heap *h, chunkid_t c)
{
    a000516c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0005170:	910003fd 	mov	x29, sp
    a0005174:	f9000fe0 	str	x0, [sp, #24]
    a0005178:	b90017e1 	str	w1, [sp, #20]
	return big_heap(h) && chunk_size(h, c) == 1U;
    a000517c:	f9400fe0 	ldr	x0, [sp, #24]
    a0005180:	97fffef0 	bl	a0004d40 <big_heap>
    a0005184:	12001c00 	and	w0, w0, #0xff
    a0005188:	7100001f 	cmp	w0, #0x0
    a000518c:	54000100 	b.eq	a00051ac <solo_free_header+0x40>  // b.none
    a0005190:	b94017e1 	ldr	w1, [sp, #20]
    a0005194:	f9400fe0 	ldr	x0, [sp, #24]
    a0005198:	97ffff4b 	bl	a0004ec4 <chunk_size>
    a000519c:	7100041f 	cmp	w0, #0x1
    a00051a0:	54000061 	b.ne	a00051ac <solo_free_header+0x40>  // b.any
    a00051a4:	52800020 	mov	w0, #0x1                   	// #1
    a00051a8:	14000002 	b	a00051b0 <solo_free_header+0x44>
    a00051ac:	52800000 	mov	w0, #0x0                   	// #0
    a00051b0:	12000000 	and	w0, w0, #0x1
    a00051b4:	12001c00 	and	w0, w0, #0xff
}
    a00051b8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a00051bc:	d65f03c0 	ret

00000000a00051c0 <chunk_header_bytes>:

static inline size_t chunk_header_bytes(struct z_heap *h)
{
    a00051c0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a00051c4:	910003fd 	mov	x29, sp
    a00051c8:	f9000fe0 	str	x0, [sp, #24]
	return big_heap(h) ? 8 : 4;
    a00051cc:	f9400fe0 	ldr	x0, [sp, #24]
    a00051d0:	97fffedc 	bl	a0004d40 <big_heap>
    a00051d4:	12001c00 	and	w0, w0, #0xff
    a00051d8:	7100001f 	cmp	w0, #0x0
    a00051dc:	54000060 	b.eq	a00051e8 <chunk_header_bytes+0x28>  // b.none
    a00051e0:	d2800100 	mov	x0, #0x8                   	// #8
    a00051e4:	14000002 	b	a00051ec <chunk_header_bytes+0x2c>
    a00051e8:	d2800080 	mov	x0, #0x4                   	// #4
}
    a00051ec:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a00051f0:	d65f03c0 	ret

00000000a00051f4 <heap_footer_bytes>:

static inline size_t heap_footer_bytes(size_t size)
{
    a00051f4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a00051f8:	910003fd 	mov	x29, sp
    a00051fc:	f9000fe0 	str	x0, [sp, #24]
	return big_heap_bytes(size) ? 8 : 4;
    a0005200:	f9400fe0 	ldr	x0, [sp, #24]
    a0005204:	97fffec6 	bl	a0004d1c <big_heap_bytes>
    a0005208:	12001c00 	and	w0, w0, #0xff
    a000520c:	7100001f 	cmp	w0, #0x0
    a0005210:	54000060 	b.eq	a000521c <heap_footer_bytes+0x28>  // b.none
    a0005214:	d2800100 	mov	x0, #0x8                   	// #8
    a0005218:	14000002 	b	a0005220 <heap_footer_bytes+0x2c>
    a000521c:	d2800080 	mov	x0, #0x4                   	// #4
}
    a0005220:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0005224:	d65f03c0 	ret

00000000a0005228 <chunksz>:

static inline chunksz_t chunksz(size_t bytes)
{
    a0005228:	d10043ff 	sub	sp, sp, #0x10
    a000522c:	f90007e0 	str	x0, [sp, #8]
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
    a0005230:	f94007e0 	ldr	x0, [sp, #8]
    a0005234:	91001c00 	add	x0, x0, #0x7
    a0005238:	d343fc00 	lsr	x0, x0, #3
}
    a000523c:	910043ff 	add	sp, sp, #0x10
    a0005240:	d65f03c0 	ret

00000000a0005244 <bytes_to_chunksz>:

static inline chunksz_t bytes_to_chunksz(struct z_heap *h, size_t bytes)
{
    a0005244:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0005248:	910003fd 	mov	x29, sp
    a000524c:	f9000fe0 	str	x0, [sp, #24]
    a0005250:	f9000be1 	str	x1, [sp, #16]
	return chunksz(chunk_header_bytes(h) + bytes);
    a0005254:	f9400fe0 	ldr	x0, [sp, #24]
    a0005258:	97ffffda 	bl	a00051c0 <chunk_header_bytes>
    a000525c:	aa0003e1 	mov	x1, x0
    a0005260:	f9400be0 	ldr	x0, [sp, #16]
    a0005264:	8b000020 	add	x0, x1, x0
    a0005268:	97fffff0 	bl	a0005228 <chunksz>
}
    a000526c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0005270:	d65f03c0 	ret

00000000a0005274 <min_chunk_size>:

static inline chunksz_t min_chunk_size(struct z_heap *h)
{
    a0005274:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0005278:	910003fd 	mov	x29, sp
    a000527c:	f9000fe0 	str	x0, [sp, #24]
	return bytes_to_chunksz(h, 1);
    a0005280:	d2800021 	mov	x1, #0x1                   	// #1
    a0005284:	f9400fe0 	ldr	x0, [sp, #24]
    a0005288:	97ffffef 	bl	a0005244 <bytes_to_chunksz>
}
    a000528c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0005290:	d65f03c0 	ret

00000000a0005294 <bucket_idx>:
{
	return chunksz_in * CHUNK_UNIT - chunk_header_bytes(h);
}

static inline int bucket_idx(struct z_heap *h, chunksz_t sz)
{
    a0005294:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0005298:	910003fd 	mov	x29, sp
    a000529c:	f9000fe0 	str	x0, [sp, #24]
    a00052a0:	b90017e1 	str	w1, [sp, #20]
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
    a00052a4:	f9400fe0 	ldr	x0, [sp, #24]
    a00052a8:	97fffff3 	bl	a0005274 <min_chunk_size>
    a00052ac:	2a0003e1 	mov	w1, w0
    a00052b0:	b94017e0 	ldr	w0, [sp, #20]
    a00052b4:	4b010000 	sub	w0, w0, w1
    a00052b8:	11000400 	add	w0, w0, #0x1
    a00052bc:	b9002fe0 	str	w0, [sp, #44]
	return 31 - __builtin_clz(usable_sz);
    a00052c0:	b9402fe0 	ldr	w0, [sp, #44]
    a00052c4:	5ac01000 	clz	w0, w0
    a00052c8:	528003e1 	mov	w1, #0x1f                  	// #31
    a00052cc:	4b000020 	sub	w0, w1, w0
}
    a00052d0:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a00052d4:	d65f03c0 	ret

00000000a00052d8 <size_too_big>:

static inline bool size_too_big(struct z_heap *h, size_t bytes)
{
    a00052d8:	d10043ff 	sub	sp, sp, #0x10
    a00052dc:	f90007e0 	str	x0, [sp, #8]
    a00052e0:	f90003e1 	str	x1, [sp]
	/*
	 * Quick check to bail out early if size is too big.
	 * Also guards against potential arithmetic overflows elsewhere.
	 */
	return (bytes / CHUNK_UNIT) >= h->end_chunk;
    a00052e4:	f94003e0 	ldr	x0, [sp]
    a00052e8:	d343fc01 	lsr	x1, x0, #3
    a00052ec:	f94007e0 	ldr	x0, [sp, #8]
    a00052f0:	b9400800 	ldr	w0, [x0, #8]
    a00052f4:	2a0003e0 	mov	w0, w0
    a00052f8:	eb00003f 	cmp	x1, x0
    a00052fc:	1a9f37e0 	cset	w0, cs  // cs = hs, nlast
    a0005300:	12001c00 	and	w0, w0, #0xff
}
    a0005304:	910043ff 	add	sp, sp, #0x10
    a0005308:	d65f03c0 	ret

00000000a000530c <chunk_mem>:
#include <kernel.h>
#include <string.h>
#include "heap.h"

static void *chunk_mem(struct z_heap *h, chunkid_t c)
{
    a000530c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    a0005310:	910003fd 	mov	x29, sp
    a0005314:	f9000bf3 	str	x19, [sp, #16]
    a0005318:	f90017e0 	str	x0, [sp, #40]
    a000531c:	b90027e1 	str	w1, [sp, #36]
	chunk_unit_t *buf = chunk_buf(h);
    a0005320:	f94017e0 	ldr	x0, [sp, #40]
    a0005324:	97fffe90 	bl	a0004d64 <chunk_buf>
    a0005328:	f9001fe0 	str	x0, [sp, #56]
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
    a000532c:	b94027e0 	ldr	w0, [sp, #36]
    a0005330:	d37df000 	lsl	x0, x0, #3
    a0005334:	f9401fe1 	ldr	x1, [sp, #56]
    a0005338:	8b000033 	add	x19, x1, x0
    a000533c:	f94017e0 	ldr	x0, [sp, #40]
    a0005340:	97ffffa0 	bl	a00051c0 <chunk_header_bytes>
    a0005344:	8b000260 	add	x0, x19, x0
    a0005348:	f9001be0 	str	x0, [sp, #48]

	CHECK(!(((uintptr_t)ret) & (big_heap(h) ? 7 : 3)));

	return ret;
    a000534c:	f9401be0 	ldr	x0, [sp, #48]
}
    a0005350:	f9400bf3 	ldr	x19, [sp, #16]
    a0005354:	a8c47bfd 	ldp	x29, x30, [sp], #64
    a0005358:	d65f03c0 	ret

00000000a000535c <free_list_remove_bidx>:

static void free_list_remove_bidx(struct z_heap *h, chunkid_t c, int bidx)
{
    a000535c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0005360:	910003fd 	mov	x29, sp
    a0005364:	f9000fe0 	str	x0, [sp, #24]
    a0005368:	b90017e1 	str	w1, [sp, #20]
    a000536c:	b90013e2 	str	w2, [sp, #16]
	struct z_heap_bucket *b = &h->buckets[bidx];
    a0005370:	b98013e0 	ldrsw	x0, [sp, #16]
    a0005374:	91001000 	add	x0, x0, #0x4
    a0005378:	d37ef400 	lsl	x0, x0, #2
    a000537c:	f9400fe1 	ldr	x1, [sp, #24]
    a0005380:	8b000020 	add	x0, x1, x0
    a0005384:	f90017e0 	str	x0, [sp, #40]

	CHECK(!chunk_used(h, c));
	CHECK(b->next != 0);
	CHECK(h->avail_buckets & BIT(bidx));

	if (next_free_chunk(h, c) == c) {
    a0005388:	b94017e1 	ldr	w1, [sp, #20]
    a000538c:	f9400fe0 	ldr	x0, [sp, #24]
    a0005390:	97ffff2d 	bl	a0005044 <next_free_chunk>
    a0005394:	2a0003e1 	mov	w1, w0
    a0005398:	b94017e0 	ldr	w0, [sp, #20]
    a000539c:	6b01001f 	cmp	w0, w1
    a00053a0:	540001a1 	b.ne	a00053d4 <free_list_remove_bidx+0x78>  // b.any
		/* this is the last chunk */
		h->avail_buckets &= ~BIT(bidx);
    a00053a4:	f9400fe0 	ldr	x0, [sp, #24]
    a00053a8:	b9400c01 	ldr	w1, [x0, #12]
    a00053ac:	b94013e0 	ldr	w0, [sp, #16]
    a00053b0:	d2800022 	mov	x2, #0x1                   	// #1
    a00053b4:	9ac02040 	lsl	x0, x2, x0
    a00053b8:	2a2003e0 	mvn	w0, w0
    a00053bc:	0a000021 	and	w1, w1, w0
    a00053c0:	f9400fe0 	ldr	x0, [sp, #24]
    a00053c4:	b9000c01 	str	w1, [x0, #12]
		b->next = 0;
    a00053c8:	f94017e0 	ldr	x0, [sp, #40]
    a00053cc:	b900001f 	str	wzr, [x0]
	}

#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS
	h->free_bytes -= chunksz_to_bytes(h, chunk_size(h, c));
#endif
}
    a00053d0:	14000014 	b	a0005420 <free_list_remove_bidx+0xc4>
		chunkid_t first = prev_free_chunk(h, c),
    a00053d4:	b94017e1 	ldr	w1, [sp, #20]
    a00053d8:	f9400fe0 	ldr	x0, [sp, #24]
    a00053dc:	97ffff10 	bl	a000501c <prev_free_chunk>
    a00053e0:	b90027e0 	str	w0, [sp, #36]
			  second = next_free_chunk(h, c);
    a00053e4:	b94017e1 	ldr	w1, [sp, #20]
    a00053e8:	f9400fe0 	ldr	x0, [sp, #24]
    a00053ec:	97ffff16 	bl	a0005044 <next_free_chunk>
    a00053f0:	b90023e0 	str	w0, [sp, #32]
		b->next = second;
    a00053f4:	f94017e0 	ldr	x0, [sp, #40]
    a00053f8:	b94023e1 	ldr	w1, [sp, #32]
    a00053fc:	b9000001 	str	w1, [x0]
		set_next_free_chunk(h, first, second);
    a0005400:	b94023e2 	ldr	w2, [sp, #32]
    a0005404:	b94027e1 	ldr	w1, [sp, #36]
    a0005408:	f9400fe0 	ldr	x0, [sp, #24]
    a000540c:	97ffff25 	bl	a00050a0 <set_next_free_chunk>
		set_prev_free_chunk(h, second, first);
    a0005410:	b94027e2 	ldr	w2, [sp, #36]
    a0005414:	b94023e1 	ldr	w1, [sp, #32]
    a0005418:	f9400fe0 	ldr	x0, [sp, #24]
    a000541c:	97ffff14 	bl	a000506c <set_prev_free_chunk>
}
    a0005420:	d503201f 	nop
    a0005424:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0005428:	d65f03c0 	ret

00000000a000542c <free_list_remove>:

static void free_list_remove(struct z_heap *h, chunkid_t c)
{
    a000542c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0005430:	910003fd 	mov	x29, sp
    a0005434:	f9000fe0 	str	x0, [sp, #24]
    a0005438:	b90017e1 	str	w1, [sp, #20]
	if (!solo_free_header(h, c)) {
    a000543c:	b94017e1 	ldr	w1, [sp, #20]
    a0005440:	f9400fe0 	ldr	x0, [sp, #24]
    a0005444:	97ffff4a 	bl	a000516c <solo_free_header>
    a0005448:	12001c00 	and	w0, w0, #0xff
    a000544c:	52000000 	eor	w0, w0, #0x1
    a0005450:	12001c00 	and	w0, w0, #0xff
    a0005454:	7100001f 	cmp	w0, #0x0
    a0005458:	54000180 	b.eq	a0005488 <free_list_remove+0x5c>  // b.none
		int bidx = bucket_idx(h, chunk_size(h, c));
    a000545c:	b94017e1 	ldr	w1, [sp, #20]
    a0005460:	f9400fe0 	ldr	x0, [sp, #24]
    a0005464:	97fffe98 	bl	a0004ec4 <chunk_size>
    a0005468:	2a0003e1 	mov	w1, w0
    a000546c:	f9400fe0 	ldr	x0, [sp, #24]
    a0005470:	97ffff89 	bl	a0005294 <bucket_idx>
    a0005474:	b9002fe0 	str	w0, [sp, #44]
		free_list_remove_bidx(h, c, bidx);
    a0005478:	b9402fe2 	ldr	w2, [sp, #44]
    a000547c:	b94017e1 	ldr	w1, [sp, #20]
    a0005480:	f9400fe0 	ldr	x0, [sp, #24]
    a0005484:	97ffffb6 	bl	a000535c <free_list_remove_bidx>
	}
}
    a0005488:	d503201f 	nop
    a000548c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0005490:	d65f03c0 	ret

00000000a0005494 <free_list_add_bidx>:

static void free_list_add_bidx(struct z_heap *h, chunkid_t c, int bidx)
{
    a0005494:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0005498:	910003fd 	mov	x29, sp
    a000549c:	f9000fe0 	str	x0, [sp, #24]
    a00054a0:	b90017e1 	str	w1, [sp, #20]
    a00054a4:	b90013e2 	str	w2, [sp, #16]
	struct z_heap_bucket *b = &h->buckets[bidx];
    a00054a8:	b98013e0 	ldrsw	x0, [sp, #16]
    a00054ac:	91001000 	add	x0, x0, #0x4
    a00054b0:	d37ef400 	lsl	x0, x0, #2
    a00054b4:	f9400fe1 	ldr	x1, [sp, #24]
    a00054b8:	8b000020 	add	x0, x1, x0
    a00054bc:	f90017e0 	str	x0, [sp, #40]

	if (b->next == 0U) {
    a00054c0:	f94017e0 	ldr	x0, [sp, #40]
    a00054c4:	b9400000 	ldr	w0, [x0]
    a00054c8:	7100001f 	cmp	w0, #0x0
    a00054cc:	540002a1 	b.ne	a0005520 <free_list_add_bidx+0x8c>  // b.any
		CHECK((h->avail_buckets & BIT(bidx)) == 0);

		/* Empty list, first item */
		h->avail_buckets |= BIT(bidx);
    a00054d0:	f9400fe0 	ldr	x0, [sp, #24]
    a00054d4:	b9400c00 	ldr	w0, [x0, #12]
    a00054d8:	b94013e1 	ldr	w1, [sp, #16]
    a00054dc:	d2800022 	mov	x2, #0x1                   	// #1
    a00054e0:	9ac12041 	lsl	x1, x2, x1
    a00054e4:	2a010001 	orr	w1, w0, w1
    a00054e8:	f9400fe0 	ldr	x0, [sp, #24]
    a00054ec:	b9000c01 	str	w1, [x0, #12]
		b->next = c;
    a00054f0:	f94017e0 	ldr	x0, [sp, #40]
    a00054f4:	b94017e1 	ldr	w1, [sp, #20]
    a00054f8:	b9000001 	str	w1, [x0]
		set_prev_free_chunk(h, c, c);
    a00054fc:	b94017e2 	ldr	w2, [sp, #20]
    a0005500:	b94017e1 	ldr	w1, [sp, #20]
    a0005504:	f9400fe0 	ldr	x0, [sp, #24]
    a0005508:	97fffed9 	bl	a000506c <set_prev_free_chunk>
		set_next_free_chunk(h, c, c);
    a000550c:	b94017e2 	ldr	w2, [sp, #20]
    a0005510:	b94017e1 	ldr	w1, [sp, #20]
    a0005514:	f9400fe0 	ldr	x0, [sp, #24]
    a0005518:	97fffee2 	bl	a00050a0 <set_next_free_chunk>
	}

#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS
	h->free_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
}
    a000551c:	14000018 	b	a000557c <free_list_add_bidx+0xe8>
		chunkid_t second = b->next;
    a0005520:	f94017e0 	ldr	x0, [sp, #40]
    a0005524:	b9400000 	ldr	w0, [x0]
    a0005528:	b90027e0 	str	w0, [sp, #36]
		chunkid_t first = prev_free_chunk(h, second);
    a000552c:	b94027e1 	ldr	w1, [sp, #36]
    a0005530:	f9400fe0 	ldr	x0, [sp, #24]
    a0005534:	97fffeba 	bl	a000501c <prev_free_chunk>
    a0005538:	b90023e0 	str	w0, [sp, #32]
		set_prev_free_chunk(h, c, first);
    a000553c:	b94023e2 	ldr	w2, [sp, #32]
    a0005540:	b94017e1 	ldr	w1, [sp, #20]
    a0005544:	f9400fe0 	ldr	x0, [sp, #24]
    a0005548:	97fffec9 	bl	a000506c <set_prev_free_chunk>
		set_next_free_chunk(h, c, second);
    a000554c:	b94027e2 	ldr	w2, [sp, #36]
    a0005550:	b94017e1 	ldr	w1, [sp, #20]
    a0005554:	f9400fe0 	ldr	x0, [sp, #24]
    a0005558:	97fffed2 	bl	a00050a0 <set_next_free_chunk>
		set_next_free_chunk(h, first, c);
    a000555c:	b94017e2 	ldr	w2, [sp, #20]
    a0005560:	b94023e1 	ldr	w1, [sp, #32]
    a0005564:	f9400fe0 	ldr	x0, [sp, #24]
    a0005568:	97fffece 	bl	a00050a0 <set_next_free_chunk>
		set_prev_free_chunk(h, second, c);
    a000556c:	b94017e2 	ldr	w2, [sp, #20]
    a0005570:	b94027e1 	ldr	w1, [sp, #36]
    a0005574:	f9400fe0 	ldr	x0, [sp, #24]
    a0005578:	97fffebd 	bl	a000506c <set_prev_free_chunk>
}
    a000557c:	d503201f 	nop
    a0005580:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0005584:	d65f03c0 	ret

00000000a0005588 <free_list_add>:

static void free_list_add(struct z_heap *h, chunkid_t c)
{
    a0005588:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a000558c:	910003fd 	mov	x29, sp
    a0005590:	f9000fe0 	str	x0, [sp, #24]
    a0005594:	b90017e1 	str	w1, [sp, #20]
	if (!solo_free_header(h, c)) {
    a0005598:	b94017e1 	ldr	w1, [sp, #20]
    a000559c:	f9400fe0 	ldr	x0, [sp, #24]
    a00055a0:	97fffef3 	bl	a000516c <solo_free_header>
    a00055a4:	12001c00 	and	w0, w0, #0xff
    a00055a8:	52000000 	eor	w0, w0, #0x1
    a00055ac:	12001c00 	and	w0, w0, #0xff
    a00055b0:	7100001f 	cmp	w0, #0x0
    a00055b4:	54000180 	b.eq	a00055e4 <free_list_add+0x5c>  // b.none
		int bidx = bucket_idx(h, chunk_size(h, c));
    a00055b8:	b94017e1 	ldr	w1, [sp, #20]
    a00055bc:	f9400fe0 	ldr	x0, [sp, #24]
    a00055c0:	97fffe41 	bl	a0004ec4 <chunk_size>
    a00055c4:	2a0003e1 	mov	w1, w0
    a00055c8:	f9400fe0 	ldr	x0, [sp, #24]
    a00055cc:	97ffff32 	bl	a0005294 <bucket_idx>
    a00055d0:	b9002fe0 	str	w0, [sp, #44]
		free_list_add_bidx(h, c, bidx);
    a00055d4:	b9402fe2 	ldr	w2, [sp, #44]
    a00055d8:	b94017e1 	ldr	w1, [sp, #20]
    a00055dc:	f9400fe0 	ldr	x0, [sp, #24]
    a00055e0:	97ffffad 	bl	a0005494 <free_list_add_bidx>
	}
}
    a00055e4:	d503201f 	nop
    a00055e8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a00055ec:	d65f03c0 	ret

00000000a00055f0 <split_chunks>:

/* Splits a chunk "lc" into a left chunk and a right chunk at "rc".
 * Leaves both chunks marked "free"
 */
static void split_chunks(struct z_heap *h, chunkid_t lc, chunkid_t rc)
{
    a00055f0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a00055f4:	910003fd 	mov	x29, sp
    a00055f8:	f9000fe0 	str	x0, [sp, #24]
    a00055fc:	b90017e1 	str	w1, [sp, #20]
    a0005600:	b90013e2 	str	w2, [sp, #16]
	CHECK(rc > lc);
	CHECK(rc - lc < chunk_size(h, lc));

	chunksz_t sz0 = chunk_size(h, lc);
    a0005604:	b94017e1 	ldr	w1, [sp, #20]
    a0005608:	f9400fe0 	ldr	x0, [sp, #24]
    a000560c:	97fffe2e 	bl	a0004ec4 <chunk_size>
    a0005610:	b9002fe0 	str	w0, [sp, #44]
	chunksz_t lsz = rc - lc;
    a0005614:	b94013e1 	ldr	w1, [sp, #16]
    a0005618:	b94017e0 	ldr	w0, [sp, #20]
    a000561c:	4b000020 	sub	w0, w1, w0
    a0005620:	b9002be0 	str	w0, [sp, #40]
	chunksz_t rsz = sz0 - lsz;
    a0005624:	b9402fe1 	ldr	w1, [sp, #44]
    a0005628:	b9402be0 	ldr	w0, [sp, #40]
    a000562c:	4b000020 	sub	w0, w1, w0
    a0005630:	b90027e0 	str	w0, [sp, #36]

	set_chunk_size(h, lc, lsz);
    a0005634:	b9402be2 	ldr	w2, [sp, #40]
    a0005638:	b94017e1 	ldr	w1, [sp, #20]
    a000563c:	f9400fe0 	ldr	x0, [sp, #24]
    a0005640:	97fffe68 	bl	a0004fe0 <set_chunk_size>
	set_chunk_size(h, rc, rsz);
    a0005644:	b94027e2 	ldr	w2, [sp, #36]
    a0005648:	b94013e1 	ldr	w1, [sp, #16]
    a000564c:	f9400fe0 	ldr	x0, [sp, #24]
    a0005650:	97fffe64 	bl	a0004fe0 <set_chunk_size>
	set_left_chunk_size(h, rc, lsz);
    a0005654:	b9402be2 	ldr	w2, [sp, #40]
    a0005658:	b94013e1 	ldr	w1, [sp, #16]
    a000565c:	f9400fe0 	ldr	x0, [sp, #24]
    a0005660:	97fffeb6 	bl	a0005138 <set_left_chunk_size>
	set_left_chunk_size(h, right_chunk(h, rc), rsz);
    a0005664:	b94013e1 	ldr	w1, [sp, #16]
    a0005668:	f9400fe0 	ldr	x0, [sp, #24]
    a000566c:	97fffea7 	bl	a0005108 <right_chunk>
    a0005670:	b94027e2 	ldr	w2, [sp, #36]
    a0005674:	2a0003e1 	mov	w1, w0
    a0005678:	f9400fe0 	ldr	x0, [sp, #24]
    a000567c:	97fffeaf 	bl	a0005138 <set_left_chunk_size>
}
    a0005680:	d503201f 	nop
    a0005684:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0005688:	d65f03c0 	ret

00000000a000568c <merge_chunks>:

/* Does not modify free list */
static void merge_chunks(struct z_heap *h, chunkid_t lc, chunkid_t rc)
{
    a000568c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    a0005690:	910003fd 	mov	x29, sp
    a0005694:	f9000bf3 	str	x19, [sp, #16]
    a0005698:	f90017e0 	str	x0, [sp, #40]
    a000569c:	b90027e1 	str	w1, [sp, #36]
    a00056a0:	b90023e2 	str	w2, [sp, #32]
	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
    a00056a4:	b94027e1 	ldr	w1, [sp, #36]
    a00056a8:	f94017e0 	ldr	x0, [sp, #40]
    a00056ac:	97fffe06 	bl	a0004ec4 <chunk_size>
    a00056b0:	2a0003f3 	mov	w19, w0
    a00056b4:	b94023e1 	ldr	w1, [sp, #32]
    a00056b8:	f94017e0 	ldr	x0, [sp, #40]
    a00056bc:	97fffe02 	bl	a0004ec4 <chunk_size>
    a00056c0:	0b000260 	add	w0, w19, w0
    a00056c4:	b9003fe0 	str	w0, [sp, #60]

	set_chunk_size(h, lc, newsz);
    a00056c8:	b9403fe2 	ldr	w2, [sp, #60]
    a00056cc:	b94027e1 	ldr	w1, [sp, #36]
    a00056d0:	f94017e0 	ldr	x0, [sp, #40]
    a00056d4:	97fffe43 	bl	a0004fe0 <set_chunk_size>
	set_left_chunk_size(h, right_chunk(h, rc), newsz);
    a00056d8:	b94023e1 	ldr	w1, [sp, #32]
    a00056dc:	f94017e0 	ldr	x0, [sp, #40]
    a00056e0:	97fffe8a 	bl	a0005108 <right_chunk>
    a00056e4:	b9403fe2 	ldr	w2, [sp, #60]
    a00056e8:	2a0003e1 	mov	w1, w0
    a00056ec:	f94017e0 	ldr	x0, [sp, #40]
    a00056f0:	97fffe92 	bl	a0005138 <set_left_chunk_size>
}
    a00056f4:	d503201f 	nop
    a00056f8:	f9400bf3 	ldr	x19, [sp, #16]
    a00056fc:	a8c47bfd 	ldp	x29, x30, [sp], #64
    a0005700:	d65f03c0 	ret

00000000a0005704 <free_chunk>:

static void free_chunk(struct z_heap *h, chunkid_t c)
{
    a0005704:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0005708:	910003fd 	mov	x29, sp
    a000570c:	f9000fe0 	str	x0, [sp, #24]
    a0005710:	b90017e1 	str	w1, [sp, #20]
	/* Merge with free right chunk? */
	if (!chunk_used(h, right_chunk(h, c))) {
    a0005714:	b94017e1 	ldr	w1, [sp, #20]
    a0005718:	f9400fe0 	ldr	x0, [sp, #24]
    a000571c:	97fffe7b 	bl	a0005108 <right_chunk>
    a0005720:	2a0003e1 	mov	w1, w0
    a0005724:	f9400fe0 	ldr	x0, [sp, #24]
    a0005728:	97fffdd9 	bl	a0004e8c <chunk_used>
    a000572c:	12001c00 	and	w0, w0, #0xff
    a0005730:	52000000 	eor	w0, w0, #0x1
    a0005734:	12001c00 	and	w0, w0, #0xff
    a0005738:	7100001f 	cmp	w0, #0x0
    a000573c:	540001c0 	b.eq	a0005774 <free_chunk+0x70>  // b.none
		free_list_remove(h, right_chunk(h, c));
    a0005740:	b94017e1 	ldr	w1, [sp, #20]
    a0005744:	f9400fe0 	ldr	x0, [sp, #24]
    a0005748:	97fffe70 	bl	a0005108 <right_chunk>
    a000574c:	2a0003e1 	mov	w1, w0
    a0005750:	f9400fe0 	ldr	x0, [sp, #24]
    a0005754:	97ffff36 	bl	a000542c <free_list_remove>
		merge_chunks(h, c, right_chunk(h, c));
    a0005758:	b94017e1 	ldr	w1, [sp, #20]
    a000575c:	f9400fe0 	ldr	x0, [sp, #24]
    a0005760:	97fffe6a 	bl	a0005108 <right_chunk>
    a0005764:	2a0003e2 	mov	w2, w0
    a0005768:	b94017e1 	ldr	w1, [sp, #20]
    a000576c:	f9400fe0 	ldr	x0, [sp, #24]
    a0005770:	97ffffc7 	bl	a000568c <merge_chunks>
	}

	/* Merge with free left chunk? */
	if (!chunk_used(h, left_chunk(h, c))) {
    a0005774:	b94017e1 	ldr	w1, [sp, #20]
    a0005778:	f9400fe0 	ldr	x0, [sp, #24]
    a000577c:	97fffe56 	bl	a00050d4 <left_chunk>
    a0005780:	2a0003e1 	mov	w1, w0
    a0005784:	f9400fe0 	ldr	x0, [sp, #24]
    a0005788:	97fffdc1 	bl	a0004e8c <chunk_used>
    a000578c:	12001c00 	and	w0, w0, #0xff
    a0005790:	52000000 	eor	w0, w0, #0x1
    a0005794:	12001c00 	and	w0, w0, #0xff
    a0005798:	7100001f 	cmp	w0, #0x0
    a000579c:	54000240 	b.eq	a00057e4 <free_chunk+0xe0>  // b.none
		free_list_remove(h, left_chunk(h, c));
    a00057a0:	b94017e1 	ldr	w1, [sp, #20]
    a00057a4:	f9400fe0 	ldr	x0, [sp, #24]
    a00057a8:	97fffe4b 	bl	a00050d4 <left_chunk>
    a00057ac:	2a0003e1 	mov	w1, w0
    a00057b0:	f9400fe0 	ldr	x0, [sp, #24]
    a00057b4:	97ffff1e 	bl	a000542c <free_list_remove>
		merge_chunks(h, left_chunk(h, c), c);
    a00057b8:	b94017e1 	ldr	w1, [sp, #20]
    a00057bc:	f9400fe0 	ldr	x0, [sp, #24]
    a00057c0:	97fffe45 	bl	a00050d4 <left_chunk>
    a00057c4:	b94017e2 	ldr	w2, [sp, #20]
    a00057c8:	2a0003e1 	mov	w1, w0
    a00057cc:	f9400fe0 	ldr	x0, [sp, #24]
    a00057d0:	97ffffaf 	bl	a000568c <merge_chunks>
		c = left_chunk(h, c);
    a00057d4:	b94017e1 	ldr	w1, [sp, #20]
    a00057d8:	f9400fe0 	ldr	x0, [sp, #24]
    a00057dc:	97fffe3e 	bl	a00050d4 <left_chunk>
    a00057e0:	b90017e0 	str	w0, [sp, #20]
	}

	free_list_add(h, c);
    a00057e4:	b94017e1 	ldr	w1, [sp, #20]
    a00057e8:	f9400fe0 	ldr	x0, [sp, #24]
    a00057ec:	97ffff67 	bl	a0005588 <free_list_add>
}
    a00057f0:	d503201f 	nop
    a00057f4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a00057f8:	d65f03c0 	ret

00000000a00057fc <mem_to_chunkid>:
 * Here "closest" is only meaningful in the context of sys_heap_aligned_alloc()
 * where wanted alignment might not always correspond to a chunk header
 * boundary.
 */
static chunkid_t mem_to_chunkid(struct z_heap *h, void *p)
{
    a00057fc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0005800:	910003fd 	mov	x29, sp
    a0005804:	f9000fe0 	str	x0, [sp, #24]
    a0005808:	f9000be1 	str	x1, [sp, #16]
	uint8_t *mem = p, *base = (uint8_t *)chunk_buf(h);
    a000580c:	f9400be0 	ldr	x0, [sp, #16]
    a0005810:	f90017e0 	str	x0, [sp, #40]
    a0005814:	f9400fe0 	ldr	x0, [sp, #24]
    a0005818:	97fffd53 	bl	a0004d64 <chunk_buf>
    a000581c:	f90013e0 	str	x0, [sp, #32]
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
    a0005820:	f9400fe0 	ldr	x0, [sp, #24]
    a0005824:	97fffe67 	bl	a00051c0 <chunk_header_bytes>
    a0005828:	cb0003e0 	neg	x0, x0
    a000582c:	f94017e1 	ldr	x1, [sp, #40]
    a0005830:	8b000021 	add	x1, x1, x0
    a0005834:	f94013e0 	ldr	x0, [sp, #32]
    a0005838:	cb000020 	sub	x0, x1, x0
    a000583c:	91001c01 	add	x1, x0, #0x7
    a0005840:	f100001f 	cmp	x0, #0x0
    a0005844:	9a80b020 	csel	x0, x1, x0, lt  // lt = tstop
    a0005848:	9343fc00 	asr	x0, x0, #3
}
    a000584c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0005850:	d65f03c0 	ret

00000000a0005854 <sys_heap_free>:

void sys_heap_free(struct sys_heap *heap, void *mem)
{
    a0005854:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0005858:	910003fd 	mov	x29, sp
    a000585c:	f9000fe0 	str	x0, [sp, #24]
    a0005860:	f9000be1 	str	x1, [sp, #16]
	if (mem == NULL) {
    a0005864:	f9400be0 	ldr	x0, [sp, #16]
    a0005868:	f100001f 	cmp	x0, #0x0
    a000586c:	54000200 	b.eq	a00058ac <sys_heap_free+0x58>  // b.none
		return; /* ISO C free() semantics */
	}
	struct z_heap *h = heap->heap;
    a0005870:	f9400fe0 	ldr	x0, [sp, #24]
    a0005874:	f9400000 	ldr	x0, [x0]
    a0005878:	f90017e0 	str	x0, [sp, #40]
	chunkid_t c = mem_to_chunkid(h, mem);
    a000587c:	f9400be1 	ldr	x1, [sp, #16]
    a0005880:	f94017e0 	ldr	x0, [sp, #40]
    a0005884:	97ffffde 	bl	a00057fc <mem_to_chunkid>
    a0005888:	b90027e0 	str	w0, [sp, #36]
	 */
	__ASSERT(left_chunk(h, right_chunk(h, c)) == c,
		 "corrupted heap bounds (buffer overflow?) for memory at %p",
		 mem);

	set_chunk_used(h, c, false);
    a000588c:	52800002 	mov	w2, #0x0                   	// #0
    a0005890:	b94027e1 	ldr	w1, [sp, #36]
    a0005894:	f94017e0 	ldr	x0, [sp, #40]
    a0005898:	97fffd96 	bl	a0004ef0 <set_chunk_used>
#ifdef CONFIG_SYS_HEAP_LISTENER
	heap_listener_notify_free(HEAP_ID_FROM_POINTER(heap), mem,
				  chunksz_to_bytes(h, chunk_size(h, c)));
#endif

	free_chunk(h, c);
    a000589c:	b94027e1 	ldr	w1, [sp, #36]
    a00058a0:	f94017e0 	ldr	x0, [sp, #40]
    a00058a4:	97ffff98 	bl	a0005704 <free_chunk>
    a00058a8:	14000002 	b	a00058b0 <sys_heap_free+0x5c>
		return; /* ISO C free() semantics */
    a00058ac:	d503201f 	nop
}
    a00058b0:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a00058b4:	d65f03c0 	ret

00000000a00058b8 <alloc_chunk>:

	return chunk_sz - (addr - chunk_base);
}

static chunkid_t alloc_chunk(struct z_heap *h, chunksz_t sz)
{
    a00058b8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a00058bc:	910003fd 	mov	x29, sp
    a00058c0:	f9000fe0 	str	x0, [sp, #24]
    a00058c4:	b90017e1 	str	w1, [sp, #20]
	int bi = bucket_idx(h, sz);
    a00058c8:	b94017e1 	ldr	w1, [sp, #20]
    a00058cc:	f9400fe0 	ldr	x0, [sp, #24]
    a00058d0:	97fffe71 	bl	a0005294 <bucket_idx>
    a00058d4:	b9004be0 	str	w0, [sp, #72]
	struct z_heap_bucket *b = &h->buckets[bi];
    a00058d8:	b9804be0 	ldrsw	x0, [sp, #72]
    a00058dc:	91001000 	add	x0, x0, #0x4
    a00058e0:	d37ef400 	lsl	x0, x0, #2
    a00058e4:	f9400fe1 	ldr	x1, [sp, #24]
    a00058e8:	8b000020 	add	x0, x1, x0
    a00058ec:	f90023e0 	str	x0, [sp, #64]
	 * course.  But even in pathological situations we still
	 * maintain our constant time performance and at worst see
	 * fragmentation waste of the order of the block allocated
	 * only.
	 */
	if (b->next) {
    a00058f0:	f94023e0 	ldr	x0, [sp, #64]
    a00058f4:	b9400000 	ldr	w0, [x0]
    a00058f8:	7100001f 	cmp	w0, #0x0
    a00058fc:	540004e0 	b.eq	a0005998 <alloc_chunk+0xe0>  // b.none
		chunkid_t first = b->next;
    a0005900:	f94023e0 	ldr	x0, [sp, #64]
    a0005904:	b9400000 	ldr	w0, [x0]
    a0005908:	b9003fe0 	str	w0, [sp, #60]
		int i = CONFIG_SYS_HEAP_ALLOC_LOOPS;
    a000590c:	52800060 	mov	w0, #0x3                   	// #3
    a0005910:	b9004fe0 	str	w0, [sp, #76]
		do {
			chunkid_t c = b->next;
    a0005914:	f94023e0 	ldr	x0, [sp, #64]
    a0005918:	b9400000 	ldr	w0, [x0]
    a000591c:	b9003be0 	str	w0, [sp, #56]
			if (chunk_size(h, c) >= sz) {
    a0005920:	b9403be1 	ldr	w1, [sp, #56]
    a0005924:	f9400fe0 	ldr	x0, [sp, #24]
    a0005928:	97fffd67 	bl	a0004ec4 <chunk_size>
    a000592c:	2a0003e1 	mov	w1, w0
    a0005930:	b94017e0 	ldr	w0, [sp, #20]
    a0005934:	6b01001f 	cmp	w0, w1
    a0005938:	540000e8 	b.hi	a0005954 <alloc_chunk+0x9c>  // b.pmore
				free_list_remove_bidx(h, c, bi);
    a000593c:	b9404be2 	ldr	w2, [sp, #72]
    a0005940:	b9403be1 	ldr	w1, [sp, #56]
    a0005944:	f9400fe0 	ldr	x0, [sp, #24]
    a0005948:	97fffe85 	bl	a000535c <free_list_remove_bidx>
				return c;
    a000594c:	b9403be0 	ldr	w0, [sp, #56]
    a0005950:	1400002e 	b	a0005a08 <alloc_chunk+0x150>
			}
			b->next = next_free_chunk(h, c);
    a0005954:	b9403be1 	ldr	w1, [sp, #56]
    a0005958:	f9400fe0 	ldr	x0, [sp, #24]
    a000595c:	97fffdba 	bl	a0005044 <next_free_chunk>
    a0005960:	2a0003e1 	mov	w1, w0
    a0005964:	f94023e0 	ldr	x0, [sp, #64]
    a0005968:	b9000001 	str	w1, [x0]
			CHECK(b->next != 0);
		} while (--i && b->next != first);
    a000596c:	b9404fe0 	ldr	w0, [sp, #76]
    a0005970:	51000400 	sub	w0, w0, #0x1
    a0005974:	b9004fe0 	str	w0, [sp, #76]
    a0005978:	b9404fe0 	ldr	w0, [sp, #76]
    a000597c:	7100001f 	cmp	w0, #0x0
    a0005980:	540000c0 	b.eq	a0005998 <alloc_chunk+0xe0>  // b.none
    a0005984:	f94023e0 	ldr	x0, [sp, #64]
    a0005988:	b9400000 	ldr	w0, [x0]
    a000598c:	b9403fe1 	ldr	w1, [sp, #60]
    a0005990:	6b00003f 	cmp	w1, w0
    a0005994:	54fffc01 	b.ne	a0005914 <alloc_chunk+0x5c>  // b.any
	}

	/* Otherwise pick the smallest non-empty bucket guaranteed to
	 * fit and use that unconditionally.
	 */
	uint32_t bmask = h->avail_buckets & ~BIT_MASK(bi + 1);
    a0005998:	f9400fe0 	ldr	x0, [sp, #24]
    a000599c:	b9400c01 	ldr	w1, [x0, #12]
    a00059a0:	b9404be0 	ldr	w0, [sp, #72]
    a00059a4:	11000400 	add	w0, w0, #0x1
    a00059a8:	d2800022 	mov	x2, #0x1                   	// #1
    a00059ac:	9ac02040 	lsl	x0, x2, x0
    a00059b0:	4b0003e0 	neg	w0, w0
    a00059b4:	0a000020 	and	w0, w1, w0
    a00059b8:	b90037e0 	str	w0, [sp, #52]

	if (bmask != 0U) {
    a00059bc:	b94037e0 	ldr	w0, [sp, #52]
    a00059c0:	7100001f 	cmp	w0, #0x0
    a00059c4:	54000200 	b.eq	a0005a04 <alloc_chunk+0x14c>  // b.none
		int minbucket = __builtin_ctz(bmask);
    a00059c8:	b94037e0 	ldr	w0, [sp, #52]
    a00059cc:	5ac00000 	rbit	w0, w0
    a00059d0:	5ac01000 	clz	w0, w0
    a00059d4:	b90033e0 	str	w0, [sp, #48]
		chunkid_t c = h->buckets[minbucket].next;
    a00059d8:	f9400fe0 	ldr	x0, [sp, #24]
    a00059dc:	b98033e1 	ldrsw	x1, [sp, #48]
    a00059e0:	91001021 	add	x1, x1, #0x4
    a00059e4:	b8617800 	ldr	w0, [x0, x1, lsl #2]
    a00059e8:	b9002fe0 	str	w0, [sp, #44]

		free_list_remove_bidx(h, c, minbucket);
    a00059ec:	b94033e2 	ldr	w2, [sp, #48]
    a00059f0:	b9402fe1 	ldr	w1, [sp, #44]
    a00059f4:	f9400fe0 	ldr	x0, [sp, #24]
    a00059f8:	97fffe59 	bl	a000535c <free_list_remove_bidx>
		CHECK(chunk_size(h, c) >= sz);
		return c;
    a00059fc:	b9402fe0 	ldr	w0, [sp, #44]
    a0005a00:	14000002 	b	a0005a08 <alloc_chunk+0x150>
	}

	return 0;
    a0005a04:	52800000 	mov	w0, #0x0                   	// #0
}
    a0005a08:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a0005a0c:	d65f03c0 	ret

00000000a0005a10 <sys_heap_alloc>:

void *sys_heap_alloc(struct sys_heap *heap, size_t bytes)
{
    a0005a10:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    a0005a14:	910003fd 	mov	x29, sp
    a0005a18:	f9000fe0 	str	x0, [sp, #24]
    a0005a1c:	f9000be1 	str	x1, [sp, #16]
	struct z_heap *h = heap->heap;
    a0005a20:	f9400fe0 	ldr	x0, [sp, #24]
    a0005a24:	f9400000 	ldr	x0, [x0]
    a0005a28:	f9001fe0 	str	x0, [sp, #56]
	void *mem;

	if (bytes == 0U || size_too_big(h, bytes)) {
    a0005a2c:	f9400be0 	ldr	x0, [sp, #16]
    a0005a30:	f100001f 	cmp	x0, #0x0
    a0005a34:	540000e0 	b.eq	a0005a50 <sys_heap_alloc+0x40>  // b.none
    a0005a38:	f9400be1 	ldr	x1, [sp, #16]
    a0005a3c:	f9401fe0 	ldr	x0, [sp, #56]
    a0005a40:	97fffe26 	bl	a00052d8 <size_too_big>
    a0005a44:	12001c00 	and	w0, w0, #0xff
    a0005a48:	7100001f 	cmp	w0, #0x0
    a0005a4c:	54000060 	b.eq	a0005a58 <sys_heap_alloc+0x48>  // b.none
		return NULL;
    a0005a50:	d2800000 	mov	x0, #0x0                   	// #0
    a0005a54:	1400002b 	b	a0005b00 <sys_heap_alloc+0xf0>
	}

	chunksz_t chunk_sz = bytes_to_chunksz(h, bytes);
    a0005a58:	f9400be1 	ldr	x1, [sp, #16]
    a0005a5c:	f9401fe0 	ldr	x0, [sp, #56]
    a0005a60:	97fffdf9 	bl	a0005244 <bytes_to_chunksz>
    a0005a64:	b90037e0 	str	w0, [sp, #52]
	chunkid_t c = alloc_chunk(h, chunk_sz);
    a0005a68:	b94037e1 	ldr	w1, [sp, #52]
    a0005a6c:	f9401fe0 	ldr	x0, [sp, #56]
    a0005a70:	97ffff92 	bl	a00058b8 <alloc_chunk>
    a0005a74:	b90033e0 	str	w0, [sp, #48]
	if (c == 0U) {
    a0005a78:	b94033e0 	ldr	w0, [sp, #48]
    a0005a7c:	7100001f 	cmp	w0, #0x0
    a0005a80:	54000061 	b.ne	a0005a8c <sys_heap_alloc+0x7c>  // b.any
		return NULL;
    a0005a84:	d2800000 	mov	x0, #0x0                   	// #0
    a0005a88:	1400001e 	b	a0005b00 <sys_heap_alloc+0xf0>
	}

	/* Split off remainder if any */
	if (chunk_size(h, c) > chunk_sz) {
    a0005a8c:	b94033e1 	ldr	w1, [sp, #48]
    a0005a90:	f9401fe0 	ldr	x0, [sp, #56]
    a0005a94:	97fffd0c 	bl	a0004ec4 <chunk_size>
    a0005a98:	2a0003e1 	mov	w1, w0
    a0005a9c:	b94037e0 	ldr	w0, [sp, #52]
    a0005aa0:	6b01001f 	cmp	w0, w1
    a0005aa4:	540001c2 	b.cs	a0005adc <sys_heap_alloc+0xcc>  // b.hs, b.nlast
		split_chunks(h, c, c + chunk_sz);
    a0005aa8:	b94033e1 	ldr	w1, [sp, #48]
    a0005aac:	b94037e0 	ldr	w0, [sp, #52]
    a0005ab0:	0b000020 	add	w0, w1, w0
    a0005ab4:	2a0003e2 	mov	w2, w0
    a0005ab8:	b94033e1 	ldr	w1, [sp, #48]
    a0005abc:	f9401fe0 	ldr	x0, [sp, #56]
    a0005ac0:	97fffecc 	bl	a00055f0 <split_chunks>
		free_list_add(h, c + chunk_sz);
    a0005ac4:	b94033e1 	ldr	w1, [sp, #48]
    a0005ac8:	b94037e0 	ldr	w0, [sp, #52]
    a0005acc:	0b000020 	add	w0, w1, w0
    a0005ad0:	2a0003e1 	mov	w1, w0
    a0005ad4:	f9401fe0 	ldr	x0, [sp, #56]
    a0005ad8:	97fffeac 	bl	a0005588 <free_list_add>
	}

	set_chunk_used(h, c, true);
    a0005adc:	52800022 	mov	w2, #0x1                   	// #1
    a0005ae0:	b94033e1 	ldr	w1, [sp, #48]
    a0005ae4:	f9401fe0 	ldr	x0, [sp, #56]
    a0005ae8:	97fffd02 	bl	a0004ef0 <set_chunk_used>

	mem = chunk_mem(h, c);
    a0005aec:	b94033e1 	ldr	w1, [sp, #48]
    a0005af0:	f9401fe0 	ldr	x0, [sp, #56]
    a0005af4:	97fffe06 	bl	a000530c <chunk_mem>
    a0005af8:	f90017e0 	str	x0, [sp, #40]
#ifdef CONFIG_SYS_HEAP_LISTENER
	heap_listener_notify_alloc(HEAP_ID_FROM_POINTER(heap), mem,
				   chunksz_to_bytes(h, chunk_size(h, c)));
#endif

	return mem;
    a0005afc:	f94017e0 	ldr	x0, [sp, #40]
}
    a0005b00:	a8c47bfd 	ldp	x29, x30, [sp], #64
    a0005b04:	d65f03c0 	ret

00000000a0005b08 <sys_heap_aligned_alloc>:

void *sys_heap_aligned_alloc(struct sys_heap *heap, size_t align, size_t bytes)
{
    a0005b08:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    a0005b0c:	910003fd 	mov	x29, sp
    a0005b10:	f90017e0 	str	x0, [sp, #40]
    a0005b14:	f90013e1 	str	x1, [sp, #32]
    a0005b18:	f9000fe2 	str	x2, [sp, #24]
	struct z_heap *h = heap->heap;
    a0005b1c:	f94017e0 	ldr	x0, [sp, #40]
    a0005b20:	f9400000 	ldr	x0, [x0]
    a0005b24:	f9002fe0 	str	x0, [sp, #88]
	 * We allow for one bit of rewind in addition to the alignment
	 * value to efficiently accommodate z_heap_aligned_alloc().
	 * So if e.g. align = 0x28 (32 | 8) this means we align to a 32-byte
	 * boundary and then rewind 8 bytes.
	 */
	rew = align & -align;
    a0005b28:	f94013e0 	ldr	x0, [sp, #32]
    a0005b2c:	cb0003e0 	neg	x0, x0
    a0005b30:	f94013e1 	ldr	x1, [sp, #32]
    a0005b34:	8a000020 	and	x0, x1, x0
    a0005b38:	f90033e0 	str	x0, [sp, #96]
	if (align != rew) {
    a0005b3c:	f94013e1 	ldr	x1, [sp, #32]
    a0005b40:	f94033e0 	ldr	x0, [sp, #96]
    a0005b44:	eb00003f 	cmp	x1, x0
    a0005b48:	54000220 	b.eq	a0005b8c <sys_heap_aligned_alloc+0x84>  // b.none
		align -= rew;
    a0005b4c:	f94013e1 	ldr	x1, [sp, #32]
    a0005b50:	f94033e0 	ldr	x0, [sp, #96]
    a0005b54:	cb000020 	sub	x0, x1, x0
    a0005b58:	f90013e0 	str	x0, [sp, #32]
		gap = MIN(rew, chunk_header_bytes(h));
    a0005b5c:	f9402fe0 	ldr	x0, [sp, #88]
    a0005b60:	97fffd98 	bl	a00051c0 <chunk_header_bytes>
    a0005b64:	aa0003e1 	mov	x1, x0
    a0005b68:	f94033e0 	ldr	x0, [sp, #96]
    a0005b6c:	eb01001f 	cmp	x0, x1
    a0005b70:	54000083 	b.cc	a0005b80 <sys_heap_aligned_alloc+0x78>  // b.lo, b.ul, b.last
    a0005b74:	f9402fe0 	ldr	x0, [sp, #88]
    a0005b78:	97fffd92 	bl	a00051c0 <chunk_header_bytes>
    a0005b7c:	14000002 	b	a0005b84 <sys_heap_aligned_alloc+0x7c>
    a0005b80:	f94033e0 	ldr	x0, [sp, #96]
    a0005b84:	f90037e0 	str	x0, [sp, #104]
    a0005b88:	1400000f 	b	a0005bc4 <sys_heap_aligned_alloc+0xbc>
	} else {
		if (align <= chunk_header_bytes(h)) {
    a0005b8c:	f9402fe0 	ldr	x0, [sp, #88]
    a0005b90:	97fffd8c 	bl	a00051c0 <chunk_header_bytes>
    a0005b94:	aa0003e1 	mov	x1, x0
    a0005b98:	f94013e0 	ldr	x0, [sp, #32]
    a0005b9c:	eb01001f 	cmp	x0, x1
    a0005ba0:	540000a8 	b.hi	a0005bb4 <sys_heap_aligned_alloc+0xac>  // b.pmore
			return sys_heap_alloc(heap, bytes);
    a0005ba4:	f9400fe1 	ldr	x1, [sp, #24]
    a0005ba8:	f94017e0 	ldr	x0, [sp, #40]
    a0005bac:	97ffff99 	bl	a0005a10 <sys_heap_alloc>
    a0005bb0:	14000062 	b	a0005d38 <sys_heap_aligned_alloc+0x230>
		}
		rew = 0;
    a0005bb4:	f90033ff 	str	xzr, [sp, #96]
		gap = chunk_header_bytes(h);
    a0005bb8:	f9402fe0 	ldr	x0, [sp, #88]
    a0005bbc:	97fffd81 	bl	a00051c0 <chunk_header_bytes>
    a0005bc0:	f90037e0 	str	x0, [sp, #104]
	}
	__ASSERT((align & (align - 1)) == 0, "align must be a power of 2");

	if (bytes == 0 || size_too_big(h, bytes)) {
    a0005bc4:	f9400fe0 	ldr	x0, [sp, #24]
    a0005bc8:	f100001f 	cmp	x0, #0x0
    a0005bcc:	540000e0 	b.eq	a0005be8 <sys_heap_aligned_alloc+0xe0>  // b.none
    a0005bd0:	f9400fe1 	ldr	x1, [sp, #24]
    a0005bd4:	f9402fe0 	ldr	x0, [sp, #88]
    a0005bd8:	97fffdc0 	bl	a00052d8 <size_too_big>
    a0005bdc:	12001c00 	and	w0, w0, #0xff
    a0005be0:	7100001f 	cmp	w0, #0x0
    a0005be4:	54000060 	b.eq	a0005bf0 <sys_heap_aligned_alloc+0xe8>  // b.none
		return NULL;
    a0005be8:	d2800000 	mov	x0, #0x0                   	// #0
    a0005bec:	14000053 	b	a0005d38 <sys_heap_aligned_alloc+0x230>
	/*
	 * Find a free block that is guaranteed to fit.
	 * We over-allocate to account for alignment and then free
	 * the extra allocations afterwards.
	 */
	chunksz_t padded_sz = bytes_to_chunksz(h, bytes + align - gap);
    a0005bf0:	f9400fe1 	ldr	x1, [sp, #24]
    a0005bf4:	f94013e0 	ldr	x0, [sp, #32]
    a0005bf8:	8b000021 	add	x1, x1, x0
    a0005bfc:	f94037e0 	ldr	x0, [sp, #104]
    a0005c00:	cb000020 	sub	x0, x1, x0
    a0005c04:	aa0003e1 	mov	x1, x0
    a0005c08:	f9402fe0 	ldr	x0, [sp, #88]
    a0005c0c:	97fffd8e 	bl	a0005244 <bytes_to_chunksz>
    a0005c10:	b90057e0 	str	w0, [sp, #84]
	chunkid_t c0 = alloc_chunk(h, padded_sz);
    a0005c14:	b94057e1 	ldr	w1, [sp, #84]
    a0005c18:	f9402fe0 	ldr	x0, [sp, #88]
    a0005c1c:	97ffff27 	bl	a00058b8 <alloc_chunk>
    a0005c20:	b90053e0 	str	w0, [sp, #80]

	if (c0 == 0) {
    a0005c24:	b94053e0 	ldr	w0, [sp, #80]
    a0005c28:	7100001f 	cmp	w0, #0x0
    a0005c2c:	54000061 	b.ne	a0005c38 <sys_heap_aligned_alloc+0x130>  // b.any
		return NULL;
    a0005c30:	d2800000 	mov	x0, #0x0                   	// #0
    a0005c34:	14000041 	b	a0005d38 <sys_heap_aligned_alloc+0x230>
	}
	uint8_t *mem = chunk_mem(h, c0);
    a0005c38:	b94053e1 	ldr	w1, [sp, #80]
    a0005c3c:	f9402fe0 	ldr	x0, [sp, #88]
    a0005c40:	97fffdb3 	bl	a000530c <chunk_mem>
    a0005c44:	f90027e0 	str	x0, [sp, #72]

	/* Align allocated memory */
	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
    a0005c48:	f94027e1 	ldr	x1, [sp, #72]
    a0005c4c:	f94033e0 	ldr	x0, [sp, #96]
    a0005c50:	8b000020 	add	x0, x1, x0
    a0005c54:	aa0003e1 	mov	x1, x0
    a0005c58:	f94013e0 	ldr	x0, [sp, #32]
    a0005c5c:	8b000020 	add	x0, x1, x0
    a0005c60:	d1000401 	sub	x1, x0, #0x1
    a0005c64:	f94013e0 	ldr	x0, [sp, #32]
    a0005c68:	cb0003e0 	neg	x0, x0
    a0005c6c:	8a000021 	and	x1, x1, x0
    a0005c70:	f94033e0 	ldr	x0, [sp, #96]
    a0005c74:	cb000020 	sub	x0, x1, x0
    a0005c78:	f90027e0 	str	x0, [sp, #72]
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
    a0005c7c:	f94027e1 	ldr	x1, [sp, #72]
    a0005c80:	f9400fe0 	ldr	x0, [sp, #24]
    a0005c84:	8b000020 	add	x0, x1, x0
    a0005c88:	91001c00 	add	x0, x0, #0x7
    a0005c8c:	927df000 	and	x0, x0, #0xfffffffffffffff8
    a0005c90:	f90023e0 	str	x0, [sp, #64]

	/* Get corresponding chunks */
	chunkid_t c = mem_to_chunkid(h, mem);
    a0005c94:	f94027e1 	ldr	x1, [sp, #72]
    a0005c98:	f9402fe0 	ldr	x0, [sp, #88]
    a0005c9c:	97fffed8 	bl	a00057fc <mem_to_chunkid>
    a0005ca0:	b9003fe0 	str	w0, [sp, #60]
	chunkid_t c_end = end - chunk_buf(h);
    a0005ca4:	f9402fe0 	ldr	x0, [sp, #88]
    a0005ca8:	97fffc2f 	bl	a0004d64 <chunk_buf>
    a0005cac:	aa0003e1 	mov	x1, x0
    a0005cb0:	f94023e0 	ldr	x0, [sp, #64]
    a0005cb4:	cb010000 	sub	x0, x0, x1
    a0005cb8:	9343fc00 	asr	x0, x0, #3
    a0005cbc:	b9003be0 	str	w0, [sp, #56]
	CHECK(c >= c0 && c  < c_end && c_end <= c0 + padded_sz);

	/* Split and free unused prefix */
	if (c > c0) {
    a0005cc0:	b9403fe1 	ldr	w1, [sp, #60]
    a0005cc4:	b94053e0 	ldr	w0, [sp, #80]
    a0005cc8:	6b00003f 	cmp	w1, w0
    a0005ccc:	54000109 	b.ls	a0005cec <sys_heap_aligned_alloc+0x1e4>  // b.plast
		split_chunks(h, c0, c);
    a0005cd0:	b9403fe2 	ldr	w2, [sp, #60]
    a0005cd4:	b94053e1 	ldr	w1, [sp, #80]
    a0005cd8:	f9402fe0 	ldr	x0, [sp, #88]
    a0005cdc:	97fffe45 	bl	a00055f0 <split_chunks>
		free_list_add(h, c0);
    a0005ce0:	b94053e1 	ldr	w1, [sp, #80]
    a0005ce4:	f9402fe0 	ldr	x0, [sp, #88]
    a0005ce8:	97fffe28 	bl	a0005588 <free_list_add>
	}

	/* Split and free unused suffix */
	if (right_chunk(h, c) > c_end) {
    a0005cec:	b9403fe1 	ldr	w1, [sp, #60]
    a0005cf0:	f9402fe0 	ldr	x0, [sp, #88]
    a0005cf4:	97fffd05 	bl	a0005108 <right_chunk>
    a0005cf8:	2a0003e1 	mov	w1, w0
    a0005cfc:	b9403be0 	ldr	w0, [sp, #56]
    a0005d00:	6b01001f 	cmp	w0, w1
    a0005d04:	54000102 	b.cs	a0005d24 <sys_heap_aligned_alloc+0x21c>  // b.hs, b.nlast
		split_chunks(h, c, c_end);
    a0005d08:	b9403be2 	ldr	w2, [sp, #56]
    a0005d0c:	b9403fe1 	ldr	w1, [sp, #60]
    a0005d10:	f9402fe0 	ldr	x0, [sp, #88]
    a0005d14:	97fffe37 	bl	a00055f0 <split_chunks>
		free_list_add(h, c_end);
    a0005d18:	b9403be1 	ldr	w1, [sp, #56]
    a0005d1c:	f9402fe0 	ldr	x0, [sp, #88]
    a0005d20:	97fffe1a 	bl	a0005588 <free_list_add>
	}

	set_chunk_used(h, c, true);
    a0005d24:	52800022 	mov	w2, #0x1                   	// #1
    a0005d28:	b9403fe1 	ldr	w1, [sp, #60]
    a0005d2c:	f9402fe0 	ldr	x0, [sp, #88]
    a0005d30:	97fffc70 	bl	a0004ef0 <set_chunk_used>
#ifdef CONFIG_SYS_HEAP_LISTENER
	heap_listener_notify_alloc(HEAP_ID_FROM_POINTER(heap), mem,
				   chunksz_to_bytes(h, chunk_size(h, c)));
#endif

	return mem;
    a0005d34:	f94027e0 	ldr	x0, [sp, #72]
}
    a0005d38:	a8c77bfd 	ldp	x29, x30, [sp], #112
    a0005d3c:	d65f03c0 	ret

00000000a0005d40 <sys_heap_init>:
	}
	return ptr2;
}

void sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes)
{
    a0005d40:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a0005d44:	910003fd 	mov	x29, sp
    a0005d48:	f90017e0 	str	x0, [sp, #40]
    a0005d4c:	f90013e1 	str	x1, [sp, #32]
    a0005d50:	f9000fe2 	str	x2, [sp, #24]
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffffffU, "heap size is too big");
	}

	/* Reserve the end marker chunk's header */
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
	bytes -= heap_footer_bytes(bytes);
    a0005d54:	f9400fe0 	ldr	x0, [sp, #24]
    a0005d58:	97fffd27 	bl	a00051f4 <heap_footer_bytes>
    a0005d5c:	aa0003e1 	mov	x1, x0
    a0005d60:	f9400fe0 	ldr	x0, [sp, #24]
    a0005d64:	cb010000 	sub	x0, x0, x1
    a0005d68:	f9000fe0 	str	x0, [sp, #24]

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
    a0005d6c:	f94013e0 	ldr	x0, [sp, #32]
    a0005d70:	91001c00 	add	x0, x0, #0x7
    a0005d74:	927df000 	and	x0, x0, #0xfffffffffffffff8
    a0005d78:	f9002be0 	str	x0, [sp, #80]
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
    a0005d7c:	f94013e1 	ldr	x1, [sp, #32]
    a0005d80:	f9400fe0 	ldr	x0, [sp, #24]
    a0005d84:	8b000020 	add	x0, x1, x0
    a0005d88:	927df000 	and	x0, x0, #0xfffffffffffffff8
    a0005d8c:	f90027e0 	str	x0, [sp, #72]
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
    a0005d90:	f94027e1 	ldr	x1, [sp, #72]
    a0005d94:	f9402be0 	ldr	x0, [sp, #80]
    a0005d98:	cb000020 	sub	x0, x1, x0
    a0005d9c:	d343fc00 	lsr	x0, x0, #3
    a0005da0:	b90047e0 	str	w0, [sp, #68]

	CHECK(end > addr);
	__ASSERT(heap_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");

	struct z_heap *h = (struct z_heap *)addr;
    a0005da4:	f9402be0 	ldr	x0, [sp, #80]
    a0005da8:	f9001fe0 	str	x0, [sp, #56]
	heap->heap = h;
    a0005dac:	f94017e0 	ldr	x0, [sp, #40]
    a0005db0:	f9401fe1 	ldr	x1, [sp, #56]
    a0005db4:	f9000001 	str	x1, [x0]
	h->end_chunk = heap_sz;
    a0005db8:	f9401fe0 	ldr	x0, [sp, #56]
    a0005dbc:	b94047e1 	ldr	w1, [sp, #68]
    a0005dc0:	b9000801 	str	w1, [x0, #8]
	h->avail_buckets = 0;
    a0005dc4:	f9401fe0 	ldr	x0, [sp, #56]
    a0005dc8:	b9000c1f 	str	wzr, [x0, #12]
#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS
	h->free_bytes = 0;
	h->allocated_bytes = 0;
#endif

	int nb_buckets = bucket_idx(h, heap_sz) + 1;
    a0005dcc:	b94047e1 	ldr	w1, [sp, #68]
    a0005dd0:	f9401fe0 	ldr	x0, [sp, #56]
    a0005dd4:	97fffd30 	bl	a0005294 <bucket_idx>
    a0005dd8:	11000400 	add	w0, w0, #0x1
    a0005ddc:	b90037e0 	str	w0, [sp, #52]
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
    a0005de0:	b98037e0 	ldrsw	x0, [sp, #52]
    a0005de4:	91001000 	add	x0, x0, #0x4
    a0005de8:	d37ef400 	lsl	x0, x0, #2
    a0005dec:	97fffd0f 	bl	a0005228 <chunksz>
    a0005df0:	b90033e0 	str	w0, [sp, #48]
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, "heap size is too small");

	for (int i = 0; i < nb_buckets; i++) {
    a0005df4:	b9005fff 	str	wzr, [sp, #92]
    a0005df8:	14000008 	b	a0005e18 <sys_heap_init+0xd8>
		h->buckets[i].next = 0;
    a0005dfc:	f9401fe0 	ldr	x0, [sp, #56]
    a0005e00:	b9805fe1 	ldrsw	x1, [sp, #92]
    a0005e04:	91001021 	add	x1, x1, #0x4
    a0005e08:	b821781f 	str	wzr, [x0, x1, lsl #2]
	for (int i = 0; i < nb_buckets; i++) {
    a0005e0c:	b9405fe0 	ldr	w0, [sp, #92]
    a0005e10:	11000400 	add	w0, w0, #0x1
    a0005e14:	b9005fe0 	str	w0, [sp, #92]
    a0005e18:	b9405fe1 	ldr	w1, [sp, #92]
    a0005e1c:	b94037e0 	ldr	w0, [sp, #52]
    a0005e20:	6b00003f 	cmp	w1, w0
    a0005e24:	54fffecb 	b.lt	a0005dfc <sys_heap_init+0xbc>  // b.tstop
	}

	/* chunk containing our struct z_heap */
	set_chunk_size(h, 0, chunk0_size);
    a0005e28:	b94033e2 	ldr	w2, [sp, #48]
    a0005e2c:	52800001 	mov	w1, #0x0                   	// #0
    a0005e30:	f9401fe0 	ldr	x0, [sp, #56]
    a0005e34:	97fffc6b 	bl	a0004fe0 <set_chunk_size>
	set_left_chunk_size(h, 0, 0);
    a0005e38:	52800002 	mov	w2, #0x0                   	// #0
    a0005e3c:	52800001 	mov	w1, #0x0                   	// #0
    a0005e40:	f9401fe0 	ldr	x0, [sp, #56]
    a0005e44:	97fffcbd 	bl	a0005138 <set_left_chunk_size>
	set_chunk_used(h, 0, true);
    a0005e48:	52800022 	mov	w2, #0x1                   	// #1
    a0005e4c:	52800001 	mov	w1, #0x0                   	// #0
    a0005e50:	f9401fe0 	ldr	x0, [sp, #56]
    a0005e54:	97fffc27 	bl	a0004ef0 <set_chunk_used>

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
    a0005e58:	b94047e1 	ldr	w1, [sp, #68]
    a0005e5c:	b94033e0 	ldr	w0, [sp, #48]
    a0005e60:	4b000020 	sub	w0, w1, w0
    a0005e64:	2a0003e2 	mov	w2, w0
    a0005e68:	b94033e1 	ldr	w1, [sp, #48]
    a0005e6c:	f9401fe0 	ldr	x0, [sp, #56]
    a0005e70:	97fffc5c 	bl	a0004fe0 <set_chunk_size>
	set_left_chunk_size(h, chunk0_size, chunk0_size);
    a0005e74:	b94033e2 	ldr	w2, [sp, #48]
    a0005e78:	b94033e1 	ldr	w1, [sp, #48]
    a0005e7c:	f9401fe0 	ldr	x0, [sp, #56]
    a0005e80:	97fffcae 	bl	a0005138 <set_left_chunk_size>

	/* the end marker chunk */
	set_chunk_size(h, heap_sz, 0);
    a0005e84:	52800002 	mov	w2, #0x0                   	// #0
    a0005e88:	b94047e1 	ldr	w1, [sp, #68]
    a0005e8c:	f9401fe0 	ldr	x0, [sp, #56]
    a0005e90:	97fffc54 	bl	a0004fe0 <set_chunk_size>
	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
    a0005e94:	b94047e1 	ldr	w1, [sp, #68]
    a0005e98:	b94033e0 	ldr	w0, [sp, #48]
    a0005e9c:	4b000020 	sub	w0, w1, w0
    a0005ea0:	2a0003e2 	mov	w2, w0
    a0005ea4:	b94047e1 	ldr	w1, [sp, #68]
    a0005ea8:	f9401fe0 	ldr	x0, [sp, #56]
    a0005eac:	97fffca3 	bl	a0005138 <set_left_chunk_size>
	set_chunk_used(h, heap_sz, true);
    a0005eb0:	52800022 	mov	w2, #0x1                   	// #1
    a0005eb4:	b94047e1 	ldr	w1, [sp, #68]
    a0005eb8:	f9401fe0 	ldr	x0, [sp, #56]
    a0005ebc:	97fffc0d 	bl	a0004ef0 <set_chunk_used>

	free_list_add(h, chunk0_size);
    a0005ec0:	b94033e1 	ldr	w1, [sp, #48]
    a0005ec4:	f9401fe0 	ldr	x0, [sp, #56]
    a0005ec8:	97fffdb0 	bl	a0005588 <free_list_add>
}
    a0005ecc:	d503201f 	nop
    a0005ed0:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a0005ed4:	d65f03c0 	ret

00000000a0005ed8 <isupper>:
#ifdef __cplusplus
extern "C" {
#endif

static inline int isupper(int a)
{
    a0005ed8:	d10043ff 	sub	sp, sp, #0x10
    a0005edc:	b9000fe0 	str	w0, [sp, #12]
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
    a0005ee0:	b9400fe0 	ldr	w0, [sp, #12]
    a0005ee4:	51010400 	sub	w0, w0, #0x41
    a0005ee8:	7100641f 	cmp	w0, #0x19
    a0005eec:	1a9f87e0 	cset	w0, ls  // ls = plast
    a0005ef0:	12001c00 	and	w0, w0, #0xff
}
    a0005ef4:	910043ff 	add	sp, sp, #0x10
    a0005ef8:	d65f03c0 	ret

00000000a0005efc <isdigit>:
	return (int)((((unsigned)c) >= ' ') &&
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
    a0005efc:	d10043ff 	sub	sp, sp, #0x10
    a0005f00:	b9000fe0 	str	w0, [sp, #12]
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
    a0005f04:	b9400fe0 	ldr	w0, [sp, #12]
    a0005f08:	5100c000 	sub	w0, w0, #0x30
    a0005f0c:	7100241f 	cmp	w0, #0x9
    a0005f10:	1a9f87e0 	cset	w0, ls  // ls = plast
    a0005f14:	12001c00 	and	w0, w0, #0xff
}
    a0005f18:	910043ff 	add	sp, sp, #0x10
    a0005f1c:	d65f03c0 	ret

00000000a0005f20 <extract_decimal>:
 * the referenced text.
 *
 * @return the decoded integer value.
 */
static size_t extract_decimal(const char **str)
{
    a0005f20:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0005f24:	910003fd 	mov	x29, sp
    a0005f28:	f9000fe0 	str	x0, [sp, #24]
	const char *sp = *str;
    a0005f2c:	f9400fe0 	ldr	x0, [sp, #24]
    a0005f30:	f9400000 	ldr	x0, [x0]
    a0005f34:	f90017e0 	str	x0, [sp, #40]
	size_t val = 0;
    a0005f38:	f90013ff 	str	xzr, [sp, #32]

	while (isdigit((int)(unsigned char)*sp)) {
    a0005f3c:	1400000f 	b	a0005f78 <extract_decimal+0x58>
		val = 10U * val + *sp++ - '0';
    a0005f40:	f94013e1 	ldr	x1, [sp, #32]
    a0005f44:	aa0103e0 	mov	x0, x1
    a0005f48:	d37ef400 	lsl	x0, x0, #2
    a0005f4c:	8b010000 	add	x0, x0, x1
    a0005f50:	8b000000 	add	x0, x0, x0
    a0005f54:	aa0003e2 	mov	x2, x0
    a0005f58:	f94017e0 	ldr	x0, [sp, #40]
    a0005f5c:	91000401 	add	x1, x0, #0x1
    a0005f60:	f90017e1 	str	x1, [sp, #40]
    a0005f64:	39400000 	ldrb	w0, [x0]
    a0005f68:	92401c00 	and	x0, x0, #0xff
    a0005f6c:	8b000040 	add	x0, x2, x0
    a0005f70:	d100c000 	sub	x0, x0, #0x30
    a0005f74:	f90013e0 	str	x0, [sp, #32]
	while (isdigit((int)(unsigned char)*sp)) {
    a0005f78:	f94017e0 	ldr	x0, [sp, #40]
    a0005f7c:	39400000 	ldrb	w0, [x0]
    a0005f80:	97ffffdf 	bl	a0005efc <isdigit>
    a0005f84:	7100001f 	cmp	w0, #0x0
    a0005f88:	54fffdc1 	b.ne	a0005f40 <extract_decimal+0x20>  // b.any
	}
	*str = sp;
    a0005f8c:	f9400fe0 	ldr	x0, [sp, #24]
    a0005f90:	f94017e1 	ldr	x1, [sp, #40]
    a0005f94:	f9000001 	str	x1, [x0]
	return val;
    a0005f98:	f94013e0 	ldr	x0, [sp, #32]
}
    a0005f9c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0005fa0:	d65f03c0 	ret

00000000a0005fa4 <extract_flags>:
 *
 * @return a pointer the first character that follows the flags.
 */
static inline const char *extract_flags(struct conversion *conv,
					const char *sp)
{
    a0005fa4:	d10083ff 	sub	sp, sp, #0x20
    a0005fa8:	f90007e0 	str	x0, [sp, #8]
    a0005fac:	f90003e1 	str	x1, [sp]
	bool loop = true;
    a0005fb0:	52800020 	mov	w0, #0x1                   	// #1
    a0005fb4:	39007fe0 	strb	w0, [sp, #31]

	do {
		switch (*sp) {
    a0005fb8:	f94003e0 	ldr	x0, [sp]
    a0005fbc:	39400000 	ldrb	w0, [x0]
    a0005fc0:	7100c01f 	cmp	w0, #0x30
    a0005fc4:	54000480 	b.eq	a0006054 <extract_flags+0xb0>  // b.none
    a0005fc8:	7100c01f 	cmp	w0, #0x30
    a0005fcc:	540004ec 	b.gt	a0006068 <extract_flags+0xc4>
    a0005fd0:	7100b41f 	cmp	w0, #0x2d
    a0005fd4:	54000180 	b.eq	a0006004 <extract_flags+0x60>  // b.none
    a0005fd8:	7100b41f 	cmp	w0, #0x2d
    a0005fdc:	5400046c 	b.gt	a0006068 <extract_flags+0xc4>
    a0005fe0:	7100ac1f 	cmp	w0, #0x2b
    a0005fe4:	540001a0 	b.eq	a0006018 <extract_flags+0x74>  // b.none
    a0005fe8:	7100ac1f 	cmp	w0, #0x2b
    a0005fec:	540003ec 	b.gt	a0006068 <extract_flags+0xc4>
    a0005ff0:	7100801f 	cmp	w0, #0x20
    a0005ff4:	540001c0 	b.eq	a000602c <extract_flags+0x88>  // b.none
    a0005ff8:	71008c1f 	cmp	w0, #0x23
    a0005ffc:	54000220 	b.eq	a0006040 <extract_flags+0x9c>  // b.none
    a0006000:	1400001a 	b	a0006068 <extract_flags+0xc4>
		case '-':
			conv->flag_dash = true;
    a0006004:	f94007e0 	ldr	x0, [sp, #8]
    a0006008:	79400001 	ldrh	w1, [x0]
    a000600c:	321e0021 	orr	w1, w1, #0x4
    a0006010:	79000001 	strh	w1, [x0]
			break;
    a0006014:	14000016 	b	a000606c <extract_flags+0xc8>
		case '+':
			conv->flag_plus = true;
    a0006018:	f94007e0 	ldr	x0, [sp, #8]
    a000601c:	79400001 	ldrh	w1, [x0]
    a0006020:	321d0021 	orr	w1, w1, #0x8
    a0006024:	79000001 	strh	w1, [x0]
			break;
    a0006028:	14000011 	b	a000606c <extract_flags+0xc8>
		case ' ':
			conv->flag_space = true;
    a000602c:	f94007e0 	ldr	x0, [sp, #8]
    a0006030:	79400001 	ldrh	w1, [x0]
    a0006034:	321c0021 	orr	w1, w1, #0x10
    a0006038:	79000001 	strh	w1, [x0]
			break;
    a000603c:	1400000c 	b	a000606c <extract_flags+0xc8>
		case '#':
			conv->flag_hash = true;
    a0006040:	f94007e0 	ldr	x0, [sp, #8]
    a0006044:	79400001 	ldrh	w1, [x0]
    a0006048:	321b0021 	orr	w1, w1, #0x20
    a000604c:	79000001 	strh	w1, [x0]
			break;
    a0006050:	14000007 	b	a000606c <extract_flags+0xc8>
		case '0':
			conv->flag_zero = true;
    a0006054:	f94007e0 	ldr	x0, [sp, #8]
    a0006058:	79400001 	ldrh	w1, [x0]
    a000605c:	321a0021 	orr	w1, w1, #0x40
    a0006060:	79000001 	strh	w1, [x0]
			break;
    a0006064:	14000002 	b	a000606c <extract_flags+0xc8>
		default:
			loop = false;
    a0006068:	39007fff 	strb	wzr, [sp, #31]
		}
		if (loop) {
    a000606c:	39407fe0 	ldrb	w0, [sp, #31]
    a0006070:	7100001f 	cmp	w0, #0x0
    a0006074:	54000080 	b.eq	a0006084 <extract_flags+0xe0>  // b.none
			++sp;
    a0006078:	f94003e0 	ldr	x0, [sp]
    a000607c:	91000400 	add	x0, x0, #0x1
    a0006080:	f90003e0 	str	x0, [sp]
		}
	} while (loop);
    a0006084:	39407fe0 	ldrb	w0, [sp, #31]
    a0006088:	7100001f 	cmp	w0, #0x0
    a000608c:	54fff961 	b.ne	a0005fb8 <extract_flags+0x14>  // b.any

	/* zero && dash => !zero */
	if (conv->flag_zero && conv->flag_dash) {
    a0006090:	f94007e0 	ldr	x0, [sp, #8]
    a0006094:	79400000 	ldrh	w0, [x0]
    a0006098:	121a0000 	and	w0, w0, #0x40
    a000609c:	12003c00 	and	w0, w0, #0xffff
    a00060a0:	7100001f 	cmp	w0, #0x0
    a00060a4:	54000160 	b.eq	a00060d0 <extract_flags+0x12c>  // b.none
    a00060a8:	f94007e0 	ldr	x0, [sp, #8]
    a00060ac:	79400000 	ldrh	w0, [x0]
    a00060b0:	121e0000 	and	w0, w0, #0x4
    a00060b4:	12003c00 	and	w0, w0, #0xffff
    a00060b8:	7100001f 	cmp	w0, #0x0
    a00060bc:	540000a0 	b.eq	a00060d0 <extract_flags+0x12c>  // b.none
		conv->flag_zero = false;
    a00060c0:	f94007e0 	ldr	x0, [sp, #8]
    a00060c4:	79400001 	ldrh	w1, [x0]
    a00060c8:	12197821 	and	w1, w1, #0xffffffbf
    a00060cc:	79000001 	strh	w1, [x0]
	}

	/* space && plus => !plus, handled in emitter code */

	return sp;
    a00060d0:	f94003e0 	ldr	x0, [sp]
}
    a00060d4:	910083ff 	add	sp, sp, #0x20
    a00060d8:	d65f03c0 	ret

00000000a00060dc <extract_width>:
 *
 * @return a pointer the first character that follows the width.
 */
static inline const char *extract_width(struct conversion *conv,
					const char *sp)
{
    a00060dc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a00060e0:	910003fd 	mov	x29, sp
    a00060e4:	f9000fe0 	str	x0, [sp, #24]
    a00060e8:	f9000be1 	str	x1, [sp, #16]
	conv->width_present = true;
    a00060ec:	f9400fe0 	ldr	x0, [sp, #24]
    a00060f0:	79400001 	ldrh	w1, [x0]
    a00060f4:	32190021 	orr	w1, w1, #0x80
    a00060f8:	79000001 	strh	w1, [x0]

	if (*sp == '*') {
    a00060fc:	f9400be0 	ldr	x0, [sp, #16]
    a0006100:	39400000 	ldrb	w0, [x0]
    a0006104:	7100a81f 	cmp	w0, #0x2a
    a0006108:	54000141 	b.ne	a0006130 <extract_width+0x54>  // b.any
		conv->width_star = true;
    a000610c:	f9400fe0 	ldr	x0, [sp, #24]
    a0006110:	79400001 	ldrh	w1, [x0]
    a0006114:	32180021 	orr	w1, w1, #0x100
    a0006118:	79000001 	strh	w1, [x0]
		return ++sp;
    a000611c:	f9400be0 	ldr	x0, [sp, #16]
    a0006120:	91000400 	add	x0, x0, #0x1
    a0006124:	f9000be0 	str	x0, [sp, #16]
    a0006128:	f9400be0 	ldr	x0, [sp, #16]
    a000612c:	1400002d 	b	a00061e0 <extract_width+0x104>
	}

	const char *wp = sp;
    a0006130:	f9400be0 	ldr	x0, [sp, #16]
    a0006134:	f90017e0 	str	x0, [sp, #40]
	size_t width = extract_decimal(&sp);
    a0006138:	910043e0 	add	x0, sp, #0x10
    a000613c:	97ffff79 	bl	a0005f20 <extract_decimal>
    a0006140:	f90013e0 	str	x0, [sp, #32]

	if (sp != wp) {
    a0006144:	f9400be0 	ldr	x0, [sp, #16]
    a0006148:	f94017e1 	ldr	x1, [sp, #40]
    a000614c:	eb00003f 	cmp	x1, x0
    a0006150:	54000460 	b.eq	a00061dc <extract_width+0x100>  // b.none
		conv->width_present = true;
    a0006154:	f9400fe0 	ldr	x0, [sp, #24]
    a0006158:	79400001 	ldrh	w1, [x0]
    a000615c:	32190021 	orr	w1, w1, #0x80
    a0006160:	79000001 	strh	w1, [x0]
		conv->width_value = width;
    a0006164:	f94013e0 	ldr	x0, [sp, #32]
    a0006168:	2a0003e1 	mov	w1, w0
    a000616c:	f9400fe0 	ldr	x0, [sp, #24]
    a0006170:	b9000401 	str	w1, [x0, #4]
		conv->unsupported |= ((conv->width_value < 0)
    a0006174:	f9400fe0 	ldr	x0, [sp, #24]
    a0006178:	b9400000 	ldr	w0, [x0]
    a000617c:	d3410400 	ubfx	x0, x0, #1, #1
    a0006180:	12001c00 	and	w0, w0, #0xff
    a0006184:	2a0003e2 	mov	w2, w0
    a0006188:	f9400fe0 	ldr	x0, [sp, #24]
    a000618c:	b9400400 	ldr	w0, [x0, #4]
				      || (width != (size_t)conv->width_value));
    a0006190:	7100001f 	cmp	w0, #0x0
    a0006194:	540000eb 	b.lt	a00061b0 <extract_width+0xd4>  // b.tstop
    a0006198:	f9400fe0 	ldr	x0, [sp, #24]
    a000619c:	b9400400 	ldr	w0, [x0, #4]
    a00061a0:	93407c00 	sxtw	x0, w0
    a00061a4:	f94013e1 	ldr	x1, [sp, #32]
    a00061a8:	eb00003f 	cmp	x1, x0
    a00061ac:	54000060 	b.eq	a00061b8 <extract_width+0xdc>  // b.none
    a00061b0:	52800020 	mov	w0, #0x1                   	// #1
    a00061b4:	14000002 	b	a00061bc <extract_width+0xe0>
    a00061b8:	52800000 	mov	w0, #0x0                   	// #0
		conv->unsupported |= ((conv->width_value < 0)
    a00061bc:	2a020000 	orr	w0, w0, w2
    a00061c0:	7100001f 	cmp	w0, #0x0
    a00061c4:	1a9f07e0 	cset	w0, ne  // ne = any
    a00061c8:	12001c02 	and	w2, w0, #0xff
    a00061cc:	f9400fe1 	ldr	x1, [sp, #24]
    a00061d0:	79400020 	ldrh	w0, [x1]
    a00061d4:	331f0040 	bfi	w0, w2, #1, #1
    a00061d8:	79000020 	strh	w0, [x1]
	}

	return sp;
    a00061dc:	f9400be0 	ldr	x0, [sp, #16]
}
    a00061e0:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a00061e4:	d65f03c0 	ret

00000000a00061e8 <extract_prec>:
 *
 * @return a pointer the first character that follows the precision.
 */
static inline const char *extract_prec(struct conversion *conv,
				       const char *sp)
{
    a00061e8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a00061ec:	910003fd 	mov	x29, sp
    a00061f0:	f9000fe0 	str	x0, [sp, #24]
    a00061f4:	f9000be1 	str	x1, [sp, #16]
	conv->prec_present = (*sp == '.');
    a00061f8:	f9400be0 	ldr	x0, [sp, #16]
    a00061fc:	39400000 	ldrb	w0, [x0]
    a0006200:	7100b81f 	cmp	w0, #0x2e
    a0006204:	1a9f17e0 	cset	w0, eq  // eq = none
    a0006208:	12001c02 	and	w2, w0, #0xff
    a000620c:	f9400fe1 	ldr	x1, [sp, #24]
    a0006210:	79400020 	ldrh	w0, [x1]
    a0006214:	33170040 	bfi	w0, w2, #9, #1
    a0006218:	79000020 	strh	w0, [x1]

	if (!conv->prec_present) {
    a000621c:	f9400fe0 	ldr	x0, [sp, #24]
    a0006220:	b9400000 	ldr	w0, [x0]
    a0006224:	d3492400 	ubfx	x0, x0, #9, #1
    a0006228:	12001c00 	and	w0, w0, #0xff
    a000622c:	52000000 	eor	w0, w0, #0x1
    a0006230:	12001c00 	and	w0, w0, #0xff
    a0006234:	7100001f 	cmp	w0, #0x0
    a0006238:	54000060 	b.eq	a0006244 <extract_prec+0x5c>  // b.none
		return sp;
    a000623c:	f9400be0 	ldr	x0, [sp, #16]
    a0006240:	14000033 	b	a000630c <extract_prec+0x124>
	}
	++sp;
    a0006244:	f9400be0 	ldr	x0, [sp, #16]
    a0006248:	91000400 	add	x0, x0, #0x1
    a000624c:	f9000be0 	str	x0, [sp, #16]

	if (*sp == '*') {
    a0006250:	f9400be0 	ldr	x0, [sp, #16]
    a0006254:	39400000 	ldrb	w0, [x0]
    a0006258:	7100a81f 	cmp	w0, #0x2a
    a000625c:	54000141 	b.ne	a0006284 <extract_prec+0x9c>  // b.any
		conv->prec_star = true;
    a0006260:	f9400fe0 	ldr	x0, [sp, #24]
    a0006264:	79400001 	ldrh	w1, [x0]
    a0006268:	32160021 	orr	w1, w1, #0x400
    a000626c:	79000001 	strh	w1, [x0]
		return ++sp;
    a0006270:	f9400be0 	ldr	x0, [sp, #16]
    a0006274:	91000400 	add	x0, x0, #0x1
    a0006278:	f9000be0 	str	x0, [sp, #16]
    a000627c:	f9400be0 	ldr	x0, [sp, #16]
    a0006280:	14000023 	b	a000630c <extract_prec+0x124>
	}

	size_t prec = extract_decimal(&sp);
    a0006284:	910043e0 	add	x0, sp, #0x10
    a0006288:	97ffff26 	bl	a0005f20 <extract_decimal>
    a000628c:	f90017e0 	str	x0, [sp, #40]

	conv->prec_value = prec;
    a0006290:	f94017e0 	ldr	x0, [sp, #40]
    a0006294:	2a0003e1 	mov	w1, w0
    a0006298:	f9400fe0 	ldr	x0, [sp, #24]
    a000629c:	b9000801 	str	w1, [x0, #8]
	conv->unsupported |= ((conv->prec_value < 0)
    a00062a0:	f9400fe0 	ldr	x0, [sp, #24]
    a00062a4:	b9400000 	ldr	w0, [x0]
    a00062a8:	d3410400 	ubfx	x0, x0, #1, #1
    a00062ac:	12001c00 	and	w0, w0, #0xff
    a00062b0:	2a0003e2 	mov	w2, w0
    a00062b4:	f9400fe0 	ldr	x0, [sp, #24]
    a00062b8:	b9400800 	ldr	w0, [x0, #8]
			      || (prec != (size_t)conv->prec_value));
    a00062bc:	7100001f 	cmp	w0, #0x0
    a00062c0:	540000eb 	b.lt	a00062dc <extract_prec+0xf4>  // b.tstop
    a00062c4:	f9400fe0 	ldr	x0, [sp, #24]
    a00062c8:	b9400800 	ldr	w0, [x0, #8]
    a00062cc:	93407c00 	sxtw	x0, w0
    a00062d0:	f94017e1 	ldr	x1, [sp, #40]
    a00062d4:	eb00003f 	cmp	x1, x0
    a00062d8:	54000060 	b.eq	a00062e4 <extract_prec+0xfc>  // b.none
    a00062dc:	52800020 	mov	w0, #0x1                   	// #1
    a00062e0:	14000002 	b	a00062e8 <extract_prec+0x100>
    a00062e4:	52800000 	mov	w0, #0x0                   	// #0
	conv->unsupported |= ((conv->prec_value < 0)
    a00062e8:	2a020000 	orr	w0, w0, w2
    a00062ec:	7100001f 	cmp	w0, #0x0
    a00062f0:	1a9f07e0 	cset	w0, ne  // ne = any
    a00062f4:	12001c02 	and	w2, w0, #0xff
    a00062f8:	f9400fe1 	ldr	x1, [sp, #24]
    a00062fc:	79400020 	ldrh	w0, [x1]
    a0006300:	331f0040 	bfi	w0, w2, #1, #1
    a0006304:	79000020 	strh	w0, [x1]

	return sp;
    a0006308:	f9400be0 	ldr	x0, [sp, #16]
}
    a000630c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0006310:	d65f03c0 	ret

00000000a0006314 <extract_length>:
 *
 * @return a pointer the first character that follows the precision.
 */
static inline const char *extract_length(struct conversion *conv,
					 const char *sp)
{
    a0006314:	d10043ff 	sub	sp, sp, #0x10
    a0006318:	f90007e0 	str	x0, [sp, #8]
    a000631c:	f90003e1 	str	x1, [sp]
	switch (*sp) {
    a0006320:	f94003e0 	ldr	x0, [sp]
    a0006324:	39400000 	ldrb	w0, [x0]
    a0006328:	7101e81f 	cmp	w0, #0x7a
    a000632c:	54000900 	b.eq	a000644c <extract_length+0x138>  // b.none
    a0006330:	7101e81f 	cmp	w0, #0x7a
    a0006334:	54000cac 	b.gt	a00064c8 <extract_length+0x1b4>
    a0006338:	7101d01f 	cmp	w0, #0x74
    a000633c:	540009a0 	b.eq	a0006470 <extract_length+0x15c>  // b.none
    a0006340:	7101d01f 	cmp	w0, #0x74
    a0006344:	54000c2c 	b.gt	a00064c8 <extract_length+0x1b4>
    a0006348:	7101b01f 	cmp	w0, #0x6c
    a000634c:	54000420 	b.eq	a00063d0 <extract_length+0xbc>  // b.none
    a0006350:	7101b01f 	cmp	w0, #0x6c
    a0006354:	54000bac 	b.gt	a00064c8 <extract_length+0x1b4>
    a0006358:	7101a81f 	cmp	w0, #0x6a
    a000635c:	54000660 	b.eq	a0006428 <extract_length+0x114>  // b.none
    a0006360:	7101a81f 	cmp	w0, #0x6a
    a0006364:	54000b2c 	b.gt	a00064c8 <extract_length+0x1b4>
    a0006368:	7101301f 	cmp	w0, #0x4c
    a000636c:	54000940 	b.eq	a0006494 <extract_length+0x180>  // b.none
    a0006370:	7101a01f 	cmp	w0, #0x68
    a0006374:	54000aa1 	b.ne	a00064c8 <extract_length+0x1b4>  // b.any
	case 'h':
		if (*++sp == 'h') {
    a0006378:	f94003e0 	ldr	x0, [sp]
    a000637c:	91000400 	add	x0, x0, #0x1
    a0006380:	f90003e0 	str	x0, [sp]
    a0006384:	f94003e0 	ldr	x0, [sp]
    a0006388:	39400000 	ldrb	w0, [x0]
    a000638c:	7101a01f 	cmp	w0, #0x68
    a0006390:	54000141 	b.ne	a00063b8 <extract_length+0xa4>  // b.any
			conv->length_mod = LENGTH_HH;
    a0006394:	f94007e1 	ldr	x1, [sp, #8]
    a0006398:	79400020 	ldrh	w0, [x1]
    a000639c:	52800022 	mov	w2, #0x1                   	// #1
    a00063a0:	33150c40 	bfi	w0, w2, #11, #4
    a00063a4:	79000020 	strh	w0, [x1]
			++sp;
    a00063a8:	f94003e0 	ldr	x0, [sp]
    a00063ac:	91000400 	add	x0, x0, #0x1
    a00063b0:	f90003e0 	str	x0, [sp]
		} else {
			conv->length_mod = LENGTH_H;
		}
		break;
    a00063b4:	1400004a 	b	a00064dc <extract_length+0x1c8>
			conv->length_mod = LENGTH_H;
    a00063b8:	f94007e1 	ldr	x1, [sp, #8]
    a00063bc:	79400020 	ldrh	w0, [x1]
    a00063c0:	52800042 	mov	w2, #0x2                   	// #2
    a00063c4:	33150c40 	bfi	w0, w2, #11, #4
    a00063c8:	79000020 	strh	w0, [x1]
		break;
    a00063cc:	14000044 	b	a00064dc <extract_length+0x1c8>
	case 'l':
		if (*++sp == 'l') {
    a00063d0:	f94003e0 	ldr	x0, [sp]
    a00063d4:	91000400 	add	x0, x0, #0x1
    a00063d8:	f90003e0 	str	x0, [sp]
    a00063dc:	f94003e0 	ldr	x0, [sp]
    a00063e0:	39400000 	ldrb	w0, [x0]
    a00063e4:	7101b01f 	cmp	w0, #0x6c
    a00063e8:	54000141 	b.ne	a0006410 <extract_length+0xfc>  // b.any
			conv->length_mod = LENGTH_LL;
    a00063ec:	f94007e1 	ldr	x1, [sp, #8]
    a00063f0:	79400020 	ldrh	w0, [x1]
    a00063f4:	52800082 	mov	w2, #0x4                   	// #4
    a00063f8:	33150c40 	bfi	w0, w2, #11, #4
    a00063fc:	79000020 	strh	w0, [x1]
			++sp;
    a0006400:	f94003e0 	ldr	x0, [sp]
    a0006404:	91000400 	add	x0, x0, #0x1
    a0006408:	f90003e0 	str	x0, [sp]
		} else {
			conv->length_mod = LENGTH_L;
		}
		break;
    a000640c:	14000034 	b	a00064dc <extract_length+0x1c8>
			conv->length_mod = LENGTH_L;
    a0006410:	f94007e1 	ldr	x1, [sp, #8]
    a0006414:	79400020 	ldrh	w0, [x1]
    a0006418:	52800062 	mov	w2, #0x3                   	// #3
    a000641c:	33150c40 	bfi	w0, w2, #11, #4
    a0006420:	79000020 	strh	w0, [x1]
		break;
    a0006424:	1400002e 	b	a00064dc <extract_length+0x1c8>
	case 'j':
		conv->length_mod = LENGTH_J;
    a0006428:	f94007e1 	ldr	x1, [sp, #8]
    a000642c:	79400020 	ldrh	w0, [x1]
    a0006430:	528000a2 	mov	w2, #0x5                   	// #5
    a0006434:	33150c40 	bfi	w0, w2, #11, #4
    a0006438:	79000020 	strh	w0, [x1]
		++sp;
    a000643c:	f94003e0 	ldr	x0, [sp]
    a0006440:	91000400 	add	x0, x0, #0x1
    a0006444:	f90003e0 	str	x0, [sp]
		break;
    a0006448:	14000025 	b	a00064dc <extract_length+0x1c8>
	case 'z':
		conv->length_mod = LENGTH_Z;
    a000644c:	f94007e1 	ldr	x1, [sp, #8]
    a0006450:	79400020 	ldrh	w0, [x1]
    a0006454:	528000c2 	mov	w2, #0x6                   	// #6
    a0006458:	33150c40 	bfi	w0, w2, #11, #4
    a000645c:	79000020 	strh	w0, [x1]
		++sp;
    a0006460:	f94003e0 	ldr	x0, [sp]
    a0006464:	91000400 	add	x0, x0, #0x1
    a0006468:	f90003e0 	str	x0, [sp]
		break;
    a000646c:	1400001c 	b	a00064dc <extract_length+0x1c8>
	case 't':
		conv->length_mod = LENGTH_T;
    a0006470:	f94007e1 	ldr	x1, [sp, #8]
    a0006474:	79400020 	ldrh	w0, [x1]
    a0006478:	528000e2 	mov	w2, #0x7                   	// #7
    a000647c:	33150c40 	bfi	w0, w2, #11, #4
    a0006480:	79000020 	strh	w0, [x1]
		++sp;
    a0006484:	f94003e0 	ldr	x0, [sp]
    a0006488:	91000400 	add	x0, x0, #0x1
    a000648c:	f90003e0 	str	x0, [sp]
		break;
    a0006490:	14000013 	b	a00064dc <extract_length+0x1c8>
	case 'L':
		conv->length_mod = LENGTH_UPPER_L;
    a0006494:	f94007e1 	ldr	x1, [sp, #8]
    a0006498:	79400020 	ldrh	w0, [x1]
    a000649c:	52800102 	mov	w2, #0x8                   	// #8
    a00064a0:	33150c40 	bfi	w0, w2, #11, #4
    a00064a4:	79000020 	strh	w0, [x1]
		++sp;
    a00064a8:	f94003e0 	ldr	x0, [sp]
    a00064ac:	91000400 	add	x0, x0, #0x1
    a00064b0:	f90003e0 	str	x0, [sp]

		/* We recognize and consume these, but can't format
		 * them.
		 */
		conv->unsupported = true;
    a00064b4:	f94007e0 	ldr	x0, [sp, #8]
    a00064b8:	79400001 	ldrh	w1, [x0]
    a00064bc:	321f0021 	orr	w1, w1, #0x2
    a00064c0:	79000001 	strh	w1, [x0]
		break;
    a00064c4:	14000006 	b	a00064dc <extract_length+0x1c8>
	default:
		conv->length_mod = LENGTH_NONE;
    a00064c8:	f94007e0 	ldr	x0, [sp, #8]
    a00064cc:	79400001 	ldrh	w1, [x0]
    a00064d0:	12116c21 	and	w1, w1, #0xffff87ff
    a00064d4:	79000001 	strh	w1, [x0]
		break;
    a00064d8:	d503201f 	nop
	}
	return sp;
    a00064dc:	f94003e0 	ldr	x0, [sp]
}
    a00064e0:	910043ff 	add	sp, sp, #0x10
    a00064e4:	d65f03c0 	ret

00000000a00064e8 <extract_specifier>:
 *
 * @return a pointer the first character that follows the specifier.
 */
static inline const char *extract_specifier(struct conversion *conv,
					    const char *sp)
{
    a00064e8:	d10083ff 	sub	sp, sp, #0x20
    a00064ec:	f90007e0 	str	x0, [sp, #8]
    a00064f0:	f90003e1 	str	x1, [sp]
	bool unsupported = false;
    a00064f4:	39007fff 	strb	wzr, [sp, #31]

	conv->specifier = *sp++;
    a00064f8:	f94003e0 	ldr	x0, [sp]
    a00064fc:	91000401 	add	x1, x0, #0x1
    a0006500:	f90003e1 	str	x1, [sp]
    a0006504:	39400001 	ldrb	w1, [x0]
    a0006508:	f94007e0 	ldr	x0, [sp, #8]
    a000650c:	39000c01 	strb	w1, [x0, #3]

	switch (conv->specifier) {
    a0006510:	f94007e0 	ldr	x0, [sp, #8]
    a0006514:	39400c00 	ldrb	w0, [x0, #3]
    a0006518:	7101a41f 	cmp	w0, #0x69
    a000651c:	540006ec 	b.gt	a00065f8 <extract_specifier+0x110>
    a0006520:	7101041f 	cmp	w0, #0x41
    a0006524:	5400034a 	b.ge	a000658c <extract_specifier+0xa4>  // b.tcont
    a0006528:	140000b2 	b	a00067f0 <extract_specifier+0x308>
    a000652c:	5101b800 	sub	w0, w0, #0x6e
    a0006530:	d2800021 	mov	x1, #0x1                   	// #1
    a0006534:	9ac02020 	lsl	x0, x1, x0
    a0006538:	d2809041 	mov	x1, #0x482                 	// #1154
    a000653c:	8a010001 	and	x1, x0, x1
    a0006540:	f100003f 	cmp	x1, #0x0
    a0006544:	1a9f07e1 	cset	w1, ne  // ne = any
    a0006548:	12001c21 	and	w1, w1, #0xff
    a000654c:	7100003f 	cmp	w1, #0x0
    a0006550:	540006a1 	b.ne	a0006624 <extract_specifier+0x13c>  // b.any
    a0006554:	d2800481 	mov	x1, #0x24                  	// #36
    a0006558:	8a010001 	and	x1, x0, x1
    a000655c:	f100003f 	cmp	x1, #0x0
    a0006560:	1a9f07e1 	cset	w1, ne  // ne = any
    a0006564:	12001c21 	and	w1, w1, #0xff
    a0006568:	7100003f 	cmp	w1, #0x0
    a000656c:	54001261 	b.ne	a00067b8 <extract_specifier+0x2d0>  // b.any
    a0006570:	92400000 	and	x0, x0, #0x1
    a0006574:	f100001f 	cmp	x0, #0x0
    a0006578:	1a9f07e0 	cset	w0, ne  // ne = any
    a000657c:	12001c00 	and	w0, w0, #0xff
    a0006580:	7100001f 	cmp	w0, #0x0
    a0006584:	54000fe1 	b.ne	a0006780 <extract_specifier+0x298>  // b.any
    a0006588:	1400009a 	b	a00067f0 <extract_specifier+0x308>
    a000658c:	51010400 	sub	w0, w0, #0x41
    a0006590:	d2800021 	mov	x1, #0x1                   	// #1
    a0006594:	9ac02020 	lsl	x0, x1, x0
    a0006598:	d2800e21 	mov	x1, #0x71                  	// #113
    a000659c:	f2c00e21 	movk	x1, #0x71, lsl #32
    a00065a0:	8a010001 	and	x1, x0, x1
    a00065a4:	f100003f 	cmp	x1, #0x0
    a00065a8:	1a9f07e1 	cset	w1, ne  // ne = any
    a00065ac:	12001c21 	and	w1, w1, #0xff
    a00065b0:	7100003f 	cmp	w1, #0x0
    a00065b4:	540006e1 	b.ne	a0006690 <extract_specifier+0x1a8>  // b.any
    a00065b8:	d2a01001 	mov	x1, #0x800000              	// #8388608
    a00065bc:	f2c00081 	movk	x1, #0x4, lsl #32
    a00065c0:	8a010001 	and	x1, x0, x1
    a00065c4:	f100003f 	cmp	x1, #0x0
    a00065c8:	1a9f07e1 	cset	w1, ne  // ne = any
    a00065cc:	12001c21 	and	w1, w1, #0xff
    a00065d0:	7100003f 	cmp	w1, #0x0
    a00065d4:	54000281 	b.ne	a0006624 <extract_specifier+0x13c>  // b.any
    a00065d8:	d2c02101 	mov	x1, #0x10800000000         	// #1133871366144
    a00065dc:	8a010000 	and	x0, x0, x1
    a00065e0:	f100001f 	cmp	x0, #0x0
    a00065e4:	1a9f07e0 	cset	w0, ne  // ne = any
    a00065e8:	12001c00 	and	w0, w0, #0xff
    a00065ec:	7100001f 	cmp	w0, #0x0
    a00065f0:	540000e1 	b.ne	a000660c <extract_specifier+0x124>  // b.any
    a00065f4:	1400007f 	b	a00067f0 <extract_specifier+0x308>
    a00065f8:	7101e01f 	cmp	w0, #0x78
    a00065fc:	54000fac 	b.gt	a00067f0 <extract_specifier+0x308>
    a0006600:	7101b81f 	cmp	w0, #0x6e
    a0006604:	54fff94a 	b.ge	a000652c <extract_specifier+0x44>  // b.tcont
    a0006608:	1400007a 	b	a00067f0 <extract_specifier+0x308>
	case SINT_CONV_CASES:
		conv->specifier_cat = SPECIFIER_SINT;
    a000660c:	f94007e1 	ldr	x1, [sp, #8]
    a0006610:	39400820 	ldrb	w0, [x1, #2]
    a0006614:	52800022 	mov	w2, #0x1                   	// #1
    a0006618:	33000840 	bfxil	w0, w2, #0, #3
    a000661c:	39000820 	strb	w0, [x1, #2]
		goto int_conv;
    a0006620:	14000006 	b	a0006638 <extract_specifier+0x150>
	case UINT_CONV_CASES:
		conv->specifier_cat = SPECIFIER_UINT;
    a0006624:	f94007e1 	ldr	x1, [sp, #8]
    a0006628:	39400820 	ldrb	w0, [x1, #2]
    a000662c:	52800042 	mov	w2, #0x2                   	// #2
    a0006630:	33000840 	bfxil	w0, w2, #0, #3
    a0006634:	39000820 	strb	w0, [x1, #2]
int_conv:
		/* L length specifier not acceptable */
		if (conv->length_mod == LENGTH_UPPER_L) {
    a0006638:	f94007e0 	ldr	x0, [sp, #8]
    a000663c:	79400000 	ldrh	w0, [x0]
    a0006640:	12150c00 	and	w0, w0, #0x7800
    a0006644:	12003c00 	and	w0, w0, #0xffff
    a0006648:	7140101f 	cmp	w0, #0x4, lsl #12
    a000664c:	540000a1 	b.ne	a0006660 <extract_specifier+0x178>  // b.any
			conv->invalid = true;
    a0006650:	f94007e0 	ldr	x0, [sp, #8]
    a0006654:	79400001 	ldrh	w1, [x0]
    a0006658:	32000021 	orr	w1, w1, #0x1
    a000665c:	79000001 	strh	w1, [x0]
		}

		/* For c LENGTH_NONE and LENGTH_L would be ok,
		 * but we don't support formatting wide characters.
		 */
		if (conv->specifier == 'c') {
    a0006660:	f94007e0 	ldr	x0, [sp, #8]
    a0006664:	39400c00 	ldrb	w0, [x0, #3]
    a0006668:	71018c1f 	cmp	w0, #0x63
    a000666c:	54000cc1 	b.ne	a0006804 <extract_specifier+0x31c>  // b.any
			unsupported = (conv->length_mod != LENGTH_NONE);
    a0006670:	f94007e0 	ldr	x0, [sp, #8]
    a0006674:	79400000 	ldrh	w0, [x0]
    a0006678:	12150c00 	and	w0, w0, #0x7800
    a000667c:	12003c00 	and	w0, w0, #0xffff
    a0006680:	7100001f 	cmp	w0, #0x0
    a0006684:	1a9f07e0 	cset	w0, ne  // ne = any
    a0006688:	39007fe0 	strb	w0, [sp, #31]
				break;
			}
		} else {
			;
		}
		break;
    a000668c:	1400005e 	b	a0006804 <extract_specifier+0x31c>

	case FP_CONV_CASES:
		conv->specifier_cat = SPECIFIER_FP;
    a0006690:	f94007e1 	ldr	x1, [sp, #8]
    a0006694:	39400820 	ldrb	w0, [x1, #2]
    a0006698:	52800082 	mov	w2, #0x4                   	// #4
    a000669c:	33000840 	bfxil	w0, w2, #0, #3
    a00066a0:	39000820 	strb	w0, [x1, #2]
			unsupported = true;
			break;
		}

		/* When FP enabled %a support is still conditional. */
		conv->specifier_a = (conv->specifier == 'a')
    a00066a4:	f94007e0 	ldr	x0, [sp, #8]
    a00066a8:	39400c00 	ldrb	w0, [x0, #3]
			|| (conv->specifier == 'A');
    a00066ac:	7101841f 	cmp	w0, #0x61
    a00066b0:	540000a0 	b.eq	a00066c4 <extract_specifier+0x1dc>  // b.none
    a00066b4:	f94007e0 	ldr	x0, [sp, #8]
    a00066b8:	39400c00 	ldrb	w0, [x0, #3]
    a00066bc:	7101041f 	cmp	w0, #0x41
    a00066c0:	54000061 	b.ne	a00066cc <extract_specifier+0x1e4>  // b.any
    a00066c4:	52800020 	mov	w0, #0x1                   	// #1
    a00066c8:	14000002 	b	a00066d0 <extract_specifier+0x1e8>
    a00066cc:	52800000 	mov	w0, #0x0                   	// #0
    a00066d0:	12000000 	and	w0, w0, #0x1
    a00066d4:	12001c02 	and	w2, w0, #0xff
		conv->specifier_a = (conv->specifier == 'a')
    a00066d8:	f94007e1 	ldr	x1, [sp, #8]
    a00066dc:	79400020 	ldrh	w0, [x1]
    a00066e0:	33110040 	bfi	w0, w2, #15, #1
    a00066e4:	79000020 	strh	w0, [x1]
		if (conv->specifier_a
    a00066e8:	f94007e0 	ldr	x0, [sp, #8]
    a00066ec:	79400000 	ldrh	w0, [x0]
		    && !IS_ENABLED(CONFIG_CBPRINTF_FP_A_SUPPORT)) {
    a00066f0:	12114000 	and	w0, w0, #0xffff8000
    a00066f4:	12003c00 	and	w0, w0, #0xffff
		if (conv->specifier_a
    a00066f8:	7100001f 	cmp	w0, #0x0
    a00066fc:	54000080 	b.eq	a000670c <extract_specifier+0x224>  // b.none
			unsupported = true;
    a0006700:	52800020 	mov	w0, #0x1                   	// #1
    a0006704:	39007fe0 	strb	w0, [sp, #31]
			break;
    a0006708:	14000046 	b	a0006820 <extract_specifier+0x338>
		}

		/* The l specifier has no effect.  Otherwise length
		 * modifiers other than L are invalid.
		 */
		if (conv->length_mod == LENGTH_L) {
    a000670c:	f94007e0 	ldr	x0, [sp, #8]
    a0006710:	79400000 	ldrh	w0, [x0]
    a0006714:	12150c00 	and	w0, w0, #0x7800
    a0006718:	12003c01 	and	w1, w0, #0xffff
    a000671c:	52830000 	mov	w0, #0x1800                	// #6144
    a0006720:	6b00003f 	cmp	w1, w0
    a0006724:	540000c1 	b.ne	a000673c <extract_specifier+0x254>  // b.any
			conv->length_mod = LENGTH_NONE;
    a0006728:	f94007e0 	ldr	x0, [sp, #8]
    a000672c:	79400001 	ldrh	w1, [x0]
    a0006730:	12116c21 	and	w1, w1, #0xffff87ff
    a0006734:	79000001 	strh	w1, [x0]
			conv->invalid = true;
		} else {
			;
		}

		break;
    a0006738:	14000035 	b	a000680c <extract_specifier+0x324>
		} else if ((conv->length_mod != LENGTH_NONE)
    a000673c:	f94007e0 	ldr	x0, [sp, #8]
    a0006740:	79400000 	ldrh	w0, [x0]
    a0006744:	12150c00 	and	w0, w0, #0x7800
    a0006748:	12003c00 	and	w0, w0, #0xffff
    a000674c:	7100001f 	cmp	w0, #0x0
    a0006750:	540005e0 	b.eq	a000680c <extract_specifier+0x324>  // b.none
			   && (conv->length_mod != LENGTH_UPPER_L)) {
    a0006754:	f94007e0 	ldr	x0, [sp, #8]
    a0006758:	79400000 	ldrh	w0, [x0]
    a000675c:	12150c00 	and	w0, w0, #0x7800
    a0006760:	12003c00 	and	w0, w0, #0xffff
    a0006764:	7140101f 	cmp	w0, #0x4, lsl #12
    a0006768:	54000520 	b.eq	a000680c <extract_specifier+0x324>  // b.none
			conv->invalid = true;
    a000676c:	f94007e0 	ldr	x0, [sp, #8]
    a0006770:	79400001 	ldrh	w1, [x0]
    a0006774:	32000021 	orr	w1, w1, #0x1
    a0006778:	79000001 	strh	w1, [x0]
		break;
    a000677c:	14000024 	b	a000680c <extract_specifier+0x324>

		/* PTR cases are distinct */
	case 'n':
		conv->specifier_cat = SPECIFIER_PTR;
    a0006780:	f94007e1 	ldr	x1, [sp, #8]
    a0006784:	39400820 	ldrb	w0, [x1, #2]
    a0006788:	52800062 	mov	w2, #0x3                   	// #3
    a000678c:	33000840 	bfxil	w0, w2, #0, #3
    a0006790:	39000820 	strb	w0, [x1, #2]
		/* Anything except L */
		if (conv->length_mod == LENGTH_UPPER_L) {
    a0006794:	f94007e0 	ldr	x0, [sp, #8]
    a0006798:	79400000 	ldrh	w0, [x0]
    a000679c:	12150c00 	and	w0, w0, #0x7800
    a00067a0:	12003c00 	and	w0, w0, #0xffff
    a00067a4:	7140101f 	cmp	w0, #0x4, lsl #12
    a00067a8:	54000361 	b.ne	a0006814 <extract_specifier+0x32c>  // b.any
			unsupported = true;
    a00067ac:	52800020 	mov	w0, #0x1                   	// #1
    a00067b0:	39007fe0 	strb	w0, [sp, #31]
		}
		break;
    a00067b4:	14000018 	b	a0006814 <extract_specifier+0x32c>

	case 's':
	case 'p':
		conv->specifier_cat = SPECIFIER_PTR;
    a00067b8:	f94007e1 	ldr	x1, [sp, #8]
    a00067bc:	39400820 	ldrb	w0, [x1, #2]
    a00067c0:	52800062 	mov	w2, #0x3                   	// #3
    a00067c4:	33000840 	bfxil	w0, w2, #0, #3
    a00067c8:	39000820 	strb	w0, [x1, #2]
		/* p: only LENGTH_NONE
		 *
		 * s: LENGTH_NONE or LENGTH_L but wide
		 * characters not supported.
		 */
		if (conv->length_mod != LENGTH_NONE) {
    a00067cc:	f94007e0 	ldr	x0, [sp, #8]
    a00067d0:	79400000 	ldrh	w0, [x0]
    a00067d4:	12150c00 	and	w0, w0, #0x7800
    a00067d8:	12003c00 	and	w0, w0, #0xffff
    a00067dc:	7100001f 	cmp	w0, #0x0
    a00067e0:	540001e0 	b.eq	a000681c <extract_specifier+0x334>  // b.none
			unsupported = true;
    a00067e4:	52800020 	mov	w0, #0x1                   	// #1
    a00067e8:	39007fe0 	strb	w0, [sp, #31]
		}
		break;
    a00067ec:	1400000c 	b	a000681c <extract_specifier+0x334>

	default:
		conv->invalid = true;
    a00067f0:	f94007e0 	ldr	x0, [sp, #8]
    a00067f4:	79400001 	ldrh	w1, [x0]
    a00067f8:	32000021 	orr	w1, w1, #0x1
    a00067fc:	79000001 	strh	w1, [x0]
		break;
    a0006800:	14000008 	b	a0006820 <extract_specifier+0x338>
		break;
    a0006804:	d503201f 	nop
    a0006808:	14000006 	b	a0006820 <extract_specifier+0x338>
		break;
    a000680c:	d503201f 	nop
    a0006810:	14000004 	b	a0006820 <extract_specifier+0x338>
		break;
    a0006814:	d503201f 	nop
    a0006818:	14000002 	b	a0006820 <extract_specifier+0x338>
		break;
    a000681c:	d503201f 	nop
	}

	conv->unsupported |= unsupported;
    a0006820:	f94007e0 	ldr	x0, [sp, #8]
    a0006824:	b9400000 	ldr	w0, [x0]
    a0006828:	d3410400 	ubfx	x0, x0, #1, #1
    a000682c:	12001c01 	and	w1, w0, #0xff
    a0006830:	39407fe0 	ldrb	w0, [sp, #31]
    a0006834:	2a000020 	orr	w0, w1, w0
    a0006838:	12001c00 	and	w0, w0, #0xff
    a000683c:	7100001f 	cmp	w0, #0x0
    a0006840:	1a9f07e0 	cset	w0, ne  // ne = any
    a0006844:	12001c02 	and	w2, w0, #0xff
    a0006848:	f94007e1 	ldr	x1, [sp, #8]
    a000684c:	79400020 	ldrh	w0, [x1]
    a0006850:	331f0040 	bfi	w0, w2, #1, #1
    a0006854:	79000020 	strh	w0, [x1]

	return sp;
    a0006858:	f94003e0 	ldr	x0, [sp]
}
    a000685c:	910083ff 	add	sp, sp, #0x20
    a0006860:	d65f03c0 	ret

00000000a0006864 <extract_conversion>:
 *
 * @return pointer to the first character that follows the specification.
 */
static inline const char *extract_conversion(struct conversion *conv,
					     const char *sp)
{
    a0006864:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0006868:	910003fd 	mov	x29, sp
    a000686c:	f9000fe0 	str	x0, [sp, #24]
    a0006870:	f9000be1 	str	x1, [sp, #16]
	*conv = (struct conversion) {
    a0006874:	f9400fe0 	ldr	x0, [sp, #24]
    a0006878:	f900001f 	str	xzr, [x0]
    a000687c:	b900081f 	str	wzr, [x0, #8]

	/* Skip over the opening %.  If the conversion specifier is %,
	 * that's the only thing that should be there, so
	 * fast-exit.
	 */
	++sp;
    a0006880:	f9400be0 	ldr	x0, [sp, #16]
    a0006884:	91000400 	add	x0, x0, #0x1
    a0006888:	f9000be0 	str	x0, [sp, #16]
	if (*sp == '%') {
    a000688c:	f9400be0 	ldr	x0, [sp, #16]
    a0006890:	39400000 	ldrb	w0, [x0]
    a0006894:	7100941f 	cmp	w0, #0x25
    a0006898:	54000121 	b.ne	a00068bc <extract_conversion+0x58>  // b.any
		conv->specifier = *sp++;
    a000689c:	f9400be0 	ldr	x0, [sp, #16]
    a00068a0:	91000401 	add	x1, x0, #0x1
    a00068a4:	f9000be1 	str	x1, [sp, #16]
    a00068a8:	39400001 	ldrb	w1, [x0]
    a00068ac:	f9400fe0 	ldr	x0, [sp, #24]
    a00068b0:	39000c01 	strb	w1, [x0, #3]
		return sp;
    a00068b4:	f9400be0 	ldr	x0, [sp, #16]
    a00068b8:	14000016 	b	a0006910 <extract_conversion+0xac>
	}

	sp = extract_flags(conv, sp);
    a00068bc:	f9400be1 	ldr	x1, [sp, #16]
    a00068c0:	f9400fe0 	ldr	x0, [sp, #24]
    a00068c4:	97fffdb8 	bl	a0005fa4 <extract_flags>
    a00068c8:	f9000be0 	str	x0, [sp, #16]
	sp = extract_width(conv, sp);
    a00068cc:	f9400be1 	ldr	x1, [sp, #16]
    a00068d0:	f9400fe0 	ldr	x0, [sp, #24]
    a00068d4:	97fffe02 	bl	a00060dc <extract_width>
    a00068d8:	f9000be0 	str	x0, [sp, #16]
	sp = extract_prec(conv, sp);
    a00068dc:	f9400be1 	ldr	x1, [sp, #16]
    a00068e0:	f9400fe0 	ldr	x0, [sp, #24]
    a00068e4:	97fffe41 	bl	a00061e8 <extract_prec>
    a00068e8:	f9000be0 	str	x0, [sp, #16]
	sp = extract_length(conv, sp);
    a00068ec:	f9400be1 	ldr	x1, [sp, #16]
    a00068f0:	f9400fe0 	ldr	x0, [sp, #24]
    a00068f4:	97fffe88 	bl	a0006314 <extract_length>
    a00068f8:	f9000be0 	str	x0, [sp, #16]
	sp = extract_specifier(conv, sp);
    a00068fc:	f9400be1 	ldr	x1, [sp, #16]
    a0006900:	f9400fe0 	ldr	x0, [sp, #24]
    a0006904:	97fffef9 	bl	a00064e8 <extract_specifier>
    a0006908:	f9000be0 	str	x0, [sp, #16]

	return sp;
    a000690c:	f9400be0 	ldr	x0, [sp, #16]
}
    a0006910:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0006914:	d65f03c0 	ret

00000000a0006918 <_ldiv5>:

#ifdef CONFIG_64BIT

static void _ldiv5(uint64_t *v)
{
    a0006918:	d10043ff 	sub	sp, sp, #0x10
    a000691c:	f90007e0 	str	x0, [sp, #8]
	/* The compiler can optimize this on its own on 64-bit architectures */
	*v /= 5U;
    a0006920:	f94007e0 	ldr	x0, [sp, #8]
    a0006924:	f9400001 	ldr	x1, [x0]
    a0006928:	b202e7e0 	mov	x0, #0xcccccccccccccccc    	// #-3689348814741910324
    a000692c:	f29999a0 	movk	x0, #0xcccd
    a0006930:	9bc07c20 	umulh	x0, x1, x0
    a0006934:	d342fc01 	lsr	x1, x0, #2
    a0006938:	f94007e0 	ldr	x0, [sp, #8]
    a000693c:	f9000001 	str	x1, [x0]
}
    a0006940:	d503201f 	nop
    a0006944:	910043ff 	add	sp, sp, #0x10
    a0006948:	d65f03c0 	ret

00000000a000694c <_ldiv10>:

#endif /* CONFIG_64BIT */

/* Division by 10 */
static void _ldiv10(uint64_t *v)
{
    a000694c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0006950:	910003fd 	mov	x29, sp
    a0006954:	f9000fe0 	str	x0, [sp, #24]
	*v >>= 1;
    a0006958:	f9400fe0 	ldr	x0, [sp, #24]
    a000695c:	f9400000 	ldr	x0, [x0]
    a0006960:	d341fc01 	lsr	x1, x0, #1
    a0006964:	f9400fe0 	ldr	x0, [sp, #24]
    a0006968:	f9000001 	str	x1, [x0]
	_ldiv5(v);
    a000696c:	f9400fe0 	ldr	x0, [sp, #24]
    a0006970:	97ffffea 	bl	a0006918 <_ldiv5>
}
    a0006974:	d503201f 	nop
    a0006978:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a000697c:	d65f03c0 	ret

00000000a0006980 <_get_digit>:

/* Extract the next decimal character in the converted representation of a
 * fractional component.
 */
static char _get_digit(uint64_t *fr, int *digit_count)
{
    a0006980:	d10083ff 	sub	sp, sp, #0x20
    a0006984:	f90007e0 	str	x0, [sp, #8]
    a0006988:	f90003e1 	str	x1, [sp]
	char rval;

	if (*digit_count > 0) {
    a000698c:	f94003e0 	ldr	x0, [sp]
    a0006990:	b9400000 	ldr	w0, [x0]
    a0006994:	7100001f 	cmp	w0, #0x0
    a0006998:	5400036d 	b.le	a0006a04 <_get_digit+0x84>
		--*digit_count;
    a000699c:	f94003e0 	ldr	x0, [sp]
    a00069a0:	b9400000 	ldr	w0, [x0]
    a00069a4:	51000401 	sub	w1, w0, #0x1
    a00069a8:	f94003e0 	ldr	x0, [sp]
    a00069ac:	b9000001 	str	w1, [x0]
		*fr *= 10U;
    a00069b0:	f94007e0 	ldr	x0, [sp, #8]
    a00069b4:	f9400001 	ldr	x1, [x0]
    a00069b8:	aa0103e0 	mov	x0, x1
    a00069bc:	d37ef400 	lsl	x0, x0, #2
    a00069c0:	8b010000 	add	x0, x0, x1
    a00069c4:	8b000000 	add	x0, x0, x0
    a00069c8:	aa0003e1 	mov	x1, x0
    a00069cc:	f94007e0 	ldr	x0, [sp, #8]
    a00069d0:	f9000001 	str	x1, [x0]
		rval = ((*fr >> 60) & 0xF) + '0';
    a00069d4:	f94007e0 	ldr	x0, [sp, #8]
    a00069d8:	f9400000 	ldr	x0, [x0]
    a00069dc:	d37cfc00 	lsr	x0, x0, #60
    a00069e0:	12001c00 	and	w0, w0, #0xff
    a00069e4:	1100c000 	add	w0, w0, #0x30
    a00069e8:	39007fe0 	strb	w0, [sp, #31]
		*fr &= (BIT64(60) - 1U);
    a00069ec:	f94007e0 	ldr	x0, [sp, #8]
    a00069f0:	f9400000 	ldr	x0, [x0]
    a00069f4:	9240ec01 	and	x1, x0, #0xfffffffffffffff
    a00069f8:	f94007e0 	ldr	x0, [sp, #8]
    a00069fc:	f9000001 	str	x1, [x0]
    a0006a00:	14000003 	b	a0006a0c <_get_digit+0x8c>
	} else {
		rval = '0';
    a0006a04:	52800600 	mov	w0, #0x30                  	// #48
    a0006a08:	39007fe0 	strb	w0, [sp, #31]
	}

	return rval;
    a0006a0c:	39407fe0 	ldrb	w0, [sp, #31]
}
    a0006a10:	910083ff 	add	sp, sp, #0x20
    a0006a14:	d65f03c0 	ret

00000000a0006a18 <conversion_radix>:

static inline size_t conversion_radix(char specifier)
{
    a0006a18:	d10043ff 	sub	sp, sp, #0x10
    a0006a1c:	39003fe0 	strb	w0, [sp, #15]
	switch (specifier) {
    a0006a20:	39403fe0 	ldrb	w0, [sp, #15]
    a0006a24:	7101e01f 	cmp	w0, #0x78
    a0006a28:	540001e0 	b.eq	a0006a64 <conversion_radix+0x4c>  // b.none
    a0006a2c:	7101e01f 	cmp	w0, #0x78
    a0006a30:	5400012c 	b.gt	a0006a54 <conversion_radix+0x3c>
    a0006a34:	7101c01f 	cmp	w0, #0x70
    a0006a38:	54000160 	b.eq	a0006a64 <conversion_radix+0x4c>  // b.none
    a0006a3c:	7101c01f 	cmp	w0, #0x70
    a0006a40:	540000ac 	b.gt	a0006a54 <conversion_radix+0x3c>
    a0006a44:	7101601f 	cmp	w0, #0x58
    a0006a48:	540000e0 	b.eq	a0006a64 <conversion_radix+0x4c>  // b.none
    a0006a4c:	7101bc1f 	cmp	w0, #0x6f
    a0006a50:	54000060 	b.eq	a0006a5c <conversion_radix+0x44>  // b.none
	default:
	case 'd':
	case 'i':
	case 'u':
		return 10;
    a0006a54:	d2800140 	mov	x0, #0xa                   	// #10
    a0006a58:	14000004 	b	a0006a68 <conversion_radix+0x50>
	case 'o':
		return 8;
    a0006a5c:	d2800100 	mov	x0, #0x8                   	// #8
    a0006a60:	14000002 	b	a0006a68 <conversion_radix+0x50>
	case 'p':
	case 'x':
	case 'X':
		return 16;
    a0006a64:	d2800200 	mov	x0, #0x10                  	// #16
	}
}
    a0006a68:	910043ff 	add	sp, sp, #0x10
    a0006a6c:	d65f03c0 	ret

00000000a0006a70 <encode_uint>:
 */
static char *encode_uint(uint_value_type value,
			 struct conversion *conv,
			 char *bps,
			 const char *bpe)
{
    a0006a70:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a0006a74:	910003fd 	mov	x29, sp
    a0006a78:	f90017e0 	str	x0, [sp, #40]
    a0006a7c:	f90013e1 	str	x1, [sp, #32]
    a0006a80:	f9000fe2 	str	x2, [sp, #24]
    a0006a84:	f9000be3 	str	x3, [sp, #16]
	bool upcase = isupper((int)conv->specifier);
    a0006a88:	f94013e0 	ldr	x0, [sp, #32]
    a0006a8c:	39400c00 	ldrb	w0, [x0, #3]
    a0006a90:	97fffd12 	bl	a0005ed8 <isupper>
    a0006a94:	7100001f 	cmp	w0, #0x0
    a0006a98:	1a9f07e0 	cset	w0, ne  // ne = any
    a0006a9c:	39011fe0 	strb	w0, [sp, #71]
	const unsigned int radix = conversion_radix(conv->specifier);
    a0006aa0:	f94013e0 	ldr	x0, [sp, #32]
    a0006aa4:	39400c00 	ldrb	w0, [x0, #3]
    a0006aa8:	97ffffdc 	bl	a0006a18 <conversion_radix>
    a0006aac:	b90043e0 	str	w0, [sp, #64]
	char *bp = bps + (bpe - bps);
    a0006ab0:	f9400be0 	ldr	x0, [sp, #16]
    a0006ab4:	f90027e0 	str	x0, [sp, #72]

	do {
		unsigned int lsv = (unsigned int)(value % radix);
    a0006ab8:	b94043e1 	ldr	w1, [sp, #64]
    a0006abc:	f94017e0 	ldr	x0, [sp, #40]
    a0006ac0:	9ac10802 	udiv	x2, x0, x1
    a0006ac4:	9b017c41 	mul	x1, x2, x1
    a0006ac8:	cb010000 	sub	x0, x0, x1
    a0006acc:	b9003fe0 	str	w0, [sp, #60]

		*--bp = (lsv <= 9) ? ('0' + lsv)
    a0006ad0:	b9403fe0 	ldr	w0, [sp, #60]
    a0006ad4:	7100241f 	cmp	w0, #0x9
    a0006ad8:	540000c8 	b.hi	a0006af0 <encode_uint+0x80>  // b.pmore
    a0006adc:	b9403fe0 	ldr	w0, [sp, #60]
    a0006ae0:	12001c00 	and	w0, w0, #0xff
    a0006ae4:	1100c000 	add	w0, w0, #0x30
    a0006ae8:	12001c00 	and	w0, w0, #0xff
    a0006aec:	1400000d 	b	a0006b20 <encode_uint+0xb0>
    a0006af0:	39411fe0 	ldrb	w0, [sp, #71]
    a0006af4:	7100001f 	cmp	w0, #0x0
    a0006af8:	540000c0 	b.eq	a0006b10 <encode_uint+0xa0>  // b.none
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
    a0006afc:	b9403fe0 	ldr	w0, [sp, #60]
    a0006b00:	12001c00 	and	w0, w0, #0xff
		*--bp = (lsv <= 9) ? ('0' + lsv)
    a0006b04:	1100dc00 	add	w0, w0, #0x37
    a0006b08:	12001c00 	and	w0, w0, #0xff
    a0006b0c:	14000005 	b	a0006b20 <encode_uint+0xb0>
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
    a0006b10:	b9403fe0 	ldr	w0, [sp, #60]
    a0006b14:	12001c00 	and	w0, w0, #0xff
		*--bp = (lsv <= 9) ? ('0' + lsv)
    a0006b18:	11015c00 	add	w0, w0, #0x57
    a0006b1c:	12001c00 	and	w0, w0, #0xff
    a0006b20:	f94027e1 	ldr	x1, [sp, #72]
    a0006b24:	d1000421 	sub	x1, x1, #0x1
    a0006b28:	f90027e1 	str	x1, [sp, #72]
    a0006b2c:	f94027e1 	ldr	x1, [sp, #72]
    a0006b30:	39000020 	strb	w0, [x1]
		value /= radix;
    a0006b34:	b94043e0 	ldr	w0, [sp, #64]
    a0006b38:	f94017e1 	ldr	x1, [sp, #40]
    a0006b3c:	9ac00820 	udiv	x0, x1, x0
    a0006b40:	f90017e0 	str	x0, [sp, #40]
	} while ((value != 0) && (bps < bp));
    a0006b44:	f94017e0 	ldr	x0, [sp, #40]
    a0006b48:	f100001f 	cmp	x0, #0x0
    a0006b4c:	540000a0 	b.eq	a0006b60 <encode_uint+0xf0>  // b.none
    a0006b50:	f9400fe1 	ldr	x1, [sp, #24]
    a0006b54:	f94027e0 	ldr	x0, [sp, #72]
    a0006b58:	eb00003f 	cmp	x1, x0
    a0006b5c:	54fffae3 	b.cc	a0006ab8 <encode_uint+0x48>  // b.lo, b.ul, b.last

	/* Record required alternate forms.  This can be determined
	 * from the radix without re-checking specifier.
	 */
	if (conv->flag_hash) {
    a0006b60:	f94013e0 	ldr	x0, [sp, #32]
    a0006b64:	79400000 	ldrh	w0, [x0]
    a0006b68:	121b0000 	and	w0, w0, #0x20
    a0006b6c:	12003c00 	and	w0, w0, #0xffff
    a0006b70:	7100001f 	cmp	w0, #0x0
    a0006b74:	54000200 	b.eq	a0006bb4 <encode_uint+0x144>  // b.none
		if (radix == 8) {
    a0006b78:	b94043e0 	ldr	w0, [sp, #64]
    a0006b7c:	7100201f 	cmp	w0, #0x8
    a0006b80:	540000c1 	b.ne	a0006b98 <encode_uint+0x128>  // b.any
			conv->altform_0 = true;
    a0006b84:	f94013e0 	ldr	x0, [sp, #32]
    a0006b88:	39400801 	ldrb	w1, [x0, #2]
    a0006b8c:	321d0021 	orr	w1, w1, #0x8
    a0006b90:	39000801 	strb	w1, [x0, #2]
    a0006b94:	14000008 	b	a0006bb4 <encode_uint+0x144>
		} else if (radix == 16) {
    a0006b98:	b94043e0 	ldr	w0, [sp, #64]
    a0006b9c:	7100401f 	cmp	w0, #0x10
    a0006ba0:	540000a1 	b.ne	a0006bb4 <encode_uint+0x144>  // b.any
			conv->altform_0c = true;
    a0006ba4:	f94013e0 	ldr	x0, [sp, #32]
    a0006ba8:	39400801 	ldrb	w1, [x0, #2]
    a0006bac:	321c0021 	orr	w1, w1, #0x10
    a0006bb0:	39000801 	strb	w1, [x0, #2]
		} else {
			;
		}
	}

	return bp;
    a0006bb4:	f94027e0 	ldr	x0, [sp, #72]
}
    a0006bb8:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a0006bbc:	d65f03c0 	ret

00000000a0006bc0 <encode_float>:
			  struct conversion *conv,
			  int precision,
			  char *sign,
			  char *bps,
			  const char **bpe)
{
    a0006bc0:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
    a0006bc4:	910003fd 	mov	x29, sp
    a0006bc8:	f9000bf3 	str	x19, [sp, #16]
    a0006bcc:	fd0027e0 	str	d0, [sp, #72]
    a0006bd0:	f90023e0 	str	x0, [sp, #64]
    a0006bd4:	b9003fe1 	str	w1, [sp, #60]
    a0006bd8:	f9001be2 	str	x2, [sp, #48]
    a0006bdc:	f90017e3 	str	x3, [sp, #40]
    a0006be0:	f90013e4 	str	x4, [sp, #32]
	union {
		uint64_t u64;
		double dbl;
	} u = {
    a0006be4:	fd4027e0 	ldr	d0, [sp, #72]
    a0006be8:	fd003fe0 	str	d0, [sp, #120]
		.dbl = value,
	};
	bool prune_zero = false;
    a0006bec:	39021fff 	strb	wzr, [sp, #135]
	char *buf = bps;
    a0006bf0:	f94017e0 	ldr	x0, [sp, #40]
    a0006bf4:	f90047e0 	str	x0, [sp, #136]

	/* Prepend the sign: '-' if negative, flags control
	 * non-negative behavior.
	 */
	if ((u.u64 & SIGN_MASK) != 0U) {
    a0006bf8:	f9403fe0 	ldr	x0, [sp, #120]
    a0006bfc:	f100001f 	cmp	x0, #0x0
    a0006c00:	540000aa 	b.ge	a0006c14 <encode_float+0x54>  // b.tcont
		*sign = '-';
    a0006c04:	f9401be0 	ldr	x0, [sp, #48]
    a0006c08:	528005a1 	mov	w1, #0x2d                  	// #45
    a0006c0c:	39000001 	strb	w1, [x0]
    a0006c10:	14000014 	b	a0006c60 <encode_float+0xa0>
	} else if (conv->flag_plus) {
    a0006c14:	f94023e0 	ldr	x0, [sp, #64]
    a0006c18:	79400000 	ldrh	w0, [x0]
    a0006c1c:	121d0000 	and	w0, w0, #0x8
    a0006c20:	12003c00 	and	w0, w0, #0xffff
    a0006c24:	7100001f 	cmp	w0, #0x0
    a0006c28:	540000a0 	b.eq	a0006c3c <encode_float+0x7c>  // b.none
		*sign = '+';
    a0006c2c:	f9401be0 	ldr	x0, [sp, #48]
    a0006c30:	52800561 	mov	w1, #0x2b                  	// #43
    a0006c34:	39000001 	strb	w1, [x0]
    a0006c38:	1400000a 	b	a0006c60 <encode_float+0xa0>
	} else if (conv->flag_space) {
    a0006c3c:	f94023e0 	ldr	x0, [sp, #64]
    a0006c40:	79400000 	ldrh	w0, [x0]
    a0006c44:	121c0000 	and	w0, w0, #0x10
    a0006c48:	12003c00 	and	w0, w0, #0xffff
    a0006c4c:	7100001f 	cmp	w0, #0x0
    a0006c50:	54000080 	b.eq	a0006c60 <encode_float+0xa0>  // b.none
		*sign = ' ';
    a0006c54:	f9401be0 	ldr	x0, [sp, #48]
    a0006c58:	52800401 	mov	w1, #0x20                  	// #32
    a0006c5c:	39000001 	strb	w1, [x0]
	}

	/* Extract the non-negative offset exponent and fraction.  Record
	 * whether the value is subnormal.
	 */
	char c = conv->specifier;
    a0006c60:	f94023e0 	ldr	x0, [sp, #64]
    a0006c64:	39400c00 	ldrb	w0, [x0, #3]
    a0006c68:	39024fe0 	strb	w0, [sp, #147]
	int expo = (u.u64 >> FRACTION_BITS) & BIT_MASK(EXPONENT_BITS);
    a0006c6c:	f9403fe0 	ldr	x0, [sp, #120]
    a0006c70:	d374fc00 	lsr	x0, x0, #52
    a0006c74:	12002800 	and	w0, w0, #0x7ff
    a0006c78:	b90097e0 	str	w0, [sp, #148]
	uint64_t fract = u.u64 & BIT64_MASK(FRACTION_BITS);
    a0006c7c:	f9403fe0 	ldr	x0, [sp, #120]
    a0006c80:	9240cc00 	and	x0, x0, #0xfffffffffffff
    a0006c84:	f9003be0 	str	x0, [sp, #112]
	bool is_subnormal = (expo == 0) && (fract != 0);
    a0006c88:	b94097e0 	ldr	w0, [sp, #148]
    a0006c8c:	7100001f 	cmp	w0, #0x0
    a0006c90:	540000c1 	b.ne	a0006ca8 <encode_float+0xe8>  // b.any
    a0006c94:	f9403be0 	ldr	x0, [sp, #112]
    a0006c98:	f100001f 	cmp	x0, #0x0
    a0006c9c:	54000060 	b.eq	a0006ca8 <encode_float+0xe8>  // b.none
    a0006ca0:	52800020 	mov	w0, #0x1                   	// #1
    a0006ca4:	14000002 	b	a0006cac <encode_float+0xec>
    a0006ca8:	52800000 	mov	w0, #0x0                   	// #0
    a0006cac:	39021be0 	strb	w0, [sp, #134]
    a0006cb0:	39421be0 	ldrb	w0, [sp, #134]
    a0006cb4:	12000000 	and	w0, w0, #0x1
    a0006cb8:	39021be0 	strb	w0, [sp, #134]

	/* Exponent of all-ones signals infinity or NaN, which are
	 * text constants regardless of specifier.
	 */
	if (expo == BIT_MASK(EXPONENT_BITS)) {
    a0006cbc:	b94097e0 	ldr	w0, [sp, #148]
    a0006cc0:	711ffc1f 	cmp	w0, #0x7ff
    a0006cc4:	54000a81 	b.ne	a0006e14 <encode_float+0x254>  // b.any
		if (fract == 0) {
    a0006cc8:	f9403be0 	ldr	x0, [sp, #112]
    a0006ccc:	f100001f 	cmp	x0, #0x0
    a0006cd0:	540004a1 	b.ne	a0006d64 <encode_float+0x1a4>  // b.any
			if (isupper((int)c)) {
    a0006cd4:	39424fe0 	ldrb	w0, [sp, #147]
    a0006cd8:	97fffc80 	bl	a0005ed8 <isupper>
    a0006cdc:	7100001f 	cmp	w0, #0x0
    a0006ce0:	54000220 	b.eq	a0006d24 <encode_float+0x164>  // b.none
				*buf++ = 'I';
    a0006ce4:	f94047e0 	ldr	x0, [sp, #136]
    a0006ce8:	91000401 	add	x1, x0, #0x1
    a0006cec:	f90047e1 	str	x1, [sp, #136]
    a0006cf0:	52800921 	mov	w1, #0x49                  	// #73
    a0006cf4:	39000001 	strb	w1, [x0]
				*buf++ = 'N';
    a0006cf8:	f94047e0 	ldr	x0, [sp, #136]
    a0006cfc:	91000401 	add	x1, x0, #0x1
    a0006d00:	f90047e1 	str	x1, [sp, #136]
    a0006d04:	528009c1 	mov	w1, #0x4e                  	// #78
    a0006d08:	39000001 	strb	w1, [x0]
				*buf++ = 'F';
    a0006d0c:	f94047e0 	ldr	x0, [sp, #136]
    a0006d10:	91000401 	add	x1, x0, #0x1
    a0006d14:	f90047e1 	str	x1, [sp, #136]
    a0006d18:	528008c1 	mov	w1, #0x46                  	// #70
    a0006d1c:	39000001 	strb	w1, [x0]
    a0006d20:	14000034 	b	a0006df0 <encode_float+0x230>
			} else {
				*buf++ = 'i';
    a0006d24:	f94047e0 	ldr	x0, [sp, #136]
    a0006d28:	91000401 	add	x1, x0, #0x1
    a0006d2c:	f90047e1 	str	x1, [sp, #136]
    a0006d30:	52800d21 	mov	w1, #0x69                  	// #105
    a0006d34:	39000001 	strb	w1, [x0]
				*buf++ = 'n';
    a0006d38:	f94047e0 	ldr	x0, [sp, #136]
    a0006d3c:	91000401 	add	x1, x0, #0x1
    a0006d40:	f90047e1 	str	x1, [sp, #136]
    a0006d44:	52800dc1 	mov	w1, #0x6e                  	// #110
    a0006d48:	39000001 	strb	w1, [x0]
				*buf++ = 'f';
    a0006d4c:	f94047e0 	ldr	x0, [sp, #136]
    a0006d50:	91000401 	add	x1, x0, #0x1
    a0006d54:	f90047e1 	str	x1, [sp, #136]
    a0006d58:	52800cc1 	mov	w1, #0x66                  	// #102
    a0006d5c:	39000001 	strb	w1, [x0]
    a0006d60:	14000024 	b	a0006df0 <encode_float+0x230>
			}
		} else {
			if (isupper((int)c)) {
    a0006d64:	39424fe0 	ldrb	w0, [sp, #147]
    a0006d68:	97fffc5c 	bl	a0005ed8 <isupper>
    a0006d6c:	7100001f 	cmp	w0, #0x0
    a0006d70:	54000220 	b.eq	a0006db4 <encode_float+0x1f4>  // b.none
				*buf++ = 'N';
    a0006d74:	f94047e0 	ldr	x0, [sp, #136]
    a0006d78:	91000401 	add	x1, x0, #0x1
    a0006d7c:	f90047e1 	str	x1, [sp, #136]
    a0006d80:	528009c1 	mov	w1, #0x4e                  	// #78
    a0006d84:	39000001 	strb	w1, [x0]
				*buf++ = 'A';
    a0006d88:	f94047e0 	ldr	x0, [sp, #136]
    a0006d8c:	91000401 	add	x1, x0, #0x1
    a0006d90:	f90047e1 	str	x1, [sp, #136]
    a0006d94:	52800821 	mov	w1, #0x41                  	// #65
    a0006d98:	39000001 	strb	w1, [x0]
				*buf++ = 'N';
    a0006d9c:	f94047e0 	ldr	x0, [sp, #136]
    a0006da0:	91000401 	add	x1, x0, #0x1
    a0006da4:	f90047e1 	str	x1, [sp, #136]
    a0006da8:	528009c1 	mov	w1, #0x4e                  	// #78
    a0006dac:	39000001 	strb	w1, [x0]
    a0006db0:	14000010 	b	a0006df0 <encode_float+0x230>
			} else {
				*buf++ = 'n';
    a0006db4:	f94047e0 	ldr	x0, [sp, #136]
    a0006db8:	91000401 	add	x1, x0, #0x1
    a0006dbc:	f90047e1 	str	x1, [sp, #136]
    a0006dc0:	52800dc1 	mov	w1, #0x6e                  	// #110
    a0006dc4:	39000001 	strb	w1, [x0]
				*buf++ = 'a';
    a0006dc8:	f94047e0 	ldr	x0, [sp, #136]
    a0006dcc:	91000401 	add	x1, x0, #0x1
    a0006dd0:	f90047e1 	str	x1, [sp, #136]
    a0006dd4:	52800c21 	mov	w1, #0x61                  	// #97
    a0006dd8:	39000001 	strb	w1, [x0]
				*buf++ = 'n';
    a0006ddc:	f94047e0 	ldr	x0, [sp, #136]
    a0006de0:	91000401 	add	x1, x0, #0x1
    a0006de4:	f90047e1 	str	x1, [sp, #136]
    a0006de8:	52800dc1 	mov	w1, #0x6e                  	// #110
    a0006dec:	39000001 	strb	w1, [x0]
			}
		}

		/* No zero-padding with text values */
		conv->flag_zero = false;
    a0006df0:	f94023e0 	ldr	x0, [sp, #64]
    a0006df4:	79400001 	ldrh	w1, [x0]
    a0006df8:	12197821 	and	w1, w1, #0xffffffbf
    a0006dfc:	79000001 	strh	w1, [x0]

		*bpe = buf;
    a0006e00:	f94013e0 	ldr	x0, [sp, #32]
    a0006e04:	f94047e1 	ldr	x1, [sp, #136]
    a0006e08:	f9000001 	str	x1, [x0]
		return bps;
    a0006e0c:	f94017e0 	ldr	x0, [sp, #40]
    a0006e10:	140001bd 	b	a0007504 <encode_float+0x944>
	}

	/* The case of an F specifier is no longer relevant. */
	if (c == 'F') {
    a0006e14:	39424fe0 	ldrb	w0, [sp, #147]
    a0006e18:	7101181f 	cmp	w0, #0x46
    a0006e1c:	54000061 	b.ne	a0006e28 <encode_float+0x268>  // b.any
		c = 'f';
    a0006e20:	52800cc0 	mov	w0, #0x66                  	// #102
    a0006e24:	39024fe0 	strb	w0, [sp, #147]

	/* Remainder of code operates on a 64-bit fraction, so shift up (and
	 * discard garbage from the exponent where the implicit 1 would be
	 * stored).
	 */
	fract <<= EXPONENT_BITS;
    a0006e28:	f9403be0 	ldr	x0, [sp, #112]
    a0006e2c:	d375d000 	lsl	x0, x0, #11
    a0006e30:	f9003be0 	str	x0, [sp, #112]
	fract &= ~SIGN_MASK;
    a0006e34:	f9403be0 	ldr	x0, [sp, #112]
    a0006e38:	9240f800 	and	x0, x0, #0x7fffffffffffffff
    a0006e3c:	f9003be0 	str	x0, [sp, #112]

	/* Non-zero values need normalization. */
	if ((expo | fract) != 0) {
    a0006e40:	b98097e1 	ldrsw	x1, [sp, #148]
    a0006e44:	f9403be0 	ldr	x0, [sp, #112]
    a0006e48:	aa000020 	orr	x0, x1, x0
    a0006e4c:	f100001f 	cmp	x0, #0x0
    a0006e50:	54000280 	b.eq	a0006ea0 <encode_float+0x2e0>  // b.none
		if (is_subnormal) {
    a0006e54:	39421be0 	ldrb	w0, [sp, #134]
    a0006e58:	7100001f 	cmp	w0, #0x0
    a0006e5c:	54000160 	b.eq	a0006e88 <encode_float+0x2c8>  // b.none
			/* Fraction is subnormal.  Normalize it and correct
			 * the exponent.
			 */
			while (((fract <<= 1) & BIT_63) == 0) {
    a0006e60:	14000004 	b	a0006e70 <encode_float+0x2b0>
				expo--;
    a0006e64:	b94097e0 	ldr	w0, [sp, #148]
    a0006e68:	51000400 	sub	w0, w0, #0x1
    a0006e6c:	b90097e0 	str	w0, [sp, #148]
			while (((fract <<= 1) & BIT_63) == 0) {
    a0006e70:	f9403be0 	ldr	x0, [sp, #112]
    a0006e74:	8b000000 	add	x0, x0, x0
    a0006e78:	f9003be0 	str	x0, [sp, #112]
    a0006e7c:	f9403be0 	ldr	x0, [sp, #112]
    a0006e80:	f100001f 	cmp	x0, #0x0
    a0006e84:	54ffff0a 	b.ge	a0006e64 <encode_float+0x2a4>  // b.tcont
		}
		/* Adjust the offset exponent to be signed rather than offset,
		 * and set the implicit 1 bit in the (shifted) 53-bit
		 * fraction.
		 */
		expo -= (1023 - 1);	/* +1 since .1 vs 1. */
    a0006e88:	b94097e0 	ldr	w0, [sp, #148]
    a0006e8c:	510ff800 	sub	w0, w0, #0x3fe
    a0006e90:	b90097e0 	str	w0, [sp, #148]
		fract |= BIT_63;
    a0006e94:	f9403be0 	ldr	x0, [sp, #112]
    a0006e98:	b2410000 	orr	x0, x0, #0x8000000000000000
    a0006e9c:	f9003be0 	str	x0, [sp, #112]
	 *	value = fract * 2^expo * 10^decexp
	 *
	 * Initially decexp = 0. The goal is to bring exp between
	 * 0 and -2 as the magnitude of a fractional decimal digit is 3 bits.
	 */
	int decexp = 0;
    a0006ea0:	b9009bff 	str	wzr, [sp, #152]

	while (expo < -2) {
    a0006ea4:	14000018 	b	a0006f04 <encode_float+0x344>
		/*
		 * Make roon to allow a multiplication by 5 without overflow.
		 * We test only the top part for faster code.
		 */
		do {
			fract >>= 1;
    a0006ea8:	f9403be0 	ldr	x0, [sp, #112]
    a0006eac:	d341fc00 	lsr	x0, x0, #1
    a0006eb0:	f9003be0 	str	x0, [sp, #112]
			expo++;
    a0006eb4:	b94097e0 	ldr	w0, [sp, #148]
    a0006eb8:	11000400 	add	w0, w0, #0x1
    a0006ebc:	b90097e0 	str	w0, [sp, #148]
		} while ((uint32_t)(fract >> 32) >= (UINT32_MAX / 5U));
    a0006ec0:	f9403be0 	ldr	x0, [sp, #112]
    a0006ec4:	d360fc00 	lsr	x0, x0, #32
    a0006ec8:	2a0003e1 	mov	w1, w0
    a0006ecc:	3200e7e0 	mov	w0, #0x33333333            	// #858993459
    a0006ed0:	6b00003f 	cmp	w1, w0
    a0006ed4:	54fffea2 	b.cs	a0006ea8 <encode_float+0x2e8>  // b.hs, b.nlast

		/* Perform fract * 5 * 2 / 10 */
		fract *= 5U;
    a0006ed8:	f9403be1 	ldr	x1, [sp, #112]
    a0006edc:	aa0103e0 	mov	x0, x1
    a0006ee0:	d37ef400 	lsl	x0, x0, #2
    a0006ee4:	8b010000 	add	x0, x0, x1
    a0006ee8:	f9003be0 	str	x0, [sp, #112]
		expo++;
    a0006eec:	b94097e0 	ldr	w0, [sp, #148]
    a0006ef0:	11000400 	add	w0, w0, #0x1
    a0006ef4:	b90097e0 	str	w0, [sp, #148]
		decexp--;
    a0006ef8:	b9409be0 	ldr	w0, [sp, #152]
    a0006efc:	51000400 	sub	w0, w0, #0x1
    a0006f00:	b9009be0 	str	w0, [sp, #152]
	while (expo < -2) {
    a0006f04:	b94097e0 	ldr	w0, [sp, #148]
    a0006f08:	3100081f 	cmn	w0, #0x2
    a0006f0c:	54fffceb 	b.lt	a0006ea8 <encode_float+0x2e8>  // b.tstop
	}

	while (expo > 0) {
    a0006f10:	14000015 	b	a0006f64 <encode_float+0x3a4>
		/*
		 * Perform fract / 5 / 2 * 10.
		 * The +2 is there to do round the result of the division
		 * by 5 not to lose too much precision in extreme cases.
		 */
		fract += 2;
    a0006f14:	f9403be0 	ldr	x0, [sp, #112]
    a0006f18:	91000800 	add	x0, x0, #0x2
    a0006f1c:	f9003be0 	str	x0, [sp, #112]
		_ldiv5(&fract);
    a0006f20:	9101c3e0 	add	x0, sp, #0x70
    a0006f24:	97fffe7d 	bl	a0006918 <_ldiv5>
		expo--;
    a0006f28:	b94097e0 	ldr	w0, [sp, #148]
    a0006f2c:	51000400 	sub	w0, w0, #0x1
    a0006f30:	b90097e0 	str	w0, [sp, #148]
		decexp++;
    a0006f34:	b9409be0 	ldr	w0, [sp, #152]
    a0006f38:	11000400 	add	w0, w0, #0x1
    a0006f3c:	b9009be0 	str	w0, [sp, #152]

		/* Bring back our fractional number to full scale */
		do {
			fract <<= 1;
    a0006f40:	f9403be0 	ldr	x0, [sp, #112]
    a0006f44:	8b000000 	add	x0, x0, x0
    a0006f48:	f9003be0 	str	x0, [sp, #112]
			expo--;
    a0006f4c:	b94097e0 	ldr	w0, [sp, #148]
    a0006f50:	51000400 	sub	w0, w0, #0x1
    a0006f54:	b90097e0 	str	w0, [sp, #148]
		} while (!(fract & BIT_63));
    a0006f58:	f9403be0 	ldr	x0, [sp, #112]
    a0006f5c:	f100001f 	cmp	x0, #0x0
    a0006f60:	54ffff0a 	b.ge	a0006f40 <encode_float+0x380>  // b.tcont
	while (expo > 0) {
    a0006f64:	b94097e0 	ldr	w0, [sp, #148]
    a0006f68:	7100001f 	cmp	w0, #0x0
    a0006f6c:	54fffd4c 	b.gt	a0006f14 <encode_float+0x354>
	/*
	 * The binary fractional point is located somewhere above bit 63.
	 * Move it between bits 59 and 60 to give 4 bits of room to the
	 * integer part.
	 */
	fract >>= (4 - expo);
    a0006f70:	f9403be1 	ldr	x1, [sp, #112]
    a0006f74:	52800082 	mov	w2, #0x4                   	// #4
    a0006f78:	b94097e0 	ldr	w0, [sp, #148]
    a0006f7c:	4b000040 	sub	w0, w2, w0
    a0006f80:	9ac02420 	lsr	x0, x1, x0
    a0006f84:	f9003be0 	str	x0, [sp, #112]

	if ((c == 'g') || (c == 'G')) {
    a0006f88:	39424fe0 	ldrb	w0, [sp, #147]
    a0006f8c:	71019c1f 	cmp	w0, #0x67
    a0006f90:	54000080 	b.eq	a0006fa0 <encode_float+0x3e0>  // b.none
    a0006f94:	39424fe0 	ldrb	w0, [sp, #147]
    a0006f98:	71011c1f 	cmp	w0, #0x47
    a0006f9c:	540004a1 	b.ne	a0007030 <encode_float+0x470>  // b.any
		/* Use the specified precision and exponent to select the
		 * representation and correct the precision and zero-pruning
		 * in accordance with the ISO C rule.
		 */
		if (decexp < (-4 + 1) || decexp > precision) {
    a0006fa0:	b9409be0 	ldr	w0, [sp, #152]
    a0006fa4:	31000c1f 	cmn	w0, #0x3
    a0006fa8:	540000ab 	b.lt	a0006fbc <encode_float+0x3fc>  // b.tstop
    a0006fac:	b9409be1 	ldr	w1, [sp, #152]
    a0006fb0:	b9403fe0 	ldr	w0, [sp, #60]
    a0006fb4:	6b00003f 	cmp	w1, w0
    a0006fb8:	5400016d 	b.le	a0006fe4 <encode_float+0x424>
			c += 'e' - 'g';  /* e or E */
    a0006fbc:	39424fe0 	ldrb	w0, [sp, #147]
    a0006fc0:	51000800 	sub	w0, w0, #0x2
    a0006fc4:	39024fe0 	strb	w0, [sp, #147]
			if (precision > 0) {
    a0006fc8:	b9403fe0 	ldr	w0, [sp, #60]
    a0006fcc:	7100001f 	cmp	w0, #0x0
    a0006fd0:	5400016d 	b.le	a0006ffc <encode_float+0x43c>
				precision--;
    a0006fd4:	b9403fe0 	ldr	w0, [sp, #60]
    a0006fd8:	51000400 	sub	w0, w0, #0x1
    a0006fdc:	b9003fe0 	str	w0, [sp, #60]
			if (precision > 0) {
    a0006fe0:	14000007 	b	a0006ffc <encode_float+0x43c>
			}
		} else {
			c = 'f';
    a0006fe4:	52800cc0 	mov	w0, #0x66                  	// #102
    a0006fe8:	39024fe0 	strb	w0, [sp, #147]
			precision -= decexp;
    a0006fec:	b9403fe1 	ldr	w1, [sp, #60]
    a0006ff0:	b9409be0 	ldr	w0, [sp, #152]
    a0006ff4:	4b000020 	sub	w0, w1, w0
    a0006ff8:	b9003fe0 	str	w0, [sp, #60]
		}
		if (!conv->flag_hash && (precision > 0)) {
    a0006ffc:	f94023e0 	ldr	x0, [sp, #64]
    a0007000:	b9400000 	ldr	w0, [x0]
    a0007004:	d3451400 	ubfx	x0, x0, #5, #1
    a0007008:	12001c00 	and	w0, w0, #0xff
    a000700c:	52000000 	eor	w0, w0, #0x1
    a0007010:	12001c00 	and	w0, w0, #0xff
    a0007014:	7100001f 	cmp	w0, #0x0
    a0007018:	540000c0 	b.eq	a0007030 <encode_float+0x470>  // b.none
    a000701c:	b9403fe0 	ldr	w0, [sp, #60]
    a0007020:	7100001f 	cmp	w0, #0x0
    a0007024:	5400006d 	b.le	a0007030 <encode_float+0x470>
			prune_zero = true;
    a0007028:	52800020 	mov	w0, #0x1                   	// #1
    a000702c:	39021fe0 	strb	w0, [sp, #135]
		}
	}

	int decimals;
	if (c == 'f') {
    a0007030:	39424fe0 	ldrb	w0, [sp, #147]
    a0007034:	7101981f 	cmp	w0, #0x66
    a0007038:	54000141 	b.ne	a0007060 <encode_float+0x4a0>  // b.any
		decimals = precision + decexp;
    a000703c:	b9403fe1 	ldr	w1, [sp, #60]
    a0007040:	b9409be0 	ldr	w0, [sp, #152]
    a0007044:	0b000020 	add	w0, w1, w0
    a0007048:	b9009fe0 	str	w0, [sp, #156]
		if (decimals < 0) {
    a000704c:	b9409fe0 	ldr	w0, [sp, #156]
    a0007050:	7100001f 	cmp	w0, #0x0
    a0007054:	540000ca 	b.ge	a000706c <encode_float+0x4ac>  // b.tcont
			decimals = 0;
    a0007058:	b9009fff 	str	wzr, [sp, #156]
    a000705c:	14000004 	b	a000706c <encode_float+0x4ac>
		}
	} else {
		decimals = precision + 1;
    a0007060:	b9403fe0 	ldr	w0, [sp, #60]
    a0007064:	11000400 	add	w0, w0, #0x1
    a0007068:	b9009fe0 	str	w0, [sp, #156]
	}

	int digit_count = 16;
    a000706c:	52800200 	mov	w0, #0x10                  	// #16
    a0007070:	b9006fe0 	str	w0, [sp, #108]

	if (decimals > 16) {
    a0007074:	b9409fe0 	ldr	w0, [sp, #156]
    a0007078:	7100401f 	cmp	w0, #0x10
    a000707c:	5400006d 	b.le	a0007088 <encode_float+0x4c8>
		decimals = 16;
    a0007080:	52800200 	mov	w0, #0x10                  	// #16
    a0007084:	b9009fe0 	str	w0, [sp, #156]
	}

	/* Round the value to the last digit being printed. */
	uint64_t round = BIT64(59); /* 0.5 */
    a0007088:	d2e10000 	mov	x0, #0x800000000000000     	// #576460752303423488
    a000708c:	f90033e0 	str	x0, [sp, #96]
	while (decimals--) {
    a0007090:	14000003 	b	a000709c <encode_float+0x4dc>
		_ldiv10(&round);
    a0007094:	910183e0 	add	x0, sp, #0x60
    a0007098:	97fffe2d 	bl	a000694c <_ldiv10>
	while (decimals--) {
    a000709c:	b9409fe0 	ldr	w0, [sp, #156]
    a00070a0:	51000401 	sub	w1, w0, #0x1
    a00070a4:	b9009fe1 	str	w1, [sp, #156]
    a00070a8:	7100001f 	cmp	w0, #0x0
    a00070ac:	54ffff41 	b.ne	a0007094 <encode_float+0x4d4>  // b.any
	}
	fract += round;
    a00070b0:	f9403be1 	ldr	x1, [sp, #112]
    a00070b4:	f94033e0 	ldr	x0, [sp, #96]
    a00070b8:	8b000020 	add	x0, x1, x0
    a00070bc:	f9003be0 	str	x0, [sp, #112]
	/* Make sure rounding didn't make fract >= 1.0 */
	if (fract >= BIT64(60)) {
    a00070c0:	f9403be1 	ldr	x1, [sp, #112]
    a00070c4:	92fe0000 	mov	x0, #0xfffffffffffffff     	// #1152921504606846975
    a00070c8:	eb00003f 	cmp	x1, x0
    a00070cc:	540000c9 	b.ls	a00070e4 <encode_float+0x524>  // b.plast
		_ldiv10(&fract);
    a00070d0:	9101c3e0 	add	x0, sp, #0x70
    a00070d4:	97fffe1e 	bl	a000694c <_ldiv10>
		decexp++;
    a00070d8:	b9409be0 	ldr	w0, [sp, #152]
    a00070dc:	11000400 	add	w0, w0, #0x1
    a00070e0:	b9009be0 	str	w0, [sp, #152]
	}

	if (c == 'f') {
    a00070e4:	39424fe0 	ldrb	w0, [sp, #147]
    a00070e8:	7101981f 	cmp	w0, #0x66
    a00070ec:	540009e1 	b.ne	a0007228 <encode_float+0x668>  // b.any
		if (decexp > 0) {
    a00070f0:	b9409be0 	ldr	w0, [sp, #152]
    a00070f4:	7100001f 	cmp	w0, #0x0
    a00070f8:	5400030d 	b.le	a0007158 <encode_float+0x598>
			/* Emit the digits above the decimal point. */
			while (decexp > 0 && digit_count > 0) {
    a00070fc:	1400000c 	b	a000712c <encode_float+0x56c>
				*buf++ = _get_digit(&fract, &digit_count);
    a0007100:	f94047f3 	ldr	x19, [sp, #136]
    a0007104:	91000660 	add	x0, x19, #0x1
    a0007108:	f90047e0 	str	x0, [sp, #136]
    a000710c:	9101b3e1 	add	x1, sp, #0x6c
    a0007110:	9101c3e0 	add	x0, sp, #0x70
    a0007114:	97fffe1b 	bl	a0006980 <_get_digit>
    a0007118:	12001c00 	and	w0, w0, #0xff
    a000711c:	39000260 	strb	w0, [x19]
				decexp--;
    a0007120:	b9409be0 	ldr	w0, [sp, #152]
    a0007124:	51000400 	sub	w0, w0, #0x1
    a0007128:	b9009be0 	str	w0, [sp, #152]
			while (decexp > 0 && digit_count > 0) {
    a000712c:	b9409be0 	ldr	w0, [sp, #152]
    a0007130:	7100001f 	cmp	w0, #0x0
    a0007134:	5400008d 	b.le	a0007144 <encode_float+0x584>
    a0007138:	b9406fe0 	ldr	w0, [sp, #108]
    a000713c:	7100001f 	cmp	w0, #0x0
    a0007140:	54fffe0c 	b.gt	a0007100 <encode_float+0x540>
			}

			conv->pad0_value = decexp;
    a0007144:	f94023e0 	ldr	x0, [sp, #64]
    a0007148:	b9409be1 	ldr	w1, [sp, #152]
    a000714c:	b9000401 	str	w1, [x0, #4]

			decexp = 0;
    a0007150:	b9009bff 	str	wzr, [sp, #152]
    a0007154:	14000006 	b	a000716c <encode_float+0x5ac>
		} else {
			*buf++ = '0';
    a0007158:	f94047e0 	ldr	x0, [sp, #136]
    a000715c:	91000401 	add	x1, x0, #0x1
    a0007160:	f90047e1 	str	x1, [sp, #136]
    a0007164:	52800601 	mov	w1, #0x30                  	// #48
    a0007168:	39000001 	strb	w1, [x0]
		}

		/* Emit the decimal point only if required by the alternative
		 * format, or if more digits are to follow.
		 */
		if (conv->flag_hash || (precision > 0)) {
    a000716c:	f94023e0 	ldr	x0, [sp, #64]
    a0007170:	79400000 	ldrh	w0, [x0]
    a0007174:	121b0000 	and	w0, w0, #0x20
    a0007178:	12003c00 	and	w0, w0, #0xffff
    a000717c:	7100001f 	cmp	w0, #0x0
    a0007180:	54000081 	b.ne	a0007190 <encode_float+0x5d0>  // b.any
    a0007184:	b9403fe0 	ldr	w0, [sp, #60]
    a0007188:	7100001f 	cmp	w0, #0x0
    a000718c:	540000cd 	b.le	a00071a4 <encode_float+0x5e4>
			*buf++ = '.';
    a0007190:	f94047e0 	ldr	x0, [sp, #136]
    a0007194:	91000401 	add	x1, x0, #0x1
    a0007198:	f90047e1 	str	x1, [sp, #136]
    a000719c:	528005c1 	mov	w1, #0x2e                  	// #46
    a00071a0:	39000001 	strb	w1, [x0]
		}

		if (decexp < 0 && precision > 0) {
    a00071a4:	b9409be0 	ldr	w0, [sp, #152]
    a00071a8:	7100001f 	cmp	w0, #0x0
    a00071ac:	5400090a 	b.ge	a00072cc <encode_float+0x70c>  // b.tcont
    a00071b0:	b9403fe0 	ldr	w0, [sp, #60]
    a00071b4:	7100001f 	cmp	w0, #0x0
    a00071b8:	540008ad 	b.le	a00072cc <encode_float+0x70c>
			conv->pad0_value = -decexp;
    a00071bc:	b9409be0 	ldr	w0, [sp, #152]
    a00071c0:	4b0003e1 	neg	w1, w0
    a00071c4:	f94023e0 	ldr	x0, [sp, #64]
    a00071c8:	b9000401 	str	w1, [x0, #4]
			if (conv->pad0_value > precision) {
    a00071cc:	f94023e0 	ldr	x0, [sp, #64]
    a00071d0:	b9400400 	ldr	w0, [x0, #4]
    a00071d4:	b9403fe1 	ldr	w1, [sp, #60]
    a00071d8:	6b00003f 	cmp	w1, w0
    a00071dc:	5400008a 	b.ge	a00071ec <encode_float+0x62c>  // b.tcont
				conv->pad0_value = precision;
    a00071e0:	f94023e0 	ldr	x0, [sp, #64]
    a00071e4:	b9403fe1 	ldr	w1, [sp, #60]
    a00071e8:	b9000401 	str	w1, [x0, #4]
			}

			precision -= conv->pad0_value;
    a00071ec:	f94023e0 	ldr	x0, [sp, #64]
    a00071f0:	b9400400 	ldr	w0, [x0, #4]
    a00071f4:	b9403fe1 	ldr	w1, [sp, #60]
    a00071f8:	4b000020 	sub	w0, w1, w0
    a00071fc:	b9003fe0 	str	w0, [sp, #60]
			conv->pad_postdp = (conv->pad0_value > 0);
    a0007200:	f94023e0 	ldr	x0, [sp, #64]
    a0007204:	b9400400 	ldr	w0, [x0, #4]
    a0007208:	7100001f 	cmp	w0, #0x0
    a000720c:	1a9fd7e0 	cset	w0, gt
    a0007210:	12001c02 	and	w2, w0, #0xff
    a0007214:	f94023e1 	ldr	x1, [sp, #64]
    a0007218:	39400820 	ldrb	w0, [x1, #2]
    a000721c:	331b0040 	bfi	w0, w2, #5, #1
    a0007220:	39000820 	strb	w0, [x1, #2]
    a0007224:	1400002a 	b	a00072cc <encode_float+0x70c>
		}
	} else { /* e or E */
		/* Emit the one digit before the decimal.  If it's not zero,
		 * this is significant so reduce the base-10 exponent.
		 */
		*buf = _get_digit(&fract, &digit_count);
    a0007228:	9101b3e1 	add	x1, sp, #0x6c
    a000722c:	9101c3e0 	add	x0, sp, #0x70
    a0007230:	97fffdd4 	bl	a0006980 <_get_digit>
    a0007234:	12001c01 	and	w1, w0, #0xff
    a0007238:	f94047e0 	ldr	x0, [sp, #136]
    a000723c:	39000001 	strb	w1, [x0]
		if (*buf++ != '0') {
    a0007240:	f94047e0 	ldr	x0, [sp, #136]
    a0007244:	91000401 	add	x1, x0, #0x1
    a0007248:	f90047e1 	str	x1, [sp, #136]
    a000724c:	39400000 	ldrb	w0, [x0]
    a0007250:	7100c01f 	cmp	w0, #0x30
    a0007254:	54000080 	b.eq	a0007264 <encode_float+0x6a4>  // b.none
			decexp--;
    a0007258:	b9409be0 	ldr	w0, [sp, #152]
    a000725c:	51000400 	sub	w0, w0, #0x1
    a0007260:	b9009be0 	str	w0, [sp, #152]
		}

		/* Emit the decimal point only if required by the alternative
		 * format, or if more digits are to follow.
		 */
		if (conv->flag_hash || (precision > 0)) {
    a0007264:	f94023e0 	ldr	x0, [sp, #64]
    a0007268:	79400000 	ldrh	w0, [x0]
    a000726c:	121b0000 	and	w0, w0, #0x20
    a0007270:	12003c00 	and	w0, w0, #0xffff
    a0007274:	7100001f 	cmp	w0, #0x0
    a0007278:	54000081 	b.ne	a0007288 <encode_float+0x6c8>  // b.any
    a000727c:	b9403fe0 	ldr	w0, [sp, #60]
    a0007280:	7100001f 	cmp	w0, #0x0
    a0007284:	5400024d 	b.le	a00072cc <encode_float+0x70c>
			*buf++ = '.';
    a0007288:	f94047e0 	ldr	x0, [sp, #136]
    a000728c:	91000401 	add	x1, x0, #0x1
    a0007290:	f90047e1 	str	x1, [sp, #136]
    a0007294:	528005c1 	mov	w1, #0x2e                  	// #46
    a0007298:	39000001 	strb	w1, [x0]
		}
	}

	while (precision > 0 && digit_count > 0) {
    a000729c:	1400000c 	b	a00072cc <encode_float+0x70c>
		*buf++ = _get_digit(&fract, &digit_count);
    a00072a0:	f94047f3 	ldr	x19, [sp, #136]
    a00072a4:	91000660 	add	x0, x19, #0x1
    a00072a8:	f90047e0 	str	x0, [sp, #136]
    a00072ac:	9101b3e1 	add	x1, sp, #0x6c
    a00072b0:	9101c3e0 	add	x0, sp, #0x70
    a00072b4:	97fffdb3 	bl	a0006980 <_get_digit>
    a00072b8:	12001c00 	and	w0, w0, #0xff
    a00072bc:	39000260 	strb	w0, [x19]
		precision--;
    a00072c0:	b9403fe0 	ldr	w0, [sp, #60]
    a00072c4:	51000400 	sub	w0, w0, #0x1
    a00072c8:	b9003fe0 	str	w0, [sp, #60]
	while (precision > 0 && digit_count > 0) {
    a00072cc:	b9403fe0 	ldr	w0, [sp, #60]
    a00072d0:	7100001f 	cmp	w0, #0x0
    a00072d4:	5400008d 	b.le	a00072e4 <encode_float+0x724>
    a00072d8:	b9406fe0 	ldr	w0, [sp, #108]
    a00072dc:	7100001f 	cmp	w0, #0x0
    a00072e0:	54fffe0c 	b.gt	a00072a0 <encode_float+0x6e0>
	}

	conv->pad0_pre_exp = precision;
    a00072e4:	f94023e0 	ldr	x0, [sp, #64]
    a00072e8:	b9403fe1 	ldr	w1, [sp, #60]
    a00072ec:	b9000801 	str	w1, [x0, #8]

	if (prune_zero) {
    a00072f0:	39421fe0 	ldrb	w0, [sp, #135]
    a00072f4:	7100001f 	cmp	w0, #0x0
    a00072f8:	54000220 	b.eq	a000733c <encode_float+0x77c>  // b.none
		conv->pad0_pre_exp = 0;
    a00072fc:	f94023e0 	ldr	x0, [sp, #64]
    a0007300:	b900081f 	str	wzr, [x0, #8]
		while (*--buf == '0') {
    a0007304:	f94047e0 	ldr	x0, [sp, #136]
    a0007308:	d1000400 	sub	x0, x0, #0x1
    a000730c:	f90047e0 	str	x0, [sp, #136]
    a0007310:	f94047e0 	ldr	x0, [sp, #136]
    a0007314:	39400000 	ldrb	w0, [x0]
    a0007318:	7100c01f 	cmp	w0, #0x30
    a000731c:	54ffff40 	b.eq	a0007304 <encode_float+0x744>  // b.none
			;
		}
		if (*buf != '.') {
    a0007320:	f94047e0 	ldr	x0, [sp, #136]
    a0007324:	39400000 	ldrb	w0, [x0]
    a0007328:	7100b81f 	cmp	w0, #0x2e
    a000732c:	54000080 	b.eq	a000733c <encode_float+0x77c>  // b.none
			buf++;
    a0007330:	f94047e0 	ldr	x0, [sp, #136]
    a0007334:	91000400 	add	x0, x0, #0x1
    a0007338:	f90047e0 	str	x0, [sp, #136]
		}
	}

	/* Emit the explicit exponent, if format requires it. */
	if ((c == 'e') || (c == 'E')) {
    a000733c:	39424fe0 	ldrb	w0, [sp, #147]
    a0007340:	7101941f 	cmp	w0, #0x65
    a0007344:	54000080 	b.eq	a0007354 <encode_float+0x794>  // b.none
    a0007348:	39424fe0 	ldrb	w0, [sp, #147]
    a000734c:	7101141f 	cmp	w0, #0x45
    a0007350:	54000ac1 	b.ne	a00074a8 <encode_float+0x8e8>  // b.any
		*buf++ = c;
    a0007354:	f94047e0 	ldr	x0, [sp, #136]
    a0007358:	91000401 	add	x1, x0, #0x1
    a000735c:	f90047e1 	str	x1, [sp, #136]
    a0007360:	39424fe1 	ldrb	w1, [sp, #147]
    a0007364:	39000001 	strb	w1, [x0]
		if (decexp < 0) {
    a0007368:	b9409be0 	ldr	w0, [sp, #152]
    a000736c:	7100001f 	cmp	w0, #0x0
    a0007370:	5400014a 	b.ge	a0007398 <encode_float+0x7d8>  // b.tcont
			decexp = -decexp;
    a0007374:	b9409be0 	ldr	w0, [sp, #152]
    a0007378:	4b0003e0 	neg	w0, w0
    a000737c:	b9009be0 	str	w0, [sp, #152]
			*buf++ = '-';
    a0007380:	f94047e0 	ldr	x0, [sp, #136]
    a0007384:	91000401 	add	x1, x0, #0x1
    a0007388:	f90047e1 	str	x1, [sp, #136]
    a000738c:	528005a1 	mov	w1, #0x2d                  	// #45
    a0007390:	39000001 	strb	w1, [x0]
    a0007394:	14000006 	b	a00073ac <encode_float+0x7ec>
		} else {
			*buf++ = '+';
    a0007398:	f94047e0 	ldr	x0, [sp, #136]
    a000739c:	91000401 	add	x1, x0, #0x1
    a00073a0:	f90047e1 	str	x1, [sp, #136]
    a00073a4:	52800561 	mov	w1, #0x2b                  	// #43
    a00073a8:	39000001 	strb	w1, [x0]
		}

		/* At most 3 digits to the decimal.  Spit them out. */
		if (decexp >= 100) {
    a00073ac:	b9409be0 	ldr	w0, [sp, #152]
    a00073b0:	71018c1f 	cmp	w0, #0x63
    a00073b4:	5400038d 	b.le	a0007424 <encode_float+0x864>
			*buf++ = (decexp / 100) + '0';
    a00073b8:	b9409be0 	ldr	w0, [sp, #152]
    a00073bc:	5290a3e1 	mov	w1, #0x851f                	// #34079
    a00073c0:	72aa3d61 	movk	w1, #0x51eb, lsl #16
    a00073c4:	9b217c01 	smull	x1, w0, w1
    a00073c8:	d360fc21 	lsr	x1, x1, #32
    a00073cc:	13057c21 	asr	w1, w1, #5
    a00073d0:	131f7c00 	asr	w0, w0, #31
    a00073d4:	4b000020 	sub	w0, w1, w0
    a00073d8:	12001c01 	and	w1, w0, #0xff
    a00073dc:	f94047e0 	ldr	x0, [sp, #136]
    a00073e0:	91000402 	add	x2, x0, #0x1
    a00073e4:	f90047e2 	str	x2, [sp, #136]
    a00073e8:	1100c021 	add	w1, w1, #0x30
    a00073ec:	12001c21 	and	w1, w1, #0xff
    a00073f0:	39000001 	strb	w1, [x0]
			decexp %= 100;
    a00073f4:	b9409be0 	ldr	w0, [sp, #152]
    a00073f8:	5290a3e1 	mov	w1, #0x851f                	// #34079
    a00073fc:	72aa3d61 	movk	w1, #0x51eb, lsl #16
    a0007400:	9b217c01 	smull	x1, w0, w1
    a0007404:	d360fc21 	lsr	x1, x1, #32
    a0007408:	13057c22 	asr	w2, w1, #5
    a000740c:	131f7c01 	asr	w1, w0, #31
    a0007410:	4b010042 	sub	w2, w2, w1
    a0007414:	52800c81 	mov	w1, #0x64                  	// #100
    a0007418:	1b017c41 	mul	w1, w2, w1
    a000741c:	4b010000 	sub	w0, w0, w1
    a0007420:	b9009be0 	str	w0, [sp, #152]
		}

		*buf++ = (decexp / 10) + '0';
    a0007424:	b9409be0 	ldr	w0, [sp, #152]
    a0007428:	528ccce1 	mov	w1, #0x6667                	// #26215
    a000742c:	72acccc1 	movk	w1, #0x6666, lsl #16
    a0007430:	9b217c01 	smull	x1, w0, w1
    a0007434:	d360fc21 	lsr	x1, x1, #32
    a0007438:	13027c21 	asr	w1, w1, #2
    a000743c:	131f7c00 	asr	w0, w0, #31
    a0007440:	4b000020 	sub	w0, w1, w0
    a0007444:	12001c01 	and	w1, w0, #0xff
    a0007448:	f94047e0 	ldr	x0, [sp, #136]
    a000744c:	91000402 	add	x2, x0, #0x1
    a0007450:	f90047e2 	str	x2, [sp, #136]
    a0007454:	1100c021 	add	w1, w1, #0x30
    a0007458:	12001c21 	and	w1, w1, #0xff
    a000745c:	39000001 	strb	w1, [x0]
		*buf++ = (decexp % 10) + '0';
    a0007460:	b9409be0 	ldr	w0, [sp, #152]
    a0007464:	528ccce1 	mov	w1, #0x6667                	// #26215
    a0007468:	72acccc1 	movk	w1, #0x6666, lsl #16
    a000746c:	9b217c01 	smull	x1, w0, w1
    a0007470:	d360fc21 	lsr	x1, x1, #32
    a0007474:	13027c22 	asr	w2, w1, #2
    a0007478:	131f7c01 	asr	w1, w0, #31
    a000747c:	4b010041 	sub	w1, w2, w1
    a0007480:	52800142 	mov	w2, #0xa                   	// #10
    a0007484:	1b027c21 	mul	w1, w1, w2
    a0007488:	4b010001 	sub	w1, w0, w1
    a000748c:	12001c21 	and	w1, w1, #0xff
    a0007490:	f94047e0 	ldr	x0, [sp, #136]
    a0007494:	91000402 	add	x2, x0, #0x1
    a0007498:	f90047e2 	str	x2, [sp, #136]
    a000749c:	1100c021 	add	w1, w1, #0x30
    a00074a0:	12001c21 	and	w1, w1, #0xff
    a00074a4:	39000001 	strb	w1, [x0]
	}

	/* Cache whether there's padding required */
	conv->pad_fp = (conv->pad0_value > 0)
    a00074a8:	f94023e0 	ldr	x0, [sp, #64]
    a00074ac:	b9400400 	ldr	w0, [x0, #4]
		|| (conv->pad0_pre_exp > 0);
    a00074b0:	7100001f 	cmp	w0, #0x0
    a00074b4:	540000ac 	b.gt	a00074c8 <encode_float+0x908>
    a00074b8:	f94023e0 	ldr	x0, [sp, #64]
    a00074bc:	b9400800 	ldr	w0, [x0, #8]
    a00074c0:	7100001f 	cmp	w0, #0x0
    a00074c4:	5400006d 	b.le	a00074d0 <encode_float+0x910>
    a00074c8:	52800020 	mov	w0, #0x1                   	// #1
    a00074cc:	14000002 	b	a00074d4 <encode_float+0x914>
    a00074d0:	52800000 	mov	w0, #0x0                   	// #0
    a00074d4:	12000000 	and	w0, w0, #0x1
    a00074d8:	12001c02 	and	w2, w0, #0xff
	conv->pad_fp = (conv->pad0_value > 0)
    a00074dc:	f94023e1 	ldr	x1, [sp, #64]
    a00074e0:	39400820 	ldrb	w0, [x1, #2]
    a00074e4:	331a0040 	bfi	w0, w2, #6, #1
    a00074e8:	39000820 	strb	w0, [x1, #2]

	/* Set the end of the encoded sequence, and return its start.  Also
	 * store EOS as a non-digit/non-decimal value so we don't have to
	 * check against bpe when iterating in multiple places.
	 */
	*bpe = buf;
    a00074ec:	f94013e0 	ldr	x0, [sp, #32]
    a00074f0:	f94047e1 	ldr	x1, [sp, #136]
    a00074f4:	f9000001 	str	x1, [x0]
	*buf = 0;
    a00074f8:	f94047e0 	ldr	x0, [sp, #136]
    a00074fc:	3900001f 	strb	wzr, [x0]
	return bps;
    a0007500:	f94017e0 	ldr	x0, [sp, #40]
}
    a0007504:	f9400bf3 	ldr	x19, [sp, #16]
    a0007508:	a8ca7bfd 	ldp	x29, x30, [sp], #160
    a000750c:	d65f03c0 	ret

00000000a0007510 <store_count>:
 * @param count the count to be stored.
 */
static inline void store_count(const struct conversion *conv,
			       void *dp,
			       int count)
{
    a0007510:	d10083ff 	sub	sp, sp, #0x20
    a0007514:	f9000fe0 	str	x0, [sp, #24]
    a0007518:	f9000be1 	str	x1, [sp, #16]
    a000751c:	b9000fe2 	str	w2, [sp, #12]
	switch ((enum length_mod_enum)conv->length_mod) {
    a0007520:	f9400fe0 	ldr	x0, [sp, #24]
    a0007524:	b9400000 	ldr	w0, [x0]
    a0007528:	d34b3800 	ubfx	x0, x0, #11, #4
    a000752c:	12001c00 	and	w0, w0, #0xff
    a0007530:	71001c1f 	cmp	w0, #0x7
    a0007534:	54000740 	b.eq	a000761c <store_count+0x10c>  // b.none
    a0007538:	71001c1f 	cmp	w0, #0x7
    a000753c:	54000788 	b.hi	a000762c <store_count+0x11c>  // b.pmore
    a0007540:	7100181f 	cmp	w0, #0x6
    a0007544:	54000640 	b.eq	a000760c <store_count+0xfc>  // b.none
    a0007548:	7100181f 	cmp	w0, #0x6
    a000754c:	54000708 	b.hi	a000762c <store_count+0x11c>  // b.pmore
    a0007550:	7100141f 	cmp	w0, #0x5
    a0007554:	54000540 	b.eq	a00075fc <store_count+0xec>  // b.none
    a0007558:	7100141f 	cmp	w0, #0x5
    a000755c:	54000688 	b.hi	a000762c <store_count+0x11c>  // b.pmore
    a0007560:	7100101f 	cmp	w0, #0x4
    a0007564:	54000440 	b.eq	a00075ec <store_count+0xdc>  // b.none
    a0007568:	7100101f 	cmp	w0, #0x4
    a000756c:	54000608 	b.hi	a000762c <store_count+0x11c>  // b.pmore
    a0007570:	71000c1f 	cmp	w0, #0x3
    a0007574:	54000340 	b.eq	a00075dc <store_count+0xcc>  // b.none
    a0007578:	71000c1f 	cmp	w0, #0x3
    a000757c:	54000588 	b.hi	a000762c <store_count+0x11c>  // b.pmore
    a0007580:	7100081f 	cmp	w0, #0x2
    a0007584:	54000220 	b.eq	a00075c8 <store_count+0xb8>  // b.none
    a0007588:	7100081f 	cmp	w0, #0x2
    a000758c:	54000508 	b.hi	a000762c <store_count+0x11c>  // b.pmore
    a0007590:	7100001f 	cmp	w0, #0x0
    a0007594:	54000080 	b.eq	a00075a4 <store_count+0x94>  // b.none
    a0007598:	7100041f 	cmp	w0, #0x1
    a000759c:	540000c0 	b.eq	a00075b4 <store_count+0xa4>  // b.none
	default:
		/* Add an empty default with break, this is a defensive programming.
		 * Static analysis tool won't raise a violation if default is empty,
		 * but has that comment.
		 */
		break;
    a00075a0:	14000023 	b	a000762c <store_count+0x11c>
		*(int *)dp = count;
    a00075a4:	f9400be0 	ldr	x0, [sp, #16]
    a00075a8:	b9400fe1 	ldr	w1, [sp, #12]
    a00075ac:	b9000001 	str	w1, [x0]
		break;
    a00075b0:	14000020 	b	a0007630 <store_count+0x120>
		*(signed char *)dp = (signed char)count;
    a00075b4:	b9400fe0 	ldr	w0, [sp, #12]
    a00075b8:	13001c01 	sxtb	w1, w0
    a00075bc:	f9400be0 	ldr	x0, [sp, #16]
    a00075c0:	39000001 	strb	w1, [x0]
		break;
    a00075c4:	1400001b 	b	a0007630 <store_count+0x120>
		*(short *)dp = (short)count;
    a00075c8:	b9400fe0 	ldr	w0, [sp, #12]
    a00075cc:	13003c01 	sxth	w1, w0
    a00075d0:	f9400be0 	ldr	x0, [sp, #16]
    a00075d4:	79000001 	strh	w1, [x0]
		break;
    a00075d8:	14000016 	b	a0007630 <store_count+0x120>
		*(long *)dp = (long)count;
    a00075dc:	b9800fe1 	ldrsw	x1, [sp, #12]
    a00075e0:	f9400be0 	ldr	x0, [sp, #16]
    a00075e4:	f9000001 	str	x1, [x0]
		break;
    a00075e8:	14000012 	b	a0007630 <store_count+0x120>
		*(long long *)dp = (long long)count;
    a00075ec:	b9800fe1 	ldrsw	x1, [sp, #12]
    a00075f0:	f9400be0 	ldr	x0, [sp, #16]
    a00075f4:	f9000001 	str	x1, [x0]
		break;
    a00075f8:	1400000e 	b	a0007630 <store_count+0x120>
		*(intmax_t *)dp = (intmax_t)count;
    a00075fc:	b9800fe1 	ldrsw	x1, [sp, #12]
    a0007600:	f9400be0 	ldr	x0, [sp, #16]
    a0007604:	f9000001 	str	x1, [x0]
		break;
    a0007608:	1400000a 	b	a0007630 <store_count+0x120>
		*(size_t *)dp = (size_t)count;
    a000760c:	b9800fe1 	ldrsw	x1, [sp, #12]
    a0007610:	f9400be0 	ldr	x0, [sp, #16]
    a0007614:	f9000001 	str	x1, [x0]
		break;
    a0007618:	14000006 	b	a0007630 <store_count+0x120>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
    a000761c:	b9800fe1 	ldrsw	x1, [sp, #12]
    a0007620:	f9400be0 	ldr	x0, [sp, #16]
    a0007624:	f9000001 	str	x1, [x0]
		break;
    a0007628:	14000002 	b	a0007630 <store_count+0x120>
		break;
    a000762c:	d503201f 	nop
	}
}
    a0007630:	d503201f 	nop
    a0007634:	910083ff 	add	sp, sp, #0x20
    a0007638:	d65f03c0 	ret

00000000a000763c <outs>:
/* Outline function to emit all characters in [sp, ep). */
static int outs(cbprintf_cb out,
		void *ctx,
		const char *sp,
		const char *ep)
{
    a000763c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    a0007640:	910003fd 	mov	x29, sp
    a0007644:	f90017e0 	str	x0, [sp, #40]
    a0007648:	f90013e1 	str	x1, [sp, #32]
    a000764c:	f9000fe2 	str	x2, [sp, #24]
    a0007650:	f9000be3 	str	x3, [sp, #16]
	size_t count = 0;
    a0007654:	f9001fff 	str	xzr, [sp, #56]

	while ((sp < ep) || ((ep == NULL) && *sp)) {
    a0007658:	14000011 	b	a000769c <outs+0x60>
		int rc = out((int)*sp++, ctx);
    a000765c:	f9400fe0 	ldr	x0, [sp, #24]
    a0007660:	91000401 	add	x1, x0, #0x1
    a0007664:	f9000fe1 	str	x1, [sp, #24]
    a0007668:	39400000 	ldrb	w0, [x0]
    a000766c:	f94017e2 	ldr	x2, [sp, #40]
    a0007670:	f94013e1 	ldr	x1, [sp, #32]
    a0007674:	d63f0040 	blr	x2
    a0007678:	b90037e0 	str	w0, [sp, #52]

		if (rc < 0) {
    a000767c:	b94037e0 	ldr	w0, [sp, #52]
    a0007680:	7100001f 	cmp	w0, #0x0
    a0007684:	5400006a 	b.ge	a0007690 <outs+0x54>  // b.tcont
			return rc;
    a0007688:	b94037e0 	ldr	w0, [sp, #52]
    a000768c:	14000010 	b	a00076cc <outs+0x90>
		}
		++count;
    a0007690:	f9401fe0 	ldr	x0, [sp, #56]
    a0007694:	91000400 	add	x0, x0, #0x1
    a0007698:	f9001fe0 	str	x0, [sp, #56]
	while ((sp < ep) || ((ep == NULL) && *sp)) {
    a000769c:	f9400fe1 	ldr	x1, [sp, #24]
    a00076a0:	f9400be0 	ldr	x0, [sp, #16]
    a00076a4:	eb00003f 	cmp	x1, x0
    a00076a8:	54fffda3 	b.cc	a000765c <outs+0x20>  // b.lo, b.ul, b.last
    a00076ac:	f9400be0 	ldr	x0, [sp, #16]
    a00076b0:	f100001f 	cmp	x0, #0x0
    a00076b4:	540000a1 	b.ne	a00076c8 <outs+0x8c>  // b.any
    a00076b8:	f9400fe0 	ldr	x0, [sp, #24]
    a00076bc:	39400000 	ldrb	w0, [x0]
    a00076c0:	7100001f 	cmp	w0, #0x0
    a00076c4:	54fffcc1 	b.ne	a000765c <outs+0x20>  // b.any
	}

	return (int)count;
    a00076c8:	f9401fe0 	ldr	x0, [sp, #56]
}
    a00076cc:	a8c47bfd 	ldp	x29, x30, [sp], #64
    a00076d0:	d65f03c0 	ret

00000000a00076d4 <cbvprintf>:

int cbvprintf(cbprintf_cb out, void *ctx, const char *fp, va_list ap)
{
    a00076d4:	a9ab7bfd 	stp	x29, x30, [sp, #-336]!
    a00076d8:	910003fd 	mov	x29, sp
    a00076dc:	f9000bf3 	str	x19, [sp, #16]
    a00076e0:	f9001fe0 	str	x0, [sp, #56]
    a00076e4:	f9001be1 	str	x1, [sp, #48]
    a00076e8:	f90017e2 	str	x2, [sp, #40]
    a00076ec:	aa0303f3 	mov	x19, x3
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
    a00076f0:	f900a7ff 	str	xzr, [sp, #328]
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
    a00076f4:	14000509 	b	a0008b18 <cbvprintf+0x1444>
		if (*fp != '%') {
    a00076f8:	f94017e0 	ldr	x0, [sp, #40]
    a00076fc:	39400000 	ldrb	w0, [x0]
    a0007700:	7100941f 	cmp	w0, #0x25
    a0007704:	54000240 	b.eq	a000774c <cbvprintf+0x78>  // b.none
			OUTC(*fp++);
    a0007708:	f94017e0 	ldr	x0, [sp, #40]
    a000770c:	91000401 	add	x1, x0, #0x1
    a0007710:	f90017e1 	str	x1, [sp, #40]
    a0007714:	39400000 	ldrb	w0, [x0]
    a0007718:	f9401fe2 	ldr	x2, [sp, #56]
    a000771c:	f9401be1 	ldr	x1, [sp, #48]
    a0007720:	d63f0040 	blr	x2
    a0007724:	b90097e0 	str	w0, [sp, #148]
    a0007728:	b94097e0 	ldr	w0, [sp, #148]
    a000772c:	7100001f 	cmp	w0, #0x0
    a0007730:	5400006a 	b.ge	a000773c <cbvprintf+0x68>  // b.tcont
    a0007734:	b94097e0 	ldr	w0, [sp, #148]
    a0007738:	140004fd 	b	a0008b2c <cbvprintf+0x1458>
    a000773c:	f940a7e0 	ldr	x0, [sp, #328]
    a0007740:	91000400 	add	x0, x0, #0x1
    a0007744:	f900a7e0 	str	x0, [sp, #328]
			continue;
    a0007748:	140004f4 	b	a0008b18 <cbvprintf+0x1444>
		 * mitigate LLVM code generation bug.
		 */
		struct {
			union argument_value value;
			struct conversion conv;
		} state = {
    a000774c:	a9047fff 	stp	xzr, xzr, [sp, #64]
    a0007750:	a9057fff 	stp	xzr, xzr, [sp, #80]
			.value = {
				.uint = 0,
			},
		};
		struct conversion *const conv = &state.conv;
    a0007754:	910103e0 	add	x0, sp, #0x40
    a0007758:	91004000 	add	x0, x0, #0x10
    a000775c:	f9008be0 	str	x0, [sp, #272]
		union argument_value *const value = &state.value;
    a0007760:	910103e0 	add	x0, sp, #0x40
    a0007764:	f90087e0 	str	x0, [sp, #264]
		const char *sp = fp;
    a0007768:	f94017e0 	ldr	x0, [sp, #40]
    a000776c:	f90083e0 	str	x0, [sp, #256]
		int width = -1;
    a0007770:	12800000 	mov	w0, #0xffffffff            	// #-1
    a0007774:	b90147e0 	str	w0, [sp, #324]
		int precision = -1;
    a0007778:	12800000 	mov	w0, #0xffffffff            	// #-1
    a000777c:	b90143e0 	str	w0, [sp, #320]
		const char *bps = NULL;
    a0007780:	f9009fff 	str	xzr, [sp, #312]
		const char *bpe = buf + sizeof(buf);
    a0007784:	9101e3e0 	add	x0, sp, #0x78
    a0007788:	91006400 	add	x0, x0, #0x19
    a000778c:	f9003be0 	str	x0, [sp, #112]
		char sign = 0;
    a0007790:	3901bfff 	strb	wzr, [sp, #111]

		fp = extract_conversion(conv, sp);
    a0007794:	f94083e1 	ldr	x1, [sp, #256]
    a0007798:	f9408be0 	ldr	x0, [sp, #272]
    a000779c:	97fffc32 	bl	a0006864 <extract_conversion>
    a00077a0:	f90017e0 	str	x0, [sp, #40]

		/* If dynamic width is specified, process it,
		 * otherwise set width if present.
		 */
		if (conv->width_star) {
    a00077a4:	f9408be0 	ldr	x0, [sp, #272]
    a00077a8:	79400000 	ldrh	w0, [x0]
    a00077ac:	12180000 	and	w0, w0, #0x100
    a00077b0:	12003c00 	and	w0, w0, #0xffff
    a00077b4:	7100001f 	cmp	w0, #0x0
    a00077b8:	54000440 	b.eq	a0007840 <cbvprintf+0x16c>  // b.none
			width = va_arg(ap, int);
    a00077bc:	b9401a61 	ldr	w1, [x19, #24]
    a00077c0:	f9400260 	ldr	x0, [x19]
    a00077c4:	7100003f 	cmp	w1, #0x0
    a00077c8:	540000ab 	b.lt	a00077dc <cbvprintf+0x108>  // b.tstop
    a00077cc:	91002c01 	add	x1, x0, #0xb
    a00077d0:	927df021 	and	x1, x1, #0xfffffffffffffff8
    a00077d4:	f9000261 	str	x1, [x19]
    a00077d8:	1400000d 	b	a000780c <cbvprintf+0x138>
    a00077dc:	11002022 	add	w2, w1, #0x8
    a00077e0:	b9001a62 	str	w2, [x19, #24]
    a00077e4:	b9401a62 	ldr	w2, [x19, #24]
    a00077e8:	7100005f 	cmp	w2, #0x0
    a00077ec:	540000ad 	b.le	a0007800 <cbvprintf+0x12c>
    a00077f0:	91002c01 	add	x1, x0, #0xb
    a00077f4:	927df021 	and	x1, x1, #0xfffffffffffffff8
    a00077f8:	f9000261 	str	x1, [x19]
    a00077fc:	14000004 	b	a000780c <cbvprintf+0x138>
    a0007800:	f9400662 	ldr	x2, [x19, #8]
    a0007804:	93407c20 	sxtw	x0, w1
    a0007808:	8b000040 	add	x0, x2, x0
    a000780c:	b9400000 	ldr	w0, [x0]
    a0007810:	b90147e0 	str	w0, [sp, #324]

			if (width < 0) {
    a0007814:	b94147e0 	ldr	w0, [sp, #324]
    a0007818:	7100001f 	cmp	w0, #0x0
    a000781c:	5400024a 	b.ge	a0007864 <cbvprintf+0x190>  // b.tcont
				conv->flag_dash = true;
    a0007820:	f9408be0 	ldr	x0, [sp, #272]
    a0007824:	79400001 	ldrh	w1, [x0]
    a0007828:	321e0021 	orr	w1, w1, #0x4
    a000782c:	79000001 	strh	w1, [x0]
				width = -width;
    a0007830:	b94147e0 	ldr	w0, [sp, #324]
    a0007834:	4b0003e0 	neg	w0, w0
    a0007838:	b90147e0 	str	w0, [sp, #324]
    a000783c:	1400000a 	b	a0007864 <cbvprintf+0x190>
			}
		} else if (conv->width_present) {
    a0007840:	f9408be0 	ldr	x0, [sp, #272]
    a0007844:	79400000 	ldrh	w0, [x0]
    a0007848:	12190000 	and	w0, w0, #0x80
    a000784c:	12003c00 	and	w0, w0, #0xffff
    a0007850:	7100001f 	cmp	w0, #0x0
    a0007854:	54000080 	b.eq	a0007864 <cbvprintf+0x190>  // b.none
			width = conv->width_value;
    a0007858:	f9408be0 	ldr	x0, [sp, #272]
    a000785c:	b9400400 	ldr	w0, [x0, #4]
    a0007860:	b90147e0 	str	w0, [sp, #324]

		/* If dynamic precision is specified, process it, otherwise
		 * set precision if present.  For floating point where
		 * precision is not present use 6.
		 */
		if (conv->prec_star) {
    a0007864:	f9408be0 	ldr	x0, [sp, #272]
    a0007868:	79400000 	ldrh	w0, [x0]
    a000786c:	12160000 	and	w0, w0, #0x400
    a0007870:	12003c00 	and	w0, w0, #0xffff
    a0007874:	7100001f 	cmp	w0, #0x0
    a0007878:	54000440 	b.eq	a0007900 <cbvprintf+0x22c>  // b.none
			int arg = va_arg(ap, int);
    a000787c:	b9401a61 	ldr	w1, [x19, #24]
    a0007880:	f9400260 	ldr	x0, [x19]
    a0007884:	7100003f 	cmp	w1, #0x0
    a0007888:	540000ab 	b.lt	a000789c <cbvprintf+0x1c8>  // b.tstop
    a000788c:	91002c01 	add	x1, x0, #0xb
    a0007890:	927df021 	and	x1, x1, #0xfffffffffffffff8
    a0007894:	f9000261 	str	x1, [x19]
    a0007898:	1400000d 	b	a00078cc <cbvprintf+0x1f8>
    a000789c:	11002022 	add	w2, w1, #0x8
    a00078a0:	b9001a62 	str	w2, [x19, #24]
    a00078a4:	b9401a62 	ldr	w2, [x19, #24]
    a00078a8:	7100005f 	cmp	w2, #0x0
    a00078ac:	540000ad 	b.le	a00078c0 <cbvprintf+0x1ec>
    a00078b0:	91002c01 	add	x1, x0, #0xb
    a00078b4:	927df021 	and	x1, x1, #0xfffffffffffffff8
    a00078b8:	f9000261 	str	x1, [x19]
    a00078bc:	14000004 	b	a00078cc <cbvprintf+0x1f8>
    a00078c0:	f9400662 	ldr	x2, [x19, #8]
    a00078c4:	93407c20 	sxtw	x0, w1
    a00078c8:	8b000040 	add	x0, x2, x0
    a00078cc:	b9400000 	ldr	w0, [x0]
    a00078d0:	b900ffe0 	str	w0, [sp, #252]

			if (arg < 0) {
    a00078d4:	b940ffe0 	ldr	w0, [sp, #252]
    a00078d8:	7100001f 	cmp	w0, #0x0
    a00078dc:	540000ca 	b.ge	a00078f4 <cbvprintf+0x220>  // b.tcont
				conv->prec_present = false;
    a00078e0:	f9408be0 	ldr	x0, [sp, #272]
    a00078e4:	79400001 	ldrh	w1, [x0]
    a00078e8:	12167821 	and	w1, w1, #0xfffffdff
    a00078ec:	79000001 	strh	w1, [x0]
    a00078f0:	1400000d 	b	a0007924 <cbvprintf+0x250>
			} else {
				precision = arg;
    a00078f4:	b940ffe0 	ldr	w0, [sp, #252]
    a00078f8:	b90143e0 	str	w0, [sp, #320]
    a00078fc:	1400000a 	b	a0007924 <cbvprintf+0x250>
			}
		} else if (conv->prec_present) {
    a0007900:	f9408be0 	ldr	x0, [sp, #272]
    a0007904:	79400000 	ldrh	w0, [x0]
    a0007908:	12170000 	and	w0, w0, #0x200
    a000790c:	12003c00 	and	w0, w0, #0xffff
    a0007910:	7100001f 	cmp	w0, #0x0
    a0007914:	54000080 	b.eq	a0007924 <cbvprintf+0x250>  // b.none
			precision = conv->prec_value;
    a0007918:	f9408be0 	ldr	x0, [sp, #272]
    a000791c:	b9400800 	ldr	w0, [x0, #8]
    a0007920:	b90143e0 	str	w0, [sp, #320]
		}

		/* Reuse width and precision memory in conv for value
		 * padding counts.
		 */
		conv->pad0_value = 0;
    a0007924:	f9408be0 	ldr	x0, [sp, #272]
    a0007928:	b900041f 	str	wzr, [x0, #4]
		conv->pad0_pre_exp = 0;
    a000792c:	f9408be0 	ldr	x0, [sp, #272]
    a0007930:	b900081f 	str	wzr, [x0, #8]

		/* FP conversion requires knowing the precision. */
		if (IS_ENABLED(CONFIG_CBPRINTF_FP_SUPPORT)
		    && (conv->specifier_cat == SPECIFIER_FP)
    a0007934:	f9408be0 	ldr	x0, [sp, #272]
    a0007938:	39400800 	ldrb	w0, [x0, #2]
    a000793c:	12000800 	and	w0, w0, #0x7
    a0007940:	12001c00 	and	w0, w0, #0xff
		if (IS_ENABLED(CONFIG_CBPRINTF_FP_SUPPORT)
    a0007944:	7100101f 	cmp	w0, #0x4
    a0007948:	54000281 	b.ne	a0007998 <cbvprintf+0x2c4>  // b.any
		    && !conv->prec_present) {
    a000794c:	f9408be0 	ldr	x0, [sp, #272]
    a0007950:	b9400000 	ldr	w0, [x0]
    a0007954:	d3492400 	ubfx	x0, x0, #9, #1
    a0007958:	12001c00 	and	w0, w0, #0xff
    a000795c:	52000000 	eor	w0, w0, #0x1
    a0007960:	12001c00 	and	w0, w0, #0xff
    a0007964:	7100001f 	cmp	w0, #0x0
    a0007968:	54000180 	b.eq	a0007998 <cbvprintf+0x2c4>  // b.none
			if (conv->specifier_a) {
    a000796c:	f9408be0 	ldr	x0, [sp, #272]
    a0007970:	79400000 	ldrh	w0, [x0]
    a0007974:	12114000 	and	w0, w0, #0xffff8000
    a0007978:	12003c00 	and	w0, w0, #0xffff
    a000797c:	7100001f 	cmp	w0, #0x0
    a0007980:	54000080 	b.eq	a0007990 <cbvprintf+0x2bc>  // b.none
				precision = FRACTION_HEX;
    a0007984:	528001a0 	mov	w0, #0xd                   	// #13
    a0007988:	b90143e0 	str	w0, [sp, #320]
    a000798c:	14000003 	b	a0007998 <cbvprintf+0x2c4>
			} else {
				precision = 6;
    a0007990:	528000c0 	mov	w0, #0x6                   	// #6
    a0007994:	b90143e0 	str	w0, [sp, #320]
		 * This can't be extracted to a helper function because
		 * passing a pointer to va_list doesn't work on x86_64.  See
		 * https://stackoverflow.com/a/8048892.
		 */
		enum specifier_cat_enum specifier_cat
			= (enum specifier_cat_enum)conv->specifier_cat;
    a0007998:	f9408be0 	ldr	x0, [sp, #272]
    a000799c:	b9400000 	ldr	w0, [x0]
    a00079a0:	d3504800 	ubfx	x0, x0, #16, #3
    a00079a4:	12001c00 	and	w0, w0, #0xff
		enum specifier_cat_enum specifier_cat
    a00079a8:	b900fbe0 	str	w0, [sp, #248]
		enum length_mod_enum length_mod
			= (enum length_mod_enum)conv->length_mod;
    a00079ac:	f9408be0 	ldr	x0, [sp, #272]
    a00079b0:	b9400000 	ldr	w0, [x0]
    a00079b4:	d34b3800 	ubfx	x0, x0, #11, #4
    a00079b8:	12001c00 	and	w0, w0, #0xff
		enum length_mod_enum length_mod
    a00079bc:	b900f7e0 	str	w0, [sp, #244]
		/* Extract the value based on the argument category and length.
		 *
		 * Note that the length modifier doesn't affect the value of a
		 * pointer argument.
		 */
		if (specifier_cat == SPECIFIER_SINT) {
    a00079c0:	b940fbe0 	ldr	w0, [sp, #248]
    a00079c4:	7100041f 	cmp	w0, #0x1
    a00079c8:	54001401 	b.ne	a0007c48 <cbvprintf+0x574>  // b.any
			switch (length_mod) {
    a00079cc:	b940f7e0 	ldr	w0, [sp, #244]
    a00079d0:	71001c1f 	cmp	w0, #0x7
    a00079d4:	54000208 	b.hi	a0007a14 <cbvprintf+0x340>  // b.pmore
    a00079d8:	b940f7e0 	ldr	w0, [sp, #244]
    a00079dc:	7100181f 	cmp	w0, #0x6
    a00079e0:	54000dc2 	b.cs	a0007b98 <cbvprintf+0x4c4>  // b.hs, b.nlast
    a00079e4:	b940f7e0 	ldr	w0, [sp, #244]
    a00079e8:	7100141f 	cmp	w0, #0x5
    a00079ec:	54000a60 	b.eq	a0007b38 <cbvprintf+0x464>  // b.none
    a00079f0:	b940f7e0 	ldr	w0, [sp, #244]
    a00079f4:	7100141f 	cmp	w0, #0x5
    a00079f8:	540000e8 	b.hi	a0007a14 <cbvprintf+0x340>  // b.pmore
    a00079fc:	b940f7e0 	ldr	w0, [sp, #244]
    a0007a00:	71000c1f 	cmp	w0, #0x3
    a0007a04:	540003a0 	b.eq	a0007a78 <cbvprintf+0x3a4>  // b.none
    a0007a08:	b940f7e0 	ldr	w0, [sp, #244]
    a0007a0c:	7100101f 	cmp	w0, #0x4
    a0007a10:	54000640 	b.eq	a0007ad8 <cbvprintf+0x404>  // b.none
			default:
			case LENGTH_NONE:
			case LENGTH_HH:
			case LENGTH_H:
				value->sint = va_arg(ap, int);
    a0007a14:	b9401a61 	ldr	w1, [x19, #24]
    a0007a18:	f9400260 	ldr	x0, [x19]
    a0007a1c:	7100003f 	cmp	w1, #0x0
    a0007a20:	540000ab 	b.lt	a0007a34 <cbvprintf+0x360>  // b.tstop
    a0007a24:	91002c01 	add	x1, x0, #0xb
    a0007a28:	927df021 	and	x1, x1, #0xfffffffffffffff8
    a0007a2c:	f9000261 	str	x1, [x19]
    a0007a30:	1400000d 	b	a0007a64 <cbvprintf+0x390>
    a0007a34:	11002022 	add	w2, w1, #0x8
    a0007a38:	b9001a62 	str	w2, [x19, #24]
    a0007a3c:	b9401a62 	ldr	w2, [x19, #24]
    a0007a40:	7100005f 	cmp	w2, #0x0
    a0007a44:	540000ad 	b.le	a0007a58 <cbvprintf+0x384>
    a0007a48:	91002c01 	add	x1, x0, #0xb
    a0007a4c:	927df021 	and	x1, x1, #0xfffffffffffffff8
    a0007a50:	f9000261 	str	x1, [x19]
    a0007a54:	14000004 	b	a0007a64 <cbvprintf+0x390>
    a0007a58:	f9400662 	ldr	x2, [x19, #8]
    a0007a5c:	93407c20 	sxtw	x0, w1
    a0007a60:	8b000040 	add	x0, x2, x0
    a0007a64:	b9400000 	ldr	w0, [x0]
    a0007a68:	93407c01 	sxtw	x1, w0
    a0007a6c:	f94087e0 	ldr	x0, [sp, #264]
    a0007a70:	f9000001 	str	x1, [x0]
				break;
    a0007a74:	14000061 	b	a0007bf8 <cbvprintf+0x524>
				if (WCHAR_IS_SIGNED
				    && (conv->specifier == 'c')) {
					value->sint = (wchar_t)va_arg(ap,
							      WINT_TYPE);
				} else {
					value->sint = va_arg(ap, long);
    a0007a78:	b9401a61 	ldr	w1, [x19, #24]
    a0007a7c:	f9400260 	ldr	x0, [x19]
    a0007a80:	7100003f 	cmp	w1, #0x0
    a0007a84:	540000ab 	b.lt	a0007a98 <cbvprintf+0x3c4>  // b.tstop
    a0007a88:	91003c01 	add	x1, x0, #0xf
    a0007a8c:	927df021 	and	x1, x1, #0xfffffffffffffff8
    a0007a90:	f9000261 	str	x1, [x19]
    a0007a94:	1400000d 	b	a0007ac8 <cbvprintf+0x3f4>
    a0007a98:	11002022 	add	w2, w1, #0x8
    a0007a9c:	b9001a62 	str	w2, [x19, #24]
    a0007aa0:	b9401a62 	ldr	w2, [x19, #24]
    a0007aa4:	7100005f 	cmp	w2, #0x0
    a0007aa8:	540000ad 	b.le	a0007abc <cbvprintf+0x3e8>
    a0007aac:	91003c01 	add	x1, x0, #0xf
    a0007ab0:	927df021 	and	x1, x1, #0xfffffffffffffff8
    a0007ab4:	f9000261 	str	x1, [x19]
    a0007ab8:	14000004 	b	a0007ac8 <cbvprintf+0x3f4>
    a0007abc:	f9400662 	ldr	x2, [x19, #8]
    a0007ac0:	93407c20 	sxtw	x0, w1
    a0007ac4:	8b000040 	add	x0, x2, x0
    a0007ac8:	f9400001 	ldr	x1, [x0]
    a0007acc:	f94087e0 	ldr	x0, [sp, #264]
    a0007ad0:	f9000001 	str	x1, [x0]
				}
				break;
    a0007ad4:	14000049 	b	a0007bf8 <cbvprintf+0x524>
			case LENGTH_LL:
				value->sint =
					(sint_value_type)va_arg(ap, long long);
    a0007ad8:	b9401a61 	ldr	w1, [x19, #24]
    a0007adc:	f9400260 	ldr	x0, [x19]
    a0007ae0:	7100003f 	cmp	w1, #0x0
    a0007ae4:	540000ab 	b.lt	a0007af8 <cbvprintf+0x424>  // b.tstop
    a0007ae8:	91003c01 	add	x1, x0, #0xf
    a0007aec:	927df021 	and	x1, x1, #0xfffffffffffffff8
    a0007af0:	f9000261 	str	x1, [x19]
    a0007af4:	1400000d 	b	a0007b28 <cbvprintf+0x454>
    a0007af8:	11002022 	add	w2, w1, #0x8
    a0007afc:	b9001a62 	str	w2, [x19, #24]
    a0007b00:	b9401a62 	ldr	w2, [x19, #24]
    a0007b04:	7100005f 	cmp	w2, #0x0
    a0007b08:	540000ad 	b.le	a0007b1c <cbvprintf+0x448>
    a0007b0c:	91003c01 	add	x1, x0, #0xf
    a0007b10:	927df021 	and	x1, x1, #0xfffffffffffffff8
    a0007b14:	f9000261 	str	x1, [x19]
    a0007b18:	14000004 	b	a0007b28 <cbvprintf+0x454>
    a0007b1c:	f9400662 	ldr	x2, [x19, #8]
    a0007b20:	93407c20 	sxtw	x0, w1
    a0007b24:	8b000040 	add	x0, x2, x0
    a0007b28:	f9400001 	ldr	x1, [x0]
				value->sint =
    a0007b2c:	f94087e0 	ldr	x0, [sp, #264]
    a0007b30:	f9000001 	str	x1, [x0]
				break;
    a0007b34:	14000031 	b	a0007bf8 <cbvprintf+0x524>
			case LENGTH_J:
				value->sint =
					(sint_value_type)va_arg(ap, intmax_t);
    a0007b38:	b9401a61 	ldr	w1, [x19, #24]
    a0007b3c:	f9400260 	ldr	x0, [x19]
    a0007b40:	7100003f 	cmp	w1, #0x0
    a0007b44:	540000ab 	b.lt	a0007b58 <cbvprintf+0x484>  // b.tstop
    a0007b48:	91003c01 	add	x1, x0, #0xf
    a0007b4c:	927df021 	and	x1, x1, #0xfffffffffffffff8
    a0007b50:	f9000261 	str	x1, [x19]
    a0007b54:	1400000d 	b	a0007b88 <cbvprintf+0x4b4>
    a0007b58:	11002022 	add	w2, w1, #0x8
    a0007b5c:	b9001a62 	str	w2, [x19, #24]
    a0007b60:	b9401a62 	ldr	w2, [x19, #24]
    a0007b64:	7100005f 	cmp	w2, #0x0
    a0007b68:	540000ad 	b.le	a0007b7c <cbvprintf+0x4a8>
    a0007b6c:	91003c01 	add	x1, x0, #0xf
    a0007b70:	927df021 	and	x1, x1, #0xfffffffffffffff8
    a0007b74:	f9000261 	str	x1, [x19]
    a0007b78:	14000004 	b	a0007b88 <cbvprintf+0x4b4>
    a0007b7c:	f9400662 	ldr	x2, [x19, #8]
    a0007b80:	93407c20 	sxtw	x0, w1
    a0007b84:	8b000040 	add	x0, x2, x0
    a0007b88:	f9400001 	ldr	x1, [x0]
				value->sint =
    a0007b8c:	f94087e0 	ldr	x0, [sp, #264]
    a0007b90:	f9000001 	str	x1, [x0]
				break;
    a0007b94:	14000019 	b	a0007bf8 <cbvprintf+0x524>
				 * unsigned and signed equivalents of each
				 * other.  This can be checked in a platform
				 * test.
				 */
				value->sint =
					(sint_value_type)va_arg(ap, ptrdiff_t);
    a0007b98:	b9401a61 	ldr	w1, [x19, #24]
    a0007b9c:	f9400260 	ldr	x0, [x19]
    a0007ba0:	7100003f 	cmp	w1, #0x0
    a0007ba4:	540000ab 	b.lt	a0007bb8 <cbvprintf+0x4e4>  // b.tstop
    a0007ba8:	91003c01 	add	x1, x0, #0xf
    a0007bac:	927df021 	and	x1, x1, #0xfffffffffffffff8
    a0007bb0:	f9000261 	str	x1, [x19]
    a0007bb4:	1400000d 	b	a0007be8 <cbvprintf+0x514>
    a0007bb8:	11002022 	add	w2, w1, #0x8
    a0007bbc:	b9001a62 	str	w2, [x19, #24]
    a0007bc0:	b9401a62 	ldr	w2, [x19, #24]
    a0007bc4:	7100005f 	cmp	w2, #0x0
    a0007bc8:	540000ad 	b.le	a0007bdc <cbvprintf+0x508>
    a0007bcc:	91003c01 	add	x1, x0, #0xf
    a0007bd0:	927df021 	and	x1, x1, #0xfffffffffffffff8
    a0007bd4:	f9000261 	str	x1, [x19]
    a0007bd8:	14000004 	b	a0007be8 <cbvprintf+0x514>
    a0007bdc:	f9400662 	ldr	x2, [x19, #8]
    a0007be0:	93407c20 	sxtw	x0, w1
    a0007be4:	8b000040 	add	x0, x2, x0
    a0007be8:	f9400001 	ldr	x1, [x0]
				value->sint =
    a0007bec:	f94087e0 	ldr	x0, [sp, #264]
    a0007bf0:	f9000001 	str	x1, [x0]
				break;
    a0007bf4:	d503201f 	nop
			}
			if (length_mod == LENGTH_HH) {
    a0007bf8:	b940f7e0 	ldr	w0, [sp, #244]
    a0007bfc:	7100041f 	cmp	w0, #0x1
    a0007c00:	54000101 	b.ne	a0007c20 <cbvprintf+0x54c>  // b.any
				value->sint = (char)value->sint;
    a0007c04:	f94087e0 	ldr	x0, [sp, #264]
    a0007c08:	f9400000 	ldr	x0, [x0]
    a0007c0c:	12001c00 	and	w0, w0, #0xff
    a0007c10:	92401c01 	and	x1, x0, #0xff
    a0007c14:	f94087e0 	ldr	x0, [sp, #264]
    a0007c18:	f9000001 	str	x1, [x0]
    a0007c1c:	1400011e 	b	a0008094 <cbvprintf+0x9c0>
			} else if (length_mod == LENGTH_H) {
    a0007c20:	b940f7e0 	ldr	w0, [sp, #244]
    a0007c24:	7100081f 	cmp	w0, #0x2
    a0007c28:	54002361 	b.ne	a0008094 <cbvprintf+0x9c0>  // b.any
				value->sint = (short)value->sint;
    a0007c2c:	f94087e0 	ldr	x0, [sp, #264]
    a0007c30:	f9400000 	ldr	x0, [x0]
    a0007c34:	13003c00 	sxth	w0, w0
    a0007c38:	93403c01 	sxth	x1, w0
    a0007c3c:	f94087e0 	ldr	x0, [sp, #264]
    a0007c40:	f9000001 	str	x1, [x0]
    a0007c44:	14000114 	b	a0008094 <cbvprintf+0x9c0>
			}
		} else if (specifier_cat == SPECIFIER_UINT) {
    a0007c48:	b940fbe0 	ldr	w0, [sp, #248]
    a0007c4c:	7100081f 	cmp	w0, #0x2
    a0007c50:	540017a1 	b.ne	a0007f44 <cbvprintf+0x870>  // b.any
			switch (length_mod) {
    a0007c54:	b940f7e0 	ldr	w0, [sp, #244]
    a0007c58:	71001c1f 	cmp	w0, #0x7
    a0007c5c:	54000208 	b.hi	a0007c9c <cbvprintf+0x5c8>  // b.pmore
    a0007c60:	b940f7e0 	ldr	w0, [sp, #244]
    a0007c64:	7100181f 	cmp	w0, #0x6
    a0007c68:	54001162 	b.cs	a0007e94 <cbvprintf+0x7c0>  // b.hs, b.nlast
    a0007c6c:	b940f7e0 	ldr	w0, [sp, #244]
    a0007c70:	7100141f 	cmp	w0, #0x5
    a0007c74:	54000e00 	b.eq	a0007e34 <cbvprintf+0x760>  // b.none
    a0007c78:	b940f7e0 	ldr	w0, [sp, #244]
    a0007c7c:	7100141f 	cmp	w0, #0x5
    a0007c80:	540000e8 	b.hi	a0007c9c <cbvprintf+0x5c8>  // b.pmore
    a0007c84:	b940f7e0 	ldr	w0, [sp, #244]
    a0007c88:	71000c1f 	cmp	w0, #0x3
    a0007c8c:	540003a0 	b.eq	a0007d00 <cbvprintf+0x62c>  // b.none
    a0007c90:	b940f7e0 	ldr	w0, [sp, #244]
    a0007c94:	7100101f 	cmp	w0, #0x4
    a0007c98:	540009e0 	b.eq	a0007dd4 <cbvprintf+0x700>  // b.none
			default:
			case LENGTH_NONE:
			case LENGTH_HH:
			case LENGTH_H:
				value->uint = va_arg(ap, unsigned int);
    a0007c9c:	b9401a61 	ldr	w1, [x19, #24]
    a0007ca0:	f9400260 	ldr	x0, [x19]
    a0007ca4:	7100003f 	cmp	w1, #0x0
    a0007ca8:	540000ab 	b.lt	a0007cbc <cbvprintf+0x5e8>  // b.tstop
    a0007cac:	91002c01 	add	x1, x0, #0xb
    a0007cb0:	927df021 	and	x1, x1, #0xfffffffffffffff8
    a0007cb4:	f9000261 	str	x1, [x19]
    a0007cb8:	1400000d 	b	a0007cec <cbvprintf+0x618>
    a0007cbc:	11002022 	add	w2, w1, #0x8
    a0007cc0:	b9001a62 	str	w2, [x19, #24]
    a0007cc4:	b9401a62 	ldr	w2, [x19, #24]
    a0007cc8:	7100005f 	cmp	w2, #0x0
    a0007ccc:	540000ad 	b.le	a0007ce0 <cbvprintf+0x60c>
    a0007cd0:	91002c01 	add	x1, x0, #0xb
    a0007cd4:	927df021 	and	x1, x1, #0xfffffffffffffff8
    a0007cd8:	f9000261 	str	x1, [x19]
    a0007cdc:	14000004 	b	a0007cec <cbvprintf+0x618>
    a0007ce0:	f9400662 	ldr	x2, [x19, #8]
    a0007ce4:	93407c20 	sxtw	x0, w1
    a0007ce8:	8b000040 	add	x0, x2, x0
    a0007cec:	b9400000 	ldr	w0, [x0]
    a0007cf0:	2a0003e1 	mov	w1, w0
    a0007cf4:	f94087e0 	ldr	x0, [sp, #264]
    a0007cf8:	f9000001 	str	x1, [x0]
				break;
    a0007cfc:	1400007e 	b	a0007ef4 <cbvprintf+0x820>
			case LENGTH_L:
				if ((!WCHAR_IS_SIGNED)
				    && (conv->specifier == 'c')) {
    a0007d00:	f9408be0 	ldr	x0, [sp, #272]
    a0007d04:	39400c00 	ldrb	w0, [x0, #3]
				if ((!WCHAR_IS_SIGNED)
    a0007d08:	71018c1f 	cmp	w0, #0x63
    a0007d0c:	54000341 	b.ne	a0007d74 <cbvprintf+0x6a0>  // b.any
					value->uint = (wchar_t)va_arg(ap,
    a0007d10:	b9401a61 	ldr	w1, [x19, #24]
    a0007d14:	f9400260 	ldr	x0, [x19]
    a0007d18:	7100003f 	cmp	w1, #0x0
    a0007d1c:	540000ab 	b.lt	a0007d30 <cbvprintf+0x65c>  // b.tstop
    a0007d20:	91002c01 	add	x1, x0, #0xb
    a0007d24:	927df021 	and	x1, x1, #0xfffffffffffffff8
    a0007d28:	f9000261 	str	x1, [x19]
    a0007d2c:	1400000d 	b	a0007d60 <cbvprintf+0x68c>
    a0007d30:	11002022 	add	w2, w1, #0x8
    a0007d34:	b9001a62 	str	w2, [x19, #24]
    a0007d38:	b9401a62 	ldr	w2, [x19, #24]
    a0007d3c:	7100005f 	cmp	w2, #0x0
    a0007d40:	540000ad 	b.le	a0007d54 <cbvprintf+0x680>
    a0007d44:	91002c01 	add	x1, x0, #0xb
    a0007d48:	927df021 	and	x1, x1, #0xfffffffffffffff8
    a0007d4c:	f9000261 	str	x1, [x19]
    a0007d50:	14000004 	b	a0007d60 <cbvprintf+0x68c>
    a0007d54:	f9400662 	ldr	x2, [x19, #8]
    a0007d58:	93407c20 	sxtw	x0, w1
    a0007d5c:	8b000040 	add	x0, x2, x0
    a0007d60:	b9400000 	ldr	w0, [x0]
    a0007d64:	2a0003e1 	mov	w1, w0
    a0007d68:	f94087e0 	ldr	x0, [sp, #264]
    a0007d6c:	f9000001 	str	x1, [x0]
							      WINT_TYPE);
				} else {
					value->uint = va_arg(ap, unsigned long);
				}
				break;
    a0007d70:	14000061 	b	a0007ef4 <cbvprintf+0x820>
					value->uint = va_arg(ap, unsigned long);
    a0007d74:	b9401a61 	ldr	w1, [x19, #24]
    a0007d78:	f9400260 	ldr	x0, [x19]
    a0007d7c:	7100003f 	cmp	w1, #0x0
    a0007d80:	540000ab 	b.lt	a0007d94 <cbvprintf+0x6c0>  // b.tstop
    a0007d84:	91003c01 	add	x1, x0, #0xf
    a0007d88:	927df021 	and	x1, x1, #0xfffffffffffffff8
    a0007d8c:	f9000261 	str	x1, [x19]
    a0007d90:	1400000d 	b	a0007dc4 <cbvprintf+0x6f0>
    a0007d94:	11002022 	add	w2, w1, #0x8
    a0007d98:	b9001a62 	str	w2, [x19, #24]
    a0007d9c:	b9401a62 	ldr	w2, [x19, #24]
    a0007da0:	7100005f 	cmp	w2, #0x0
    a0007da4:	540000ad 	b.le	a0007db8 <cbvprintf+0x6e4>
    a0007da8:	91003c01 	add	x1, x0, #0xf
    a0007dac:	927df021 	and	x1, x1, #0xfffffffffffffff8
    a0007db0:	f9000261 	str	x1, [x19]
    a0007db4:	14000004 	b	a0007dc4 <cbvprintf+0x6f0>
    a0007db8:	f9400662 	ldr	x2, [x19, #8]
    a0007dbc:	93407c20 	sxtw	x0, w1
    a0007dc0:	8b000040 	add	x0, x2, x0
    a0007dc4:	f9400001 	ldr	x1, [x0]
    a0007dc8:	f94087e0 	ldr	x0, [sp, #264]
    a0007dcc:	f9000001 	str	x1, [x0]
				break;
    a0007dd0:	14000049 	b	a0007ef4 <cbvprintf+0x820>
			case LENGTH_LL:
				value->uint =
					(uint_value_type)va_arg(ap,
    a0007dd4:	b9401a61 	ldr	w1, [x19, #24]
    a0007dd8:	f9400260 	ldr	x0, [x19]
    a0007ddc:	7100003f 	cmp	w1, #0x0
    a0007de0:	540000ab 	b.lt	a0007df4 <cbvprintf+0x720>  // b.tstop
    a0007de4:	91003c01 	add	x1, x0, #0xf
    a0007de8:	927df021 	and	x1, x1, #0xfffffffffffffff8
    a0007dec:	f9000261 	str	x1, [x19]
    a0007df0:	1400000d 	b	a0007e24 <cbvprintf+0x750>
    a0007df4:	11002022 	add	w2, w1, #0x8
    a0007df8:	b9001a62 	str	w2, [x19, #24]
    a0007dfc:	b9401a62 	ldr	w2, [x19, #24]
    a0007e00:	7100005f 	cmp	w2, #0x0
    a0007e04:	540000ad 	b.le	a0007e18 <cbvprintf+0x744>
    a0007e08:	91003c01 	add	x1, x0, #0xf
    a0007e0c:	927df021 	and	x1, x1, #0xfffffffffffffff8
    a0007e10:	f9000261 	str	x1, [x19]
    a0007e14:	14000004 	b	a0007e24 <cbvprintf+0x750>
    a0007e18:	f9400662 	ldr	x2, [x19, #8]
    a0007e1c:	93407c20 	sxtw	x0, w1
    a0007e20:	8b000040 	add	x0, x2, x0
    a0007e24:	f9400001 	ldr	x1, [x0]
				value->uint =
    a0007e28:	f94087e0 	ldr	x0, [sp, #264]
    a0007e2c:	f9000001 	str	x1, [x0]
						unsigned long long);
				break;
    a0007e30:	14000031 	b	a0007ef4 <cbvprintf+0x820>
			case LENGTH_J:
				value->uint =
					(uint_value_type)va_arg(ap,
    a0007e34:	b9401a61 	ldr	w1, [x19, #24]
    a0007e38:	f9400260 	ldr	x0, [x19]
    a0007e3c:	7100003f 	cmp	w1, #0x0
    a0007e40:	540000ab 	b.lt	a0007e54 <cbvprintf+0x780>  // b.tstop
    a0007e44:	91003c01 	add	x1, x0, #0xf
    a0007e48:	927df021 	and	x1, x1, #0xfffffffffffffff8
    a0007e4c:	f9000261 	str	x1, [x19]
    a0007e50:	1400000d 	b	a0007e84 <cbvprintf+0x7b0>
    a0007e54:	11002022 	add	w2, w1, #0x8
    a0007e58:	b9001a62 	str	w2, [x19, #24]
    a0007e5c:	b9401a62 	ldr	w2, [x19, #24]
    a0007e60:	7100005f 	cmp	w2, #0x0
    a0007e64:	540000ad 	b.le	a0007e78 <cbvprintf+0x7a4>
    a0007e68:	91003c01 	add	x1, x0, #0xf
    a0007e6c:	927df021 	and	x1, x1, #0xfffffffffffffff8
    a0007e70:	f9000261 	str	x1, [x19]
    a0007e74:	14000004 	b	a0007e84 <cbvprintf+0x7b0>
    a0007e78:	f9400662 	ldr	x2, [x19, #8]
    a0007e7c:	93407c20 	sxtw	x0, w1
    a0007e80:	8b000040 	add	x0, x2, x0
    a0007e84:	f9400001 	ldr	x1, [x0]
				value->uint =
    a0007e88:	f94087e0 	ldr	x0, [sp, #264]
    a0007e8c:	f9000001 	str	x1, [x0]
								uintmax_t);
				break;
    a0007e90:	14000019 	b	a0007ef4 <cbvprintf+0x820>
			case LENGTH_Z:		/* size_t */
			case LENGTH_T:		/* ptrdiff_t */
				value->uint =
					(uint_value_type)va_arg(ap, size_t);
    a0007e94:	b9401a61 	ldr	w1, [x19, #24]
    a0007e98:	f9400260 	ldr	x0, [x19]
    a0007e9c:	7100003f 	cmp	w1, #0x0
    a0007ea0:	540000ab 	b.lt	a0007eb4 <cbvprintf+0x7e0>  // b.tstop
    a0007ea4:	91003c01 	add	x1, x0, #0xf
    a0007ea8:	927df021 	and	x1, x1, #0xfffffffffffffff8
    a0007eac:	f9000261 	str	x1, [x19]
    a0007eb0:	1400000d 	b	a0007ee4 <cbvprintf+0x810>
    a0007eb4:	11002022 	add	w2, w1, #0x8
    a0007eb8:	b9001a62 	str	w2, [x19, #24]
    a0007ebc:	b9401a62 	ldr	w2, [x19, #24]
    a0007ec0:	7100005f 	cmp	w2, #0x0
    a0007ec4:	540000ad 	b.le	a0007ed8 <cbvprintf+0x804>
    a0007ec8:	91003c01 	add	x1, x0, #0xf
    a0007ecc:	927df021 	and	x1, x1, #0xfffffffffffffff8
    a0007ed0:	f9000261 	str	x1, [x19]
    a0007ed4:	14000004 	b	a0007ee4 <cbvprintf+0x810>
    a0007ed8:	f9400662 	ldr	x2, [x19, #8]
    a0007edc:	93407c20 	sxtw	x0, w1
    a0007ee0:	8b000040 	add	x0, x2, x0
    a0007ee4:	f9400001 	ldr	x1, [x0]
				value->uint =
    a0007ee8:	f94087e0 	ldr	x0, [sp, #264]
    a0007eec:	f9000001 	str	x1, [x0]
				break;
    a0007ef0:	d503201f 	nop
			}
			if (length_mod == LENGTH_HH) {
    a0007ef4:	b940f7e0 	ldr	w0, [sp, #244]
    a0007ef8:	7100041f 	cmp	w0, #0x1
    a0007efc:	54000101 	b.ne	a0007f1c <cbvprintf+0x848>  // b.any
				value->uint = (unsigned char)value->uint;
    a0007f00:	f94087e0 	ldr	x0, [sp, #264]
    a0007f04:	f9400000 	ldr	x0, [x0]
    a0007f08:	12001c00 	and	w0, w0, #0xff
    a0007f0c:	92401c01 	and	x1, x0, #0xff
    a0007f10:	f94087e0 	ldr	x0, [sp, #264]
    a0007f14:	f9000001 	str	x1, [x0]
    a0007f18:	1400005f 	b	a0008094 <cbvprintf+0x9c0>
			} else if (length_mod == LENGTH_H) {
    a0007f1c:	b940f7e0 	ldr	w0, [sp, #244]
    a0007f20:	7100081f 	cmp	w0, #0x2
    a0007f24:	54000b81 	b.ne	a0008094 <cbvprintf+0x9c0>  // b.any
				value->uint = (unsigned short)value->uint;
    a0007f28:	f94087e0 	ldr	x0, [sp, #264]
    a0007f2c:	f9400000 	ldr	x0, [x0]
    a0007f30:	12003c00 	and	w0, w0, #0xffff
    a0007f34:	92403c01 	and	x1, x0, #0xffff
    a0007f38:	f94087e0 	ldr	x0, [sp, #264]
    a0007f3c:	f9000001 	str	x1, [x0]
    a0007f40:	14000055 	b	a0008094 <cbvprintf+0x9c0>
			}
		} else if (specifier_cat == SPECIFIER_FP) {
    a0007f44:	b940fbe0 	ldr	w0, [sp, #248]
    a0007f48:	7100101f 	cmp	w0, #0x4
    a0007f4c:	54000701 	b.ne	a000802c <cbvprintf+0x958>  // b.any
			if (length_mod == LENGTH_UPPER_L) {
    a0007f50:	b940f7e0 	ldr	w0, [sp, #244]
    a0007f54:	7100201f 	cmp	w0, #0x8
    a0007f58:	540003a1 	b.ne	a0007fcc <cbvprintf+0x8f8>  // b.any
				value->ldbl = va_arg(ap, long double);
    a0007f5c:	b9401e60 	ldr	w0, [x19, #28]
    a0007f60:	f9400261 	ldr	x1, [x19]
    a0007f64:	7100001f 	cmp	w0, #0x0
    a0007f68:	540000eb 	b.lt	a0007f84 <cbvprintf+0x8b0>  // b.tstop
    a0007f6c:	91003c20 	add	x0, x1, #0xf
    a0007f70:	927cec00 	and	x0, x0, #0xfffffffffffffff0
    a0007f74:	91005c01 	add	x1, x0, #0x17
    a0007f78:	927df021 	and	x1, x1, #0xfffffffffffffff8
    a0007f7c:	f9000261 	str	x1, [x19]
    a0007f80:	1400000f 	b	a0007fbc <cbvprintf+0x8e8>
    a0007f84:	11004002 	add	w2, w0, #0x10
    a0007f88:	b9001e62 	str	w2, [x19, #28]
    a0007f8c:	b9401e62 	ldr	w2, [x19, #28]
    a0007f90:	7100005f 	cmp	w2, #0x0
    a0007f94:	540000ed 	b.le	a0007fb0 <cbvprintf+0x8dc>
    a0007f98:	91003c20 	add	x0, x1, #0xf
    a0007f9c:	927cec00 	and	x0, x0, #0xfffffffffffffff0
    a0007fa0:	91005c01 	add	x1, x0, #0x17
    a0007fa4:	927df021 	and	x1, x1, #0xfffffffffffffff8
    a0007fa8:	f9000261 	str	x1, [x19]
    a0007fac:	14000004 	b	a0007fbc <cbvprintf+0x8e8>
    a0007fb0:	f9400a61 	ldr	x1, [x19, #16]
    a0007fb4:	93407c00 	sxtw	x0, w0
    a0007fb8:	8b000020 	add	x0, x1, x0
    a0007fbc:	3dc00000 	ldr	q0, [x0]
    a0007fc0:	f94087e0 	ldr	x0, [sp, #264]
    a0007fc4:	3d800000 	str	q0, [x0]
    a0007fc8:	14000033 	b	a0008094 <cbvprintf+0x9c0>
			} else {
				value->dbl = va_arg(ap, double);
    a0007fcc:	b9401e61 	ldr	w1, [x19, #28]
    a0007fd0:	f9400260 	ldr	x0, [x19]
    a0007fd4:	7100003f 	cmp	w1, #0x0
    a0007fd8:	540000ab 	b.lt	a0007fec <cbvprintf+0x918>  // b.tstop
    a0007fdc:	91003c01 	add	x1, x0, #0xf
    a0007fe0:	927df021 	and	x1, x1, #0xfffffffffffffff8
    a0007fe4:	f9000261 	str	x1, [x19]
    a0007fe8:	1400000d 	b	a000801c <cbvprintf+0x948>
    a0007fec:	11004022 	add	w2, w1, #0x10
    a0007ff0:	b9001e62 	str	w2, [x19, #28]
    a0007ff4:	b9401e62 	ldr	w2, [x19, #28]
    a0007ff8:	7100005f 	cmp	w2, #0x0
    a0007ffc:	540000ad 	b.le	a0008010 <cbvprintf+0x93c>
    a0008000:	91003c01 	add	x1, x0, #0xf
    a0008004:	927df021 	and	x1, x1, #0xfffffffffffffff8
    a0008008:	f9000261 	str	x1, [x19]
    a000800c:	14000004 	b	a000801c <cbvprintf+0x948>
    a0008010:	f9400a62 	ldr	x2, [x19, #16]
    a0008014:	93407c20 	sxtw	x0, w1
    a0008018:	8b000040 	add	x0, x2, x0
    a000801c:	fd400000 	ldr	d0, [x0]
    a0008020:	f94087e0 	ldr	x0, [sp, #264]
    a0008024:	fd000000 	str	d0, [x0]
    a0008028:	1400001b 	b	a0008094 <cbvprintf+0x9c0>
			}
		} else if (specifier_cat == SPECIFIER_PTR) {
    a000802c:	b940fbe0 	ldr	w0, [sp, #248]
    a0008030:	71000c1f 	cmp	w0, #0x3
    a0008034:	54000301 	b.ne	a0008094 <cbvprintf+0x9c0>  // b.any
			value->ptr = va_arg(ap, void *);
    a0008038:	b9401a61 	ldr	w1, [x19, #24]
    a000803c:	f9400260 	ldr	x0, [x19]
    a0008040:	7100003f 	cmp	w1, #0x0
    a0008044:	540000ab 	b.lt	a0008058 <cbvprintf+0x984>  // b.tstop
    a0008048:	91003c01 	add	x1, x0, #0xf
    a000804c:	927df021 	and	x1, x1, #0xfffffffffffffff8
    a0008050:	f9000261 	str	x1, [x19]
    a0008054:	1400000d 	b	a0008088 <cbvprintf+0x9b4>
    a0008058:	11002022 	add	w2, w1, #0x8
    a000805c:	b9001a62 	str	w2, [x19, #24]
    a0008060:	b9401a62 	ldr	w2, [x19, #24]
    a0008064:	7100005f 	cmp	w2, #0x0
    a0008068:	540000ad 	b.le	a000807c <cbvprintf+0x9a8>
    a000806c:	91003c01 	add	x1, x0, #0xf
    a0008070:	927df021 	and	x1, x1, #0xfffffffffffffff8
    a0008074:	f9000261 	str	x1, [x19]
    a0008078:	14000004 	b	a0008088 <cbvprintf+0x9b4>
    a000807c:	f9400662 	ldr	x2, [x19, #8]
    a0008080:	93407c20 	sxtw	x0, w1
    a0008084:	8b000040 	add	x0, x2, x0
    a0008088:	f9400001 	ldr	x1, [x0]
    a000808c:	f94087e0 	ldr	x0, [sp, #264]
    a0008090:	f9000001 	str	x1, [x0]
		/* We've now consumed all arguments related to this
		 * specification.  If the conversion is invalid, or is
		 * something we don't support, then output the original
		 * specification and move on.
		 */
		if (conv->invalid || conv->unsupported) {
    a0008094:	f9408be0 	ldr	x0, [sp, #272]
    a0008098:	79400000 	ldrh	w0, [x0]
    a000809c:	12000000 	and	w0, w0, #0x1
    a00080a0:	12003c00 	and	w0, w0, #0xffff
    a00080a4:	7100001f 	cmp	w0, #0x0
    a00080a8:	540000e1 	b.ne	a00080c4 <cbvprintf+0x9f0>  // b.any
    a00080ac:	f9408be0 	ldr	x0, [sp, #272]
    a00080b0:	79400000 	ldrh	w0, [x0]
    a00080b4:	121f0000 	and	w0, w0, #0x2
    a00080b8:	12003c00 	and	w0, w0, #0xffff
    a00080bc:	7100001f 	cmp	w0, #0x0
    a00080c0:	54000220 	b.eq	a0008104 <cbvprintf+0xa30>  // b.none
			OUTS(sp, fp);
    a00080c4:	f94017e3 	ldr	x3, [sp, #40]
    a00080c8:	f94083e2 	ldr	x2, [sp, #256]
    a00080cc:	f9401be1 	ldr	x1, [sp, #48]
    a00080d0:	f9401fe0 	ldr	x0, [sp, #56]
    a00080d4:	97fffd5a 	bl	a000763c <outs>
    a00080d8:	b9009be0 	str	w0, [sp, #152]
    a00080dc:	b9409be0 	ldr	w0, [sp, #152]
    a00080e0:	7100001f 	cmp	w0, #0x0
    a00080e4:	5400006a 	b.ge	a00080f0 <cbvprintf+0xa1c>  // b.tcont
    a00080e8:	b9409be0 	ldr	w0, [sp, #152]
    a00080ec:	14000290 	b	a0008b2c <cbvprintf+0x1458>
    a00080f0:	b9809be0 	ldrsw	x0, [sp, #152]
    a00080f4:	f940a7e1 	ldr	x1, [sp, #328]
    a00080f8:	8b000020 	add	x0, x1, x0
    a00080fc:	f900a7e0 	str	x0, [sp, #328]
			continue;
    a0008100:	14000286 	b	a0008b18 <cbvprintf+0x1444>
		}

		/* Do formatting, either into the buffer or
		 * referencing external data.
		 */
		switch (conv->specifier) {
    a0008104:	f9408be0 	ldr	x0, [sp, #272]
    a0008108:	39400c00 	ldrb	w0, [x0, #3]
    a000810c:	7101e01f 	cmp	w0, #0x78
    a0008110:	54001100 	b.eq	a0008330 <cbvprintf+0xc5c>  // b.none
    a0008114:	7101e01f 	cmp	w0, #0x78
    a0008118:	54001b0c 	b.gt	a0008478 <cbvprintf+0xda4>
    a000811c:	7101d41f 	cmp	w0, #0x75
    a0008120:	54001080 	b.eq	a0008330 <cbvprintf+0xc5c>  // b.none
    a0008124:	7101d41f 	cmp	w0, #0x75
    a0008128:	54001a8c 	b.gt	a0008478 <cbvprintf+0xda4>
    a000812c:	7101cc1f 	cmp	w0, #0x73
    a0008130:	540007c0 	b.eq	a0008228 <cbvprintf+0xb54>  // b.none
    a0008134:	7101cc1f 	cmp	w0, #0x73
    a0008138:	54001a0c 	b.gt	a0008478 <cbvprintf+0xda4>
    a000813c:	7101c01f 	cmp	w0, #0x70
    a0008140:	54001360 	b.eq	a00083ac <cbvprintf+0xcd8>  // b.none
    a0008144:	7101c01f 	cmp	w0, #0x70
    a0008148:	5400198c 	b.gt	a0008478 <cbvprintf+0xda4>
    a000814c:	7101bc1f 	cmp	w0, #0x6f
    a0008150:	54000f00 	b.eq	a0008330 <cbvprintf+0xc5c>  // b.none
    a0008154:	7101bc1f 	cmp	w0, #0x6f
    a0008158:	5400190c 	b.gt	a0008478 <cbvprintf+0xda4>
    a000815c:	7101b81f 	cmp	w0, #0x6e
    a0008160:	54001620 	b.eq	a0008424 <cbvprintf+0xd50>  // b.none
    a0008164:	7101b81f 	cmp	w0, #0x6e
    a0008168:	5400188c 	b.gt	a0008478 <cbvprintf+0xda4>
    a000816c:	7101a41f 	cmp	w0, #0x69
    a0008170:	540009c0 	b.eq	a00082a8 <cbvprintf+0xbd4>  // b.none
    a0008174:	7101a41f 	cmp	w0, #0x69
    a0008178:	5400180c 	b.gt	a0008478 <cbvprintf+0xda4>
    a000817c:	71019c1f 	cmp	w0, #0x67
    a0008180:	540017cc 	b.gt	a0008478 <cbvprintf+0xda4>
    a0008184:	7101941f 	cmp	w0, #0x65
    a0008188:	540015ea 	b.ge	a0008444 <cbvprintf+0xd70>  // b.tcont
    a000818c:	7101901f 	cmp	w0, #0x64
    a0008190:	540008c0 	b.eq	a00082a8 <cbvprintf+0xbd4>  // b.none
    a0008194:	7101901f 	cmp	w0, #0x64
    a0008198:	5400170c 	b.gt	a0008478 <cbvprintf+0xda4>
    a000819c:	71018c1f 	cmp	w0, #0x63
    a00081a0:	54000700 	b.eq	a0008280 <cbvprintf+0xbac>  // b.none
    a00081a4:	71018c1f 	cmp	w0, #0x63
    a00081a8:	5400168c 	b.gt	a0008478 <cbvprintf+0xda4>
    a00081ac:	7101841f 	cmp	w0, #0x61
    a00081b0:	540014a0 	b.eq	a0008444 <cbvprintf+0xd70>  // b.none
    a00081b4:	7101841f 	cmp	w0, #0x61
    a00081b8:	5400160c 	b.gt	a0008478 <cbvprintf+0xda4>
    a00081bc:	7101601f 	cmp	w0, #0x58
    a00081c0:	54000b80 	b.eq	a0008330 <cbvprintf+0xc5c>  // b.none
    a00081c4:	7101601f 	cmp	w0, #0x58
    a00081c8:	5400158c 	b.gt	a0008478 <cbvprintf+0xda4>
    a00081cc:	71011c1f 	cmp	w0, #0x47
    a00081d0:	5400154c 	b.gt	a0008478 <cbvprintf+0xda4>
    a00081d4:	7101141f 	cmp	w0, #0x45
    a00081d8:	5400136a 	b.ge	a0008444 <cbvprintf+0xd70>  // b.tcont
    a00081dc:	7100941f 	cmp	w0, #0x25
    a00081e0:	54000080 	b.eq	a00081f0 <cbvprintf+0xb1c>  // b.none
    a00081e4:	7101041f 	cmp	w0, #0x41
    a00081e8:	540012e0 	b.eq	a0008444 <cbvprintf+0xd70>  // b.none
		default:
			/* Add an empty default with break, this is a defensive
			 * programming. Static analysis tool won't raise a violation
			 * if default is empty, but has that comment.
			 */
			break;
    a00081ec:	140000a3 	b	a0008478 <cbvprintf+0xda4>
			OUTC('%');
    a00081f0:	f9401fe2 	ldr	x2, [sp, #56]
    a00081f4:	f9401be1 	ldr	x1, [sp, #48]
    a00081f8:	528004a0 	mov	w0, #0x25                  	// #37
    a00081fc:	d63f0040 	blr	x2
    a0008200:	b900dfe0 	str	w0, [sp, #220]
    a0008204:	b940dfe0 	ldr	w0, [sp, #220]
    a0008208:	7100001f 	cmp	w0, #0x0
    a000820c:	5400006a 	b.ge	a0008218 <cbvprintf+0xb44>  // b.tcont
    a0008210:	b940dfe0 	ldr	w0, [sp, #220]
    a0008214:	14000246 	b	a0008b2c <cbvprintf+0x1458>
    a0008218:	f940a7e0 	ldr	x0, [sp, #328]
    a000821c:	91000400 	add	x0, x0, #0x1
    a0008220:	f900a7e0 	str	x0, [sp, #328]
			break;
    a0008224:	14000098 	b	a0008484 <cbvprintf+0xdb0>
			bps = (const char *)value->ptr;
    a0008228:	f94087e0 	ldr	x0, [sp, #264]
    a000822c:	f9400000 	ldr	x0, [x0]
    a0008230:	f9009fe0 	str	x0, [sp, #312]
			if (precision >= 0) {
    a0008234:	b94143e0 	ldr	w0, [sp, #320]
    a0008238:	7100001f 	cmp	w0, #0x0
    a000823c:	540000eb 	b.lt	a0008258 <cbvprintf+0xb84>  // b.tstop
				len = strnlen(bps, precision);
    a0008240:	b98143e0 	ldrsw	x0, [sp, #320]
    a0008244:	aa0003e1 	mov	x1, x0
    a0008248:	f9409fe0 	ldr	x0, [sp, #312]
    a000824c:	94000ee1 	bl	a000bdd0 <strnlen>
    a0008250:	f9009be0 	str	x0, [sp, #304]
    a0008254:	14000004 	b	a0008264 <cbvprintf+0xb90>
				len = strlen(bps);
    a0008258:	f9409fe0 	ldr	x0, [sp, #312]
    a000825c:	94000ecc 	bl	a000bd8c <strlen>
    a0008260:	f9009be0 	str	x0, [sp, #304]
			bpe = bps + len;
    a0008264:	f9409fe1 	ldr	x1, [sp, #312]
    a0008268:	f9409be0 	ldr	x0, [sp, #304]
    a000826c:	8b000020 	add	x0, x1, x0
    a0008270:	f9003be0 	str	x0, [sp, #112]
			precision = -1;
    a0008274:	12800000 	mov	w0, #0xffffffff            	// #-1
    a0008278:	b90143e0 	str	w0, [sp, #320]
			break;
    a000827c:	14000082 	b	a0008484 <cbvprintf+0xdb0>
			bps = buf;
    a0008280:	9101e3e0 	add	x0, sp, #0x78
    a0008284:	f9009fe0 	str	x0, [sp, #312]
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
    a0008288:	f94087e0 	ldr	x0, [sp, #264]
    a000828c:	f9400000 	ldr	x0, [x0]
    a0008290:	12001c00 	and	w0, w0, #0xff
    a0008294:	3901e3e0 	strb	w0, [sp, #120]
			bpe = buf + 1;
    a0008298:	9101e3e0 	add	x0, sp, #0x78
    a000829c:	91000400 	add	x0, x0, #0x1
    a00082a0:	f9003be0 	str	x0, [sp, #112]
			break;
    a00082a4:	14000078 	b	a0008484 <cbvprintf+0xdb0>
			if (conv->flag_plus) {
    a00082a8:	f9408be0 	ldr	x0, [sp, #272]
    a00082ac:	79400000 	ldrh	w0, [x0]
    a00082b0:	121d0000 	and	w0, w0, #0x8
    a00082b4:	12003c00 	and	w0, w0, #0xffff
    a00082b8:	7100001f 	cmp	w0, #0x0
    a00082bc:	54000080 	b.eq	a00082cc <cbvprintf+0xbf8>  // b.none
				sign = '+';
    a00082c0:	52800560 	mov	w0, #0x2b                  	// #43
    a00082c4:	3901bfe0 	strb	w0, [sp, #111]
    a00082c8:	14000009 	b	a00082ec <cbvprintf+0xc18>
			} else if (conv->flag_space) {
    a00082cc:	f9408be0 	ldr	x0, [sp, #272]
    a00082d0:	79400000 	ldrh	w0, [x0]
    a00082d4:	121c0000 	and	w0, w0, #0x10
    a00082d8:	12003c00 	and	w0, w0, #0xffff
    a00082dc:	7100001f 	cmp	w0, #0x0
    a00082e0:	54000060 	b.eq	a00082ec <cbvprintf+0xc18>  // b.none
				sign = ' ';
    a00082e4:	52800400 	mov	w0, #0x20                  	// #32
    a00082e8:	3901bfe0 	strb	w0, [sp, #111]
			sint = value->sint;
    a00082ec:	f94087e0 	ldr	x0, [sp, #264]
    a00082f0:	f9400000 	ldr	x0, [x0]
    a00082f4:	f90077e0 	str	x0, [sp, #232]
			if (sint < 0) {
    a00082f8:	f94077e0 	ldr	x0, [sp, #232]
    a00082fc:	f100001f 	cmp	x0, #0x0
    a0008300:	5400012a 	b.ge	a0008324 <cbvprintf+0xc50>  // b.tcont
				sign = '-';
    a0008304:	528005a0 	mov	w0, #0x2d                  	// #45
    a0008308:	3901bfe0 	strb	w0, [sp, #111]
				value->uint = (uint_value_type)-sint;
    a000830c:	f94077e0 	ldr	x0, [sp, #232]
    a0008310:	cb0003e0 	neg	x0, x0
    a0008314:	aa0003e1 	mov	x1, x0
    a0008318:	f94087e0 	ldr	x0, [sp, #264]
    a000831c:	f9000001 	str	x1, [x0]
    a0008320:	14000004 	b	a0008330 <cbvprintf+0xc5c>
				value->uint = (uint_value_type)sint;
    a0008324:	f94077e1 	ldr	x1, [sp, #232]
    a0008328:	f94087e0 	ldr	x0, [sp, #264]
    a000832c:	f9000001 	str	x1, [x0]
			bps = encode_uint(value->uint, conv, buf, bpe);
    a0008330:	f94087e0 	ldr	x0, [sp, #264]
    a0008334:	f9400000 	ldr	x0, [x0]
    a0008338:	f9403be2 	ldr	x2, [sp, #112]
    a000833c:	9101e3e1 	add	x1, sp, #0x78
    a0008340:	aa0203e3 	mov	x3, x2
    a0008344:	aa0103e2 	mov	x2, x1
    a0008348:	f9408be1 	ldr	x1, [sp, #272]
    a000834c:	97fff9c9 	bl	a0006a70 <encode_uint>
    a0008350:	f9009fe0 	str	x0, [sp, #312]
			if (precision >= 0) {
    a0008354:	b94143e0 	ldr	w0, [sp, #320]
    a0008358:	7100001f 	cmp	w0, #0x0
    a000835c:	5400092b 	b.lt	a0008480 <cbvprintf+0xdac>  // b.tstop
				size_t len = bpe - bps;
    a0008360:	f9403be1 	ldr	x1, [sp, #112]
    a0008364:	f9409fe0 	ldr	x0, [sp, #312]
    a0008368:	cb000020 	sub	x0, x1, x0
    a000836c:	f90073e0 	str	x0, [sp, #224]
				conv->flag_zero = false;
    a0008370:	f9408be0 	ldr	x0, [sp, #272]
    a0008374:	79400001 	ldrh	w1, [x0]
    a0008378:	12197821 	and	w1, w1, #0xffffffbf
    a000837c:	79000001 	strh	w1, [x0]
				if (len < (size_t)precision) {
    a0008380:	b98143e0 	ldrsw	x0, [sp, #320]
    a0008384:	f94073e1 	ldr	x1, [sp, #224]
    a0008388:	eb00003f 	cmp	x1, x0
    a000838c:	540007a2 	b.cs	a0008480 <cbvprintf+0xdac>  // b.hs, b.nlast
					conv->pad0_value = precision - (int)len;
    a0008390:	f94073e0 	ldr	x0, [sp, #224]
    a0008394:	2a0003e1 	mov	w1, w0
    a0008398:	b94143e0 	ldr	w0, [sp, #320]
    a000839c:	4b010001 	sub	w1, w0, w1
    a00083a0:	f9408be0 	ldr	x0, [sp, #272]
    a00083a4:	b9000401 	str	w1, [x0, #4]
			break;
    a00083a8:	14000036 	b	a0008480 <cbvprintf+0xdac>
			if (value->ptr != NULL) {
    a00083ac:	f94087e0 	ldr	x0, [sp, #264]
    a00083b0:	f9400000 	ldr	x0, [x0]
    a00083b4:	f100001f 	cmp	x0, #0x0
    a00083b8:	54000280 	b.eq	a0008408 <cbvprintf+0xd34>  // b.none
				bps = encode_uint((uintptr_t)value->ptr, conv,
    a00083bc:	f94087e0 	ldr	x0, [sp, #264]
    a00083c0:	f9400000 	ldr	x0, [x0]
    a00083c4:	aa0003e4 	mov	x4, x0
    a00083c8:	f9403be1 	ldr	x1, [sp, #112]
    a00083cc:	9101e3e0 	add	x0, sp, #0x78
    a00083d0:	aa0103e3 	mov	x3, x1
    a00083d4:	aa0003e2 	mov	x2, x0
    a00083d8:	f9408be1 	ldr	x1, [sp, #272]
    a00083dc:	aa0403e0 	mov	x0, x4
    a00083e0:	97fff9a4 	bl	a0006a70 <encode_uint>
    a00083e4:	f9009fe0 	str	x0, [sp, #312]
				conv->altform_0c = true;
    a00083e8:	f9408be0 	ldr	x0, [sp, #272]
    a00083ec:	39400801 	ldrb	w1, [x0, #2]
    a00083f0:	321c0021 	orr	w1, w1, #0x10
    a00083f4:	39000801 	strb	w1, [x0, #2]
				conv->specifier = 'x';
    a00083f8:	f9408be0 	ldr	x0, [sp, #272]
    a00083fc:	52800f01 	mov	w1, #0x78                  	// #120
    a0008400:	39000c01 	strb	w1, [x0, #3]
				goto prec_int_pad0;
    a0008404:	17ffffd4 	b	a0008354 <cbvprintf+0xc80>
			bps = "(nil)";
    a0008408:	900000e0 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a000840c:	910d4000 	add	x0, x0, #0x350
    a0008410:	f9009fe0 	str	x0, [sp, #312]
			bpe = bps + 5;
    a0008414:	f9409fe0 	ldr	x0, [sp, #312]
    a0008418:	91001400 	add	x0, x0, #0x5
    a000841c:	f9003be0 	str	x0, [sp, #112]
			break;
    a0008420:	14000019 	b	a0008484 <cbvprintf+0xdb0>
				store_count(conv, value->ptr, count);
    a0008424:	f94087e0 	ldr	x0, [sp, #264]
    a0008428:	f9400000 	ldr	x0, [x0]
    a000842c:	f940a7e1 	ldr	x1, [sp, #328]
    a0008430:	2a0103e2 	mov	w2, w1
    a0008434:	aa0003e1 	mov	x1, x0
    a0008438:	f9408be0 	ldr	x0, [sp, #272]
    a000843c:	97fffc35 	bl	a0007510 <store_count>
			break;
    a0008440:	14000011 	b	a0008484 <cbvprintf+0xdb0>
				bps = encode_float(value->dbl, conv, precision,
    a0008444:	f94087e0 	ldr	x0, [sp, #264]
    a0008448:	fd400000 	ldr	d0, [x0]
    a000844c:	9101c3e2 	add	x2, sp, #0x70
    a0008450:	9101e3e1 	add	x1, sp, #0x78
    a0008454:	9101bfe0 	add	x0, sp, #0x6f
    a0008458:	aa0203e4 	mov	x4, x2
    a000845c:	aa0103e3 	mov	x3, x1
    a0008460:	aa0003e2 	mov	x2, x0
    a0008464:	b94143e1 	ldr	w1, [sp, #320]
    a0008468:	f9408be0 	ldr	x0, [sp, #272]
    a000846c:	97fff9d5 	bl	a0006bc0 <encode_float>
    a0008470:	f9009fe0 	str	x0, [sp, #312]
			break;
    a0008474:	14000004 	b	a0008484 <cbvprintf+0xdb0>
			break;
    a0008478:	d503201f 	nop
    a000847c:	14000002 	b	a0008484 <cbvprintf+0xdb0>
			break;
    a0008480:	d503201f 	nop
		}

		/* If we don't have a converted value to emit, move
		 * on.
		 */
		if (bps == NULL) {
    a0008484:	f9409fe0 	ldr	x0, [sp, #312]
    a0008488:	f100001f 	cmp	x0, #0x0
    a000848c:	54003440 	b.eq	a0008b14 <cbvprintf+0x1440>  // b.none
		 *   * any exponent content from the converted value
		 * * for non-FP:
		 *   * any pad0_prefix
		 *   * the converted value
		 */
		size_t nj_len = (bpe - bps);
    a0008490:	f9403be1 	ldr	x1, [sp, #112]
    a0008494:	f9409fe0 	ldr	x0, [sp, #312]
    a0008498:	cb000020 	sub	x0, x1, x0
    a000849c:	f90097e0 	str	x0, [sp, #296]
		int pad_len = 0;
    a00084a0:	b90127ff 	str	wzr, [sp, #292]

		if (sign != 0) {
    a00084a4:	3941bfe0 	ldrb	w0, [sp, #111]
    a00084a8:	7100001f 	cmp	w0, #0x0
    a00084ac:	54000080 	b.eq	a00084bc <cbvprintf+0xde8>  // b.none
			nj_len += 1U;
    a00084b0:	f94097e0 	ldr	x0, [sp, #296]
    a00084b4:	91000400 	add	x0, x0, #0x1
    a00084b8:	f90097e0 	str	x0, [sp, #296]
		}

		if (conv->altform_0c) {
    a00084bc:	f9408be0 	ldr	x0, [sp, #272]
    a00084c0:	39400800 	ldrb	w0, [x0, #2]
    a00084c4:	121c0000 	and	w0, w0, #0x10
    a00084c8:	12001c00 	and	w0, w0, #0xff
    a00084cc:	7100001f 	cmp	w0, #0x0
    a00084d0:	540000a0 	b.eq	a00084e4 <cbvprintf+0xe10>  // b.none
			nj_len += 2U;
    a00084d4:	f94097e0 	ldr	x0, [sp, #296]
    a00084d8:	91000800 	add	x0, x0, #0x2
    a00084dc:	f90097e0 	str	x0, [sp, #296]
    a00084e0:	1400000a 	b	a0008508 <cbvprintf+0xe34>
		} else if (conv->altform_0) {
    a00084e4:	f9408be0 	ldr	x0, [sp, #272]
    a00084e8:	39400800 	ldrb	w0, [x0, #2]
    a00084ec:	121d0000 	and	w0, w0, #0x8
    a00084f0:	12001c00 	and	w0, w0, #0xff
    a00084f4:	7100001f 	cmp	w0, #0x0
    a00084f8:	54000080 	b.eq	a0008508 <cbvprintf+0xe34>  // b.none
			nj_len += 1U;
    a00084fc:	f94097e0 	ldr	x0, [sp, #296]
    a0008500:	91000400 	add	x0, x0, #0x1
    a0008504:	f90097e0 	str	x0, [sp, #296]
		}

		nj_len += conv->pad0_value;
    a0008508:	f9408be0 	ldr	x0, [sp, #272]
    a000850c:	b9400400 	ldr	w0, [x0, #4]
    a0008510:	93407c00 	sxtw	x0, w0
    a0008514:	f94097e1 	ldr	x1, [sp, #296]
    a0008518:	8b000020 	add	x0, x1, x0
    a000851c:	f90097e0 	str	x0, [sp, #296]
		if (conv->pad_fp) {
    a0008520:	f9408be0 	ldr	x0, [sp, #272]
    a0008524:	39400800 	ldrb	w0, [x0, #2]
    a0008528:	121a0000 	and	w0, w0, #0x40
    a000852c:	12001c00 	and	w0, w0, #0xff
    a0008530:	7100001f 	cmp	w0, #0x0
    a0008534:	540000e0 	b.eq	a0008550 <cbvprintf+0xe7c>  // b.none
			nj_len += conv->pad0_pre_exp;
    a0008538:	f9408be0 	ldr	x0, [sp, #272]
    a000853c:	b9400800 	ldr	w0, [x0, #8]
    a0008540:	93407c00 	sxtw	x0, w0
    a0008544:	f94097e1 	ldr	x1, [sp, #296]
    a0008548:	8b000020 	add	x0, x1, x0
    a000854c:	f90097e0 	str	x0, [sp, #296]
		 * result in no padding.
		 *
		 * If a non-negative padding width is present and we're doing
		 * right-justification, emit the padding now.
		 */
		if (width > 0) {
    a0008550:	b94147e0 	ldr	w0, [sp, #324]
    a0008554:	7100001f 	cmp	w0, #0x0
    a0008558:	5400078d 	b.le	a0008648 <cbvprintf+0xf74>
			width -= (int)nj_len;
    a000855c:	f94097e0 	ldr	x0, [sp, #296]
    a0008560:	2a0003e1 	mov	w1, w0
    a0008564:	b94147e0 	ldr	w0, [sp, #324]
    a0008568:	4b010000 	sub	w0, w0, w1
    a000856c:	b90147e0 	str	w0, [sp, #324]

			if (!conv->flag_dash) {
    a0008570:	f9408be0 	ldr	x0, [sp, #272]
    a0008574:	b9400000 	ldr	w0, [x0]
    a0008578:	d3420800 	ubfx	x0, x0, #2, #1
    a000857c:	12001c00 	and	w0, w0, #0xff
    a0008580:	52000000 	eor	w0, w0, #0x1
    a0008584:	12001c00 	and	w0, w0, #0xff
    a0008588:	7100001f 	cmp	w0, #0x0
    a000858c:	540005e0 	b.eq	a0008648 <cbvprintf+0xf74>  // b.none
				char pad = ' ';
    a0008590:	52800400 	mov	w0, #0x20                  	// #32
    a0008594:	39048fe0 	strb	w0, [sp, #291]

				/* If we're zero-padding we have to emit the
				 * sign first.
				 */
				if (conv->flag_zero) {
    a0008598:	f9408be0 	ldr	x0, [sp, #272]
    a000859c:	79400000 	ldrh	w0, [x0]
    a00085a0:	121a0000 	and	w0, w0, #0x40
    a00085a4:	12003c00 	and	w0, w0, #0xffff
    a00085a8:	7100001f 	cmp	w0, #0x0
    a00085ac:	54000440 	b.eq	a0008634 <cbvprintf+0xf60>  // b.none
					if (sign != 0) {
    a00085b0:	3941bfe0 	ldrb	w0, [sp, #111]
    a00085b4:	7100001f 	cmp	w0, #0x0
    a00085b8:	540001e0 	b.eq	a00085f4 <cbvprintf+0xf20>  // b.none
						OUTC(sign);
    a00085bc:	3941bfe0 	ldrb	w0, [sp, #111]
    a00085c0:	f9401fe2 	ldr	x2, [sp, #56]
    a00085c4:	f9401be1 	ldr	x1, [sp, #48]
    a00085c8:	d63f0040 	blr	x2
    a00085cc:	b900dbe0 	str	w0, [sp, #216]
    a00085d0:	b940dbe0 	ldr	w0, [sp, #216]
    a00085d4:	7100001f 	cmp	w0, #0x0
    a00085d8:	5400006a 	b.ge	a00085e4 <cbvprintf+0xf10>  // b.tcont
    a00085dc:	b940dbe0 	ldr	w0, [sp, #216]
    a00085e0:	14000153 	b	a0008b2c <cbvprintf+0x1458>
    a00085e4:	f940a7e0 	ldr	x0, [sp, #328]
    a00085e8:	91000400 	add	x0, x0, #0x1
    a00085ec:	f900a7e0 	str	x0, [sp, #328]
						sign = 0;
    a00085f0:	3901bfff 	strb	wzr, [sp, #111]
					}
					pad = '0';
    a00085f4:	52800600 	mov	w0, #0x30                  	// #48
    a00085f8:	39048fe0 	strb	w0, [sp, #291]
				}

				while (width-- > 0) {
    a00085fc:	1400000e 	b	a0008634 <cbvprintf+0xf60>
					OUTC(pad);
    a0008600:	39448fe0 	ldrb	w0, [sp, #291]
    a0008604:	f9401fe2 	ldr	x2, [sp, #56]
    a0008608:	f9401be1 	ldr	x1, [sp, #48]
    a000860c:	d63f0040 	blr	x2
    a0008610:	b900d7e0 	str	w0, [sp, #212]
    a0008614:	b940d7e0 	ldr	w0, [sp, #212]
    a0008618:	7100001f 	cmp	w0, #0x0
    a000861c:	5400006a 	b.ge	a0008628 <cbvprintf+0xf54>  // b.tcont
    a0008620:	b940d7e0 	ldr	w0, [sp, #212]
    a0008624:	14000142 	b	a0008b2c <cbvprintf+0x1458>
    a0008628:	f940a7e0 	ldr	x0, [sp, #328]
    a000862c:	91000400 	add	x0, x0, #0x1
    a0008630:	f900a7e0 	str	x0, [sp, #328]
				while (width-- > 0) {
    a0008634:	b94147e0 	ldr	w0, [sp, #324]
    a0008638:	51000401 	sub	w1, w0, #0x1
    a000863c:	b90147e1 	str	w1, [sp, #324]
    a0008640:	7100001f 	cmp	w0, #0x0
    a0008644:	54fffdec 	b.gt	a0008600 <cbvprintf+0xf2c>
		}

		/* If we have a sign that hasn't been emitted, now's the
		 * time....
		 */
		if (sign != 0) {
    a0008648:	3941bfe0 	ldrb	w0, [sp, #111]
    a000864c:	7100001f 	cmp	w0, #0x0
    a0008650:	540001c0 	b.eq	a0008688 <cbvprintf+0xfb4>  // b.none
			OUTC(sign);
    a0008654:	3941bfe0 	ldrb	w0, [sp, #111]
    a0008658:	f9401fe2 	ldr	x2, [sp, #56]
    a000865c:	f9401be1 	ldr	x1, [sp, #48]
    a0008660:	d63f0040 	blr	x2
    a0008664:	b900d3e0 	str	w0, [sp, #208]
    a0008668:	b940d3e0 	ldr	w0, [sp, #208]
    a000866c:	7100001f 	cmp	w0, #0x0
    a0008670:	5400006a 	b.ge	a000867c <cbvprintf+0xfa8>  // b.tcont
    a0008674:	b940d3e0 	ldr	w0, [sp, #208]
    a0008678:	1400012d 	b	a0008b2c <cbvprintf+0x1458>
    a000867c:	f940a7e0 	ldr	x0, [sp, #328]
    a0008680:	91000400 	add	x0, x0, #0x1
    a0008684:	f900a7e0 	str	x0, [sp, #328]
		}

		if (IS_ENABLED(CONFIG_CBPRINTF_FP_SUPPORT) && conv->pad_fp) {
    a0008688:	f9408be0 	ldr	x0, [sp, #272]
    a000868c:	39400800 	ldrb	w0, [x0, #2]
    a0008690:	121a0000 	and	w0, w0, #0x40
    a0008694:	12001c00 	and	w0, w0, #0xff
    a0008698:	7100001f 	cmp	w0, #0x0
    a000869c:	540016c0 	b.eq	a0008974 <cbvprintf+0x12a0>  // b.none
			const char *cp = bps;
    a00086a0:	f9409fe0 	ldr	x0, [sp, #312]
    a00086a4:	f9008fe0 	str	x0, [sp, #280]

			if (conv->specifier_a) {
    a00086a8:	f9408be0 	ldr	x0, [sp, #272]
    a00086ac:	79400000 	ldrh	w0, [x0]
    a00086b0:	12114000 	and	w0, w0, #0xffff8000
    a00086b4:	12003c00 	and	w0, w0, #0xffff
    a00086b8:	7100001f 	cmp	w0, #0x0
    a00086bc:	540004e0 	b.eq	a0008758 <cbvprintf+0x1084>  // b.none
				/* Only padding is pre_exp */
				while (*cp != 'p') {
    a00086c0:	14000011 	b	a0008704 <cbvprintf+0x1030>
					OUTC(*cp++);
    a00086c4:	f9408fe0 	ldr	x0, [sp, #280]
    a00086c8:	91000401 	add	x1, x0, #0x1
    a00086cc:	f9008fe1 	str	x1, [sp, #280]
    a00086d0:	39400000 	ldrb	w0, [x0]
    a00086d4:	f9401fe2 	ldr	x2, [sp, #56]
    a00086d8:	f9401be1 	ldr	x1, [sp, #48]
    a00086dc:	d63f0040 	blr	x2
    a00086e0:	b900abe0 	str	w0, [sp, #168]
    a00086e4:	b940abe0 	ldr	w0, [sp, #168]
    a00086e8:	7100001f 	cmp	w0, #0x0
    a00086ec:	5400006a 	b.ge	a00086f8 <cbvprintf+0x1024>  // b.tcont
    a00086f0:	b940abe0 	ldr	w0, [sp, #168]
    a00086f4:	1400010e 	b	a0008b2c <cbvprintf+0x1458>
    a00086f8:	f940a7e0 	ldr	x0, [sp, #328]
    a00086fc:	91000400 	add	x0, x0, #0x1
    a0008700:	f900a7e0 	str	x0, [sp, #328]
				while (*cp != 'p') {
    a0008704:	f9408fe0 	ldr	x0, [sp, #280]
    a0008708:	39400000 	ldrb	w0, [x0]
    a000870c:	7101c01f 	cmp	w0, #0x70
    a0008710:	54fffda1 	b.ne	a00086c4 <cbvprintf+0xff0>  // b.any
    a0008714:	14000071 	b	a00088d8 <cbvprintf+0x1204>
				}
			} else {
				while (isdigit((int)*cp)) {
					OUTC(*cp++);
    a0008718:	f9408fe0 	ldr	x0, [sp, #280]
    a000871c:	91000401 	add	x1, x0, #0x1
    a0008720:	f9008fe1 	str	x1, [sp, #280]
    a0008724:	39400000 	ldrb	w0, [x0]
    a0008728:	f9401fe2 	ldr	x2, [sp, #56]
    a000872c:	f9401be1 	ldr	x1, [sp, #48]
    a0008730:	d63f0040 	blr	x2
    a0008734:	b900afe0 	str	w0, [sp, #172]
    a0008738:	b940afe0 	ldr	w0, [sp, #172]
    a000873c:	7100001f 	cmp	w0, #0x0
    a0008740:	5400006a 	b.ge	a000874c <cbvprintf+0x1078>  // b.tcont
    a0008744:	b940afe0 	ldr	w0, [sp, #172]
    a0008748:	140000f9 	b	a0008b2c <cbvprintf+0x1458>
    a000874c:	f940a7e0 	ldr	x0, [sp, #328]
    a0008750:	91000400 	add	x0, x0, #0x1
    a0008754:	f900a7e0 	str	x0, [sp, #328]
				while (isdigit((int)*cp)) {
    a0008758:	f9408fe0 	ldr	x0, [sp, #280]
    a000875c:	39400000 	ldrb	w0, [x0]
    a0008760:	97fff5e7 	bl	a0005efc <isdigit>
    a0008764:	7100001f 	cmp	w0, #0x0
    a0008768:	54fffd81 	b.ne	a0008718 <cbvprintf+0x1044>  // b.any
				}

				pad_len = conv->pad0_value;
    a000876c:	f9408be0 	ldr	x0, [sp, #272]
    a0008770:	b9400400 	ldr	w0, [x0, #4]
    a0008774:	b90127e0 	str	w0, [sp, #292]
				if (!conv->pad_postdp) {
    a0008778:	f9408be0 	ldr	x0, [sp, #272]
    a000877c:	b9400000 	ldr	w0, [x0]
    a0008780:	d3555400 	ubfx	x0, x0, #21, #1
    a0008784:	12001c00 	and	w0, w0, #0xff
    a0008788:	52000000 	eor	w0, w0, #0x1
    a000878c:	12001c00 	and	w0, w0, #0xff
    a0008790:	7100001f 	cmp	w0, #0x0
    a0008794:	54000280 	b.eq	a00087e4 <cbvprintf+0x1110>  // b.none
					while (pad_len-- > 0) {
    a0008798:	1400000e 	b	a00087d0 <cbvprintf+0x10fc>
						OUTC('0');
    a000879c:	f9401fe2 	ldr	x2, [sp, #56]
    a00087a0:	f9401be1 	ldr	x1, [sp, #48]
    a00087a4:	52800600 	mov	w0, #0x30                  	// #48
    a00087a8:	d63f0040 	blr	x2
    a00087ac:	b900bfe0 	str	w0, [sp, #188]
    a00087b0:	b940bfe0 	ldr	w0, [sp, #188]
    a00087b4:	7100001f 	cmp	w0, #0x0
    a00087b8:	5400006a 	b.ge	a00087c4 <cbvprintf+0x10f0>  // b.tcont
    a00087bc:	b940bfe0 	ldr	w0, [sp, #188]
    a00087c0:	140000db 	b	a0008b2c <cbvprintf+0x1458>
    a00087c4:	f940a7e0 	ldr	x0, [sp, #328]
    a00087c8:	91000400 	add	x0, x0, #0x1
    a00087cc:	f900a7e0 	str	x0, [sp, #328]
					while (pad_len-- > 0) {
    a00087d0:	b94127e0 	ldr	w0, [sp, #292]
    a00087d4:	51000401 	sub	w1, w0, #0x1
    a00087d8:	b90127e1 	str	w1, [sp, #292]
    a00087dc:	7100001f 	cmp	w0, #0x0
    a00087e0:	54fffdec 	b.gt	a000879c <cbvprintf+0x10c8>
					}
				}

				if (*cp == '.') {
    a00087e4:	f9408fe0 	ldr	x0, [sp, #280]
    a00087e8:	39400000 	ldrb	w0, [x0]
    a00087ec:	7100b81f 	cmp	w0, #0x2e
    a00087f0:	540006a1 	b.ne	a00088c4 <cbvprintf+0x11f0>  // b.any
					OUTC(*cp++);
    a00087f4:	f9408fe0 	ldr	x0, [sp, #280]
    a00087f8:	91000401 	add	x1, x0, #0x1
    a00087fc:	f9008fe1 	str	x1, [sp, #280]
    a0008800:	39400000 	ldrb	w0, [x0]
    a0008804:	f9401fe2 	ldr	x2, [sp, #56]
    a0008808:	f9401be1 	ldr	x1, [sp, #48]
    a000880c:	d63f0040 	blr	x2
    a0008810:	b900bbe0 	str	w0, [sp, #184]
    a0008814:	b940bbe0 	ldr	w0, [sp, #184]
    a0008818:	7100001f 	cmp	w0, #0x0
    a000881c:	5400006a 	b.ge	a0008828 <cbvprintf+0x1154>  // b.tcont
    a0008820:	b940bbe0 	ldr	w0, [sp, #184]
    a0008824:	140000c2 	b	a0008b2c <cbvprintf+0x1458>
    a0008828:	f940a7e0 	ldr	x0, [sp, #328]
    a000882c:	91000400 	add	x0, x0, #0x1
    a0008830:	f900a7e0 	str	x0, [sp, #328]
					/* Remaining padding is
					 * post-dp.
					 */
					while (pad_len-- > 0) {
    a0008834:	1400000e 	b	a000886c <cbvprintf+0x1198>
						OUTC('0');
    a0008838:	f9401fe2 	ldr	x2, [sp, #56]
    a000883c:	f9401be1 	ldr	x1, [sp, #48]
    a0008840:	52800600 	mov	w0, #0x30                  	// #48
    a0008844:	d63f0040 	blr	x2
    a0008848:	b900b7e0 	str	w0, [sp, #180]
    a000884c:	b940b7e0 	ldr	w0, [sp, #180]
    a0008850:	7100001f 	cmp	w0, #0x0
    a0008854:	5400006a 	b.ge	a0008860 <cbvprintf+0x118c>  // b.tcont
    a0008858:	b940b7e0 	ldr	w0, [sp, #180]
    a000885c:	140000b4 	b	a0008b2c <cbvprintf+0x1458>
    a0008860:	f940a7e0 	ldr	x0, [sp, #328]
    a0008864:	91000400 	add	x0, x0, #0x1
    a0008868:	f900a7e0 	str	x0, [sp, #328]
					while (pad_len-- > 0) {
    a000886c:	b94127e0 	ldr	w0, [sp, #292]
    a0008870:	51000401 	sub	w1, w0, #0x1
    a0008874:	b90127e1 	str	w1, [sp, #292]
    a0008878:	7100001f 	cmp	w0, #0x0
    a000887c:	54fffdec 	b.gt	a0008838 <cbvprintf+0x1164>
					}
				}
				while (isdigit((int)*cp)) {
    a0008880:	14000011 	b	a00088c4 <cbvprintf+0x11f0>
					OUTC(*cp++);
    a0008884:	f9408fe0 	ldr	x0, [sp, #280]
    a0008888:	91000401 	add	x1, x0, #0x1
    a000888c:	f9008fe1 	str	x1, [sp, #280]
    a0008890:	39400000 	ldrb	w0, [x0]
    a0008894:	f9401fe2 	ldr	x2, [sp, #56]
    a0008898:	f9401be1 	ldr	x1, [sp, #48]
    a000889c:	d63f0040 	blr	x2
    a00088a0:	b900b3e0 	str	w0, [sp, #176]
    a00088a4:	b940b3e0 	ldr	w0, [sp, #176]
    a00088a8:	7100001f 	cmp	w0, #0x0
    a00088ac:	5400006a 	b.ge	a00088b8 <cbvprintf+0x11e4>  // b.tcont
    a00088b0:	b940b3e0 	ldr	w0, [sp, #176]
    a00088b4:	1400009e 	b	a0008b2c <cbvprintf+0x1458>
    a00088b8:	f940a7e0 	ldr	x0, [sp, #328]
    a00088bc:	91000400 	add	x0, x0, #0x1
    a00088c0:	f900a7e0 	str	x0, [sp, #328]
				while (isdigit((int)*cp)) {
    a00088c4:	f9408fe0 	ldr	x0, [sp, #280]
    a00088c8:	39400000 	ldrb	w0, [x0]
    a00088cc:	97fff58c 	bl	a0005efc <isdigit>
    a00088d0:	7100001f 	cmp	w0, #0x0
    a00088d4:	54fffd81 	b.ne	a0008884 <cbvprintf+0x11b0>  // b.any
				}
			}

			pad_len = conv->pad0_pre_exp;
    a00088d8:	f9408be0 	ldr	x0, [sp, #272]
    a00088dc:	b9400800 	ldr	w0, [x0, #8]
    a00088e0:	b90127e0 	str	w0, [sp, #292]
			while (pad_len-- > 0) {
    a00088e4:	1400000e 	b	a000891c <cbvprintf+0x1248>
				OUTC('0');
    a00088e8:	f9401fe2 	ldr	x2, [sp, #56]
    a00088ec:	f9401be1 	ldr	x1, [sp, #48]
    a00088f0:	52800600 	mov	w0, #0x30                  	// #48
    a00088f4:	d63f0040 	blr	x2
    a00088f8:	b900a3e0 	str	w0, [sp, #160]
    a00088fc:	b940a3e0 	ldr	w0, [sp, #160]
    a0008900:	7100001f 	cmp	w0, #0x0
    a0008904:	5400006a 	b.ge	a0008910 <cbvprintf+0x123c>  // b.tcont
    a0008908:	b940a3e0 	ldr	w0, [sp, #160]
    a000890c:	14000088 	b	a0008b2c <cbvprintf+0x1458>
    a0008910:	f940a7e0 	ldr	x0, [sp, #328]
    a0008914:	91000400 	add	x0, x0, #0x1
    a0008918:	f900a7e0 	str	x0, [sp, #328]
			while (pad_len-- > 0) {
    a000891c:	b94127e0 	ldr	w0, [sp, #292]
    a0008920:	51000401 	sub	w1, w0, #0x1
    a0008924:	b90127e1 	str	w1, [sp, #292]
    a0008928:	7100001f 	cmp	w0, #0x0
    a000892c:	54fffdec 	b.gt	a00088e8 <cbvprintf+0x1214>
			}

			OUTS(cp, bpe);
    a0008930:	f9403be0 	ldr	x0, [sp, #112]
    a0008934:	aa0003e3 	mov	x3, x0
    a0008938:	f9408fe2 	ldr	x2, [sp, #280]
    a000893c:	f9401be1 	ldr	x1, [sp, #48]
    a0008940:	f9401fe0 	ldr	x0, [sp, #56]
    a0008944:	97fffb3e 	bl	a000763c <outs>
    a0008948:	b900a7e0 	str	w0, [sp, #164]
    a000894c:	b940a7e0 	ldr	w0, [sp, #164]
    a0008950:	7100001f 	cmp	w0, #0x0
    a0008954:	5400006a 	b.ge	a0008960 <cbvprintf+0x128c>  // b.tcont
    a0008958:	b940a7e0 	ldr	w0, [sp, #164]
    a000895c:	14000074 	b	a0008b2c <cbvprintf+0x1458>
    a0008960:	b980a7e0 	ldrsw	x0, [sp, #164]
    a0008964:	f940a7e1 	ldr	x1, [sp, #328]
    a0008968:	8b000020 	add	x0, x1, x0
    a000896c:	f900a7e0 	str	x0, [sp, #328]
    a0008970:	14000065 	b	a0008b04 <cbvprintf+0x1430>
		} else {
			if (conv->altform_0c | conv->altform_0) {
    a0008974:	f9408be0 	ldr	x0, [sp, #272]
    a0008978:	b9400000 	ldr	w0, [x0]
    a000897c:	d3545000 	ubfx	x0, x0, #20, #1
    a0008980:	12001c01 	and	w1, w0, #0xff
    a0008984:	f9408be0 	ldr	x0, [sp, #272]
    a0008988:	b9400000 	ldr	w0, [x0]
    a000898c:	d3534c00 	ubfx	x0, x0, #19, #1
    a0008990:	12001c00 	and	w0, w0, #0xff
    a0008994:	2a000020 	orr	w0, w1, w0
    a0008998:	12001c00 	and	w0, w0, #0xff
    a000899c:	7100001f 	cmp	w0, #0x0
    a00089a0:	540001c0 	b.eq	a00089d8 <cbvprintf+0x1304>  // b.none
				OUTC('0');
    a00089a4:	f9401fe2 	ldr	x2, [sp, #56]
    a00089a8:	f9401be1 	ldr	x1, [sp, #48]
    a00089ac:	52800600 	mov	w0, #0x30                  	// #48
    a00089b0:	d63f0040 	blr	x2
    a00089b4:	b900cfe0 	str	w0, [sp, #204]
    a00089b8:	b940cfe0 	ldr	w0, [sp, #204]
    a00089bc:	7100001f 	cmp	w0, #0x0
    a00089c0:	5400006a 	b.ge	a00089cc <cbvprintf+0x12f8>  // b.tcont
    a00089c4:	b940cfe0 	ldr	w0, [sp, #204]
    a00089c8:	14000059 	b	a0008b2c <cbvprintf+0x1458>
    a00089cc:	f940a7e0 	ldr	x0, [sp, #328]
    a00089d0:	91000400 	add	x0, x0, #0x1
    a00089d4:	f900a7e0 	str	x0, [sp, #328]
			}

			if (conv->altform_0c) {
    a00089d8:	f9408be0 	ldr	x0, [sp, #272]
    a00089dc:	39400800 	ldrb	w0, [x0, #2]
    a00089e0:	121c0000 	and	w0, w0, #0x10
    a00089e4:	12001c00 	and	w0, w0, #0xff
    a00089e8:	7100001f 	cmp	w0, #0x0
    a00089ec:	540001e0 	b.eq	a0008a28 <cbvprintf+0x1354>  // b.none
				OUTC(conv->specifier);
    a00089f0:	f9408be0 	ldr	x0, [sp, #272]
    a00089f4:	39400c00 	ldrb	w0, [x0, #3]
    a00089f8:	f9401fe2 	ldr	x2, [sp, #56]
    a00089fc:	f9401be1 	ldr	x1, [sp, #48]
    a0008a00:	d63f0040 	blr	x2
    a0008a04:	b900cbe0 	str	w0, [sp, #200]
    a0008a08:	b940cbe0 	ldr	w0, [sp, #200]
    a0008a0c:	7100001f 	cmp	w0, #0x0
    a0008a10:	5400006a 	b.ge	a0008a1c <cbvprintf+0x1348>  // b.tcont
    a0008a14:	b940cbe0 	ldr	w0, [sp, #200]
    a0008a18:	14000045 	b	a0008b2c <cbvprintf+0x1458>
    a0008a1c:	f940a7e0 	ldr	x0, [sp, #328]
    a0008a20:	91000400 	add	x0, x0, #0x1
    a0008a24:	f900a7e0 	str	x0, [sp, #328]
			}

			pad_len = conv->pad0_value;
    a0008a28:	f9408be0 	ldr	x0, [sp, #272]
    a0008a2c:	b9400400 	ldr	w0, [x0, #4]
    a0008a30:	b90127e0 	str	w0, [sp, #292]
			while (pad_len-- > 0) {
    a0008a34:	1400000e 	b	a0008a6c <cbvprintf+0x1398>
				OUTC('0');
    a0008a38:	f9401fe2 	ldr	x2, [sp, #56]
    a0008a3c:	f9401be1 	ldr	x1, [sp, #48]
    a0008a40:	52800600 	mov	w0, #0x30                  	// #48
    a0008a44:	d63f0040 	blr	x2
    a0008a48:	b900c3e0 	str	w0, [sp, #192]
    a0008a4c:	b940c3e0 	ldr	w0, [sp, #192]
    a0008a50:	7100001f 	cmp	w0, #0x0
    a0008a54:	5400006a 	b.ge	a0008a60 <cbvprintf+0x138c>  // b.tcont
    a0008a58:	b940c3e0 	ldr	w0, [sp, #192]
    a0008a5c:	14000034 	b	a0008b2c <cbvprintf+0x1458>
    a0008a60:	f940a7e0 	ldr	x0, [sp, #328]
    a0008a64:	91000400 	add	x0, x0, #0x1
    a0008a68:	f900a7e0 	str	x0, [sp, #328]
			while (pad_len-- > 0) {
    a0008a6c:	b94127e0 	ldr	w0, [sp, #292]
    a0008a70:	51000401 	sub	w1, w0, #0x1
    a0008a74:	b90127e1 	str	w1, [sp, #292]
    a0008a78:	7100001f 	cmp	w0, #0x0
    a0008a7c:	54fffdec 	b.gt	a0008a38 <cbvprintf+0x1364>
			}

			OUTS(bps, bpe);
    a0008a80:	f9403be0 	ldr	x0, [sp, #112]
    a0008a84:	aa0003e3 	mov	x3, x0
    a0008a88:	f9409fe2 	ldr	x2, [sp, #312]
    a0008a8c:	f9401be1 	ldr	x1, [sp, #48]
    a0008a90:	f9401fe0 	ldr	x0, [sp, #56]
    a0008a94:	97fffaea 	bl	a000763c <outs>
    a0008a98:	b900c7e0 	str	w0, [sp, #196]
    a0008a9c:	b940c7e0 	ldr	w0, [sp, #196]
    a0008aa0:	7100001f 	cmp	w0, #0x0
    a0008aa4:	5400006a 	b.ge	a0008ab0 <cbvprintf+0x13dc>  // b.tcont
    a0008aa8:	b940c7e0 	ldr	w0, [sp, #196]
    a0008aac:	14000020 	b	a0008b2c <cbvprintf+0x1458>
    a0008ab0:	b980c7e0 	ldrsw	x0, [sp, #196]
    a0008ab4:	f940a7e1 	ldr	x1, [sp, #328]
    a0008ab8:	8b000020 	add	x0, x1, x0
    a0008abc:	f900a7e0 	str	x0, [sp, #328]
		}

		/* Finish left justification */
		while (width > 0) {
    a0008ac0:	14000011 	b	a0008b04 <cbvprintf+0x1430>
			OUTC(' ');
    a0008ac4:	f9401fe2 	ldr	x2, [sp, #56]
    a0008ac8:	f9401be1 	ldr	x1, [sp, #48]
    a0008acc:	52800400 	mov	w0, #0x20                  	// #32
    a0008ad0:	d63f0040 	blr	x2
    a0008ad4:	b9009fe0 	str	w0, [sp, #156]
    a0008ad8:	b9409fe0 	ldr	w0, [sp, #156]
    a0008adc:	7100001f 	cmp	w0, #0x0
    a0008ae0:	5400006a 	b.ge	a0008aec <cbvprintf+0x1418>  // b.tcont
    a0008ae4:	b9409fe0 	ldr	w0, [sp, #156]
    a0008ae8:	14000011 	b	a0008b2c <cbvprintf+0x1458>
    a0008aec:	f940a7e0 	ldr	x0, [sp, #328]
    a0008af0:	91000400 	add	x0, x0, #0x1
    a0008af4:	f900a7e0 	str	x0, [sp, #328]
			--width;
    a0008af8:	b94147e0 	ldr	w0, [sp, #324]
    a0008afc:	51000400 	sub	w0, w0, #0x1
    a0008b00:	b90147e0 	str	w0, [sp, #324]
		while (width > 0) {
    a0008b04:	b94147e0 	ldr	w0, [sp, #324]
    a0008b08:	7100001f 	cmp	w0, #0x0
    a0008b0c:	54fffdcc 	b.gt	a0008ac4 <cbvprintf+0x13f0>
    a0008b10:	14000002 	b	a0008b18 <cbvprintf+0x1444>
			continue;
    a0008b14:	d503201f 	nop
	while (*fp != 0) {
    a0008b18:	f94017e0 	ldr	x0, [sp, #40]
    a0008b1c:	39400000 	ldrb	w0, [x0]
    a0008b20:	7100001f 	cmp	w0, #0x0
    a0008b24:	54ff5ea1 	b.ne	a00076f8 <cbvprintf+0x24>  // b.any
		}
	}

	return count;
    a0008b28:	f940a7e0 	ldr	x0, [sp, #328]
#undef OUTS
#undef OUTC
}
    a0008b2c:	f9400bf3 	ldr	x19, [sp, #16]
    a0008b30:	a8d57bfd 	ldp	x29, x30, [sp], #336
    a0008b34:	d65f03c0 	ret

00000000a0008b38 <arch_syscall_invoke2>:
{
    a0008b38:	d10083ff 	sub	sp, sp, #0x20
    a0008b3c:	f9000fe0 	str	x0, [sp, #24]
    a0008b40:	f9000be1 	str	x1, [sp, #16]
    a0008b44:	f90007e2 	str	x2, [sp, #8]
	register uint64_t ret __asm__("x0") = arg1;
    a0008b48:	f9400fe0 	ldr	x0, [sp, #24]
	register uint64_t r1 __asm__("x1") = arg2;
    a0008b4c:	f9400be1 	ldr	x1, [sp, #16]
	register uint64_t r8 __asm__("x8") = call_id;
    a0008b50:	f94007e8 	ldr	x8, [sp, #8]
	__asm__ volatile("svc %[svid]\n"
    a0008b54:	d4000061 	svc	#0x3
}
    a0008b58:	910083ff 	add	sp, sp, #0x20
    a0008b5c:	d65f03c0 	ret

00000000a0008b60 <arch_syscall_invoke1>:
{
    a0008b60:	d10043ff 	sub	sp, sp, #0x10
    a0008b64:	f90007e0 	str	x0, [sp, #8]
    a0008b68:	f90003e1 	str	x1, [sp]
	register uint64_t ret __asm__("x0") = arg1;
    a0008b6c:	f94007e0 	ldr	x0, [sp, #8]
	register uint64_t r8 __asm__("x8") = call_id;
    a0008b70:	f94003e8 	ldr	x8, [sp]
	__asm__ volatile("svc %[svid]\n"
    a0008b74:	d4000061 	svc	#0x3
}
    a0008b78:	910043ff 	add	sp, sp, #0x10
    a0008b7c:	d65f03c0 	ret

00000000a0008b80 <arch_is_user_context>:
{
    a0008b80:	d10043ff 	sub	sp, sp, #0x10
    a0008b84:	d53bd060 	mrs	x0, tpidrro_el0
    a0008b88:	f90007e0 	str	x0, [sp, #8]
    a0008b8c:	f94007e0 	ldr	x0, [sp, #8]
    a0008b90:	d503201f 	nop
	return (read_tpidrro_el0() & TPIDRROEL0_IN_EL0) != 0;
    a0008b94:	92400000 	and	x0, x0, #0x1
    a0008b98:	f100001f 	cmp	x0, #0x0
    a0008b9c:	1a9f07e0 	cset	w0, ne  // ne = any
    a0008ba0:	12001c00 	and	w0, w0, #0xff
}
    a0008ba4:	910043ff 	add	sp, sp, #0x10
    a0008ba8:	d65f03c0 	ret

00000000a0008bac <k_mutex_lock>:
{
    a0008bac:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0008bb0:	910003fd 	mov	x29, sp
    a0008bb4:	f9000fe0 	str	x0, [sp, #24]
    a0008bb8:	f9000be1 	str	x1, [sp, #16]
	bool ret = false;
    a0008bbc:	3900bfff 	strb	wzr, [sp, #47]
	ret = arch_is_user_context();
    a0008bc0:	97fffff0 	bl	a0008b80 <arch_is_user_context>
    a0008bc4:	3900bfe0 	strb	w0, [sp, #47]
	return ret;
    a0008bc8:	3940bfe0 	ldrb	w0, [sp, #47]
	if (z_syscall_trap()) {
    a0008bcc:	7100001f 	cmp	w0, #0x0
    a0008bd0:	54000140 	b.eq	a0008bf8 <k_mutex_lock+0x4c>  // b.none
		return (int) arch_syscall_invoke2(*(uintptr_t *)&mutex, *(uintptr_t *)&timeout, K_SYSCALL_K_MUTEX_LOCK);
    a0008bd4:	910063e0 	add	x0, sp, #0x18
    a0008bd8:	f9400003 	ldr	x3, [x0]
    a0008bdc:	910043e0 	add	x0, sp, #0x10
    a0008be0:	f9400000 	ldr	x0, [x0]
    a0008be4:	d28013a2 	mov	x2, #0x9d                  	// #157
    a0008be8:	aa0003e1 	mov	x1, x0
    a0008bec:	aa0303e0 	mov	x0, x3
    a0008bf0:	97ffffd2 	bl	a0008b38 <arch_syscall_invoke2>
    a0008bf4:	14000004 	b	a0008c04 <k_mutex_lock+0x58>
	return z_impl_k_mutex_lock(mutex, timeout);
    a0008bf8:	f9400fe0 	ldr	x0, [sp, #24]
    a0008bfc:	f9400be1 	ldr	x1, [sp, #16]
    a0008c00:	94002935 	bl	a00130d4 <z_impl_k_mutex_lock>
}
    a0008c04:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0008c08:	d65f03c0 	ret

00000000a0008c0c <k_mutex_unlock>:
{
    a0008c0c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0008c10:	910003fd 	mov	x29, sp
    a0008c14:	f9000fe0 	str	x0, [sp, #24]
	bool ret = false;
    a0008c18:	3900bfff 	strb	wzr, [sp, #47]
	ret = arch_is_user_context();
    a0008c1c:	97ffffd9 	bl	a0008b80 <arch_is_user_context>
    a0008c20:	3900bfe0 	strb	w0, [sp, #47]
	return ret;
    a0008c24:	3940bfe0 	ldrb	w0, [sp, #47]
	if (z_syscall_trap()) {
    a0008c28:	7100001f 	cmp	w0, #0x0
    a0008c2c:	540000c0 	b.eq	a0008c44 <k_mutex_unlock+0x38>  // b.none
		return (int) arch_syscall_invoke1(*(uintptr_t *)&mutex, K_SYSCALL_K_MUTEX_UNLOCK);
    a0008c30:	910063e0 	add	x0, sp, #0x18
    a0008c34:	f9400000 	ldr	x0, [x0]
    a0008c38:	d28013c1 	mov	x1, #0x9e                  	// #158
    a0008c3c:	97ffffc9 	bl	a0008b60 <arch_syscall_invoke1>
    a0008c40:	14000003 	b	a0008c4c <k_mutex_unlock+0x40>
	return z_impl_k_mutex_unlock(mutex);
    a0008c44:	f9400fe0 	ldr	x0, [sp, #24]
    a0008c48:	94002a31 	bl	a001350c <z_impl_k_mutex_unlock>
}
    a0008c4c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0008c50:	d65f03c0 	ret

00000000a0008c54 <get_k_mutex>:
#include <sys/mutex.h>
#include <syscall_handler.h>
#include <kernel_structs.h>

static struct k_mutex *get_k_mutex(struct sys_mutex *mutex)
{
    a0008c54:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0008c58:	910003fd 	mov	x29, sp
    a0008c5c:	f9000fe0 	str	x0, [sp, #24]
	struct z_object *obj;

	obj = z_object_find(mutex);
    a0008c60:	f9400fe0 	ldr	x0, [sp, #24]
    a0008c64:	94004f71 	bl	a001ca28 <z_object_find>
    a0008c68:	f90017e0 	str	x0, [sp, #40]
	if (obj == NULL || obj->type != K_OBJ_SYS_MUTEX) {
    a0008c6c:	f94017e0 	ldr	x0, [sp, #40]
    a0008c70:	f100001f 	cmp	x0, #0x0
    a0008c74:	540000a0 	b.eq	a0008c88 <get_k_mutex+0x34>  // b.none
    a0008c78:	f94017e0 	ldr	x0, [sp, #40]
    a0008c7c:	39402800 	ldrb	w0, [x0, #10]
    a0008c80:	7100381f 	cmp	w0, #0xe
    a0008c84:	54000060 	b.eq	a0008c90 <get_k_mutex+0x3c>  // b.none
		return NULL;
    a0008c88:	d2800000 	mov	x0, #0x0                   	// #0
    a0008c8c:	14000003 	b	a0008c98 <get_k_mutex+0x44>
	}

	return obj->data.mutex;
    a0008c90:	f94017e0 	ldr	x0, [sp, #40]
    a0008c94:	f840c000 	ldur	x0, [x0, #12]
}
    a0008c98:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0008c9c:	d65f03c0 	ret

00000000a0008ca0 <check_sys_mutex_addr>:

static bool check_sys_mutex_addr(struct sys_mutex *addr)
{
    a0008ca0:	a9a17bfd 	stp	x29, x30, [sp, #-496]!
    a0008ca4:	910003fd 	mov	x29, sp
    a0008ca8:	f9000fe0 	str	x0, [sp, #24]
	/* sys_mutex memory is never touched, just used to lookup the
	 * underlying k_mutex, but we don't want threads using mutexes
	 * that are outside their memory domain
	 */
	return Z_SYSCALL_MEMORY_WRITE(addr, sizeof(struct sys_mutex));
    a0008cac:	52800022 	mov	w2, #0x1                   	// #1
    a0008cb0:	d2800101 	mov	x1, #0x8                   	// #8
    a0008cb4:	f9400fe0 	ldr	x0, [sp, #24]
    a0008cb8:	94000aed 	bl	a000b86c <arch_buffer_validate>
    a0008cbc:	7100001f 	cmp	w0, #0x0
    a0008cc0:	1a9f07e0 	cset	w0, ne  // ne = any
    a0008cc4:	3907bfe0 	strb	w0, [sp, #495]
    a0008cc8:	3947bfe0 	ldrb	w0, [sp, #495]
    a0008ccc:	7100001f 	cmp	w0, #0x0
    a0008cd0:	3947bfe0 	ldrb	w0, [sp, #495]
}
    a0008cd4:	a8df7bfd 	ldp	x29, x30, [sp], #496
    a0008cd8:	d65f03c0 	ret

00000000a0008cdc <z_impl_z_sys_mutex_kernel_lock>:

int z_impl_z_sys_mutex_kernel_lock(struct sys_mutex *mutex, k_timeout_t timeout)
{
    a0008cdc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0008ce0:	910003fd 	mov	x29, sp
    a0008ce4:	f9000fe0 	str	x0, [sp, #24]
    a0008ce8:	f9000be1 	str	x1, [sp, #16]
	struct k_mutex *kernel_mutex = get_k_mutex(mutex);
    a0008cec:	f9400fe0 	ldr	x0, [sp, #24]
    a0008cf0:	97ffffd9 	bl	a0008c54 <get_k_mutex>
    a0008cf4:	f90017e0 	str	x0, [sp, #40]

	if (kernel_mutex == NULL) {
    a0008cf8:	f94017e0 	ldr	x0, [sp, #40]
    a0008cfc:	f100001f 	cmp	x0, #0x0
    a0008d00:	54000061 	b.ne	a0008d0c <z_impl_z_sys_mutex_kernel_lock+0x30>  // b.any
		return -EINVAL;
    a0008d04:	128002a0 	mov	w0, #0xffffffea            	// #-22
    a0008d08:	14000004 	b	a0008d18 <z_impl_z_sys_mutex_kernel_lock+0x3c>
	}

	return k_mutex_lock(kernel_mutex, timeout);
    a0008d0c:	f9400be1 	ldr	x1, [sp, #16]
    a0008d10:	f94017e0 	ldr	x0, [sp, #40]
    a0008d14:	97ffffa6 	bl	a0008bac <k_mutex_lock>
}
    a0008d18:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0008d1c:	d65f03c0 	ret

00000000a0008d20 <z_vrfy_z_sys_mutex_kernel_lock>:

static inline int z_vrfy_z_sys_mutex_kernel_lock(struct sys_mutex *mutex,
						 k_timeout_t timeout)
{
    a0008d20:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0008d24:	910003fd 	mov	x29, sp
    a0008d28:	f9000fe0 	str	x0, [sp, #24]
    a0008d2c:	f9000be1 	str	x1, [sp, #16]
	if (check_sys_mutex_addr(mutex)) {
    a0008d30:	f9400fe0 	ldr	x0, [sp, #24]
    a0008d34:	97ffffdb 	bl	a0008ca0 <check_sys_mutex_addr>
    a0008d38:	12001c00 	and	w0, w0, #0xff
    a0008d3c:	7100001f 	cmp	w0, #0x0
    a0008d40:	54000060 	b.eq	a0008d4c <z_vrfy_z_sys_mutex_kernel_lock+0x2c>  // b.none
		return -EACCES;
    a0008d44:	12800180 	mov	w0, #0xfffffff3            	// #-13
    a0008d48:	14000004 	b	a0008d58 <z_vrfy_z_sys_mutex_kernel_lock+0x38>
	}

	return z_impl_z_sys_mutex_kernel_lock(mutex, timeout);
    a0008d4c:	f9400be1 	ldr	x1, [sp, #16]
    a0008d50:	f9400fe0 	ldr	x0, [sp, #24]
    a0008d54:	97ffffe2 	bl	a0008cdc <z_impl_z_sys_mutex_kernel_lock>
}
    a0008d58:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0008d5c:	d65f03c0 	ret

00000000a0008d60 <z_mrsh_z_sys_mutex_kernel_lock>:
#include <syscalls/mutex.h>

extern int z_vrfy_z_sys_mutex_kernel_lock(struct sys_mutex * mutex, k_timeout_t timeout);
uintptr_t z_mrsh_z_sys_mutex_kernel_lock(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a0008d60:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a0008d64:	910003fd 	mov	x29, sp
    a0008d68:	f90027e0 	str	x0, [sp, #72]
    a0008d6c:	f90023e1 	str	x1, [sp, #64]
    a0008d70:	f9001fe2 	str	x2, [sp, #56]
    a0008d74:	f9001be3 	str	x3, [sp, #48]
    a0008d78:	f90017e4 	str	x4, [sp, #40]
    a0008d7c:	f90013e5 	str	x5, [sp, #32]
    a0008d80:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a0008d84:	f00001e0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0008d88:	913f8000 	add	x0, x0, #0xfe0
    a0008d8c:	f9400800 	ldr	x0, [x0, #16]
    a0008d90:	f9400fe1 	ldr	x1, [sp, #24]
    a0008d94:	f9008401 	str	x1, [x0, #264]
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_z_sys_mutex_kernel_lock(*(struct sys_mutex **)&arg0, *(k_timeout_t*)&arg1)
    a0008d98:	910123e0 	add	x0, sp, #0x48
    a0008d9c:	f9400002 	ldr	x2, [x0]
    a0008da0:	910103e0 	add	x0, sp, #0x40
    a0008da4:	f9400001 	ldr	x1, [x0]
    a0008da8:	aa0203e0 	mov	x0, x2
    a0008dac:	97ffffdd 	bl	a0008d20 <z_vrfy_z_sys_mutex_kernel_lock>
    a0008db0:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a0008db4:	f00001e0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0008db8:	913f8000 	add	x0, x0, #0xfe0
    a0008dbc:	f9400800 	ldr	x0, [x0, #16]
    a0008dc0:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a0008dc4:	b9805fe0 	ldrsw	x0, [sp, #92]
}
    a0008dc8:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a0008dcc:	d65f03c0 	ret

00000000a0008dd0 <z_impl_z_sys_mutex_kernel_unlock>:
#include <syscalls/z_sys_mutex_kernel_lock_mrsh.c>

int z_impl_z_sys_mutex_kernel_unlock(struct sys_mutex *mutex)
{
    a0008dd0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0008dd4:	910003fd 	mov	x29, sp
    a0008dd8:	f9000fe0 	str	x0, [sp, #24]
	struct k_mutex *kernel_mutex = get_k_mutex(mutex);
    a0008ddc:	f9400fe0 	ldr	x0, [sp, #24]
    a0008de0:	97ffff9d 	bl	a0008c54 <get_k_mutex>
    a0008de4:	f90017e0 	str	x0, [sp, #40]

	if (kernel_mutex == NULL || kernel_mutex->lock_count == 0) {
    a0008de8:	f94017e0 	ldr	x0, [sp, #40]
    a0008dec:	f100001f 	cmp	x0, #0x0
    a0008df0:	540000a0 	b.eq	a0008e04 <z_impl_z_sys_mutex_kernel_unlock+0x34>  // b.none
    a0008df4:	f94017e0 	ldr	x0, [sp, #40]
    a0008df8:	b9401800 	ldr	w0, [x0, #24]
    a0008dfc:	7100001f 	cmp	w0, #0x0
    a0008e00:	54000061 	b.ne	a0008e0c <z_impl_z_sys_mutex_kernel_unlock+0x3c>  // b.any
		return -EINVAL;
    a0008e04:	128002a0 	mov	w0, #0xffffffea            	// #-22
    a0008e08:	14000003 	b	a0008e14 <z_impl_z_sys_mutex_kernel_unlock+0x44>
	}

	return k_mutex_unlock(kernel_mutex);
    a0008e0c:	f94017e0 	ldr	x0, [sp, #40]
    a0008e10:	97ffff7f 	bl	a0008c0c <k_mutex_unlock>
}
    a0008e14:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0008e18:	d65f03c0 	ret

00000000a0008e1c <z_vrfy_z_sys_mutex_kernel_unlock>:

static inline int z_vrfy_z_sys_mutex_kernel_unlock(struct sys_mutex *mutex)
{
    a0008e1c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0008e20:	910003fd 	mov	x29, sp
    a0008e24:	f9000fe0 	str	x0, [sp, #24]
	if (check_sys_mutex_addr(mutex)) {
    a0008e28:	f9400fe0 	ldr	x0, [sp, #24]
    a0008e2c:	97ffff9d 	bl	a0008ca0 <check_sys_mutex_addr>
    a0008e30:	12001c00 	and	w0, w0, #0xff
    a0008e34:	7100001f 	cmp	w0, #0x0
    a0008e38:	54000060 	b.eq	a0008e44 <z_vrfy_z_sys_mutex_kernel_unlock+0x28>  // b.none
		return -EACCES;
    a0008e3c:	12800180 	mov	w0, #0xfffffff3            	// #-13
    a0008e40:	14000003 	b	a0008e4c <z_vrfy_z_sys_mutex_kernel_unlock+0x30>
	}

	return z_impl_z_sys_mutex_kernel_unlock(mutex);
    a0008e44:	f9400fe0 	ldr	x0, [sp, #24]
    a0008e48:	97ffffe2 	bl	a0008dd0 <z_impl_z_sys_mutex_kernel_unlock>
}
    a0008e4c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0008e50:	d65f03c0 	ret

00000000a0008e54 <z_mrsh_z_sys_mutex_kernel_unlock>:
#include <syscalls/mutex.h>

extern int z_vrfy_z_sys_mutex_kernel_unlock(struct sys_mutex * mutex);
uintptr_t z_mrsh_z_sys_mutex_kernel_unlock(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a0008e54:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a0008e58:	910003fd 	mov	x29, sp
    a0008e5c:	f90027e0 	str	x0, [sp, #72]
    a0008e60:	f90023e1 	str	x1, [sp, #64]
    a0008e64:	f9001fe2 	str	x2, [sp, #56]
    a0008e68:	f9001be3 	str	x3, [sp, #48]
    a0008e6c:	f90017e4 	str	x4, [sp, #40]
    a0008e70:	f90013e5 	str	x5, [sp, #32]
    a0008e74:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a0008e78:	f00001e0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0008e7c:	913f8000 	add	x0, x0, #0xfe0
    a0008e80:	f9400800 	ldr	x0, [x0, #16]
    a0008e84:	f9400fe1 	ldr	x1, [sp, #24]
    a0008e88:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_z_sys_mutex_kernel_unlock(*(struct sys_mutex **)&arg0)
    a0008e8c:	910123e0 	add	x0, sp, #0x48
    a0008e90:	f9400000 	ldr	x0, [x0]
    a0008e94:	97ffffe2 	bl	a0008e1c <z_vrfy_z_sys_mutex_kernel_unlock>
    a0008e98:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a0008e9c:	f00001e0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0008ea0:	913f8000 	add	x0, x0, #0xfe0
    a0008ea4:	f9400800 	ldr	x0, [x0, #16]
    a0008ea8:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a0008eac:	b9805fe0 	ldrsw	x0, [sp, #92]
}
    a0008eb0:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a0008eb4:	d65f03c0 	ret

00000000a0008eb8 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_STAT, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
    a0008eb8:	d503201f 	nop
    a0008ebc:	d65f03c0 	ret

00000000a0008ec0 <z_arm64_el3_plat_init>:
#include <toolchain.h>
#include <linker/sections.h>
#include <arch/cpu.h>

void z_arm64_el3_plat_init(void)
{
    a0008ec0:	d10043ff 	sub	sp, sp, #0x10
	uint64_t reg = 0;
    a0008ec4:	f90007ff 	str	xzr, [sp, #8]

	reg = (ICC_SRE_ELx_DFB_BIT | ICC_SRE_ELx_DIB_BIT |
    a0008ec8:	d28001e0 	mov	x0, #0xf                   	// #15
    a0008ecc:	f90007e0 	str	x0, [sp, #8]
	       ICC_SRE_ELx_SRE_BIT | ICC_SRE_EL3_EN_BIT);

	write_sysreg(reg, ICC_SRE_EL3);
    a0008ed0:	f94007e0 	ldr	x0, [sp, #8]
    a0008ed4:	d51ecca0 	msr	s3_6_c12_c12_5, x0
}
    a0008ed8:	d503201f 	nop
    a0008edc:	910043ff 	add	sp, sp, #0x10
    a0008ee0:	d65f03c0 	ret

00000000a0008ee4 <arch_cpu_idle>:
#ifdef CONFIG_TRACING
	stp	xzr, x30, [sp, #-16]!
	bl	sys_trace_idle
	ldp	xzr, x30, [sp], #16
#endif
	dsb	sy
    a0008ee4:	d5033f9f 	dsb	sy
	wfi
    a0008ee8:	d503207f 	wfi
	msr	daifclr, #(DAIFCLR_IRQ_BIT)
    a0008eec:	d50342ff 	msr	daifclr, #0x2
	ret
    a0008ef0:	d65f03c0 	ret

00000000a0008ef4 <is_recoverable>:
}
#endif /* CONFIG_EXCEPTION_DEBUG */

static bool is_recoverable(z_arch_esf_t *esf, uint64_t esr, uint64_t far,
			   uint64_t elr)
{
    a0008ef4:	d10103ff 	sub	sp, sp, #0x40
    a0008ef8:	f9000fe0 	str	x0, [sp, #24]
    a0008efc:	f9000be1 	str	x1, [sp, #16]
    a0008f00:	f90007e2 	str	x2, [sp, #8]
    a0008f04:	f90003e3 	str	x3, [sp]
	if (!esf)
    a0008f08:	f9400fe0 	ldr	x0, [sp, #24]
    a0008f0c:	f100001f 	cmp	x0, #0x0
    a0008f10:	54000061 	b.ne	a0008f1c <is_recoverable+0x28>  // b.any
		return false;
    a0008f14:	52800000 	mov	w0, #0x0                   	// #0
    a0008f18:	1400002b 	b	a0008fc4 <is_recoverable+0xd0>

#ifdef CONFIG_USERSPACE
	for (int i = 0; i < ARRAY_SIZE(exceptions); i++) {
    a0008f1c:	b9003fff 	str	wzr, [sp, #60]
    a0008f20:	14000025 	b	a0008fb4 <is_recoverable+0xc0>
		/* Mask out instruction mode */
		uint64_t start = (uint64_t)exceptions[i].start;
    a0008f24:	900000e0 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a0008f28:	9117e001 	add	x1, x0, #0x5f8
    a0008f2c:	b9803fe2 	ldrsw	x2, [sp, #60]
    a0008f30:	d2800300 	mov	x0, #0x18                  	// #24
    a0008f34:	9b007c40 	mul	x0, x2, x0
    a0008f38:	8b000020 	add	x0, x1, x0
    a0008f3c:	f9400000 	ldr	x0, [x0]
    a0008f40:	f9001be0 	str	x0, [sp, #48]
		uint64_t end = (uint64_t)exceptions[i].end;
    a0008f44:	900000e0 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a0008f48:	9117e001 	add	x1, x0, #0x5f8
    a0008f4c:	b9803fe2 	ldrsw	x2, [sp, #60]
    a0008f50:	d2800300 	mov	x0, #0x18                  	// #24
    a0008f54:	9b007c40 	mul	x0, x2, x0
    a0008f58:	8b000020 	add	x0, x1, x0
    a0008f5c:	f9400400 	ldr	x0, [x0, #8]
    a0008f60:	f90017e0 	str	x0, [sp, #40]

		if (esf->elr >= start && esf->elr < end) {
    a0008f64:	f9400fe0 	ldr	x0, [sp, #24]
    a0008f68:	f9405400 	ldr	x0, [x0, #168]
    a0008f6c:	f9401be1 	ldr	x1, [sp, #48]
    a0008f70:	eb00003f 	cmp	x1, x0
    a0008f74:	540001a8 	b.hi	a0008fa8 <is_recoverable+0xb4>  // b.pmore
    a0008f78:	f9400fe0 	ldr	x0, [sp, #24]
    a0008f7c:	f9405400 	ldr	x0, [x0, #168]
    a0008f80:	f94017e1 	ldr	x1, [sp, #40]
    a0008f84:	eb00003f 	cmp	x1, x0
    a0008f88:	54000109 	b.ls	a0008fa8 <is_recoverable+0xb4>  // b.plast
			esf->elr = (uint64_t)(exceptions[i].fixup);
    a0008f8c:	f0000000 	adrp	x0, a000b000 <setup_page_tables+0x4c>
    a0008f90:	91217000 	add	x0, x0, #0x85c
    a0008f94:	aa0003e1 	mov	x1, x0
    a0008f98:	f9400fe0 	ldr	x0, [sp, #24]
    a0008f9c:	f9005401 	str	x1, [x0, #168]
			return true;
    a0008fa0:	52800020 	mov	w0, #0x1                   	// #1
    a0008fa4:	14000008 	b	a0008fc4 <is_recoverable+0xd0>
	for (int i = 0; i < ARRAY_SIZE(exceptions); i++) {
    a0008fa8:	b9403fe0 	ldr	w0, [sp, #60]
    a0008fac:	11000400 	add	w0, w0, #0x1
    a0008fb0:	b9003fe0 	str	w0, [sp, #60]
    a0008fb4:	b9403fe0 	ldr	w0, [sp, #60]
    a0008fb8:	7100001f 	cmp	w0, #0x0
    a0008fbc:	54fffb4d 	b.le	a0008f24 <is_recoverable+0x30>
		}
	}
#endif

	return false;
    a0008fc0:	52800000 	mov	w0, #0x0                   	// #0
}
    a0008fc4:	910103ff 	add	sp, sp, #0x40
    a0008fc8:	d65f03c0 	ret

00000000a0008fcc <z_arm64_fatal_error>:

void z_arm64_fatal_error(unsigned int reason, z_arch_esf_t *esf)
{
    a0008fcc:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
    a0008fd0:	910003fd 	mov	x29, sp
    a0008fd4:	b9001fe0 	str	w0, [sp, #28]
    a0008fd8:	f9000be1 	str	x1, [sp, #16]
	uint64_t esr = 0;
    a0008fdc:	f9003fff 	str	xzr, [sp, #120]
	uint64_t elr = 0;
    a0008fe0:	f9003bff 	str	xzr, [sp, #112]
	uint64_t far = 0;
    a0008fe4:	f90037ff 	str	xzr, [sp, #104]
	uint64_t el;

	if (reason != K_ERR_SPURIOUS_IRQ) {
    a0008fe8:	b9401fe0 	ldr	w0, [sp, #28]
    a0008fec:	7100041f 	cmp	w0, #0x1
    a0008ff0:	54000760 	b.eq	a00090dc <z_arm64_fatal_error+0x110>  // b.none
MAKE_REG_HELPER(currentel);
    a0008ff4:	d5384240 	mrs	x0, currentel
    a0008ff8:	f9002fe0 	str	x0, [sp, #88]
    a0008ffc:	f9402fe0 	ldr	x0, [sp, #88]
    a0009000:	d503201f 	nop
		el = read_currentel();
    a0009004:	f90033e0 	str	x0, [sp, #96]

		switch (GET_EL(el)) {
    a0009008:	f94033e0 	ldr	x0, [sp, #96]
    a000900c:	d342fc00 	lsr	x0, x0, #2
    a0009010:	92400400 	and	x0, x0, #0x3
    a0009014:	f100041f 	cmp	x0, #0x1
    a0009018:	54000080 	b.eq	a0009028 <z_arm64_fatal_error+0x5c>  // b.none
    a000901c:	f1000c1f 	cmp	x0, #0x3
    a0009020:	54000240 	b.eq	a0009068 <z_arm64_fatal_error+0x9c>  // b.none
    a0009024:	14000021 	b	a00090a8 <z_arm64_fatal_error+0xdc>

MAKE_REG_HELPER_EL123(actlr)
MAKE_REG_HELPER_EL123(cpacr)
MAKE_REG_HELPER_EL123(cptr)
MAKE_REG_HELPER_EL123(elr)
MAKE_REG_HELPER_EL123(esr)
    a0009028:	d5385200 	mrs	x0, esr_el1
    a000902c:	f90023e0 	str	x0, [sp, #64]
    a0009030:	f94023e0 	ldr	x0, [sp, #64]
    a0009034:	d503201f 	nop
		case MODE_EL1:
			esr = read_esr_el1();
    a0009038:	f9003fe0 	str	x0, [sp, #120]
MAKE_REG_HELPER_EL123(far)
    a000903c:	d5386000 	mrs	x0, far_el1
    a0009040:	f90027e0 	str	x0, [sp, #72]
    a0009044:	f94027e0 	ldr	x0, [sp, #72]
    a0009048:	d503201f 	nop
			far = read_far_el1();
    a000904c:	f90037e0 	str	x0, [sp, #104]
MAKE_REG_HELPER_EL123(elr)
    a0009050:	d5384020 	mrs	x0, elr_el1
    a0009054:	f9002be0 	str	x0, [sp, #80]
    a0009058:	f9402be0 	ldr	x0, [sp, #80]
    a000905c:	d503201f 	nop
			elr = read_elr_el1();
    a0009060:	f9003be0 	str	x0, [sp, #112]
			break;
    a0009064:	14000011 	b	a00090a8 <z_arm64_fatal_error+0xdc>
MAKE_REG_HELPER_EL123(esr)
    a0009068:	d53e5200 	mrs	x0, esr_el3
    a000906c:	f90017e0 	str	x0, [sp, #40]
    a0009070:	f94017e0 	ldr	x0, [sp, #40]
    a0009074:	d503201f 	nop
		case MODE_EL3:
			esr = read_esr_el3();
    a0009078:	f9003fe0 	str	x0, [sp, #120]
MAKE_REG_HELPER_EL123(far)
    a000907c:	d53e6000 	mrs	x0, far_el3
    a0009080:	f9001be0 	str	x0, [sp, #48]
    a0009084:	f9401be0 	ldr	x0, [sp, #48]
    a0009088:	d503201f 	nop
			far = read_far_el3();
    a000908c:	f90037e0 	str	x0, [sp, #104]
MAKE_REG_HELPER_EL123(elr)
    a0009090:	d53e4020 	mrs	x0, elr_el3
    a0009094:	f9001fe0 	str	x0, [sp, #56]
    a0009098:	f9401fe0 	ldr	x0, [sp, #56]
    a000909c:	d503201f 	nop
			elr = read_elr_el3();
    a00090a0:	f9003be0 	str	x0, [sp, #112]
			break;
    a00090a4:	d503201f 	nop
		}

		if (GET_EL(el) != MODE_EL0) {
    a00090a8:	f94033e0 	ldr	x0, [sp, #96]
    a00090ac:	d342fc00 	lsr	x0, x0, #2
    a00090b0:	92400400 	and	x0, x0, #0x3
    a00090b4:	f100001f 	cmp	x0, #0x0
    a00090b8:	54000120 	b.eq	a00090dc <z_arm64_fatal_error+0x110>  // b.none
				LOG_ERR("FAR_ELn: 0x%016llx", far);

			LOG_ERR("TPIDRRO: 0x%016llx", read_tpidrro_el0());
#endif /* CONFIG_EXCEPTION_DEBUG */

			if (is_recoverable(esf, esr, far, elr))
    a00090bc:	f9403be3 	ldr	x3, [sp, #112]
    a00090c0:	f94037e2 	ldr	x2, [sp, #104]
    a00090c4:	f9403fe1 	ldr	x1, [sp, #120]
    a00090c8:	f9400be0 	ldr	x0, [sp, #16]
    a00090cc:	97ffff8a 	bl	a0008ef4 <is_recoverable>
    a00090d0:	12001c00 	and	w0, w0, #0xff
    a00090d4:	7100001f 	cmp	w0, #0x0
    a00090d8:	54000081 	b.ne	a00090e8 <z_arm64_fatal_error+0x11c>  // b.any
	if (esf != NULL) {
		esf_dump(esf);
	}
#endif /* CONFIG_EXCEPTION_DEBUG */

	z_fatal_error(reason, esf);
    a00090dc:	f9400be1 	ldr	x1, [sp, #16]
    a00090e0:	b9401fe0 	ldr	w0, [sp, #28]
    a00090e4:	94001f78 	bl	a0010ec4 <z_fatal_error>
				return;
    a00090e8:	d503201f 	nop

	CODE_UNREACHABLE;
}
    a00090ec:	a8c87bfd 	ldp	x29, x30, [sp], #128
    a00090f0:	d65f03c0 	ret

00000000a00090f4 <z_arm64_do_kernel_oops>:
 * (e.g. kernel oops, panic, etc.).
 *
 * @param esf exception frame
 */
void z_arm64_do_kernel_oops(z_arch_esf_t *esf)
{
    a00090f4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a00090f8:	910003fd 	mov	x29, sp
    a00090fc:	f9000fe0 	str	x0, [sp, #24]
	/* x8 holds the exception reason */
	unsigned int reason = esf->x8;
    a0009100:	f9400fe0 	ldr	x0, [sp, #24]
    a0009104:	f9402000 	ldr	x0, [x0, #64]
    a0009108:	b9002fe0 	str	w0, [sp, #44]
#if defined(CONFIG_USERSPACE)
	/*
	 * User mode is only allowed to induce oopses and stack check
	 * failures via software-triggered system fatal exceptions.
	 */
	if (((_current->base.user_options & K_USER) != 0) &&
    a000910c:	d00001e0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0009110:	913f8000 	add	x0, x0, #0xfe0
    a0009114:	f9400800 	ldr	x0, [x0, #16]
    a0009118:	39406000 	ldrb	w0, [x0, #24]
    a000911c:	92401c00 	and	x0, x0, #0xff
    a0009120:	927e0000 	and	x0, x0, #0x4
    a0009124:	f100001f 	cmp	x0, #0x0
    a0009128:	540000c0 	b.eq	a0009140 <z_arm64_do_kernel_oops+0x4c>  // b.none
    a000912c:	b9402fe0 	ldr	w0, [sp, #44]
    a0009130:	7100081f 	cmp	w0, #0x2
    a0009134:	54000060 	b.eq	a0009140 <z_arm64_do_kernel_oops+0x4c>  // b.none
		reason != K_ERR_STACK_CHK_FAIL) {
		reason = K_ERR_KERNEL_OOPS;
    a0009138:	52800060 	mov	w0, #0x3                   	// #3
    a000913c:	b9002fe0 	str	w0, [sp, #44]
	}
#endif

	z_arm64_fatal_error(reason, esf);
    a0009140:	f9400fe1 	ldr	x1, [sp, #24]
    a0009144:	b9402fe0 	ldr	w0, [sp, #44]
    a0009148:	97ffffa1 	bl	a0008fcc <z_arm64_fatal_error>
}
    a000914c:	d503201f 	nop
    a0009150:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0009154:	d65f03c0 	ret

00000000a0009158 <arch_syscall_oops>:

#ifdef CONFIG_USERSPACE
FUNC_NORETURN void arch_syscall_oops(void *ssf_ptr)
{
    a0009158:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a000915c:	910003fd 	mov	x29, sp
    a0009160:	f9000fe0 	str	x0, [sp, #24]
	z_arm64_fatal_error(K_ERR_KERNEL_OOPS, ssf_ptr);
    a0009164:	f9400fe1 	ldr	x1, [sp, #24]
    a0009168:	52800060 	mov	w0, #0x3                   	// #3
    a000916c:	97ffff98 	bl	a0008fcc <z_arm64_fatal_error>

00000000a0009170 <z_arm64_interrupt_init>:
{
#ifdef CONFIG_ARM_CUSTOM_INTERRUPT_CONTROLLER
	/* Invoke SoC-specific interrupt controller initialisation */
	z_soc_irq_init();
#endif
}
    a0009170:	d503201f 	nop
    a0009174:	d65f03c0 	ret

00000000a0009178 <arch_irq_enable>:
 * interrupt control functions are mapped to the SoC layer in
 * `include/arch/arm64/irq.h`.
 */

void arch_irq_enable(unsigned int irq)
{
    a0009178:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a000917c:	910003fd 	mov	x29, sp
    a0009180:	b9001fe0 	str	w0, [sp, #28]
	arm_gic_irq_enable(irq);
    a0009184:	b9401fe0 	ldr	w0, [sp, #28]
    a0009188:	94001048 	bl	a000d2a8 <arm_gic_irq_enable>
}
    a000918c:	d503201f 	nop
    a0009190:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0009194:	d65f03c0 	ret

00000000a0009198 <z_arm64_irq_priority_set>:
{
	return arm_gic_irq_is_enabled(irq);
}

void z_arm64_irq_priority_set(unsigned int irq, unsigned int prio, uint32_t flags)
{
    a0009198:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a000919c:	910003fd 	mov	x29, sp
    a00091a0:	b9001fe0 	str	w0, [sp, #28]
    a00091a4:	b9001be1 	str	w1, [sp, #24]
    a00091a8:	b90017e2 	str	w2, [sp, #20]
	arm_gic_irq_set_priority(irq, prio, flags);
    a00091ac:	b94017e2 	ldr	w2, [sp, #20]
    a00091b0:	b9401be1 	ldr	w1, [sp, #24]
    a00091b4:	b9401fe0 	ldr	w0, [sp, #28]
    a00091b8:	94000fcf 	bl	a000d0f4 <arm_gic_irq_set_priority>
}
    a00091bc:	d503201f 	nop
    a00091c0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a00091c4:	d65f03c0 	ret

00000000a00091c8 <z_irq_spurious>:
	return irq;
}
#endif

void z_irq_spurious(const void *unused)
{
    a00091c8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a00091cc:	910003fd 	mov	x29, sp
    a00091d0:	f9000fe0 	str	x0, [sp, #24]
	ARG_UNUSED(unused);

	z_arm64_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
    a00091d4:	d2800001 	mov	x1, #0x0                   	// #0
    a00091d8:	52800020 	mov	w0, #0x1                   	// #1
    a00091dc:	97ffff7c 	bl	a0008fcc <z_arm64_fatal_error>
}
    a00091e0:	d503201f 	nop
    a00091e4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a00091e8:	d65f03c0 	ret

00000000a00091ec <z_arm64_bss_zero>:
extern FUNC_NORETURN void z_cstart(void);

extern void z_arm64_mm_init(bool is_primary_core);

static inline void z_arm64_bss_zero(void)
{
    a00091ec:	d10043ff 	sub	sp, sp, #0x10
	uint64_t *p = (uint64_t *)__bss_start;
    a00091f0:	d0000120 	adrp	x0, a002f000 <xlat_tables>
    a00091f4:	91000000 	add	x0, x0, #0x0
    a00091f8:	f90007e0 	str	x0, [sp, #8]
	uint64_t *end = (uint64_t *)__bss_end;
    a00091fc:	f0000420 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a0009200:	9111d000 	add	x0, x0, #0x474
    a0009204:	f90003e0 	str	x0, [sp]

	while (p < end) {
    a0009208:	14000005 	b	a000921c <z_arm64_bss_zero+0x30>
		*p++ = 0U;
    a000920c:	f94007e0 	ldr	x0, [sp, #8]
    a0009210:	91002001 	add	x1, x0, #0x8
    a0009214:	f90007e1 	str	x1, [sp, #8]
    a0009218:	f900001f 	str	xzr, [x0]
	while (p < end) {
    a000921c:	f94007e1 	ldr	x1, [sp, #8]
    a0009220:	f94003e0 	ldr	x0, [sp]
    a0009224:	eb00003f 	cmp	x1, x0
    a0009228:	54ffff23 	b.cc	a000920c <z_arm64_bss_zero+0x20>  // b.lo, b.ul, b.last
	}
}
    a000922c:	d503201f 	nop
    a0009230:	d503201f 	nop
    a0009234:	910043ff 	add	sp, sp, #0x10
    a0009238:	d65f03c0 	ret

00000000a000923c <z_arm64_prep_c>:
 *
 * This routine prepares for the execution of and runs C code.
 *
 */
void z_arm64_prep_c(void)
{
    a000923c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0009240:	910003fd 	mov	x29, sp
	/* Initialize tpidrro_el0 with our struct _cpu instance address */
	write_tpidrro_el0((uintptr_t)&_kernel.cpus[0]);
    a0009244:	d00001e0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0009248:	913f8000 	add	x0, x0, #0xfe0
    a000924c:	f9000fe0 	str	x0, [sp, #24]
MAKE_REG_HELPER(tpidrro_el0);
    a0009250:	f9400fe0 	ldr	x0, [sp, #24]
    a0009254:	d51bd060 	msr	tpidrro_el0, x0
    a0009258:	d503201f 	nop

	z_arm64_bss_zero();
    a000925c:	97ffffe4 	bl	a00091ec <z_arm64_bss_zero>
#ifdef CONFIG_XIP
	z_data_copy();
#endif
	z_arm64_mm_init(true);
    a0009260:	52800020 	mov	w0, #0x1                   	// #1
    a0009264:	94000801 	bl	a000b268 <z_arm64_mm_init>
	z_arm64_interrupt_init();
    a0009268:	97ffffc2 	bl	a0009170 <z_arm64_interrupt_init>
	z_cstart();
    a000926c:	94002094 	bl	a00114bc <z_cstart>

00000000a0009270 <z_arm64_el3_plat_prep_c>:
	ret
    a0009270:	d65f03c0 	ret

00000000a0009274 <z_arm64_el2_plat_prep_c>:
	ret
    a0009274:	d65f03c0 	ret

00000000a0009278 <z_arm64_el1_plat_prep_c>:
	ret
    a0009278:	d65f03c0 	ret

00000000a000927c <is_el_implemented>:
#define __ISB() isb()
#define __DMB() dmb()
#define __DSB() dsb()

static inline bool is_el_implemented(unsigned int el)
{
    a000927c:	d10083ff 	sub	sp, sp, #0x20
    a0009280:	b9000fe0 	str	w0, [sp, #12]
	unsigned int shift;

	if (el > 3) {
    a0009284:	b9400fe0 	ldr	w0, [sp, #12]
    a0009288:	71000c1f 	cmp	w0, #0x3
    a000928c:	54000069 	b.ls	a0009298 <is_el_implemented+0x1c>  // b.plast
		return false;
    a0009290:	52800000 	mov	w0, #0x0                   	// #0
    a0009294:	1400000e 	b	a00092cc <is_el_implemented+0x50>
	}

	shift = ID_AA64PFR0_EL1_SHIFT * el;
    a0009298:	b9400fe0 	ldr	w0, [sp, #12]
    a000929c:	531e7400 	lsl	w0, w0, #2
    a00092a0:	b9001fe0 	str	w0, [sp, #28]
MAKE_REG_HELPER(id_aa64pfr0_el1);
    a00092a4:	d5380400 	mrs	x0, id_aa64pfr0_el1
    a00092a8:	f9000be0 	str	x0, [sp, #16]
    a00092ac:	f9400be1 	ldr	x1, [sp, #16]
    a00092b0:	d503201f 	nop

	return (((read_id_aa64pfr0_el1() >> shift) & ID_AA64PFR0_ELX_MASK) != 0U);
    a00092b4:	b9401fe0 	ldr	w0, [sp, #28]
    a00092b8:	9ac02420 	lsr	x0, x1, x0
    a00092bc:	92400c00 	and	x0, x0, #0xf
    a00092c0:	f100001f 	cmp	x0, #0x0
    a00092c4:	1a9f07e0 	cset	w0, ne  // ne = any
    a00092c8:	12001c00 	and	w0, w0, #0xff
}
    a00092cc:	910083ff 	add	sp, sp, #0x20
    a00092d0:	d65f03c0 	ret

00000000a00092d4 <is_el_highest_implemented>:

static inline bool is_el_highest_implemented(void)
{
    a00092d4:	d10083ff 	sub	sp, sp, #0x20
MAKE_REG_HELPER(id_aa64pfr0_el1);
    a00092d8:	d5380400 	mrs	x0, id_aa64pfr0_el1
    a00092dc:	f90007e0 	str	x0, [sp, #8]
    a00092e0:	f94007e0 	ldr	x0, [sp, #8]
    a00092e4:	d503201f 	nop
	uint32_t el_highest;
	uint32_t curr_el;

	el_highest = read_id_aa64pfr0_el1() & 0xFFFF;
    a00092e8:	12003c00 	and	w0, w0, #0xffff
    a00092ec:	b9001fe0 	str	w0, [sp, #28]
	el_highest = (31U - __builtin_clz(el_highest)) / 4;
    a00092f0:	b9401fe0 	ldr	w0, [sp, #28]
    a00092f4:	5ac01000 	clz	w0, w0
    a00092f8:	2a0003e1 	mov	w1, w0
    a00092fc:	528003e0 	mov	w0, #0x1f                  	// #31
    a0009300:	4b010000 	sub	w0, w0, w1
    a0009304:	53027c00 	lsr	w0, w0, #2
    a0009308:	b9001fe0 	str	w0, [sp, #28]
MAKE_REG_HELPER(currentel);
    a000930c:	d5384240 	mrs	x0, currentel
    a0009310:	f9000be0 	str	x0, [sp, #16]
    a0009314:	f9400be0 	ldr	x0, [sp, #16]
    a0009318:	d503201f 	nop

	curr_el = GET_EL(read_currentel());
    a000931c:	d342fc00 	lsr	x0, x0, #2
    a0009320:	12000400 	and	w0, w0, #0x3
    a0009324:	b9001be0 	str	w0, [sp, #24]

	if (curr_el < el_highest)
    a0009328:	b9401be1 	ldr	w1, [sp, #24]
    a000932c:	b9401fe0 	ldr	w0, [sp, #28]
    a0009330:	6b00003f 	cmp	w1, w0
    a0009334:	54000062 	b.cs	a0009340 <is_el_highest_implemented+0x6c>  // b.hs, b.nlast
		return false;
    a0009338:	52800000 	mov	w0, #0x0                   	// #0
    a000933c:	14000002 	b	a0009344 <is_el_highest_implemented+0x70>

	return true;
    a0009340:	52800020 	mov	w0, #0x1                   	// #1
}
    a0009344:	910083ff 	add	sp, sp, #0x20
    a0009348:	d65f03c0 	ret

00000000a000934c <is_el2_sec_supported>:

static inline bool is_el2_sec_supported(void)
{
    a000934c:	d10043ff 	sub	sp, sp, #0x10
MAKE_REG_HELPER(id_aa64pfr0_el1);
    a0009350:	d5380400 	mrs	x0, id_aa64pfr0_el1
    a0009354:	f90007e0 	str	x0, [sp, #8]
    a0009358:	f94007e0 	ldr	x0, [sp, #8]
    a000935c:	d503201f 	nop
	return (((read_id_aa64pfr0_el1() >> ID_AA64PFR0_SEL2_SHIFT) &
    a0009360:	d364fc00 	lsr	x0, x0, #36
    a0009364:	92400c00 	and	x0, x0, #0xf
		ID_AA64PFR0_SEL2_MASK) != 0U);
    a0009368:	f100001f 	cmp	x0, #0x0
    a000936c:	1a9f07e0 	cset	w0, ne  // ne = any
    a0009370:	12001c00 	and	w0, w0, #0xff
}
    a0009374:	910043ff 	add	sp, sp, #0x10
    a0009378:	d65f03c0 	ret

00000000a000937c <is_in_secure_state>:

static inline bool is_in_secure_state(void)
{
	/* We cannot read SCR_EL3 from EL2 or EL1 */
	return !IS_ENABLED(CONFIG_ARMV8_A_NS);
    a000937c:	52800000 	mov	w0, #0x0                   	// #0
}
    a0009380:	d65f03c0 	ret

00000000a0009384 <z_arm64_el_highest_plat_init>:
void z_arm64_el2_init(void);

void __weak z_arm64_el_highest_plat_init(void)
{
	/* do nothing */
}
    a0009384:	d503201f 	nop
    a0009388:	d65f03c0 	ret

00000000a000938c <z_arm64_el2_plat_init>:
}

void __weak z_arm64_el2_plat_init(void)
{
	/* do nothing */
}
    a000938c:	d503201f 	nop
    a0009390:	d65f03c0 	ret

00000000a0009394 <z_arm64_el1_plat_init>:

void __weak z_arm64_el1_plat_init(void)
{
	/* do nothing */
}
    a0009394:	d503201f 	nop
    a0009398:	d65f03c0 	ret

00000000a000939c <z_arm64_el_highest_init>:

void z_arm64_el_highest_init(void)
{
    a000939c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a00093a0:	910003fd 	mov	x29, sp
	if (is_el_highest_implemented()) {
    a00093a4:	97ffffcc 	bl	a00092d4 <is_el_highest_implemented>
    a00093a8:	12001c00 	and	w0, w0, #0xff
    a00093ac:	7100001f 	cmp	w0, #0x0
    a00093b0:	540000e0 	b.eq	a00093cc <z_arm64_el_highest_init+0x30>  // b.none
    a00093b4:	d2959400 	mov	x0, #0xaca0                	// #44192
    a00093b8:	f2a07720 	movk	x0, #0x3b9, lsl #16
    a00093bc:	f9000fe0 	str	x0, [sp, #24]
MAKE_REG_HELPER(cntfrq_el0);
    a00093c0:	f9400fe0 	ldr	x0, [sp, #24]
    a00093c4:	d51be000 	msr	cntfrq_el0, x0
    a00093c8:	d503201f 	nop
		write_cntfrq_el0(CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC);
	}

	z_arm64_el_highest_plat_init();
    a00093cc:	97ffffee 	bl	a0009384 <z_arm64_el_highest_plat_init>

	isb();
    a00093d0:	d5033fdf 	isb
}
    a00093d4:	d503201f 	nop
    a00093d8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a00093dc:	d65f03c0 	ret

00000000a00093e0 <el3_get_next_el>:
	EL3_TO_EL1_NO_EL2,
	EL3_TO_EL1_SKIP_EL2
};

static inline enum el3_next_el el3_get_next_el(void)
{
    a00093e0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    a00093e4:	910003fd 	mov	x29, sp
	if (!is_el_implemented(2)) {
    a00093e8:	52800040 	mov	w0, #0x2                   	// #2
    a00093ec:	97ffffa4 	bl	a000927c <is_el_implemented>
    a00093f0:	12001c00 	and	w0, w0, #0xff
    a00093f4:	52000000 	eor	w0, w0, #0x1
    a00093f8:	12001c00 	and	w0, w0, #0xff
    a00093fc:	7100001f 	cmp	w0, #0x0
    a0009400:	54000060 	b.eq	a000940c <el3_get_next_el+0x2c>  // b.none
		return EL3_TO_EL1_NO_EL2;
    a0009404:	52800020 	mov	w0, #0x1                   	// #1
    a0009408:	1400000e 	b	a0009440 <el3_get_next_el+0x60>
	} else if (is_in_secure_state() && !is_el2_sec_supported()) {
    a000940c:	97ffffdc 	bl	a000937c <is_in_secure_state>
    a0009410:	12001c00 	and	w0, w0, #0xff
    a0009414:	7100001f 	cmp	w0, #0x0
    a0009418:	54000120 	b.eq	a000943c <el3_get_next_el+0x5c>  // b.none
    a000941c:	97ffffcc 	bl	a000934c <is_el2_sec_supported>
    a0009420:	12001c00 	and	w0, w0, #0xff
    a0009424:	52000000 	eor	w0, w0, #0x1
    a0009428:	12001c00 	and	w0, w0, #0xff
    a000942c:	7100001f 	cmp	w0, #0x0
    a0009430:	54000060 	b.eq	a000943c <el3_get_next_el+0x5c>  // b.none
		/*
		 * Is considered an illegal return "[..] a return to EL2 when EL3 is
		 * implemented and the value of the SCR_EL3.NS bit is 0 if
		 * ARMv8.4-SecEL2 is not implemented" (D1.11.2 from ARM DDI 0487E.a)
		 */
		return EL3_TO_EL1_SKIP_EL2;
    a0009434:	52800040 	mov	w0, #0x2                   	// #2
    a0009438:	14000002 	b	a0009440 <el3_get_next_el+0x60>
	} else {
		return EL3_TO_EL2;
    a000943c:	52800000 	mov	w0, #0x0                   	// #0
	}
}
    a0009440:	a8c17bfd 	ldp	x29, x30, [sp], #16
    a0009444:	d65f03c0 	ret

00000000a0009448 <z_arm64_el3_init>:

void z_arm64_el3_init(void)
{
    a0009448:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    a000944c:	910003fd 	mov	x29, sp
	uint64_t reg;

	/* Setup vector table */
	write_vbar_el3((uint64_t)_vector_table);
    a0009450:	f0ffffa0 	adrp	x0, a0000000 <__text_region_start>
    a0009454:	91200000 	add	x0, x0, #0x800
    a0009458:	f9000fe0 	str	x0, [sp, #24]
MAKE_REG_HELPER_EL123(vbar)
    a000945c:	f9400fe0 	ldr	x0, [sp, #24]
    a0009460:	d51ec000 	msr	vbar_el3, x0
    a0009464:	d503201f 	nop
	isb();
    a0009468:	d5033fdf 	isb

	reg = 0U;			/* Mostly RES0 */
    a000946c:	f9001fff 	str	xzr, [sp, #56]
	reg &= ~(CPTR_TTA_BIT |		/* Do not trap sysreg accesses */
    a0009470:	f9401fe1 	ldr	x1, [sp, #56]
    a0009474:	92808000 	mov	x0, #0xfffffffffffffbff    	// #-1025
    a0009478:	f2affde0 	movk	x0, #0x7fef, lsl #16
    a000947c:	8a000020 	and	x0, x1, x0
    a0009480:	f9001fe0 	str	x0, [sp, #56]
    a0009484:	f9401fe0 	ldr	x0, [sp, #56]
    a0009488:	f90013e0 	str	x0, [sp, #32]
MAKE_REG_HELPER_EL123(cptr)
    a000948c:	f94013e0 	ldr	x0, [sp, #32]
    a0009490:	d51e1140 	msr	cptr_el3, x0
    a0009494:	d503201f 	nop
		 CPTR_TFP_BIT |		/* Do not trap SVE, SIMD and FP */
		 CPTR_TCPAC_BIT);	/* Do not trap CPTR_EL2 / CPACR_EL1 accesses */
	write_cptr_el3(reg);

	reg = 0U;			/* Reset */
    a0009498:	f9001fff 	str	xzr, [sp, #56]
#ifdef CONFIG_ARMV8_A_NS
	reg |= SCR_NS_BIT;		/* EL2 / EL3 non-secure */
    a000949c:	f9401fe0 	ldr	x0, [sp, #56]
    a00094a0:	b2400000 	orr	x0, x0, #0x1
    a00094a4:	f9001fe0 	str	x0, [sp, #56]
#endif
	reg |= (SCR_RES1 |		/* RES1 */
    a00094a8:	f9401fe1 	ldr	x1, [sp, #56]
    a00094ac:	d281b600 	mov	x0, #0xdb0                 	// #3504
    a00094b0:	aa000020 	orr	x0, x1, x0
    a00094b4:	f9001fe0 	str	x0, [sp, #56]
    a00094b8:	f9401fe0 	ldr	x0, [sp, #56]
    a00094bc:	f90017e0 	str	x0, [sp, #40]
MAKE_REG_HELPER(scr_el3);
    a00094c0:	f94017e0 	ldr	x0, [sp, #40]
    a00094c4:	d51e1100 	msr	scr_el3, x0
    a00094c8:	d503201f 	nop
		SCR_HCE_BIT |		/* Do not trap HVC */
		SCR_SMD_BIT);		/* Do not trap SMC */
	write_scr_el3(reg);

#if defined(CONFIG_GIC_V3)
	reg = read_sysreg(ICC_SRE_EL3);
    a00094cc:	d53ecca0 	mrs	x0, s3_6_c12_c12_5
    a00094d0:	f9001be0 	str	x0, [sp, #48]
    a00094d4:	f9401be0 	ldr	x0, [sp, #48]
    a00094d8:	f9001fe0 	str	x0, [sp, #56]
	reg = (ICC_SRE_ELx_SRE_BIT |	/* System register interface is used */
    a00094dc:	d2800120 	mov	x0, #0x9                   	// #9
    a00094e0:	f9001fe0 	str	x0, [sp, #56]
	       ICC_SRE_EL3_EN_BIT);	/* Enables lower Exception level access to ICC_SRE_EL1 */
	write_sysreg(reg, ICC_SRE_EL3);
    a00094e4:	f9401fe0 	ldr	x0, [sp, #56]
    a00094e8:	d51ecca0 	msr	s3_6_c12_c12_5, x0
#endif

	z_arm64_el3_plat_init();
    a00094ec:	97fffe75 	bl	a0008ec0 <z_arm64_el3_plat_init>

	isb();
    a00094f0:	d5033fdf 	isb

	if (el3_get_next_el() == EL3_TO_EL1_SKIP_EL2) {
    a00094f4:	97ffffbb 	bl	a00093e0 <el3_get_next_el>
    a00094f8:	7100081f 	cmp	w0, #0x2
    a00094fc:	54000041 	b.ne	a0009504 <z_arm64_el3_init+0xbc>  // b.any
		/*
		 * handle EL2 init in EL3, as it still needs to be done,
		 * but we are going to be skipping EL2.
		 */
		z_arm64_el2_init();
    a0009500:	94000004 	bl	a0009510 <z_arm64_el2_init>
	}
}
    a0009504:	d503201f 	nop
    a0009508:	a8c47bfd 	ldp	x29, x30, [sp], #64
    a000950c:	d65f03c0 	ret

00000000a0009510 <z_arm64_el2_init>:

void z_arm64_el2_init(void)
{
    a0009510:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    a0009514:	910003fd 	mov	x29, sp
MAKE_REG_HELPER_EL123(sctlr)
    a0009518:	d53c1000 	mrs	x0, sctlr_el2
    a000951c:	f9000be0 	str	x0, [sp, #16]
    a0009520:	f9400be0 	ldr	x0, [sp, #16]
    a0009524:	d503201f 	nop
	uint64_t reg;

	reg = read_sctlr_el2();
    a0009528:	f9001fe0 	str	x0, [sp, #56]
	reg |= (SCTLR_EL2_RES1 |	/* RES1 */
    a000952c:	f9401fe1 	ldr	x1, [sp, #56]
    a0009530:	d2830700 	mov	x0, #0x1838                	// #6200
    a0009534:	f2a618a0 	movk	x0, #0x30c5, lsl #16
    a0009538:	aa000020 	orr	x0, x1, x0
    a000953c:	f9001fe0 	str	x0, [sp, #56]
    a0009540:	f9401fe0 	ldr	x0, [sp, #56]
    a0009544:	f9000fe0 	str	x0, [sp, #24]
    a0009548:	f9400fe0 	ldr	x0, [sp, #24]
    a000954c:	d51c1000 	msr	sctlr_el2, x0
    a0009550:	d503201f 	nop
MAKE_REG_HELPER(hcr_el2);
    a0009554:	d53c1100 	mrs	x0, hcr_el2
    a0009558:	f90013e0 	str	x0, [sp, #32]
    a000955c:	f94013e0 	ldr	x0, [sp, #32]
    a0009560:	d503201f 	nop
		SCTLR_I_BIT |		/* Enable i-cache */
		SCTLR_SA_BIT);		/* Enable SP alignment check */
	write_sctlr_el2(reg);

	reg = read_hcr_el2();
    a0009564:	f9001fe0 	str	x0, [sp, #56]
	reg |= HCR_RW_BIT;		/* EL1 Execution state is AArch64 */
    a0009568:	f9401fe0 	ldr	x0, [sp, #56]
    a000956c:	b2610000 	orr	x0, x0, #0x80000000
    a0009570:	f9001fe0 	str	x0, [sp, #56]
    a0009574:	f9401fe0 	ldr	x0, [sp, #56]
    a0009578:	f90017e0 	str	x0, [sp, #40]
    a000957c:	f94017e0 	ldr	x0, [sp, #40]
    a0009580:	d51c1100 	msr	hcr_el2, x0
    a0009584:	d503201f 	nop
	write_hcr_el2(reg);

	reg = 0U;			/* RES0 */
    a0009588:	f9001fff 	str	xzr, [sp, #56]
	reg |= CPTR_EL2_RES1;		/* RES1 */
    a000958c:	f9401fe1 	ldr	x1, [sp, #56]
    a0009590:	d2865fe0 	mov	x0, #0x32ff                	// #13055
    a0009594:	aa000020 	orr	x0, x1, x0
    a0009598:	f9001fe0 	str	x0, [sp, #56]
	reg &= ~(CPTR_TFP_BIT |		/* Do not trap SVE, SIMD and FP */
    a000959c:	f9401fe1 	ldr	x1, [sp, #56]
    a00095a0:	92808000 	mov	x0, #0xfffffffffffffbff    	// #-1025
    a00095a4:	f2afffe0 	movk	x0, #0x7fff, lsl #16
    a00095a8:	8a000020 	and	x0, x1, x0
    a00095ac:	f9001fe0 	str	x0, [sp, #56]
    a00095b0:	f9401fe0 	ldr	x0, [sp, #56]
    a00095b4:	f9001be0 	str	x0, [sp, #48]
MAKE_REG_HELPER_EL123(cptr)
    a00095b8:	f9401be0 	ldr	x0, [sp, #48]
    a00095bc:	d51c1140 	msr	cptr_el2, x0
    a00095c0:	d503201f 	nop
MAKE_REG_HELPER(cntvoff_el2);
    a00095c4:	d51ce07f 	msr	cntvoff_el2, xzr
    a00095c8:	d503201f 	nop
MAKE_REG_HELPER(cnthctl_el2);
    a00095cc:	d51ce11f 	msr	cnthctl_el2, xzr
    a00095d0:	d503201f 	nop
MAKE_REG_HELPER(cnthp_ctl_el2);
    a00095d4:	d51ce23f 	msr	cnthp_ctl_el2, xzr
    a00095d8:	d503201f 	nop
	/*
	 * Enable this if/when we use the hypervisor timer.
	 * write_cnthp_cval_el2(~(uint64_t)0);
	 */

	z_arm64_el2_plat_init();
    a00095dc:	97ffff6c 	bl	a000938c <z_arm64_el2_plat_init>

	isb();
    a00095e0:	d5033fdf 	isb
}
    a00095e4:	d503201f 	nop
    a00095e8:	a8c47bfd 	ldp	x29, x30, [sp], #64
    a00095ec:	d65f03c0 	ret

00000000a00095f0 <z_arm64_el1_init>:

void z_arm64_el1_init(void)
{
    a00095f0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    a00095f4:	910003fd 	mov	x29, sp
	uint64_t reg;

	/* Setup vector table */
	write_vbar_el1((uint64_t)_vector_table);
    a00095f8:	f0ffffa0 	adrp	x0, a0000000 <__text_region_start>
    a00095fc:	91200000 	add	x0, x0, #0x800
    a0009600:	f9000be0 	str	x0, [sp, #16]
MAKE_REG_HELPER_EL123(vbar)
    a0009604:	f9400be0 	ldr	x0, [sp, #16]
    a0009608:	d518c000 	msr	vbar_el1, x0
    a000960c:	d503201f 	nop
	isb();
    a0009610:	d5033fdf 	isb

	reg = 0U;			/* RES0 */
    a0009614:	f9001fff 	str	xzr, [sp, #56]
	reg |= CPACR_EL1_FPEN_NOTRAP;	/* Do not trap NEON/SIMD/FP initially */
    a0009618:	f9401fe0 	ldr	x0, [sp, #56]
    a000961c:	b26c0400 	orr	x0, x0, #0x300000
    a0009620:	f9001fe0 	str	x0, [sp, #56]
    a0009624:	f9401fe0 	ldr	x0, [sp, #56]
    a0009628:	f9000fe0 	str	x0, [sp, #24]
MAKE_REG_HELPER_EL123(cpacr)
    a000962c:	f9400fe0 	ldr	x0, [sp, #24]
    a0009630:	d5181040 	msr	cpacr_el1, x0
    a0009634:	d503201f 	nop
MAKE_REG_HELPER_EL123(sctlr)
    a0009638:	d5381000 	mrs	x0, sctlr_el1
    a000963c:	f90013e0 	str	x0, [sp, #32]
    a0009640:	f94013e0 	ldr	x0, [sp, #32]
    a0009644:	d503201f 	nop
					/* TODO: CONFIG_FLOAT_*_FORBIDDEN */
	write_cpacr_el1(reg);

	reg = read_sctlr_el1();
    a0009648:	f9001fe0 	str	x0, [sp, #56]
	reg |= (SCTLR_EL1_RES1 |	/* RES1 */
    a000964c:	f9401fe1 	ldr	x1, [sp, #56]
    a0009650:	d2830100 	mov	x0, #0x1808                	// #6152
    a0009654:	f2a61a00 	movk	x0, #0x30d0, lsl #16
    a0009658:	aa000020 	orr	x0, x1, x0
    a000965c:	f9001fe0 	str	x0, [sp, #56]
    a0009660:	f9401fe0 	ldr	x0, [sp, #56]
    a0009664:	f90017e0 	str	x0, [sp, #40]
    a0009668:	f94017e0 	ldr	x0, [sp, #40]
    a000966c:	d5181000 	msr	sctlr_el1, x0
    a0009670:	d503201f 	nop
    a0009674:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    a0009678:	f9001be0 	str	x0, [sp, #48]
MAKE_REG_HELPER(cntv_cval_el0)
    a000967c:	f9401be0 	ldr	x0, [sp, #48]
    a0009680:	d51be340 	msr	cntv_cval_el0, x0
    a0009684:	d503201f 	nop
	 * Enable these if/when we use the corresponding timers.
	 * write_cntp_cval_el0(~(uint64_t)0);
	 * write_cntps_cval_el1(~(uint64_t)0);
	 */

	z_arm64_el1_plat_init();
    a0009688:	97ffff43 	bl	a0009394 <z_arm64_el1_plat_init>

	isb();
    a000968c:	d5033fdf 	isb
}
    a0009690:	d503201f 	nop
    a0009694:	a8c47bfd 	ldp	x29, x30, [sp], #64
    a0009698:	d65f03c0 	ret

00000000a000969c <z_arm64_el3_get_next_el>:

void z_arm64_el3_get_next_el(uint64_t switch_addr)
{
    a000969c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    a00096a0:	910003fd 	mov	x29, sp
    a00096a4:	f9000fe0 	str	x0, [sp, #24]
    a00096a8:	f9400fe0 	ldr	x0, [sp, #24]
    a00096ac:	f9001be0 	str	x0, [sp, #48]
MAKE_REG_HELPER_EL123(elr)
    a00096b0:	f9401be0 	ldr	x0, [sp, #48]
    a00096b4:	d51e4020 	msr	elr_el3, x0
    a00096b8:	d503201f 	nop
	uint64_t spsr;

	write_elr_el3(switch_addr);

	/* Mask the DAIF */
	spsr = SPSR_DAIF_MASK;
    a00096bc:	d2807800 	mov	x0, #0x3c0                 	// #960
    a00096c0:	f9001fe0 	str	x0, [sp, #56]

	if (el3_get_next_el() == EL3_TO_EL2) {
    a00096c4:	97ffff47 	bl	a00093e0 <el3_get_next_el>
    a00096c8:	7100001f 	cmp	w0, #0x0
    a00096cc:	540000a1 	b.ne	a00096e0 <z_arm64_el3_get_next_el+0x44>  // b.any
		/* Dropping into EL2 */
		spsr |= SPSR_MODE_EL2T;
    a00096d0:	f9401fe0 	ldr	x0, [sp, #56]
    a00096d4:	b27d0000 	orr	x0, x0, #0x8
    a00096d8:	f9001fe0 	str	x0, [sp, #56]
    a00096dc:	14000004 	b	a00096ec <z_arm64_el3_get_next_el+0x50>
	} else {
		/* Dropping into EL1 */
		spsr |= SPSR_MODE_EL1T;
    a00096e0:	f9401fe0 	ldr	x0, [sp, #56]
    a00096e4:	b27e0000 	orr	x0, x0, #0x4
    a00096e8:	f9001fe0 	str	x0, [sp, #56]
    a00096ec:	f9401fe0 	ldr	x0, [sp, #56]
    a00096f0:	f90017e0 	str	x0, [sp, #40]
MAKE_REG_HELPER_EL123(spsr)
    a00096f4:	f94017e0 	ldr	x0, [sp, #40]
    a00096f8:	d51e4000 	msr	spsr_el3, x0
    a00096fc:	d503201f 	nop
	}

	write_spsr_el3(spsr);
}
    a0009700:	d503201f 	nop
    a0009704:	a8c47bfd 	ldp	x29, x30, [sp], #64
    a0009708:	d65f03c0 	ret

00000000a000970c <z_arm64_context_switch>:

GTEXT(z_arm64_context_switch)
SECTION_FUNC(TEXT, z_arm64_context_switch)

	/* Save the current SP_EL0 */
	mrs	x4, sp_el0
    a000970c:	d5384104 	mrs	x4, sp_el0

	stp	x19, x20, [x1, #_thread_offset_to_callee_saved_x19_x20]
    a0009710:	a904d033 	stp	x19, x20, [x1, #72]
	stp	x21, x22, [x1, #_thread_offset_to_callee_saved_x21_x22]
    a0009714:	a905d835 	stp	x21, x22, [x1, #88]
	stp	x23, x24, [x1, #_thread_offset_to_callee_saved_x23_x24]
    a0009718:	a906e037 	stp	x23, x24, [x1, #104]
	stp	x25, x26, [x1, #_thread_offset_to_callee_saved_x25_x26]
    a000971c:	a907e839 	stp	x25, x26, [x1, #120]
	stp	x27, x28, [x1, #_thread_offset_to_callee_saved_x27_x28]
    a0009720:	a908f03b 	stp	x27, x28, [x1, #136]
	stp	x29, x4,  [x1, #_thread_offset_to_callee_saved_x29_sp_el0]
    a0009724:	a909903d 	stp	x29, x4, [x1, #152]

	/* Save the current SP_ELx */
	mov	x4, sp
    a0009728:	910003e4 	mov	x4, sp
	str	x4, [x1, #_thread_offset_to_callee_saved_sp_elx]
    a000972c:	f9005424 	str	x4, [x1, #168]

	/* save current thread's exception depth */
	mrs	x4, tpidrro_el0
    a0009730:	d53bd064 	mrs	x4, tpidrro_el0
	lsr	x2, x4, #TPIDRROEL0_EXC_SHIFT
    a0009734:	d378fc82 	lsr	x2, x4, #56
	strb	w2, [x1, #_thread_offset_to_exception_depth]
    a0009738:	3904c022 	strb	w2, [x1, #304]

	/* retrieve next thread's exception depth */
	ldrb	w2, [x0, #_thread_offset_to_exception_depth]
    a000973c:	3944c002 	ldrb	w2, [x0, #304]
	bic	x4, x4, #TPIDRROEL0_EXC_DEPTH
    a0009740:	9240dc84 	and	x4, x4, #0xffffffffffffff
	orr	x4, x4, x2, lsl #TPIDRROEL0_EXC_SHIFT
    a0009744:	aa02e084 	orr	x4, x4, x2, lsl #56
	msr	tpidrro_el0, x4
    a0009748:	d51bd064 	msr	tpidrro_el0, x4
	 * thread variables with offsets added by toolchain.
	 */
	msr	tpidr_el0, x2
#endif

	ldp	x19, x20, [x0, #_thread_offset_to_callee_saved_x19_x20]
    a000974c:	a944d013 	ldp	x19, x20, [x0, #72]
	ldp	x21, x22, [x0, #_thread_offset_to_callee_saved_x21_x22]
    a0009750:	a945d815 	ldp	x21, x22, [x0, #88]
	ldp	x23, x24, [x0, #_thread_offset_to_callee_saved_x23_x24]
    a0009754:	a946e017 	ldp	x23, x24, [x0, #104]
	ldp	x25, x26, [x0, #_thread_offset_to_callee_saved_x25_x26]
    a0009758:	a947e819 	ldp	x25, x26, [x0, #120]
	ldp	x27, x28, [x0, #_thread_offset_to_callee_saved_x27_x28]
    a000975c:	a948f01b 	ldp	x27, x28, [x0, #136]
	ldp	x29, x4,  [x0, #_thread_offset_to_callee_saved_x29_sp_el0]
    a0009760:	a949901d 	ldp	x29, x4, [x0, #152]

	/* Restore SP_EL0 */
	msr	sp_el0, x4
    a0009764:	d5184104 	msr	sp_el0, x4

	/* Restore SP_EL1 */
	ldr	x4, [x0, #_thread_offset_to_callee_saved_sp_elx]
    a0009768:	f9405404 	ldr	x4, [x0, #168]
	mov	sp, x4
    a000976c:	9100009f 	mov	sp, x4

#ifdef CONFIG_USERSPACE
	stp     xzr, x30, [sp, #-16]!
    a0009770:	a9bf7bff 	stp	xzr, x30, [sp, #-16]!
	bl      z_arm64_swap_mem_domains
    a0009774:	9400081b 	bl	a000b7e0 <z_arm64_swap_mem_domains>
	ldp     xzr, x30, [sp], #16
    a0009778:	a8c17bff 	ldp	xzr, x30, [sp], #16
	bl	z_thread_mark_switched_in
	ldp	xzr, x30, [sp], #16
#endif

	/* Return to z_arm64_sync_exc() or _isr_wrapper() */
	ret
    a000977c:	d65f03c0 	ret

00000000a0009780 <z_arm64_sync_exc>:
 */

GTEXT(z_arm64_sync_exc)
SECTION_FUNC(TEXT, z_arm64_sync_exc)

	mrs	x0, esr_el1
    a0009780:	d5385200 	mrs	x0, esr_el1
	lsr	x1, x0, #26
    a0009784:	d35afc01 	lsr	x1, x0, #26
	bl	z_arm64_fpu_trap
	b	z_arm64_exit_exc_fpu_done
1:
#endif

	cmp	x1, #0x15 /* 0x15 = SVC */
    a0009788:	f100543f 	cmp	x1, #0x15
	bne	inv
    a000978c:	540001e1 	b.ne	a00097c8 <inv>  // b.any

	/* Demux the SVC call */
	and	x1, x0, #0xff
    a0009790:	92401c01 	and	x1, x0, #0xff

	cmp	x1, #_SVC_CALL_CONTEXT_SWITCH
    a0009794:	f100003f 	cmp	x1, #0x0
	beq	context_switch
    a0009798:	54000100 	b.eq	a00097b8 <context_switch>  // b.none

	cmp	x1, #_SVC_CALL_RUNTIME_EXCEPT
    a000979c:	f100083f 	cmp	x1, #0x2
	beq	oops
    a00097a0:	54000080 	b.eq	a00097b0 <oops>  // b.none

#ifdef CONFIG_USERSPACE
	cmp	x1, #_SVC_CALL_SYSTEM_CALL
    a00097a4:	f1000c3f 	cmp	x1, #0x3
	beq	z_arm64_do_syscall
    a00097a8:	54fbc6c0 	b.eq	a0001080 <z_arm64_do_syscall>  // b.none

	/* --(_kernel->nested) */
	dec_nest_counter x0, x1
	b	z_arm64_exit_exc
#endif
	b	inv
    a00097ac:	14000007 	b	a00097c8 <inv>

00000000a00097b0 <oops>:

oops:
	mov	x0, sp
    a00097b0:	910003e0 	mov	x0, sp
	b	z_arm64_do_kernel_oops
    a00097b4:	17fffe50 	b	a00090f4 <z_arm64_do_kernel_oops>

00000000a00097b8 <context_switch>:
	 * Retrieve x0 and x1 from the stack:
	 *
	 *  - x0 = new_thread->switch_handle = switch_to thread
	 *  - x1 = &old_thread->switch_handle = current thread
	 */
	ldp	x0, x1, [sp, ___esf_t_x0_x1_OFFSET]
    a00097b8:	a94007e0 	ldp	x0, x1, [sp]

	/* Get old thread from x1 */
	sub	x1, x1, ___thread_t_switch_handle_OFFSET
    a00097bc:	d1046021 	sub	x1, x1, #0x118

	/* Switch thread */
	bl	z_arm64_context_switch
    a00097c0:	97ffffd3 	bl	a000970c <z_arm64_context_switch>
	b	z_arm64_exit_exc
    a00097c4:	14000094 	b	a0009a14 <z_arm64_exit_exc>

00000000a00097c8 <inv>:

inv:
	mov	x0, #0 /* K_ERR_CPU_EXCEPTION */
    a00097c8:	d2800000 	mov	x0, #0x0                   	// #0
	mov	x1, sp
    a00097cc:	910003e1 	mov	x1, sp
	bl	z_arm64_fatal_error
    a00097d0:	97fffdff 	bl	a0008fcc <z_arm64_fatal_error>

	/* Return here only in case of recoverable error */
	b	z_arm64_exit_exc
    a00097d4:	14000090 	b	a0009a14 <z_arm64_exit_exc>

00000000a00097d8 <z_arm64_call_svc>:

GTEXT(z_arm64_call_svc)
SECTION_FUNC(TEXT, z_arm64_call_svc)
	svc	#_SVC_CALL_CONTEXT_SWITCH
    a00097d8:	d4000001 	svc	#0x0
	ret
    a00097dc:	d65f03c0 	ret

00000000a00097e0 <z_stack_ptr_align>:
 *
 * @param ptr Proposed stack pointer address
 * @return Properly aligned stack pointer address
 */
static inline char *z_stack_ptr_align(char *ptr)
{
    a00097e0:	d10043ff 	sub	sp, sp, #0x10
    a00097e4:	f90007e0 	str	x0, [sp, #8]
	return (char *)ROUND_DOWN(ptr, ARCH_STACK_PTR_ALIGN);
    a00097e8:	f94007e0 	ldr	x0, [sp, #8]
    a00097ec:	927cec00 	and	x0, x0, #0xfffffffffffffff0
}
    a00097f0:	910043ff 	add	sp, sp, #0x10
    a00097f4:	d65f03c0 	ret

00000000a00097f8 <is_user>:
 *
 */

#ifdef CONFIG_USERSPACE
static bool is_user(struct k_thread *thread)
{
    a00097f8:	d10043ff 	sub	sp, sp, #0x10
    a00097fc:	f90007e0 	str	x0, [sp, #8]
	return (thread->base.user_options & K_USER) != 0;
    a0009800:	f94007e0 	ldr	x0, [sp, #8]
    a0009804:	39406000 	ldrb	w0, [x0, #24]
    a0009808:	92401c00 	and	x0, x0, #0xff
    a000980c:	927e0000 	and	x0, x0, #0x4
    a0009810:	f100001f 	cmp	x0, #0x0
    a0009814:	1a9f07e0 	cset	w0, ne  // ne = any
    a0009818:	12001c00 	and	w0, w0, #0xff
}
    a000981c:	910043ff 	add	sp, sp, #0x10
    a0009820:	d65f03c0 	ret

00000000a0009824 <arch_new_thread>:
#endif

void arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		     char *stack_ptr, k_thread_entry_t entry,
		     void *p1, void *p2, void *p3)
{
    a0009824:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a0009828:	910003fd 	mov	x29, sp
    a000982c:	f90027e0 	str	x0, [sp, #72]
    a0009830:	f90023e1 	str	x1, [sp, #64]
    a0009834:	f9001fe2 	str	x2, [sp, #56]
    a0009838:	f9001be3 	str	x3, [sp, #48]
    a000983c:	f90017e4 	str	x4, [sp, #40]
    a0009840:	f90013e5 	str	x5, [sp, #32]
    a0009844:	f9000fe6 	str	x6, [sp, #24]
	 * is also fine because at this stage they are still running in EL1.
	 * The context will be relocated by arch_user_mode_enter() before
	 * dropping into EL0.
	 */

	pInitCtx = Z_STACK_PTR_TO_FRAME(struct __esf, stack_ptr);
    a0009848:	f9401fe0 	ldr	x0, [sp, #56]
    a000984c:	d102c000 	sub	x0, x0, #0xb0
    a0009850:	f9002fe0 	str	x0, [sp, #88]

	pInitCtx->x0 = (uint64_t)entry;
    a0009854:	f9401be1 	ldr	x1, [sp, #48]
    a0009858:	f9402fe0 	ldr	x0, [sp, #88]
    a000985c:	f9000001 	str	x1, [x0]
	pInitCtx->x1 = (uint64_t)p1;
    a0009860:	f94017e1 	ldr	x1, [sp, #40]
    a0009864:	f9402fe0 	ldr	x0, [sp, #88]
    a0009868:	f9000401 	str	x1, [x0, #8]
	pInitCtx->x2 = (uint64_t)p2;
    a000986c:	f94013e1 	ldr	x1, [sp, #32]
    a0009870:	f9402fe0 	ldr	x0, [sp, #88]
    a0009874:	f9000801 	str	x1, [x0, #16]
	pInitCtx->x3 = (uint64_t)p3;
    a0009878:	f9400fe1 	ldr	x1, [sp, #24]
    a000987c:	f9402fe0 	ldr	x0, [sp, #88]
    a0009880:	f9000c01 	str	x1, [x0, #24]
#ifdef CONFIG_USERSPACE
	/*
	 * If the new thread is a user thread we jump into
	 * arch_user_mode_enter() when still in EL1.
	 */
	if (is_user(thread)) {
    a0009884:	f94027e0 	ldr	x0, [sp, #72]
    a0009888:	97ffffdc 	bl	a00097f8 <is_user>
    a000988c:	12001c00 	and	w0, w0, #0xff
    a0009890:	7100001f 	cmp	w0, #0x0
    a0009894:	540000c0 	b.eq	a00098ac <arch_new_thread+0x88>  // b.none
		pInitCtx->elr = (uint64_t)arch_user_mode_enter;
    a0009898:	90000000 	adrp	x0, a0009000 <z_arm64_fatal_error+0x34>
    a000989c:	9124b001 	add	x1, x0, #0x92c
    a00098a0:	f9402fe0 	ldr	x0, [sp, #88]
    a00098a4:	f9005401 	str	x1, [x0, #168]
    a00098a8:	14000005 	b	a00098bc <arch_new_thread+0x98>
	} else {
		pInitCtx->elr = (uint64_t)z_thread_entry;
    a00098ac:	f0ffffc0 	adrp	x0, a0004000 <fix_extra_red+0xcc>
    a00098b0:	91335001 	add	x1, x0, #0xcd4
    a00098b4:	f9402fe0 	ldr	x0, [sp, #88]
    a00098b8:	f9005401 	str	x1, [x0, #168]
	}
#else
	pInitCtx->elr = (uint64_t)z_thread_entry;
#endif
	/* Keep using SP_EL1 */
	pInitCtx->spsr = SPSR_MODE_EL1H | DAIF_FIQ_BIT;
    a00098bc:	f9402fe0 	ldr	x0, [sp, #88]
    a00098c0:	d28008a1 	mov	x1, #0x45                  	// #69
    a00098c4:	f9005001 	str	x1, [x0, #160]

	/* thread birth happens through the exception return path */
	thread->arch.exception_depth = 1;
    a00098c8:	f94027e0 	ldr	x0, [sp, #72]
    a00098cc:	52800021 	mov	w1, #0x1                   	// #1
    a00098d0:	3904c001 	strb	w1, [x0, #304]
	 * We are saving SP_EL1 to pop out entry and parameters when going
	 * through z_arm64_exit_exc(). For user threads the definitive location
	 * of SP_EL1 will be set implicitly when going through
	 * z_arm64_userspace_enter() (see comments there)
	 */
	thread->callee_saved.sp_elx = (uint64_t)pInitCtx;
    a00098d4:	f9402fe1 	ldr	x1, [sp, #88]
    a00098d8:	f94027e0 	ldr	x0, [sp, #72]
    a00098dc:	f9005401 	str	x1, [x0, #168]

	thread->switch_handle = thread;
    a00098e0:	f94027e0 	ldr	x0, [sp, #72]
    a00098e4:	f94027e1 	ldr	x1, [sp, #72]
    a00098e8:	f9008c01 	str	x1, [x0, #280]
}
    a00098ec:	d503201f 	nop
    a00098f0:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a00098f4:	d65f03c0 	ret

00000000a00098f8 <z_arch_get_next_switch_handle>:

void *z_arch_get_next_switch_handle(struct k_thread **old_thread)
{
    a00098f8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a00098fc:	910003fd 	mov	x29, sp
    a0009900:	f9000fe0 	str	x0, [sp, #24]
	/*
	 * When returning from this function we will have the current thread
	 * onto the stack to be popped in x1 and the next thread in x0 returned
	 * from z_get_next_switch_handle() (see isr_wrapper.S)
	 */
	*old_thread =  _current;
    a0009904:	d00001e0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0009908:	913f8000 	add	x0, x0, #0xfe0
    a000990c:	f9400801 	ldr	x1, [x0, #16]
    a0009910:	f9400fe0 	ldr	x0, [sp, #24]
    a0009914:	f9000001 	str	x1, [x0]
	 * the thread switch_handle field.  The resulting thread won't be
	 * switched into until we write that ourselves.
	 */
	return z_get_next_switch_handle(NULL);
#else
	return z_get_next_switch_handle(*old_thread);
    a0009918:	f9400fe0 	ldr	x0, [sp, #24]
    a000991c:	f9400000 	ldr	x0, [x0]
    a0009920:	94003a9f 	bl	a001839c <z_get_next_switch_handle>
#endif
}
    a0009924:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0009928:	d65f03c0 	ret

00000000a000992c <arch_user_mode_enter>:

#ifdef CONFIG_USERSPACE
FUNC_NORETURN void arch_user_mode_enter(k_thread_entry_t user_entry,
					void *p1, void *p2, void *p3)
{
    a000992c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    a0009930:	910003fd 	mov	x29, sp
    a0009934:	f90017e0 	str	x0, [sp, #40]
    a0009938:	f90013e1 	str	x1, [sp, #32]
    a000993c:	f9000fe2 	str	x2, [sp, #24]
    a0009940:	f9000be3 	str	x3, [sp, #16]
	z_arch_esf_t *pInitCtx;
	uintptr_t stack_ptr;

	/* Map the thread stack */
	z_arm64_thread_mem_domains_init(_current);
    a0009944:	d00001e0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0009948:	913f8000 	add	x0, x0, #0xfe0
    a000994c:	f9400800 	ldr	x0, [x0, #16]
    a0009950:	9400078f 	bl	a000b78c <z_arm64_thread_mem_domains_init>

	/*
	 * Reset the SP_EL0 stack pointer to the stack top discarding any old
	 * context. The actual register is written in z_arm64_userspace_enter()
	 */
	stack_ptr = Z_STACK_PTR_ALIGN(_current->stack_info.start +
    a0009954:	d00001e0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0009958:	913f8000 	add	x0, x0, #0xfe0
    a000995c:	f9400800 	ldr	x0, [x0, #16]
    a0009960:	f9406801 	ldr	x1, [x0, #208]
    a0009964:	d00001e0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0009968:	913f8000 	add	x0, x0, #0xfe0
    a000996c:	f9400800 	ldr	x0, [x0, #16]
    a0009970:	f9406c00 	ldr	x0, [x0, #216]
    a0009974:	8b000021 	add	x1, x1, x0
    a0009978:	d00001e0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000997c:	913f8000 	add	x0, x0, #0xfe0
    a0009980:	f9400800 	ldr	x0, [x0, #16]
    a0009984:	f9407000 	ldr	x0, [x0, #224]
    a0009988:	cb000020 	sub	x0, x1, x0
    a000998c:	97ffff95 	bl	a00097e0 <z_stack_ptr_align>
    a0009990:	f9001fe0 	str	x0, [sp, #56]
	 * to EL0t. On return we will be in userspace using SP_EL0.
	 *
	 * We relocate the ESF to the beginning of the privileged stack in the
	 * not user accessible part of the stack
	 */
	pInitCtx = (struct __esf *) (_current->stack_obj + ARCH_THREAD_STACK_RESERVED -
    a0009994:	d00001e0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0009998:	913f8000 	add	x0, x0, #0xfe0
    a000999c:	f9400800 	ldr	x0, [x0, #16]
    a00099a0:	f9408000 	ldr	x0, [x0, #256]
    a00099a4:	913d4000 	add	x0, x0, #0xf50
    a00099a8:	f9001be0 	str	x0, [sp, #48]
			sizeof(struct __esf));

	pInitCtx->spsr = DAIF_FIQ_BIT | SPSR_MODE_EL0T;
    a00099ac:	f9401be0 	ldr	x0, [sp, #48]
    a00099b0:	d2800801 	mov	x1, #0x40                  	// #64
    a00099b4:	f9005001 	str	x1, [x0, #160]
	pInitCtx->elr = (uint64_t)z_thread_entry;
    a00099b8:	f0ffffc0 	adrp	x0, a0004000 <fix_extra_red+0xcc>
    a00099bc:	91335001 	add	x1, x0, #0xcd4
    a00099c0:	f9401be0 	ldr	x0, [sp, #48]
    a00099c4:	f9005401 	str	x1, [x0, #168]

	pInitCtx->x0 = (uint64_t)user_entry;
    a00099c8:	f94017e1 	ldr	x1, [sp, #40]
    a00099cc:	f9401be0 	ldr	x0, [sp, #48]
    a00099d0:	f9000001 	str	x1, [x0]
	pInitCtx->x1 = (uint64_t)p1;
    a00099d4:	f94013e1 	ldr	x1, [sp, #32]
    a00099d8:	f9401be0 	ldr	x0, [sp, #48]
    a00099dc:	f9000401 	str	x1, [x0, #8]
	pInitCtx->x2 = (uint64_t)p2;
    a00099e0:	f9400fe1 	ldr	x1, [sp, #24]
    a00099e4:	f9401be0 	ldr	x0, [sp, #48]
    a00099e8:	f9000801 	str	x1, [x0, #16]
	pInitCtx->x3 = (uint64_t)p3;
    a00099ec:	f9400be1 	ldr	x1, [sp, #16]
    a00099f0:	f9401be0 	ldr	x0, [sp, #48]
    a00099f4:	f9000c01 	str	x1, [x0, #24]

	/* All the needed information is already in the ESF */
	z_arm64_userspace_enter(pInitCtx, stack_ptr);
    a00099f8:	f9401fe1 	ldr	x1, [sp, #56]
    a00099fc:	f9401be0 	ldr	x0, [sp, #48]
    a0009a00:	940007af 	bl	a000b8bc <z_arm64_userspace_enter>

00000000a0009a04 <z_arm64_serror>:

GTEXT(z_arm64_serror)
SECTION_FUNC(TEXT, z_arm64_serror)

	mov	x1, sp
    a0009a04:	910003e1 	mov	x1, sp
	mov	x0, #0 /* K_ERR_CPU_EXCEPTION */
    a0009a08:	d2800000 	mov	x0, #0x0                   	// #0

	bl	z_arm64_fatal_error
    a0009a0c:	97fffd70 	bl	a0008fcc <z_arm64_fatal_error>
	/* Return here only in case of recoverable error */
	b	z_arm64_exit_exc
    a0009a10:	14000001 	b	a0009a14 <z_arm64_exit_exc>

00000000a0009a14 <z_arm64_exit_exc>:

 GTEXT(z_arm64_exit_exc_fpu_done)
 z_arm64_exit_exc_fpu_done:
#endif

	ldp	x0, x1, [sp, ___esf_t_spsr_elr_OFFSET]
    a0009a14:	a94a07e0 	ldp	x0, x1, [sp, #160]
	msr	spsr_el1, x0
    a0009a18:	d5184000 	msr	spsr_el1, x0
	msr	elr_el1, x1
    a0009a1c:	d5184021 	msr	elr_el1, x1

	/* Restore the kernel/user mode flag and decrement exception depth */
	tst	x0, #SPSR_MODE_MASK	/* EL0 == 0 */
    a0009a20:	f2400c1f 	tst	x0, #0xf
	mrs	x0, tpidrro_el0
    a0009a24:	d53bd060 	mrs	x0, tpidrro_el0
	mov	x1, #TPIDRROEL0_EXC_UNIT
    a0009a28:	d2e02001 	mov	x1, #0x100000000000000     	// #72057594037927936
	orr	x2, x0, #TPIDRROEL0_IN_EL0
    a0009a2c:	b2400002 	orr	x2, x0, #0x1
	csel	x0, x2, x0, eq
    a0009a30:	9a800040 	csel	x0, x2, x0, eq  // eq = none
	sub	x0, x0, x1
    a0009a34:	cb010000 	sub	x0, x0, x1
	msr	tpidrro_el0, x0
    a0009a38:	d51bd060 	msr	tpidrro_el0, x0

	ldp	x0, x1, [sp, ___esf_t_x0_x1_OFFSET]
    a0009a3c:	a94007e0 	ldp	x0, x1, [sp]
	ldp	x2, x3, [sp, ___esf_t_x2_x3_OFFSET]
    a0009a40:	a9410fe2 	ldp	x2, x3, [sp, #16]
	ldp	x4, x5, [sp, ___esf_t_x4_x5_OFFSET]
    a0009a44:	a94217e4 	ldp	x4, x5, [sp, #32]
	ldp	x6, x7, [sp, ___esf_t_x6_x7_OFFSET]
    a0009a48:	a9431fe6 	ldp	x6, x7, [sp, #48]
	ldp	x8, x9, [sp, ___esf_t_x8_x9_OFFSET]
    a0009a4c:	a94427e8 	ldp	x8, x9, [sp, #64]
	ldp	x10, x11, [sp, ___esf_t_x10_x11_OFFSET]
    a0009a50:	a9452fea 	ldp	x10, x11, [sp, #80]
	ldp	x12, x13, [sp, ___esf_t_x12_x13_OFFSET]
    a0009a54:	a94637ec 	ldp	x12, x13, [sp, #96]
	ldp	x14, x15, [sp, ___esf_t_x14_x15_OFFSET]
    a0009a58:	a9473fee 	ldp	x14, x15, [sp, #112]
	ldp	x16, x17, [sp, ___esf_t_x16_x17_OFFSET]
    a0009a5c:	a94847f0 	ldp	x16, x17, [sp, #128]
	ldp	x18, x30, [sp, ___esf_t_x18_x30_OFFSET]
    a0009a60:	a9497bf2 	ldp	x18, x30, [sp, #144]

	add	sp, sp, ___esf_t_SIZEOF
    a0009a64:	9102c3ff 	add	sp, sp, #0xb0
	 * - The address of ret in z_arm64_call_svc()
	 * - The address of the next instruction at the time of the IRQ when the
	 *   thread was switched out.
	 * - The address of z_thread_entry() for new threads (see thread.c).
	 */
	eret
    a0009a68:	d69f03e0 	eret

00000000a0009a6c <z_snode_next_set>:
{
	return node->next;
}

static inline void z_snode_next_set(sys_snode_t *parent, sys_snode_t *child)
{
    a0009a6c:	d10043ff 	sub	sp, sp, #0x10
    a0009a70:	f90007e0 	str	x0, [sp, #8]
    a0009a74:	f90003e1 	str	x1, [sp]
	parent->next = child;
    a0009a78:	f94007e0 	ldr	x0, [sp, #8]
    a0009a7c:	f94003e1 	ldr	x1, [sp]
    a0009a80:	f9000001 	str	x1, [x0]
}
    a0009a84:	d503201f 	nop
    a0009a88:	910043ff 	add	sp, sp, #0x10
    a0009a8c:	d65f03c0 	ret

00000000a0009a90 <z_slist_head_set>:

static inline void z_slist_head_set(sys_slist_t *list, sys_snode_t *node)
{
    a0009a90:	d10043ff 	sub	sp, sp, #0x10
    a0009a94:	f90007e0 	str	x0, [sp, #8]
    a0009a98:	f90003e1 	str	x1, [sp]
	list->head = node;
    a0009a9c:	f94007e0 	ldr	x0, [sp, #8]
    a0009aa0:	f94003e1 	ldr	x1, [sp]
    a0009aa4:	f9000001 	str	x1, [x0]
}
    a0009aa8:	d503201f 	nop
    a0009aac:	910043ff 	add	sp, sp, #0x10
    a0009ab0:	d65f03c0 	ret

00000000a0009ab4 <z_slist_tail_set>:

static inline void z_slist_tail_set(sys_slist_t *list, sys_snode_t *node)
{
    a0009ab4:	d10043ff 	sub	sp, sp, #0x10
    a0009ab8:	f90007e0 	str	x0, [sp, #8]
    a0009abc:	f90003e1 	str	x1, [sp]
	list->tail = node;
    a0009ac0:	f94007e0 	ldr	x0, [sp, #8]
    a0009ac4:	f94003e1 	ldr	x1, [sp]
    a0009ac8:	f9000401 	str	x1, [x0, #8]
}
    a0009acc:	d503201f 	nop
    a0009ad0:	910043ff 	add	sp, sp, #0x10
    a0009ad4:	d65f03c0 	ret

00000000a0009ad8 <sys_slist_peek_tail>:
 * @param list A point on the list to peek the last node from
 *
 * @return A pointer on the last node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_tail(sys_slist_t *list)
{
    a0009ad8:	d10043ff 	sub	sp, sp, #0x10
    a0009adc:	f90007e0 	str	x0, [sp, #8]
	return list->tail;
    a0009ae0:	f94007e0 	ldr	x0, [sp, #8]
    a0009ae4:	f9400400 	ldr	x0, [x0, #8]
}
    a0009ae8:	910043ff 	add	sp, sp, #0x10
    a0009aec:	d65f03c0 	ret

00000000a0009af0 <sys_slist_append>:
 * @param node A pointer on the node to append
 */
static inline void sys_slist_append(sys_slist_t *list,
				    sys_snode_t *node);

Z_GENLIST_APPEND(slist, snode)
    a0009af0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0009af4:	910003fd 	mov	x29, sp
    a0009af8:	f9000fe0 	str	x0, [sp, #24]
    a0009afc:	f9000be1 	str	x1, [sp, #16]
    a0009b00:	d2800001 	mov	x1, #0x0                   	// #0
    a0009b04:	f9400be0 	ldr	x0, [sp, #16]
    a0009b08:	97ffffd9 	bl	a0009a6c <z_snode_next_set>
    a0009b0c:	f9400fe0 	ldr	x0, [sp, #24]
    a0009b10:	97fffff2 	bl	a0009ad8 <sys_slist_peek_tail>
    a0009b14:	f100001f 	cmp	x0, #0x0
    a0009b18:	54000101 	b.ne	a0009b38 <sys_slist_append+0x48>  // b.any
    a0009b1c:	f9400be1 	ldr	x1, [sp, #16]
    a0009b20:	f9400fe0 	ldr	x0, [sp, #24]
    a0009b24:	97ffffe4 	bl	a0009ab4 <z_slist_tail_set>
    a0009b28:	f9400be1 	ldr	x1, [sp, #16]
    a0009b2c:	f9400fe0 	ldr	x0, [sp, #24]
    a0009b30:	97ffffd8 	bl	a0009a90 <z_slist_head_set>
    a0009b34:	14000008 	b	a0009b54 <sys_slist_append+0x64>
    a0009b38:	f9400fe0 	ldr	x0, [sp, #24]
    a0009b3c:	97ffffe7 	bl	a0009ad8 <sys_slist_peek_tail>
    a0009b40:	f9400be1 	ldr	x1, [sp, #16]
    a0009b44:	97ffffca 	bl	a0009a6c <z_snode_next_set>
    a0009b48:	f9400be1 	ldr	x1, [sp, #16]
    a0009b4c:	f9400fe0 	ldr	x0, [sp, #24]
    a0009b50:	97ffffd9 	bl	a0009ab4 <z_slist_tail_set>
    a0009b54:	d503201f 	nop
    a0009b58:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0009b5c:	d65f03c0 	ret

00000000a0009b60 <arch_syscall_invoke1>:
{
    a0009b60:	d10043ff 	sub	sp, sp, #0x10
    a0009b64:	f90007e0 	str	x0, [sp, #8]
    a0009b68:	f90003e1 	str	x1, [sp]
	register uint64_t ret __asm__("x0") = arg1;
    a0009b6c:	f94007e0 	ldr	x0, [sp, #8]
	register uint64_t r8 __asm__("x8") = call_id;
    a0009b70:	f94003e8 	ldr	x8, [sp]
	__asm__ volatile("svc %[svid]\n"
    a0009b74:	d4000061 	svc	#0x3
}
    a0009b78:	910043ff 	add	sp, sp, #0x10
    a0009b7c:	d65f03c0 	ret

00000000a0009b80 <z_impl_sys_cache_data_all>:

#endif

__syscall int sys_cache_data_all(int op);
static inline int z_impl_sys_cache_data_all(int op)
{
    a0009b80:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0009b84:	910003fd 	mov	x29, sp
    a0009b88:	b9001fe0 	str	w0, [sp, #28]
#if defined(CONFIG_CACHE_MANAGEMENT)
	return cache_data_all(op);
    a0009b8c:	b9401fe0 	ldr	w0, [sp, #28]
    a0009b90:	94000754 	bl	a000b8e0 <arch_dcache_all>
#endif
	ARG_UNUSED(op);

	return -ENOTSUP;
}
    a0009b94:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0009b98:	d65f03c0 	ret

00000000a0009b9c <sys_cache_data_all>:

extern int z_impl_sys_cache_data_all(int op);

__pinned_func
static inline int sys_cache_data_all(int op)
{
    a0009b9c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0009ba0:	910003fd 	mov	x29, sp
    a0009ba4:	b9001fe0 	str	w0, [sp, #28]
	bool ret = false;
    a0009ba8:	3900bfff 	strb	wzr, [sp, #47]
	ret = false;
    a0009bac:	3900bfff 	strb	wzr, [sp, #47]
	return ret;
    a0009bb0:	3940bfe0 	ldrb	w0, [sp, #47]
#ifdef CONFIG_USERSPACE
	if (z_syscall_trap()) {
    a0009bb4:	7100001f 	cmp	w0, #0x0
    a0009bb8:	540000c0 	b.eq	a0009bd0 <sys_cache_data_all+0x34>  // b.none
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke1(*(uintptr_t *)&op, K_SYSCALL_SYS_CACHE_DATA_ALL);
    a0009bbc:	910073e0 	add	x0, sp, #0x1c
    a0009bc0:	f9400000 	ldr	x0, [x0]
    a0009bc4:	d28023a1 	mov	x1, #0x11d                 	// #285
    a0009bc8:	97ffffe6 	bl	a0009b60 <arch_syscall_invoke1>
    a0009bcc:	14000003 	b	a0009bd8 <sys_cache_data_all+0x3c>
	}
#endif
	compiler_barrier();
	return z_impl_sys_cache_data_all(op);
    a0009bd0:	b9401fe0 	ldr	w0, [sp, #28]
    a0009bd4:	97ffffeb 	bl	a0009b80 <z_impl_sys_cache_data_all>
}
    a0009bd8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0009bdc:	d65f03c0 	ret

00000000a0009be0 <new_table>:
static uint16_t xlat_use_count[CONFIG_MAX_XLAT_TABLES];
static struct k_spinlock xlat_lock;

/* Returns a reference to a free table */
static uint64_t *new_table(void)
{
    a0009be0:	d10543ff 	sub	sp, sp, #0x150
	unsigned int i;

	/* Look for a free table. */
	for (i = 0U; i < CONFIG_MAX_XLAT_TABLES; i++) {
    a0009be4:	b9014fff 	str	wzr, [sp, #332]
    a0009be8:	14000017 	b	a0009c44 <new_table+0x64>
		if (xlat_use_count[i] == 0U) {
    a0009bec:	d00001e0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0009bf0:	913e0000 	add	x0, x0, #0xf80
    a0009bf4:	b9414fe1 	ldr	w1, [sp, #332]
    a0009bf8:	78617800 	ldrh	w0, [x0, x1, lsl #1]
    a0009bfc:	7100001f 	cmp	w0, #0x0
    a0009c00:	540001c1 	b.ne	a0009c38 <new_table+0x58>  // b.any
			xlat_use_count[i] = 1U;
    a0009c04:	d00001e0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0009c08:	913e0000 	add	x0, x0, #0xf80
    a0009c0c:	b9414fe1 	ldr	w1, [sp, #332]
    a0009c10:	52800022 	mov	w2, #0x1                   	// #1
    a0009c14:	78217802 	strh	w2, [x0, x1, lsl #1]
			return &xlat_tables[i * Ln_XLAT_NUM_ENTRIES];
    a0009c18:	b9414fe0 	ldr	w0, [sp, #332]
    a0009c1c:	53175800 	lsl	w0, w0, #9
    a0009c20:	2a0003e0 	mov	w0, w0
    a0009c24:	d37df001 	lsl	x1, x0, #3
    a0009c28:	d0000120 	adrp	x0, a002f000 <xlat_tables>
    a0009c2c:	91000000 	add	x0, x0, #0x0
    a0009c30:	8b000020 	add	x0, x1, x0
    a0009c34:	14000008 	b	a0009c54 <new_table+0x74>
	for (i = 0U; i < CONFIG_MAX_XLAT_TABLES; i++) {
    a0009c38:	b9414fe0 	ldr	w0, [sp, #332]
    a0009c3c:	11000400 	add	w0, w0, #0x1
    a0009c40:	b9014fe0 	str	w0, [sp, #332]
    a0009c44:	b9414fe0 	ldr	w0, [sp, #332]
    a0009c48:	71003c1f 	cmp	w0, #0xf
    a0009c4c:	54fffd09 	b.ls	a0009bec <new_table+0xc>  // b.plast
		}
	}

	LOG_ERR("CONFIG_MAX_XLAT_TABLES, too small");
	return NULL;
    a0009c50:	d2800000 	mov	x0, #0x0                   	// #0
}
    a0009c54:	910543ff 	add	sp, sp, #0x150
    a0009c58:	d65f03c0 	ret

00000000a0009c5c <table_index>:

static inline unsigned int table_index(uint64_t *pte)
{
    a0009c5c:	d10083ff 	sub	sp, sp, #0x20
    a0009c60:	f90007e0 	str	x0, [sp, #8]
	unsigned int i = (pte - xlat_tables) / Ln_XLAT_NUM_ENTRIES;
    a0009c64:	f94007e1 	ldr	x1, [sp, #8]
    a0009c68:	d0000120 	adrp	x0, a002f000 <xlat_tables>
    a0009c6c:	91000000 	add	x0, x0, #0x0
    a0009c70:	cb000020 	sub	x0, x1, x0
    a0009c74:	9343fc00 	asr	x0, x0, #3
    a0009c78:	9107fc01 	add	x1, x0, #0x1ff
    a0009c7c:	f100001f 	cmp	x0, #0x0
    a0009c80:	9a80b020 	csel	x0, x1, x0, lt  // lt = tstop
    a0009c84:	9349fc00 	asr	x0, x0, #9
    a0009c88:	b9001fe0 	str	w0, [sp, #28]

	__ASSERT(i < CONFIG_MAX_XLAT_TABLES, "table %p out of range", pte);
	return i;
    a0009c8c:	b9401fe0 	ldr	w0, [sp, #28]
}
    a0009c90:	910083ff 	add	sp, sp, #0x20
    a0009c94:	d65f03c0 	ret

00000000a0009c98 <free_table>:

/* Makes a table free for reuse. */
static void free_table(uint64_t *table)
{
    a0009c98:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0009c9c:	910003fd 	mov	x29, sp
    a0009ca0:	f9000fe0 	str	x0, [sp, #24]
	unsigned int i = table_index(table);
    a0009ca4:	f9400fe0 	ldr	x0, [sp, #24]
    a0009ca8:	97ffffed 	bl	a0009c5c <table_index>
    a0009cac:	b9002fe0 	str	w0, [sp, #44]

	MMU_DEBUG("freeing table [%d]%p\n", i, table);
	__ASSERT(xlat_use_count[i] == 1U, "table still in use");
	xlat_use_count[i] = 0U;
    a0009cb0:	d00001e0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0009cb4:	913e0000 	add	x0, x0, #0xf80
    a0009cb8:	b9402fe1 	ldr	w1, [sp, #44]
    a0009cbc:	7821781f 	strh	wzr, [x0, x1, lsl #1]
}
    a0009cc0:	d503201f 	nop
    a0009cc4:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0009cc8:	d65f03c0 	ret

00000000a0009ccc <table_usage>:

/* Adjusts usage count and returns current count. */
static int table_usage(uint64_t *table, int adjustment)
{
    a0009ccc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0009cd0:	910003fd 	mov	x29, sp
    a0009cd4:	f9000fe0 	str	x0, [sp, #24]
    a0009cd8:	b90017e1 	str	w1, [sp, #20]
	unsigned int i = table_index(table);
    a0009cdc:	f9400fe0 	ldr	x0, [sp, #24]
    a0009ce0:	97ffffdf 	bl	a0009c5c <table_index>
    a0009ce4:	b9002fe0 	str	w0, [sp, #44]

	xlat_use_count[i] += adjustment;
    a0009ce8:	d00001e0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0009cec:	913e0000 	add	x0, x0, #0xf80
    a0009cf0:	b9402fe1 	ldr	w1, [sp, #44]
    a0009cf4:	78617801 	ldrh	w1, [x0, x1, lsl #1]
    a0009cf8:	b94017e0 	ldr	w0, [sp, #20]
    a0009cfc:	12003c00 	and	w0, w0, #0xffff
    a0009d00:	0b000020 	add	w0, w1, w0
    a0009d04:	12003c02 	and	w2, w0, #0xffff
    a0009d08:	d00001e0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0009d0c:	913e0000 	add	x0, x0, #0xf80
    a0009d10:	b9402fe1 	ldr	w1, [sp, #44]
    a0009d14:	78217802 	strh	w2, [x0, x1, lsl #1]
	__ASSERT(xlat_use_count[i] > 0, "usage count underflow");
	return xlat_use_count[i];
    a0009d18:	d00001e0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0009d1c:	913e0000 	add	x0, x0, #0xf80
    a0009d20:	b9402fe1 	ldr	w1, [sp, #44]
    a0009d24:	78617800 	ldrh	w0, [x0, x1, lsl #1]
}
    a0009d28:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0009d2c:	d65f03c0 	ret

00000000a0009d30 <is_table_unused>:

static inline bool is_table_unused(uint64_t *table)
{
    a0009d30:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0009d34:	910003fd 	mov	x29, sp
    a0009d38:	f9000fe0 	str	x0, [sp, #24]
	return table_usage(table, 0) == 1;
    a0009d3c:	52800001 	mov	w1, #0x0                   	// #0
    a0009d40:	f9400fe0 	ldr	x0, [sp, #24]
    a0009d44:	97ffffe2 	bl	a0009ccc <table_usage>
    a0009d48:	7100041f 	cmp	w0, #0x1
    a0009d4c:	1a9f17e0 	cset	w0, eq  // eq = none
    a0009d50:	12001c00 	and	w0, w0, #0xff
}
    a0009d54:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0009d58:	d65f03c0 	ret

00000000a0009d5c <is_free_desc>:

static inline bool is_free_desc(uint64_t desc)
{
    a0009d5c:	d10043ff 	sub	sp, sp, #0x10
    a0009d60:	f90007e0 	str	x0, [sp, #8]
	return (desc & PTE_DESC_TYPE_MASK) == PTE_INVALID_DESC;
    a0009d64:	f94007e0 	ldr	x0, [sp, #8]
    a0009d68:	92400400 	and	x0, x0, #0x3
    a0009d6c:	f100001f 	cmp	x0, #0x0
    a0009d70:	1a9f17e0 	cset	w0, eq  // eq = none
    a0009d74:	12001c00 	and	w0, w0, #0xff
}
    a0009d78:	910043ff 	add	sp, sp, #0x10
    a0009d7c:	d65f03c0 	ret

00000000a0009d80 <is_table_desc>:

static inline bool is_table_desc(uint64_t desc, unsigned int level)
{
    a0009d80:	d10043ff 	sub	sp, sp, #0x10
    a0009d84:	f90007e0 	str	x0, [sp, #8]
    a0009d88:	b90007e1 	str	w1, [sp, #4]
	return level != XLAT_LAST_LEVEL &&
    a0009d8c:	b94007e0 	ldr	w0, [sp, #4]
    a0009d90:	71000c1f 	cmp	w0, #0x3
    a0009d94:	540000e0 	b.eq	a0009db0 <is_table_desc+0x30>  // b.none
	       (desc & PTE_DESC_TYPE_MASK) == PTE_TABLE_DESC;
    a0009d98:	f94007e0 	ldr	x0, [sp, #8]
    a0009d9c:	92400400 	and	x0, x0, #0x3
	return level != XLAT_LAST_LEVEL &&
    a0009da0:	f1000c1f 	cmp	x0, #0x3
    a0009da4:	54000061 	b.ne	a0009db0 <is_table_desc+0x30>  // b.any
    a0009da8:	52800020 	mov	w0, #0x1                   	// #1
    a0009dac:	14000002 	b	a0009db4 <is_table_desc+0x34>
    a0009db0:	52800000 	mov	w0, #0x0                   	// #0
    a0009db4:	12000000 	and	w0, w0, #0x1
    a0009db8:	12001c00 	and	w0, w0, #0xff
}
    a0009dbc:	910043ff 	add	sp, sp, #0x10
    a0009dc0:	d65f03c0 	ret

00000000a0009dc4 <pte_desc_table>:
{
	return (desc & PTE_DESC_TYPE_MASK) == PTE_BLOCK_DESC;
}

static inline uint64_t *pte_desc_table(uint64_t desc)
{
    a0009dc4:	d10083ff 	sub	sp, sp, #0x20
    a0009dc8:	f90007e0 	str	x0, [sp, #8]
	uint64_t address = desc & GENMASK(47, PAGE_SIZE_SHIFT);
    a0009dcc:	f94007e0 	ldr	x0, [sp, #8]
    a0009dd0:	92748c00 	and	x0, x0, #0xfffffffff000
    a0009dd4:	f9000fe0 	str	x0, [sp, #24]

	return (uint64_t *)address;
    a0009dd8:	f9400fe0 	ldr	x0, [sp, #24]
}
    a0009ddc:	910083ff 	add	sp, sp, #0x20
    a0009de0:	d65f03c0 	ret

00000000a0009de4 <is_desc_block_aligned>:

static inline bool is_desc_block_aligned(uint64_t desc, unsigned int level_size)
{
    a0009de4:	d10083ff 	sub	sp, sp, #0x20
    a0009de8:	f90007e0 	str	x0, [sp, #8]
    a0009dec:	b90007e1 	str	w1, [sp, #4]
	uint64_t mask = GENMASK(47, PAGE_SIZE_SHIFT);
    a0009df0:	b2748fe0 	mov	x0, #0xfffffffff000        	// #281474976706560
    a0009df4:	f9000fe0 	str	x0, [sp, #24]
	bool aligned = !((desc & mask) & (level_size - 1));
    a0009df8:	f94007e1 	ldr	x1, [sp, #8]
    a0009dfc:	f9400fe0 	ldr	x0, [sp, #24]
    a0009e00:	8a000021 	and	x1, x1, x0
    a0009e04:	b94007e0 	ldr	w0, [sp, #4]
    a0009e08:	51000400 	sub	w0, w0, #0x1
    a0009e0c:	2a0003e0 	mov	w0, w0
    a0009e10:	8a000020 	and	x0, x1, x0
    a0009e14:	f100001f 	cmp	x0, #0x0
    a0009e18:	1a9f17e0 	cset	w0, eq  // eq = none
    a0009e1c:	39005fe0 	strb	w0, [sp, #23]
	if (!aligned) {
		MMU_DEBUG("misaligned desc 0x%016llx for block size 0x%x\n",
			  desc, level_size);
	}

	return aligned;
    a0009e20:	39405fe0 	ldrb	w0, [sp, #23]
}
    a0009e24:	910083ff 	add	sp, sp, #0x20
    a0009e28:	d65f03c0 	ret

00000000a0009e2c <is_desc_superset>:

static inline bool is_desc_superset(uint64_t desc1, uint64_t desc2,
				    unsigned int level)
{
    a0009e2c:	d100c3ff 	sub	sp, sp, #0x30
    a0009e30:	f9000fe0 	str	x0, [sp, #24]
    a0009e34:	f9000be1 	str	x1, [sp, #16]
    a0009e38:	b9000fe2 	str	w2, [sp, #12]
	uint64_t mask = DESC_ATTRS_MASK | GENMASK(47, LEVEL_TO_VA_SIZE_SHIFT(level));
    a0009e3c:	b9400fe1 	ldr	w1, [sp, #12]
    a0009e40:	12800100 	mov	w0, #0xfffffff7            	// #-9
    a0009e44:	1b007c20 	mul	w0, w1, w0
    a0009e48:	11009c00 	add	w0, w0, #0x27
    a0009e4c:	d2800021 	mov	x1, #0x1                   	// #1
    a0009e50:	9ac02020 	lsl	x0, x1, x0
    a0009e54:	cb0003e1 	neg	x1, x0
    a0009e58:	1281ff80 	mov	w0, #0xfffff003            	// #-4093
    a0009e5c:	f2dfffe0 	movk	x0, #0xffff, lsl #32
    a0009e60:	8a000021 	and	x1, x1, x0
    a0009e64:	d281ff80 	mov	x0, #0xffc                 	// #4092
    a0009e68:	f2ffff00 	movk	x0, #0xfff8, lsl #48
    a0009e6c:	aa000020 	orr	x0, x1, x0
    a0009e70:	f90017e0 	str	x0, [sp, #40]

	return (desc1 & mask) == (desc2 & mask);
    a0009e74:	f9400fe1 	ldr	x1, [sp, #24]
    a0009e78:	f9400be0 	ldr	x0, [sp, #16]
    a0009e7c:	ca000021 	eor	x1, x1, x0
    a0009e80:	f94017e0 	ldr	x0, [sp, #40]
    a0009e84:	8a000020 	and	x0, x1, x0
    a0009e88:	f100001f 	cmp	x0, #0x0
    a0009e8c:	1a9f17e0 	cset	w0, eq  // eq = none
    a0009e90:	12001c00 	and	w0, w0, #0xff
}
    a0009e94:	9100c3ff 	add	sp, sp, #0x30
    a0009e98:	d65f03c0 	ret

00000000a0009e9c <debug_show_pte>:
	MMU_DEBUG((*pte & PTE_BLOCK_DESC_PXN) ? "-PXN" : "-PX");
	MMU_DEBUG((*pte & PTE_BLOCK_DESC_UXN) ? "-UXN" : "-UX");
	MMU_DEBUG("\n");
}
#else
static inline void debug_show_pte(uint64_t *pte, unsigned int level) { }
    a0009e9c:	d10043ff 	sub	sp, sp, #0x10
    a0009ea0:	f90007e0 	str	x0, [sp, #8]
    a0009ea4:	b90007e1 	str	w1, [sp, #4]
    a0009ea8:	d503201f 	nop
    a0009eac:	910043ff 	add	sp, sp, #0x10
    a0009eb0:	d65f03c0 	ret

00000000a0009eb4 <set_pte_table_desc>:
#endif

static void set_pte_table_desc(uint64_t *pte, uint64_t *table, unsigned int level)
{
    a0009eb4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0009eb8:	910003fd 	mov	x29, sp
    a0009ebc:	f90017e0 	str	x0, [sp, #40]
    a0009ec0:	f90013e1 	str	x1, [sp, #32]
    a0009ec4:	b9001fe2 	str	w2, [sp, #28]
	/* Point pte to new table */
	*pte = PTE_TABLE_DESC | (uint64_t)table;
    a0009ec8:	f94013e0 	ldr	x0, [sp, #32]
    a0009ecc:	b2400401 	orr	x1, x0, #0x3
    a0009ed0:	f94017e0 	ldr	x0, [sp, #40]
    a0009ed4:	f9000001 	str	x1, [x0]
	debug_show_pte(pte, level);
    a0009ed8:	b9401fe1 	ldr	w1, [sp, #28]
    a0009edc:	f94017e0 	ldr	x0, [sp, #40]
    a0009ee0:	97ffffef 	bl	a0009e9c <debug_show_pte>
}
    a0009ee4:	d503201f 	nop
    a0009ee8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0009eec:	d65f03c0 	ret

00000000a0009ef0 <set_pte_block_desc>:

static void set_pte_block_desc(uint64_t *pte, uint64_t desc, unsigned int level)
{
    a0009ef0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0009ef4:	910003fd 	mov	x29, sp
    a0009ef8:	f90017e0 	str	x0, [sp, #40]
    a0009efc:	f90013e1 	str	x1, [sp, #32]
    a0009f00:	b9001fe2 	str	w2, [sp, #28]
	if (desc) {
    a0009f04:	f94013e0 	ldr	x0, [sp, #32]
    a0009f08:	f100001f 	cmp	x0, #0x0
    a0009f0c:	54000140 	b.eq	a0009f34 <set_pte_block_desc+0x44>  // b.none
		desc |= (level == XLAT_LAST_LEVEL) ? PTE_PAGE_DESC : PTE_BLOCK_DESC;
    a0009f10:	b9401fe0 	ldr	w0, [sp, #28]
    a0009f14:	71000c1f 	cmp	w0, #0x3
    a0009f18:	54000061 	b.ne	a0009f24 <set_pte_block_desc+0x34>  // b.any
    a0009f1c:	d2800060 	mov	x0, #0x3                   	// #3
    a0009f20:	14000002 	b	a0009f28 <set_pte_block_desc+0x38>
    a0009f24:	d2800020 	mov	x0, #0x1                   	// #1
    a0009f28:	f94013e1 	ldr	x1, [sp, #32]
    a0009f2c:	aa000020 	orr	x0, x1, x0
    a0009f30:	f90013e0 	str	x0, [sp, #32]
	}
	*pte = desc;
    a0009f34:	f94017e0 	ldr	x0, [sp, #40]
    a0009f38:	f94013e1 	ldr	x1, [sp, #32]
    a0009f3c:	f9000001 	str	x1, [x0]
	debug_show_pte(pte, level);
    a0009f40:	b9401fe1 	ldr	w1, [sp, #28]
    a0009f44:	f94017e0 	ldr	x0, [sp, #40]
    a0009f48:	97ffffd5 	bl	a0009e9c <debug_show_pte>
}
    a0009f4c:	d503201f 	nop
    a0009f50:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0009f54:	d65f03c0 	ret

00000000a0009f58 <expand_to_table>:

static uint64_t *expand_to_table(uint64_t *pte, unsigned int level)
{
    a0009f58:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    a0009f5c:	910003fd 	mov	x29, sp
    a0009f60:	f9000fe0 	str	x0, [sp, #24]
    a0009f64:	b90017e1 	str	w1, [sp, #20]
	uint64_t *table;

	__ASSERT(level < XLAT_LAST_LEVEL, "can't expand last level");

	table = new_table();
    a0009f68:	97ffff1e 	bl	a0009be0 <new_table>
    a0009f6c:	f90017e0 	str	x0, [sp, #40]
	if (!table) {
    a0009f70:	f94017e0 	ldr	x0, [sp, #40]
    a0009f74:	f100001f 	cmp	x0, #0x0
    a0009f78:	54000061 	b.ne	a0009f84 <expand_to_table+0x2c>  // b.any
		return NULL;
    a0009f7c:	d2800000 	mov	x0, #0x0                   	// #0
    a0009f80:	14000039 	b	a000a064 <expand_to_table+0x10c>
	}

	if (!is_free_desc(*pte)) {
    a0009f84:	f9400fe0 	ldr	x0, [sp, #24]
    a0009f88:	f9400000 	ldr	x0, [x0]
    a0009f8c:	97ffff74 	bl	a0009d5c <is_free_desc>
    a0009f90:	12001c00 	and	w0, w0, #0xff
    a0009f94:	52000000 	eor	w0, w0, #0x1
    a0009f98:	12001c00 	and	w0, w0, #0xff
    a0009f9c:	7100001f 	cmp	w0, #0x0
    a0009fa0:	540004c0 	b.eq	a000a038 <expand_to_table+0xe0>  // b.none
		/*
		 * If entry at current level was already populated
		 * then we need to reflect that in the new table.
		 */
		uint64_t desc = *pte;
    a0009fa4:	f9400fe0 	ldr	x0, [sp, #24]
    a0009fa8:	f9400000 	ldr	x0, [x0]
    a0009fac:	f9001fe0 	str	x0, [sp, #56]

		MMU_DEBUG("expanding PTE 0x%016llx into table [%d]%p\n",
			  desc, table_index(table), table);
		__ASSERT(is_block_desc(desc), "");

		if (level + 1 == XLAT_LAST_LEVEL) {
    a0009fb0:	b94017e0 	ldr	w0, [sp, #20]
    a0009fb4:	7100081f 	cmp	w0, #0x2
    a0009fb8:	54000081 	b.ne	a0009fc8 <expand_to_table+0x70>  // b.any
			desc |= PTE_PAGE_DESC;
    a0009fbc:	f9401fe0 	ldr	x0, [sp, #56]
    a0009fc0:	b2400400 	orr	x0, x0, #0x3
    a0009fc4:	f9001fe0 	str	x0, [sp, #56]
		}

		stride_shift = LEVEL_TO_VA_SIZE_SHIFT(level + 1);
    a0009fc8:	b94017e1 	ldr	w1, [sp, #20]
    a0009fcc:	12800100 	mov	w0, #0xfffffff7            	// #-9
    a0009fd0:	1b007c20 	mul	w0, w1, w0
    a0009fd4:	11007800 	add	w0, w0, #0x1e
    a0009fd8:	b90027e0 	str	w0, [sp, #36]
		for (i = 0U; i < Ln_XLAT_NUM_ENTRIES; i++) {
    a0009fdc:	b90037ff 	str	wzr, [sp, #52]
    a0009fe0:	1400000f 	b	a000a01c <expand_to_table+0xc4>
			table[i] = desc | (i << stride_shift);
    a0009fe4:	b94027e0 	ldr	w0, [sp, #36]
    a0009fe8:	b94037e1 	ldr	w1, [sp, #52]
    a0009fec:	1ac02020 	lsl	w0, w1, w0
    a0009ff0:	2a0003e2 	mov	w2, w0
    a0009ff4:	b94037e0 	ldr	w0, [sp, #52]
    a0009ff8:	d37df000 	lsl	x0, x0, #3
    a0009ffc:	f94017e1 	ldr	x1, [sp, #40]
    a000a000:	8b000020 	add	x0, x1, x0
    a000a004:	f9401fe1 	ldr	x1, [sp, #56]
    a000a008:	aa010041 	orr	x1, x2, x1
    a000a00c:	f9000001 	str	x1, [x0]
		for (i = 0U; i < Ln_XLAT_NUM_ENTRIES; i++) {
    a000a010:	b94037e0 	ldr	w0, [sp, #52]
    a000a014:	11000400 	add	w0, w0, #0x1
    a000a018:	b90037e0 	str	w0, [sp, #52]
    a000a01c:	b94037e0 	ldr	w0, [sp, #52]
    a000a020:	7107fc1f 	cmp	w0, #0x1ff
    a000a024:	54fffe09 	b.ls	a0009fe4 <expand_to_table+0x8c>  // b.plast
		}
		table_usage(table, Ln_XLAT_NUM_ENTRIES);
    a000a028:	52804001 	mov	w1, #0x200                 	// #512
    a000a02c:	f94017e0 	ldr	x0, [sp, #40]
    a000a030:	97ffff27 	bl	a0009ccc <table_usage>
    a000a034:	14000004 	b	a000a044 <expand_to_table+0xec>
	} else {
		/*
		 * Adjust usage count for parent table's entry
		 * that will no longer be free.
		 */
		table_usage(pte, 1);
    a000a038:	52800021 	mov	w1, #0x1                   	// #1
    a000a03c:	f9400fe0 	ldr	x0, [sp, #24]
    a000a040:	97ffff23 	bl	a0009ccc <table_usage>
	}

	/* Link the new table in place of the pte it replaces */
	set_pte_table_desc(pte, table, level);
    a000a044:	b94017e2 	ldr	w2, [sp, #20]
    a000a048:	f94017e1 	ldr	x1, [sp, #40]
    a000a04c:	f9400fe0 	ldr	x0, [sp, #24]
    a000a050:	97ffff99 	bl	a0009eb4 <set_pte_table_desc>
	table_usage(table, 1);
    a000a054:	52800021 	mov	w1, #0x1                   	// #1
    a000a058:	f94017e0 	ldr	x0, [sp, #40]
    a000a05c:	97ffff1c 	bl	a0009ccc <table_usage>

	return table;
    a000a060:	f94017e0 	ldr	x0, [sp, #40]
}
    a000a064:	a8c47bfd 	ldp	x29, x30, [sp], #64
    a000a068:	d65f03c0 	ret

00000000a000a06c <set_mapping>:

static int set_mapping(struct arm_mmu_ptables *ptables,
		       uintptr_t virt, size_t size,
		       uint64_t desc, bool may_overwrite)
{
    a000a06c:	d108c3ff 	sub	sp, sp, #0x230
    a000a070:	a9007bfd 	stp	x29, x30, [sp]
    a000a074:	910003fd 	mov	x29, sp
    a000a078:	f9001fe0 	str	x0, [sp, #56]
    a000a07c:	f9001be1 	str	x1, [sp, #48]
    a000a080:	f90017e2 	str	x2, [sp, #40]
    a000a084:	f90013e3 	str	x3, [sp, #32]
    a000a088:	39007fe4 	strb	w4, [sp, #31]
	uint64_t *pte, *ptes[XLAT_LAST_LEVEL + 1];
	uint64_t level_size;
	uint64_t *table = ptables->base_xlat_table;
    a000a08c:	f9401fe0 	ldr	x0, [sp, #56]
    a000a090:	f9400000 	ldr	x0, [x0]
    a000a094:	f90117e0 	str	x0, [sp, #552]
	unsigned int level = BASE_XLAT_LEVEL;
    a000a098:	52800020 	mov	w0, #0x1                   	// #1
    a000a09c:	b90227e0 	str	w0, [sp, #548]
	int ret = 0;
    a000a0a0:	b90217ff 	str	wzr, [sp, #532]

	while (size) {
    a000a0a4:	140000b5 	b	a000a378 <set_mapping+0x30c>
		__ASSERT(level <= XLAT_LAST_LEVEL,
			 "max translation table level exceeded\n");

		/* Locate PTE for given virtual address and page table level */
		pte = &table[XLAT_TABLE_VA_IDX(virt, level)];
    a000a0a8:	b94227e1 	ldr	w1, [sp, #548]
    a000a0ac:	12800100 	mov	w0, #0xfffffff7            	// #-9
    a000a0b0:	1b007c20 	mul	w0, w1, w0
    a000a0b4:	11009c00 	add	w0, w0, #0x27
    a000a0b8:	f9401be1 	ldr	x1, [sp, #48]
    a000a0bc:	9ac02420 	lsr	x0, x1, x0
    a000a0c0:	92402000 	and	x0, x0, #0x1ff
    a000a0c4:	d37df000 	lsl	x0, x0, #3
    a000a0c8:	f94117e1 	ldr	x1, [sp, #552]
    a000a0cc:	8b000020 	add	x0, x1, x0
    a000a0d0:	f90107e0 	str	x0, [sp, #520]
		ptes[level] = pte;
    a000a0d4:	9108e3e0 	add	x0, sp, #0x238
    a000a0d8:	d1014000 	sub	x0, x0, #0x50
    a000a0dc:	b94227e1 	ldr	w1, [sp, #548]
    a000a0e0:	f94107e2 	ldr	x2, [sp, #520]
    a000a0e4:	f8217802 	str	x2, [x0, x1, lsl #3]

		if (is_table_desc(*pte, level)) {
    a000a0e8:	f94107e0 	ldr	x0, [sp, #520]
    a000a0ec:	f9400000 	ldr	x0, [x0]
    a000a0f0:	b94227e1 	ldr	w1, [sp, #548]
    a000a0f4:	97ffff23 	bl	a0009d80 <is_table_desc>
    a000a0f8:	12001c00 	and	w0, w0, #0xff
    a000a0fc:	7100001f 	cmp	w0, #0x0
    a000a100:	54000120 	b.eq	a000a124 <set_mapping+0xb8>  // b.none
			/* Move to the next translation table level */
			level++;
    a000a104:	b94227e0 	ldr	w0, [sp, #548]
    a000a108:	11000400 	add	w0, w0, #0x1
    a000a10c:	b90227e0 	str	w0, [sp, #548]
			table = pte_desc_table(*pte);
    a000a110:	f94107e0 	ldr	x0, [sp, #520]
    a000a114:	f9400000 	ldr	x0, [x0]
    a000a118:	97ffff2b 	bl	a0009dc4 <pte_desc_table>
    a000a11c:	f90117e0 	str	x0, [sp, #552]
			continue;
    a000a120:	14000096 	b	a000a378 <set_mapping+0x30c>
		}

		if (!may_overwrite && !is_free_desc(*pte)) {
    a000a124:	39407fe0 	ldrb	w0, [sp, #31]
    a000a128:	52000000 	eor	w0, w0, #0x1
    a000a12c:	12001c00 	and	w0, w0, #0xff
    a000a130:	7100001f 	cmp	w0, #0x0
    a000a134:	54000180 	b.eq	a000a164 <set_mapping+0xf8>  // b.none
    a000a138:	f94107e0 	ldr	x0, [sp, #520]
    a000a13c:	f9400000 	ldr	x0, [x0]
    a000a140:	97ffff07 	bl	a0009d5c <is_free_desc>
    a000a144:	12001c00 	and	w0, w0, #0xff
    a000a148:	52000000 	eor	w0, w0, #0x1
    a000a14c:	12001c00 	and	w0, w0, #0xff
    a000a150:	7100001f 	cmp	w0, #0x0
    a000a154:	54000080 	b.eq	a000a164 <set_mapping+0xf8>  // b.none
			/* the entry is already allocated */
			LOG_ERR("entry already in use: "
				"level %d pte %p *pte 0x%016llx",
				level, pte, *pte);
			ret = -EBUSY;
    a000a158:	128001e0 	mov	w0, #0xfffffff0            	// #-16
    a000a15c:	b90217e0 	str	w0, [sp, #532]
			break;
    a000a160:	14000089 	b	a000a384 <set_mapping+0x318>
		}

		level_size = 1ULL << LEVEL_TO_VA_SIZE_SHIFT(level);
    a000a164:	b94227e1 	ldr	w1, [sp, #548]
    a000a168:	12800100 	mov	w0, #0xfffffff7            	// #-9
    a000a16c:	1b007c20 	mul	w0, w1, w0
    a000a170:	11009c00 	add	w0, w0, #0x27
    a000a174:	d2800021 	mov	x1, #0x1                   	// #1
    a000a178:	9ac02020 	lsl	x0, x1, x0
    a000a17c:	f9010fe0 	str	x0, [sp, #536]

		if (is_desc_superset(*pte, desc, level)) {
    a000a180:	f94107e0 	ldr	x0, [sp, #520]
    a000a184:	f9400000 	ldr	x0, [x0]
    a000a188:	b94227e2 	ldr	w2, [sp, #548]
    a000a18c:	f94013e1 	ldr	x1, [sp, #32]
    a000a190:	97ffff27 	bl	a0009e2c <is_desc_superset>
    a000a194:	12001c00 	and	w0, w0, #0xff
    a000a198:	7100001f 	cmp	w0, #0x0
    a000a19c:	540001e0 	b.eq	a000a1d8 <set_mapping+0x16c>  // b.none
			/* This block already covers our range */
			level_size -= (virt & (level_size - 1));
    a000a1a0:	f9410fe0 	ldr	x0, [sp, #536]
    a000a1a4:	d1000401 	sub	x1, x0, #0x1
    a000a1a8:	f9401be0 	ldr	x0, [sp, #48]
    a000a1ac:	8a000020 	and	x0, x1, x0
    a000a1b0:	f9410fe1 	ldr	x1, [sp, #536]
    a000a1b4:	cb000020 	sub	x0, x1, x0
    a000a1b8:	f9010fe0 	str	x0, [sp, #536]
			if (level_size > size) {
    a000a1bc:	f9410fe1 	ldr	x1, [sp, #536]
    a000a1c0:	f94017e0 	ldr	x0, [sp, #40]
    a000a1c4:	eb00003f 	cmp	x1, x0
    a000a1c8:	54000a69 	b.ls	a000a314 <set_mapping+0x2a8>  // b.plast
				level_size = size;
    a000a1cc:	f94017e0 	ldr	x0, [sp, #40]
    a000a1d0:	f9010fe0 	str	x0, [sp, #536]
			}
			goto move_on;
    a000a1d4:	14000050 	b	a000a314 <set_mapping+0x2a8>
		}

		if ((size < level_size) || (virt & (level_size - 1)) ||
    a000a1d8:	f94017e1 	ldr	x1, [sp, #40]
    a000a1dc:	f9410fe0 	ldr	x0, [sp, #536]
    a000a1e0:	eb00003f 	cmp	x1, x0
    a000a1e4:	54000203 	b.cc	a000a224 <set_mapping+0x1b8>  // b.lo, b.ul, b.last
    a000a1e8:	f9410fe0 	ldr	x0, [sp, #536]
    a000a1ec:	d1000401 	sub	x1, x0, #0x1
    a000a1f0:	f9401be0 	ldr	x0, [sp, #48]
    a000a1f4:	8a000020 	and	x0, x1, x0
    a000a1f8:	f100001f 	cmp	x0, #0x0
    a000a1fc:	54000141 	b.ne	a000a224 <set_mapping+0x1b8>  // b.any
		    !is_desc_block_aligned(desc, level_size)) {
    a000a200:	f9410fe0 	ldr	x0, [sp, #536]
    a000a204:	2a0003e1 	mov	w1, w0
    a000a208:	f94013e0 	ldr	x0, [sp, #32]
    a000a20c:	97fffef6 	bl	a0009de4 <is_desc_block_aligned>
    a000a210:	12001c00 	and	w0, w0, #0xff
    a000a214:	52000000 	eor	w0, w0, #0x1
    a000a218:	12001c00 	and	w0, w0, #0xff
		if ((size < level_size) || (virt & (level_size - 1)) ||
    a000a21c:	7100001f 	cmp	w0, #0x0
    a000a220:	540001e0 	b.eq	a000a25c <set_mapping+0x1f0>  // b.none
			/* Range doesn't fit, create subtable */
			table = expand_to_table(pte, level);
    a000a224:	b94227e1 	ldr	w1, [sp, #548]
    a000a228:	f94107e0 	ldr	x0, [sp, #520]
    a000a22c:	97ffff4b 	bl	a0009f58 <expand_to_table>
    a000a230:	f90117e0 	str	x0, [sp, #552]
			if (!table) {
    a000a234:	f94117e0 	ldr	x0, [sp, #552]
    a000a238:	f100001f 	cmp	x0, #0x0
    a000a23c:	54000081 	b.ne	a000a24c <set_mapping+0x1e0>  // b.any
				ret = -ENOMEM;
    a000a240:	12800160 	mov	w0, #0xfffffff4            	// #-12
    a000a244:	b90217e0 	str	w0, [sp, #532]
				break;
    a000a248:	1400004f 	b	a000a384 <set_mapping+0x318>
			}
			level++;
    a000a24c:	b94227e0 	ldr	w0, [sp, #548]
    a000a250:	11000400 	add	w0, w0, #0x1
    a000a254:	b90227e0 	str	w0, [sp, #548]
			continue;
    a000a258:	14000048 	b	a000a378 <set_mapping+0x30c>
		}

		/* Adjust usage count for corresponding table */
		if (is_free_desc(*pte)) {
    a000a25c:	f94107e0 	ldr	x0, [sp, #520]
    a000a260:	f9400000 	ldr	x0, [x0]
    a000a264:	97fffebe 	bl	a0009d5c <is_free_desc>
    a000a268:	12001c00 	and	w0, w0, #0xff
    a000a26c:	7100001f 	cmp	w0, #0x0
    a000a270:	54000080 	b.eq	a000a280 <set_mapping+0x214>  // b.none
			table_usage(pte, 1);
    a000a274:	52800021 	mov	w1, #0x1                   	// #1
    a000a278:	f94107e0 	ldr	x0, [sp, #520]
    a000a27c:	97fffe94 	bl	a0009ccc <table_usage>
		}
		if (!desc) {
    a000a280:	f94013e0 	ldr	x0, [sp, #32]
    a000a284:	f100001f 	cmp	x0, #0x0
    a000a288:	54000081 	b.ne	a000a298 <set_mapping+0x22c>  // b.any
			table_usage(pte, -1);
    a000a28c:	12800001 	mov	w1, #0xffffffff            	// #-1
    a000a290:	f94107e0 	ldr	x0, [sp, #520]
    a000a294:	97fffe8e 	bl	a0009ccc <table_usage>
		}
		/* Create (or erase) block/page descriptor */
		set_pte_block_desc(pte, desc, level);
    a000a298:	b94227e2 	ldr	w2, [sp, #548]
    a000a29c:	f94013e1 	ldr	x1, [sp, #32]
    a000a2a0:	f94107e0 	ldr	x0, [sp, #520]
    a000a2a4:	97ffff13 	bl	a0009ef0 <set_pte_block_desc>

		/* recursively free unused tables if any */
		while (level != BASE_XLAT_LEVEL &&
    a000a2a8:	14000012 	b	a000a2f0 <set_mapping+0x284>
		       is_table_unused(pte)) {
			free_table(pte);
    a000a2ac:	f94107e0 	ldr	x0, [sp, #520]
    a000a2b0:	97fffe7a 	bl	a0009c98 <free_table>
			pte = ptes[--level];
    a000a2b4:	b94227e0 	ldr	w0, [sp, #548]
    a000a2b8:	51000400 	sub	w0, w0, #0x1
    a000a2bc:	b90227e0 	str	w0, [sp, #548]
    a000a2c0:	9108e3e0 	add	x0, sp, #0x238
    a000a2c4:	d1014000 	sub	x0, x0, #0x50
    a000a2c8:	b94227e1 	ldr	w1, [sp, #548]
    a000a2cc:	f8617800 	ldr	x0, [x0, x1, lsl #3]
    a000a2d0:	f90107e0 	str	x0, [sp, #520]
			set_pte_block_desc(pte, 0, level);
    a000a2d4:	b94227e2 	ldr	w2, [sp, #548]
    a000a2d8:	d2800001 	mov	x1, #0x0                   	// #0
    a000a2dc:	f94107e0 	ldr	x0, [sp, #520]
    a000a2e0:	97ffff04 	bl	a0009ef0 <set_pte_block_desc>
			table_usage(pte, -1);
    a000a2e4:	12800001 	mov	w1, #0xffffffff            	// #-1
    a000a2e8:	f94107e0 	ldr	x0, [sp, #520]
    a000a2ec:	97fffe78 	bl	a0009ccc <table_usage>
		while (level != BASE_XLAT_LEVEL &&
    a000a2f0:	b94227e0 	ldr	w0, [sp, #548]
    a000a2f4:	7100041f 	cmp	w0, #0x1
    a000a2f8:	54000120 	b.eq	a000a31c <set_mapping+0x2b0>  // b.none
		       is_table_unused(pte)) {
    a000a2fc:	f94107e0 	ldr	x0, [sp, #520]
    a000a300:	97fffe8c 	bl	a0009d30 <is_table_unused>
    a000a304:	12001c00 	and	w0, w0, #0xff
		while (level != BASE_XLAT_LEVEL &&
    a000a308:	7100001f 	cmp	w0, #0x0
    a000a30c:	54fffd01 	b.ne	a000a2ac <set_mapping+0x240>  // b.any
		}

move_on:
    a000a310:	14000003 	b	a000a31c <set_mapping+0x2b0>
			goto move_on;
    a000a314:	d503201f 	nop
    a000a318:	14000002 	b	a000a320 <set_mapping+0x2b4>
move_on:
    a000a31c:	d503201f 	nop
		virt += level_size;
    a000a320:	f9401be1 	ldr	x1, [sp, #48]
    a000a324:	f9410fe0 	ldr	x0, [sp, #536]
    a000a328:	8b000020 	add	x0, x1, x0
    a000a32c:	f9001be0 	str	x0, [sp, #48]
		desc += desc ? level_size : 0;
    a000a330:	f94013e0 	ldr	x0, [sp, #32]
    a000a334:	f100001f 	cmp	x0, #0x0
    a000a338:	54000060 	b.eq	a000a344 <set_mapping+0x2d8>  // b.none
    a000a33c:	f9410fe0 	ldr	x0, [sp, #536]
    a000a340:	14000002 	b	a000a348 <set_mapping+0x2dc>
    a000a344:	d2800000 	mov	x0, #0x0                   	// #0
    a000a348:	f94013e1 	ldr	x1, [sp, #32]
    a000a34c:	8b000020 	add	x0, x1, x0
    a000a350:	f90013e0 	str	x0, [sp, #32]
		size -= level_size;
    a000a354:	f94017e1 	ldr	x1, [sp, #40]
    a000a358:	f9410fe0 	ldr	x0, [sp, #536]
    a000a35c:	cb000020 	sub	x0, x1, x0
    a000a360:	f90017e0 	str	x0, [sp, #40]

		/* Range is mapped, start again for next range */
		table = ptables->base_xlat_table;
    a000a364:	f9401fe0 	ldr	x0, [sp, #56]
    a000a368:	f9400000 	ldr	x0, [x0]
    a000a36c:	f90117e0 	str	x0, [sp, #552]
		level = BASE_XLAT_LEVEL;
    a000a370:	52800020 	mov	w0, #0x1                   	// #1
    a000a374:	b90227e0 	str	w0, [sp, #548]
	while (size) {
    a000a378:	f94017e0 	ldr	x0, [sp, #40]
    a000a37c:	f100001f 	cmp	x0, #0x0
    a000a380:	54ffe941 	b.ne	a000a0a8 <set_mapping+0x3c>  // b.any
	}

	return ret;
    a000a384:	b94217e0 	ldr	w0, [sp, #532]
}
    a000a388:	a9407bfd 	ldp	x29, x30, [sp]
    a000a38c:	9108c3ff 	add	sp, sp, #0x230
    a000a390:	d65f03c0 	ret

00000000a000a394 <dup_table>:

#ifdef CONFIG_USERSPACE

static uint64_t *dup_table(uint64_t *src_table, unsigned int level)
{
    a000a394:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a000a398:	910003fd 	mov	x29, sp
    a000a39c:	f9000fe0 	str	x0, [sp, #24]
    a000a3a0:	b90017e1 	str	w1, [sp, #20]
	uint64_t *dst_table = new_table();
    a000a3a4:	97fffe0f 	bl	a0009be0 <new_table>
    a000a3a8:	f90013e0 	str	x0, [sp, #32]
	int i;

	if (!dst_table) {
    a000a3ac:	f94013e0 	ldr	x0, [sp, #32]
    a000a3b0:	f100001f 	cmp	x0, #0x0
    a000a3b4:	54000061 	b.ne	a000a3c0 <dup_table+0x2c>  // b.any
		return NULL;
    a000a3b8:	d2800000 	mov	x0, #0x0                   	// #0
    a000a3bc:	14000034 	b	a000a48c <dup_table+0xf8>

	MMU_DEBUG("dup (level %d) [%d]%p to [%d]%p\n", level,
		  table_index(src_table), src_table,
		  table_index(dst_table), dst_table);

	for (i = 0; i < Ln_XLAT_NUM_ENTRIES; i++) {
    a000a3c0:	b9002fff 	str	wzr, [sp, #44]
    a000a3c4:	1400002e 	b	a000a47c <dup_table+0xe8>
		dst_table[i] = src_table[i];
    a000a3c8:	b9802fe0 	ldrsw	x0, [sp, #44]
    a000a3cc:	d37df000 	lsl	x0, x0, #3
    a000a3d0:	f9400fe1 	ldr	x1, [sp, #24]
    a000a3d4:	8b000021 	add	x1, x1, x0
    a000a3d8:	b9802fe0 	ldrsw	x0, [sp, #44]
    a000a3dc:	d37df000 	lsl	x0, x0, #3
    a000a3e0:	f94013e2 	ldr	x2, [sp, #32]
    a000a3e4:	8b000040 	add	x0, x2, x0
    a000a3e8:	f9400021 	ldr	x1, [x1]
    a000a3ec:	f9000001 	str	x1, [x0]
		if (is_table_desc(src_table[i], level)) {
    a000a3f0:	b9802fe0 	ldrsw	x0, [sp, #44]
    a000a3f4:	d37df000 	lsl	x0, x0, #3
    a000a3f8:	f9400fe1 	ldr	x1, [sp, #24]
    a000a3fc:	8b000020 	add	x0, x1, x0
    a000a400:	f9400000 	ldr	x0, [x0]
    a000a404:	b94017e1 	ldr	w1, [sp, #20]
    a000a408:	97fffe5e 	bl	a0009d80 <is_table_desc>
    a000a40c:	12001c00 	and	w0, w0, #0xff
    a000a410:	7100001f 	cmp	w0, #0x0
    a000a414:	54000120 	b.eq	a000a438 <dup_table+0xa4>  // b.none
			table_usage(pte_desc_table(src_table[i]), 1);
    a000a418:	b9802fe0 	ldrsw	x0, [sp, #44]
    a000a41c:	d37df000 	lsl	x0, x0, #3
    a000a420:	f9400fe1 	ldr	x1, [sp, #24]
    a000a424:	8b000020 	add	x0, x1, x0
    a000a428:	f9400000 	ldr	x0, [x0]
    a000a42c:	97fffe66 	bl	a0009dc4 <pte_desc_table>
    a000a430:	52800021 	mov	w1, #0x1                   	// #1
    a000a434:	97fffe26 	bl	a0009ccc <table_usage>
		}
		if (!is_free_desc(dst_table[i])) {
    a000a438:	b9802fe0 	ldrsw	x0, [sp, #44]
    a000a43c:	d37df000 	lsl	x0, x0, #3
    a000a440:	f94013e1 	ldr	x1, [sp, #32]
    a000a444:	8b000020 	add	x0, x1, x0
    a000a448:	f9400000 	ldr	x0, [x0]
    a000a44c:	97fffe44 	bl	a0009d5c <is_free_desc>
    a000a450:	12001c00 	and	w0, w0, #0xff
    a000a454:	52000000 	eor	w0, w0, #0x1
    a000a458:	12001c00 	and	w0, w0, #0xff
    a000a45c:	7100001f 	cmp	w0, #0x0
    a000a460:	54000080 	b.eq	a000a470 <dup_table+0xdc>  // b.none
			table_usage(dst_table, 1);
    a000a464:	52800021 	mov	w1, #0x1                   	// #1
    a000a468:	f94013e0 	ldr	x0, [sp, #32]
    a000a46c:	97fffe18 	bl	a0009ccc <table_usage>
	for (i = 0; i < Ln_XLAT_NUM_ENTRIES; i++) {
    a000a470:	b9402fe0 	ldr	w0, [sp, #44]
    a000a474:	11000400 	add	w0, w0, #0x1
    a000a478:	b9002fe0 	str	w0, [sp, #44]
    a000a47c:	b9402fe0 	ldr	w0, [sp, #44]
    a000a480:	7107fc1f 	cmp	w0, #0x1ff
    a000a484:	54fffa29 	b.ls	a000a3c8 <dup_table+0x34>  // b.plast
		}
	}

	return dst_table;
    a000a488:	f94013e0 	ldr	x0, [sp, #32]
}
    a000a48c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a000a490:	d65f03c0 	ret

00000000a000a494 <privatize_table>:

static int privatize_table(uint64_t *dst_table, uint64_t *src_table,
			   uintptr_t virt, size_t size, unsigned int level)
{
    a000a494:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    a000a498:	910003fd 	mov	x29, sp
    a000a49c:	f9001fe0 	str	x0, [sp, #56]
    a000a4a0:	f9001be1 	str	x1, [sp, #48]
    a000a4a4:	f90017e2 	str	x2, [sp, #40]
    a000a4a8:	f90013e3 	str	x3, [sp, #32]
    a000a4ac:	b9001fe4 	str	w4, [sp, #28]
	size_t step, level_size = 1ULL << LEVEL_TO_VA_SIZE_SHIFT(level);
    a000a4b0:	b9401fe1 	ldr	w1, [sp, #28]
    a000a4b4:	12800100 	mov	w0, #0xfffffff7            	// #-9
    a000a4b8:	1b007c20 	mul	w0, w1, w0
    a000a4bc:	11009c00 	add	w0, w0, #0x27
    a000a4c0:	d2800021 	mov	x1, #0x1                   	// #1
    a000a4c4:	9ac02020 	lsl	x0, x1, x0
    a000a4c8:	f9002fe0 	str	x0, [sp, #88]
	unsigned int i;
	int ret;

	for ( ; size; virt += step, size -= step) {
    a000a4cc:	1400006f 	b	a000a688 <privatize_table+0x1f4>
		step = level_size - (virt & (level_size - 1));
    a000a4d0:	f9402fe0 	ldr	x0, [sp, #88]
    a000a4d4:	d1000401 	sub	x1, x0, #0x1
    a000a4d8:	f94017e0 	ldr	x0, [sp, #40]
    a000a4dc:	8a000020 	and	x0, x1, x0
    a000a4e0:	f9402fe1 	ldr	x1, [sp, #88]
    a000a4e4:	cb000020 	sub	x0, x1, x0
    a000a4e8:	f90037e0 	str	x0, [sp, #104]
		if (step > size) {
    a000a4ec:	f94037e1 	ldr	x1, [sp, #104]
    a000a4f0:	f94013e0 	ldr	x0, [sp, #32]
    a000a4f4:	eb00003f 	cmp	x1, x0
    a000a4f8:	54000069 	b.ls	a000a504 <privatize_table+0x70>  // b.plast
			step = size;
    a000a4fc:	f94013e0 	ldr	x0, [sp, #32]
    a000a500:	f90037e0 	str	x0, [sp, #104]
		}
		i = XLAT_TABLE_VA_IDX(virt, level);
    a000a504:	b9401fe1 	ldr	w1, [sp, #28]
    a000a508:	12800100 	mov	w0, #0xfffffff7            	// #-9
    a000a50c:	1b007c20 	mul	w0, w1, w0
    a000a510:	11009c00 	add	w0, w0, #0x27
    a000a514:	f94017e1 	ldr	x1, [sp, #40]
    a000a518:	9ac02420 	lsr	x0, x1, x0
    a000a51c:	12002000 	and	w0, w0, #0x1ff
    a000a520:	b90057e0 	str	w0, [sp, #84]

		if (!is_table_desc(dst_table[i], level) ||
    a000a524:	b94057e0 	ldr	w0, [sp, #84]
    a000a528:	d37df000 	lsl	x0, x0, #3
    a000a52c:	f9401fe1 	ldr	x1, [sp, #56]
    a000a530:	8b000020 	add	x0, x1, x0
    a000a534:	f9400000 	ldr	x0, [x0]
    a000a538:	b9401fe1 	ldr	w1, [sp, #28]
    a000a53c:	97fffe11 	bl	a0009d80 <is_table_desc>
    a000a540:	12001c00 	and	w0, w0, #0xff
    a000a544:	52000000 	eor	w0, w0, #0x1
    a000a548:	12001c00 	and	w0, w0, #0xff
    a000a54c:	7100001f 	cmp	w0, #0x0
    a000a550:	540008a1 	b.ne	a000a664 <privatize_table+0x1d0>  // b.any
		    !is_table_desc(src_table[i], level)) {
    a000a554:	b94057e0 	ldr	w0, [sp, #84]
    a000a558:	d37df000 	lsl	x0, x0, #3
    a000a55c:	f9401be1 	ldr	x1, [sp, #48]
    a000a560:	8b000020 	add	x0, x1, x0
    a000a564:	f9400000 	ldr	x0, [x0]
    a000a568:	b9401fe1 	ldr	w1, [sp, #28]
    a000a56c:	97fffe05 	bl	a0009d80 <is_table_desc>
    a000a570:	12001c00 	and	w0, w0, #0xff
    a000a574:	52000000 	eor	w0, w0, #0x1
    a000a578:	12001c00 	and	w0, w0, #0xff
		if (!is_table_desc(dst_table[i], level) ||
    a000a57c:	7100001f 	cmp	w0, #0x0
    a000a580:	54000721 	b.ne	a000a664 <privatize_table+0x1d0>  // b.any
			/* this entry is already private */
			continue;
		}

		uint64_t *dst_subtable = pte_desc_table(dst_table[i]);
    a000a584:	b94057e0 	ldr	w0, [sp, #84]
    a000a588:	d37df000 	lsl	x0, x0, #3
    a000a58c:	f9401fe1 	ldr	x1, [sp, #56]
    a000a590:	8b000020 	add	x0, x1, x0
    a000a594:	f9400000 	ldr	x0, [x0]
    a000a598:	97fffe0b 	bl	a0009dc4 <pte_desc_table>
    a000a59c:	f90033e0 	str	x0, [sp, #96]
		uint64_t *src_subtable = pte_desc_table(src_table[i]);
    a000a5a0:	b94057e0 	ldr	w0, [sp, #84]
    a000a5a4:	d37df000 	lsl	x0, x0, #3
    a000a5a8:	f9401be1 	ldr	x1, [sp, #48]
    a000a5ac:	8b000020 	add	x0, x1, x0
    a000a5b0:	f9400000 	ldr	x0, [x0]
    a000a5b4:	97fffe04 	bl	a0009dc4 <pte_desc_table>
    a000a5b8:	f90027e0 	str	x0, [sp, #72]

		if (dst_subtable == src_subtable) {
    a000a5bc:	f94033e1 	ldr	x1, [sp, #96]
    a000a5c0:	f94027e0 	ldr	x0, [sp, #72]
    a000a5c4:	eb00003f 	cmp	x1, x0
    a000a5c8:	54000321 	b.ne	a000a62c <privatize_table+0x198>  // b.any
			/* need to make a private copy of this table */
			dst_subtable = dup_table(src_subtable, level + 1);
    a000a5cc:	b9401fe0 	ldr	w0, [sp, #28]
    a000a5d0:	11000400 	add	w0, w0, #0x1
    a000a5d4:	2a0003e1 	mov	w1, w0
    a000a5d8:	f94027e0 	ldr	x0, [sp, #72]
    a000a5dc:	97ffff6e 	bl	a000a394 <dup_table>
    a000a5e0:	f90033e0 	str	x0, [sp, #96]
			if (!dst_subtable) {
    a000a5e4:	f94033e0 	ldr	x0, [sp, #96]
    a000a5e8:	f100001f 	cmp	x0, #0x0
    a000a5ec:	54000061 	b.ne	a000a5f8 <privatize_table+0x164>  // b.any
				return -ENOMEM;
    a000a5f0:	12800160 	mov	w0, #0xfffffff4            	// #-12
    a000a5f4:	14000029 	b	a000a698 <privatize_table+0x204>
			}
			set_pte_table_desc(&dst_table[i], dst_subtable, level);
    a000a5f8:	b94057e0 	ldr	w0, [sp, #84]
    a000a5fc:	d37df000 	lsl	x0, x0, #3
    a000a600:	f9401fe1 	ldr	x1, [sp, #56]
    a000a604:	8b000020 	add	x0, x1, x0
    a000a608:	b9401fe2 	ldr	w2, [sp, #28]
    a000a60c:	f94033e1 	ldr	x1, [sp, #96]
    a000a610:	97fffe29 	bl	a0009eb4 <set_pte_table_desc>
			table_usage(dst_subtable, 1);
    a000a614:	52800021 	mov	w1, #0x1                   	// #1
    a000a618:	f94033e0 	ldr	x0, [sp, #96]
    a000a61c:	97fffdac 	bl	a0009ccc <table_usage>
			table_usage(src_subtable, -1);
    a000a620:	12800001 	mov	w1, #0xffffffff            	// #-1
    a000a624:	f94027e0 	ldr	x0, [sp, #72]
    a000a628:	97fffda9 	bl	a0009ccc <table_usage>
		}

		ret = privatize_table(dst_subtable, src_subtable,
    a000a62c:	b9401fe0 	ldr	w0, [sp, #28]
    a000a630:	11000400 	add	w0, w0, #0x1
    a000a634:	2a0003e4 	mov	w4, w0
    a000a638:	f94037e3 	ldr	x3, [sp, #104]
    a000a63c:	f94017e2 	ldr	x2, [sp, #40]
    a000a640:	f94027e1 	ldr	x1, [sp, #72]
    a000a644:	f94033e0 	ldr	x0, [sp, #96]
    a000a648:	97ffff93 	bl	a000a494 <privatize_table>
    a000a64c:	b90047e0 	str	w0, [sp, #68]
				      virt, step, level + 1);
		if (ret) {
    a000a650:	b94047e0 	ldr	w0, [sp, #68]
    a000a654:	7100001f 	cmp	w0, #0x0
    a000a658:	54000080 	b.eq	a000a668 <privatize_table+0x1d4>  // b.none
			return ret;
    a000a65c:	b94047e0 	ldr	w0, [sp, #68]
    a000a660:	1400000e 	b	a000a698 <privatize_table+0x204>
			continue;
    a000a664:	d503201f 	nop
	for ( ; size; virt += step, size -= step) {
    a000a668:	f94017e1 	ldr	x1, [sp, #40]
    a000a66c:	f94037e0 	ldr	x0, [sp, #104]
    a000a670:	8b000020 	add	x0, x1, x0
    a000a674:	f90017e0 	str	x0, [sp, #40]
    a000a678:	f94013e1 	ldr	x1, [sp, #32]
    a000a67c:	f94037e0 	ldr	x0, [sp, #104]
    a000a680:	cb000020 	sub	x0, x1, x0
    a000a684:	f90013e0 	str	x0, [sp, #32]
    a000a688:	f94013e0 	ldr	x0, [sp, #32]
    a000a68c:	f100001f 	cmp	x0, #0x0
    a000a690:	54fff201 	b.ne	a000a4d0 <privatize_table+0x3c>  // b.any
		}
	}

	return 0;
    a000a694:	52800000 	mov	w0, #0x0                   	// #0
}
    a000a698:	a8c77bfd 	ldp	x29, x30, [sp], #112
    a000a69c:	d65f03c0 	ret

00000000a000a6a0 <privatize_page_range>:
 */
static int privatize_page_range(struct arm_mmu_ptables *dst_pt,
				struct arm_mmu_ptables *src_pt,
				uintptr_t virt_start, size_t size,
				const char *name)
{
    a000a6a0:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
    a000a6a4:	910003fd 	mov	x29, sp
    a000a6a8:	f9001fe0 	str	x0, [sp, #56]
    a000a6ac:	f9001be1 	str	x1, [sp, #48]
    a000a6b0:	f90017e2 	str	x2, [sp, #40]
    a000a6b4:	f90013e3 	str	x3, [sp, #32]
    a000a6b8:	f9000fe4 	str	x4, [sp, #24]
    a000a6bc:	b00001e0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000a6c0:	913e8000 	add	x0, x0, #0xfa0
    a000a6c4:	f90037e0 	str	x0, [sp, #104]
MAKE_REG_HELPER(daif)
    a000a6c8:	d53b4220 	mrs	x0, daif
    a000a6cc:	f90033e0 	str	x0, [sp, #96]
    a000a6d0:	f94033e0 	ldr	x0, [sp, #96]
    a000a6d4:	d503201f 	nop

	/*
	 * Return the whole DAIF register as key but use DAIFSET to disable
	 * IRQs.
	 */
	key = read_daif();
    a000a6d8:	b9005fe0 	str	w0, [sp, #92]
	__asm__ volatile ("msr DAIFSet, %0"
    a000a6dc:	d50342df 	msr	daifset, #0x2
}
    a000a6e0:	d503201f 	nop
	disable_irq();

	return key;
    a000a6e4:	b9405fe0 	ldr	w0, [sp, #92]

	/* Note that we need to use the underlying arch-specific lock
	 * implementation.  The "irq_lock()" API in SMP context is
	 * actually a wrapper for a global spinlock!
	 */
	k.key = arch_irq_lock();
    a000a6e8:	b90053e0 	str	w0, [sp, #80]
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
    a000a6ec:	b94053e0 	ldr	w0, [sp, #80]
    a000a6f0:	b9005be0 	str	w0, [sp, #88]
	MMU_DEBUG("privatize [%s]: virt %lx size %lx\n",
		  name, virt_start, size);

	key = k_spin_lock(&xlat_lock);

	ret = privatize_table(dst_pt->base_xlat_table, src_pt->base_xlat_table,
    a000a6f4:	f9401fe0 	ldr	x0, [sp, #56]
    a000a6f8:	f9400005 	ldr	x5, [x0]
    a000a6fc:	f9401be0 	ldr	x0, [sp, #48]
    a000a700:	f9400000 	ldr	x0, [x0]
    a000a704:	52800024 	mov	w4, #0x1                   	// #1
    a000a708:	f94013e3 	ldr	x3, [sp, #32]
    a000a70c:	f94017e2 	ldr	x2, [sp, #40]
    a000a710:	aa0003e1 	mov	x1, x0
    a000a714:	aa0503e0 	mov	x0, x5
    a000a718:	97ffff5f 	bl	a000a494 <privatize_table>
    a000a71c:	b9008fe0 	str	w0, [sp, #140]
    a000a720:	b00001e0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000a724:	913e8000 	add	x0, x0, #0xfa0
    a000a728:	f90043e0 	str	x0, [sp, #128]
    a000a72c:	b9405be0 	ldr	w0, [sp, #88]
    a000a730:	b9004be0 	str	w0, [sp, #72]
	 * a memory barrier when used like this, and we don't have a
	 * Zephyr framework for that.
	 */
	atomic_clear(&l->locked);
#endif
	arch_irq_unlock(key.key);
    a000a734:	b9404be0 	ldr	w0, [sp, #72]
    a000a738:	b9007fe0 	str	w0, [sp, #124]
}

static ALWAYS_INLINE void arch_irq_unlock(unsigned int key)
{
	write_daif(key);
    a000a73c:	b9407fe0 	ldr	w0, [sp, #124]
    a000a740:	f9003be0 	str	x0, [sp, #112]
MAKE_REG_HELPER(daif)
    a000a744:	f9403be0 	ldr	x0, [sp, #112]
    a000a748:	d51b4220 	msr	daif, x0
    a000a74c:	d503201f 	nop
}
    a000a750:	d503201f 	nop
}
    a000a754:	d503201f 	nop
			      virt_start, size, BASE_XLAT_LEVEL);

	k_spin_unlock(&xlat_lock, key);
	return ret;
    a000a758:	b9408fe0 	ldr	w0, [sp, #140]
}
    a000a75c:	a8c97bfd 	ldp	x29, x30, [sp], #144
    a000a760:	d65f03c0 	ret

00000000a000a764 <discard_table>:

static void discard_table(uint64_t *table, unsigned int level)
{
    a000a764:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a000a768:	910003fd 	mov	x29, sp
    a000a76c:	f9000fe0 	str	x0, [sp, #24]
    a000a770:	b90017e1 	str	w1, [sp, #20]
	unsigned int i;

	for (i = 0U; Ln_XLAT_NUM_ENTRIES; i++) {
    a000a774:	b9002fff 	str	wzr, [sp, #44]
		if (is_table_desc(table[i], level)) {
    a000a778:	b9402fe0 	ldr	w0, [sp, #44]
    a000a77c:	d37df000 	lsl	x0, x0, #3
    a000a780:	f9400fe1 	ldr	x1, [sp, #24]
    a000a784:	8b000020 	add	x0, x1, x0
    a000a788:	f9400000 	ldr	x0, [x0]
    a000a78c:	b94017e1 	ldr	w1, [sp, #20]
    a000a790:	97fffd7c 	bl	a0009d80 <is_table_desc>
    a000a794:	12001c00 	and	w0, w0, #0xff
    a000a798:	7100001f 	cmp	w0, #0x0
    a000a79c:	540002a0 	b.eq	a000a7f0 <discard_table+0x8c>  // b.none
			table_usage(pte_desc_table(table[i]), -1);
    a000a7a0:	b9402fe0 	ldr	w0, [sp, #44]
    a000a7a4:	d37df000 	lsl	x0, x0, #3
    a000a7a8:	f9400fe1 	ldr	x1, [sp, #24]
    a000a7ac:	8b000020 	add	x0, x1, x0
    a000a7b0:	f9400000 	ldr	x0, [x0]
    a000a7b4:	97fffd84 	bl	a0009dc4 <pte_desc_table>
    a000a7b8:	12800001 	mov	w1, #0xffffffff            	// #-1
    a000a7bc:	97fffd44 	bl	a0009ccc <table_usage>
			discard_table(pte_desc_table(table[i]), level + 1);
    a000a7c0:	b9402fe0 	ldr	w0, [sp, #44]
    a000a7c4:	d37df000 	lsl	x0, x0, #3
    a000a7c8:	f9400fe1 	ldr	x1, [sp, #24]
    a000a7cc:	8b000020 	add	x0, x1, x0
    a000a7d0:	f9400000 	ldr	x0, [x0]
    a000a7d4:	97fffd7c 	bl	a0009dc4 <pte_desc_table>
    a000a7d8:	aa0003e2 	mov	x2, x0
    a000a7dc:	b94017e0 	ldr	w0, [sp, #20]
    a000a7e0:	11000400 	add	w0, w0, #0x1
    a000a7e4:	2a0003e1 	mov	w1, w0
    a000a7e8:	aa0203e0 	mov	x0, x2
    a000a7ec:	97ffffde 	bl	a000a764 <discard_table>
		}
		if (!is_free_desc(table[i])) {
    a000a7f0:	b9402fe0 	ldr	w0, [sp, #44]
    a000a7f4:	d37df000 	lsl	x0, x0, #3
    a000a7f8:	f9400fe1 	ldr	x1, [sp, #24]
    a000a7fc:	8b000020 	add	x0, x1, x0
    a000a800:	f9400000 	ldr	x0, [x0]
    a000a804:	97fffd56 	bl	a0009d5c <is_free_desc>
    a000a808:	12001c00 	and	w0, w0, #0xff
    a000a80c:	52000000 	eor	w0, w0, #0x1
    a000a810:	12001c00 	and	w0, w0, #0xff
    a000a814:	7100001f 	cmp	w0, #0x0
    a000a818:	54000120 	b.eq	a000a83c <discard_table+0xd8>  // b.none
			table[i] = 0U;
    a000a81c:	b9402fe0 	ldr	w0, [sp, #44]
    a000a820:	d37df000 	lsl	x0, x0, #3
    a000a824:	f9400fe1 	ldr	x1, [sp, #24]
    a000a828:	8b000020 	add	x0, x1, x0
    a000a82c:	f900001f 	str	xzr, [x0]
			table_usage(table, -1);
    a000a830:	12800001 	mov	w1, #0xffffffff            	// #-1
    a000a834:	f9400fe0 	ldr	x0, [sp, #24]
    a000a838:	97fffd25 	bl	a0009ccc <table_usage>
	for (i = 0U; Ln_XLAT_NUM_ENTRIES; i++) {
    a000a83c:	b9402fe0 	ldr	w0, [sp, #44]
    a000a840:	11000400 	add	w0, w0, #0x1
    a000a844:	b9002fe0 	str	w0, [sp, #44]
		if (is_table_desc(table[i], level)) {
    a000a848:	17ffffcc 	b	a000a778 <discard_table+0x14>

00000000a000a84c <globalize_table>:
	free_table(table);
}

static int globalize_table(uint64_t *dst_table, uint64_t *src_table,
			   uintptr_t virt, size_t size, unsigned int level)
{
    a000a84c:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
    a000a850:	910003fd 	mov	x29, sp
    a000a854:	f9000bf3 	str	x19, [sp, #16]
    a000a858:	f90027e0 	str	x0, [sp, #72]
    a000a85c:	f90023e1 	str	x1, [sp, #64]
    a000a860:	f9001fe2 	str	x2, [sp, #56]
    a000a864:	f9001be3 	str	x3, [sp, #48]
    a000a868:	b9002fe4 	str	w4, [sp, #44]
	size_t step, level_size = 1ULL << LEVEL_TO_VA_SIZE_SHIFT(level);
    a000a86c:	b9402fe1 	ldr	w1, [sp, #44]
    a000a870:	12800100 	mov	w0, #0xfffffff7            	// #-9
    a000a874:	1b007c20 	mul	w0, w1, w0
    a000a878:	11009c00 	add	w0, w0, #0x27
    a000a87c:	d2800021 	mov	x1, #0x1                   	// #1
    a000a880:	9ac02020 	lsl	x0, x1, x0
    a000a884:	f9003be0 	str	x0, [sp, #112]
	unsigned int i;
	int ret;

	for ( ; size; virt += step, size -= step) {
    a000a888:	140000a3 	b	a000ab14 <globalize_table+0x2c8>
		step = level_size - (virt & (level_size - 1));
    a000a88c:	f9403be0 	ldr	x0, [sp, #112]
    a000a890:	d1000401 	sub	x1, x0, #0x1
    a000a894:	f9401fe0 	ldr	x0, [sp, #56]
    a000a898:	8a000020 	and	x0, x1, x0
    a000a89c:	f9403be1 	ldr	x1, [sp, #112]
    a000a8a0:	cb000020 	sub	x0, x1, x0
    a000a8a4:	f9003fe0 	str	x0, [sp, #120]
		if (step > size) {
    a000a8a8:	f9403fe1 	ldr	x1, [sp, #120]
    a000a8ac:	f9401be0 	ldr	x0, [sp, #48]
    a000a8b0:	eb00003f 	cmp	x1, x0
    a000a8b4:	54000069 	b.ls	a000a8c0 <globalize_table+0x74>  // b.plast
			step = size;
    a000a8b8:	f9401be0 	ldr	x0, [sp, #48]
    a000a8bc:	f9003fe0 	str	x0, [sp, #120]
		}
		i = XLAT_TABLE_VA_IDX(virt, level);
    a000a8c0:	b9402fe1 	ldr	w1, [sp, #44]
    a000a8c4:	12800100 	mov	w0, #0xfffffff7            	// #-9
    a000a8c8:	1b007c20 	mul	w0, w1, w0
    a000a8cc:	11009c00 	add	w0, w0, #0x27
    a000a8d0:	f9401fe1 	ldr	x1, [sp, #56]
    a000a8d4:	9ac02420 	lsr	x0, x1, x0
    a000a8d8:	12002000 	and	w0, w0, #0x1ff
    a000a8dc:	b9006fe0 	str	w0, [sp, #108]

		if (dst_table[i] == src_table[i]) {
    a000a8e0:	b9406fe0 	ldr	w0, [sp, #108]
    a000a8e4:	d37df000 	lsl	x0, x0, #3
    a000a8e8:	f94027e1 	ldr	x1, [sp, #72]
    a000a8ec:	8b000020 	add	x0, x1, x0
    a000a8f0:	f9400001 	ldr	x1, [x0]
    a000a8f4:	b9406fe0 	ldr	w0, [sp, #108]
    a000a8f8:	d37df000 	lsl	x0, x0, #3
    a000a8fc:	f94023e2 	ldr	x2, [sp, #64]
    a000a900:	8b000040 	add	x0, x2, x0
    a000a904:	f9400000 	ldr	x0, [x0]
    a000a908:	eb00003f 	cmp	x1, x0
    a000a90c:	54000ee0 	b.eq	a000aae8 <globalize_table+0x29c>  // b.none
			/* already identical to global table */
			continue;
		}

		if (step != level_size) {
    a000a910:	f9403fe1 	ldr	x1, [sp, #120]
    a000a914:	f9403be0 	ldr	x0, [sp, #112]
    a000a918:	eb00003f 	cmp	x1, x0
    a000a91c:	54000640 	b.eq	a000a9e4 <globalize_table+0x198>  // b.none
			/* boundary falls in the middle of this pte */
			__ASSERT(is_table_desc(src_table[i], level),
				 "can't have partial block pte here");
			if (!is_table_desc(dst_table[i], level)) {
    a000a920:	b9406fe0 	ldr	w0, [sp, #108]
    a000a924:	d37df000 	lsl	x0, x0, #3
    a000a928:	f94027e1 	ldr	x1, [sp, #72]
    a000a92c:	8b000020 	add	x0, x1, x0
    a000a930:	f9400000 	ldr	x0, [x0]
    a000a934:	b9402fe1 	ldr	w1, [sp, #44]
    a000a938:	97fffd12 	bl	a0009d80 <is_table_desc>
    a000a93c:	12001c00 	and	w0, w0, #0xff
    a000a940:	52000000 	eor	w0, w0, #0x1
    a000a944:	12001c00 	and	w0, w0, #0xff
    a000a948:	7100001f 	cmp	w0, #0x0
    a000a94c:	54000160 	b.eq	a000a978 <globalize_table+0x12c>  // b.none
				/* we need more fine grained boundaries */
				if (!expand_to_table(&dst_table[i], level)) {
    a000a950:	b9406fe0 	ldr	w0, [sp, #108]
    a000a954:	d37df000 	lsl	x0, x0, #3
    a000a958:	f94027e1 	ldr	x1, [sp, #72]
    a000a95c:	8b000020 	add	x0, x1, x0
    a000a960:	b9402fe1 	ldr	w1, [sp, #44]
    a000a964:	97fffd7d 	bl	a0009f58 <expand_to_table>
    a000a968:	f100001f 	cmp	x0, #0x0
    a000a96c:	54000061 	b.ne	a000a978 <globalize_table+0x12c>  // b.any
					return -ENOMEM;
    a000a970:	12800160 	mov	w0, #0xfffffff4            	// #-12
    a000a974:	1400006c 	b	a000ab24 <globalize_table+0x2d8>
				}
			}
			ret = globalize_table(pte_desc_table(dst_table[i]),
    a000a978:	b9406fe0 	ldr	w0, [sp, #108]
    a000a97c:	d37df000 	lsl	x0, x0, #3
    a000a980:	f94027e1 	ldr	x1, [sp, #72]
    a000a984:	8b000020 	add	x0, x1, x0
    a000a988:	f9400000 	ldr	x0, [x0]
    a000a98c:	97fffd0e 	bl	a0009dc4 <pte_desc_table>
    a000a990:	aa0003f3 	mov	x19, x0
					      pte_desc_table(src_table[i]),
    a000a994:	b9406fe0 	ldr	w0, [sp, #108]
    a000a998:	d37df000 	lsl	x0, x0, #3
    a000a99c:	f94023e1 	ldr	x1, [sp, #64]
    a000a9a0:	8b000020 	add	x0, x1, x0
			ret = globalize_table(pte_desc_table(dst_table[i]),
    a000a9a4:	f9400000 	ldr	x0, [x0]
    a000a9a8:	97fffd07 	bl	a0009dc4 <pte_desc_table>
    a000a9ac:	aa0003e1 	mov	x1, x0
    a000a9b0:	b9402fe0 	ldr	w0, [sp, #44]
    a000a9b4:	11000400 	add	w0, w0, #0x1
    a000a9b8:	2a0003e4 	mov	w4, w0
    a000a9bc:	f9403fe3 	ldr	x3, [sp, #120]
    a000a9c0:	f9401fe2 	ldr	x2, [sp, #56]
    a000a9c4:	aa1303e0 	mov	x0, x19
    a000a9c8:	97ffffa1 	bl	a000a84c <globalize_table>
    a000a9cc:	b9005fe0 	str	w0, [sp, #92]
					      virt, step, level + 1);
			if (ret) {
    a000a9d0:	b9405fe0 	ldr	w0, [sp, #92]
    a000a9d4:	7100001f 	cmp	w0, #0x0
    a000a9d8:	540008c0 	b.eq	a000aaf0 <globalize_table+0x2a4>  // b.none
				return ret;
    a000a9dc:	b9405fe0 	ldr	w0, [sp, #92]
    a000a9e0:	14000051 	b	a000ab24 <globalize_table+0x2d8>
			continue;
		}

		/* we discard current pte and replace with global one */

		uint64_t *old_table = is_table_desc(dst_table[i], level) ?
    a000a9e4:	b9406fe0 	ldr	w0, [sp, #108]
    a000a9e8:	d37df000 	lsl	x0, x0, #3
    a000a9ec:	f94027e1 	ldr	x1, [sp, #72]
    a000a9f0:	8b000020 	add	x0, x1, x0
    a000a9f4:	f9400000 	ldr	x0, [x0]
    a000a9f8:	b9402fe1 	ldr	w1, [sp, #44]
    a000a9fc:	97fffce1 	bl	a0009d80 <is_table_desc>
    a000aa00:	12001c00 	and	w0, w0, #0xff
					pte_desc_table(dst_table[i]) : NULL;
    a000aa04:	7100001f 	cmp	w0, #0x0
    a000aa08:	54000100 	b.eq	a000aa28 <globalize_table+0x1dc>  // b.none
    a000aa0c:	b9406fe0 	ldr	w0, [sp, #108]
    a000aa10:	d37df000 	lsl	x0, x0, #3
    a000aa14:	f94027e1 	ldr	x1, [sp, #72]
    a000aa18:	8b000020 	add	x0, x1, x0
    a000aa1c:	f9400000 	ldr	x0, [x0]
    a000aa20:	97fffce9 	bl	a0009dc4 <pte_desc_table>
    a000aa24:	14000002 	b	a000aa2c <globalize_table+0x1e0>
    a000aa28:	d2800000 	mov	x0, #0x0                   	// #0
		uint64_t *old_table = is_table_desc(dst_table[i], level) ?
    a000aa2c:	f90033e0 	str	x0, [sp, #96]

		dst_table[i] = src_table[i];
    a000aa30:	b9406fe0 	ldr	w0, [sp, #108]
    a000aa34:	d37df000 	lsl	x0, x0, #3
    a000aa38:	f94023e1 	ldr	x1, [sp, #64]
    a000aa3c:	8b000021 	add	x1, x1, x0
    a000aa40:	b9406fe0 	ldr	w0, [sp, #108]
    a000aa44:	d37df000 	lsl	x0, x0, #3
    a000aa48:	f94027e2 	ldr	x2, [sp, #72]
    a000aa4c:	8b000040 	add	x0, x2, x0
    a000aa50:	f9400021 	ldr	x1, [x1]
    a000aa54:	f9000001 	str	x1, [x0]
		debug_show_pte(&dst_table[i], level);
    a000aa58:	b9406fe0 	ldr	w0, [sp, #108]
    a000aa5c:	d37df000 	lsl	x0, x0, #3
    a000aa60:	f94027e1 	ldr	x1, [sp, #72]
    a000aa64:	8b000020 	add	x0, x1, x0
    a000aa68:	b9402fe1 	ldr	w1, [sp, #44]
    a000aa6c:	97fffd0c 	bl	a0009e9c <debug_show_pte>
		if (is_table_desc(src_table[i], level)) {
    a000aa70:	b9406fe0 	ldr	w0, [sp, #108]
    a000aa74:	d37df000 	lsl	x0, x0, #3
    a000aa78:	f94023e1 	ldr	x1, [sp, #64]
    a000aa7c:	8b000020 	add	x0, x1, x0
    a000aa80:	f9400000 	ldr	x0, [x0]
    a000aa84:	b9402fe1 	ldr	w1, [sp, #44]
    a000aa88:	97fffcbe 	bl	a0009d80 <is_table_desc>
    a000aa8c:	12001c00 	and	w0, w0, #0xff
    a000aa90:	7100001f 	cmp	w0, #0x0
    a000aa94:	54000120 	b.eq	a000aab8 <globalize_table+0x26c>  // b.none
			table_usage(pte_desc_table(src_table[i]), 1);
    a000aa98:	b9406fe0 	ldr	w0, [sp, #108]
    a000aa9c:	d37df000 	lsl	x0, x0, #3
    a000aaa0:	f94023e1 	ldr	x1, [sp, #64]
    a000aaa4:	8b000020 	add	x0, x1, x0
    a000aaa8:	f9400000 	ldr	x0, [x0]
    a000aaac:	97fffcc6 	bl	a0009dc4 <pte_desc_table>
    a000aab0:	52800021 	mov	w1, #0x1                   	// #1
    a000aab4:	97fffc86 	bl	a0009ccc <table_usage>
		}

		if (old_table) {
    a000aab8:	f94033e0 	ldr	x0, [sp, #96]
    a000aabc:	f100001f 	cmp	x0, #0x0
    a000aac0:	540001a0 	b.eq	a000aaf4 <globalize_table+0x2a8>  // b.none
			/* we can discard the whole branch */
			table_usage(old_table, -1);
    a000aac4:	12800001 	mov	w1, #0xffffffff            	// #-1
    a000aac8:	f94033e0 	ldr	x0, [sp, #96]
    a000aacc:	97fffc80 	bl	a0009ccc <table_usage>
			discard_table(old_table, level + 1);
    a000aad0:	b9402fe0 	ldr	w0, [sp, #44]
    a000aad4:	11000400 	add	w0, w0, #0x1
    a000aad8:	2a0003e1 	mov	w1, w0
    a000aadc:	f94033e0 	ldr	x0, [sp, #96]
    a000aae0:	97ffff21 	bl	a000a764 <discard_table>
    a000aae4:	14000004 	b	a000aaf4 <globalize_table+0x2a8>
			continue;
    a000aae8:	d503201f 	nop
    a000aaec:	14000002 	b	a000aaf4 <globalize_table+0x2a8>
			continue;
    a000aaf0:	d503201f 	nop
	for ( ; size; virt += step, size -= step) {
    a000aaf4:	f9401fe1 	ldr	x1, [sp, #56]
    a000aaf8:	f9403fe0 	ldr	x0, [sp, #120]
    a000aafc:	8b000020 	add	x0, x1, x0
    a000ab00:	f9001fe0 	str	x0, [sp, #56]
    a000ab04:	f9401be1 	ldr	x1, [sp, #48]
    a000ab08:	f9403fe0 	ldr	x0, [sp, #120]
    a000ab0c:	cb000020 	sub	x0, x1, x0
    a000ab10:	f9001be0 	str	x0, [sp, #48]
    a000ab14:	f9401be0 	ldr	x0, [sp, #48]
    a000ab18:	f100001f 	cmp	x0, #0x0
    a000ab1c:	54ffeb81 	b.ne	a000a88c <globalize_table+0x40>  // b.any
		}
	}

	return 0;
    a000ab20:	52800000 	mov	w0, #0x0                   	// #0
}
    a000ab24:	f9400bf3 	ldr	x19, [sp, #16]
    a000ab28:	a8c87bfd 	ldp	x29, x30, [sp], #128
    a000ab2c:	d65f03c0 	ret

00000000a000ab30 <globalize_page_range>:
 */
static int globalize_page_range(struct arm_mmu_ptables *dst_pt,
				struct arm_mmu_ptables *src_pt,
				uintptr_t virt_start, size_t size,
				const char *name)
{
    a000ab30:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
    a000ab34:	910003fd 	mov	x29, sp
    a000ab38:	f9001fe0 	str	x0, [sp, #56]
    a000ab3c:	f9001be1 	str	x1, [sp, #48]
    a000ab40:	f90017e2 	str	x2, [sp, #40]
    a000ab44:	f90013e3 	str	x3, [sp, #32]
    a000ab48:	f9000fe4 	str	x4, [sp, #24]
    a000ab4c:	b00001e0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000ab50:	913e8000 	add	x0, x0, #0xfa0
    a000ab54:	f90037e0 	str	x0, [sp, #104]
    a000ab58:	d53b4220 	mrs	x0, daif
    a000ab5c:	f90033e0 	str	x0, [sp, #96]
    a000ab60:	f94033e0 	ldr	x0, [sp, #96]
    a000ab64:	d503201f 	nop
	key = read_daif();
    a000ab68:	b9005fe0 	str	w0, [sp, #92]
	__asm__ volatile ("msr DAIFSet, %0"
    a000ab6c:	d50342df 	msr	daifset, #0x2
}
    a000ab70:	d503201f 	nop
	return key;
    a000ab74:	b9405fe0 	ldr	w0, [sp, #92]
	k.key = arch_irq_lock();
    a000ab78:	b90053e0 	str	w0, [sp, #80]
	return k;
    a000ab7c:	b94053e0 	ldr	w0, [sp, #80]
    a000ab80:	b9005be0 	str	w0, [sp, #88]
	MMU_DEBUG("globalize [%s]: virt %lx size %lx\n",
		  name, virt_start, size);

	key = k_spin_lock(&xlat_lock);

	ret = globalize_table(dst_pt->base_xlat_table, src_pt->base_xlat_table,
    a000ab84:	f9401fe0 	ldr	x0, [sp, #56]
    a000ab88:	f9400005 	ldr	x5, [x0]
    a000ab8c:	f9401be0 	ldr	x0, [sp, #48]
    a000ab90:	f9400000 	ldr	x0, [x0]
    a000ab94:	52800024 	mov	w4, #0x1                   	// #1
    a000ab98:	f94013e3 	ldr	x3, [sp, #32]
    a000ab9c:	f94017e2 	ldr	x2, [sp, #40]
    a000aba0:	aa0003e1 	mov	x1, x0
    a000aba4:	aa0503e0 	mov	x0, x5
    a000aba8:	97ffff29 	bl	a000a84c <globalize_table>
    a000abac:	b9008fe0 	str	w0, [sp, #140]
    a000abb0:	b00001e0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000abb4:	913e8000 	add	x0, x0, #0xfa0
    a000abb8:	f90043e0 	str	x0, [sp, #128]
    a000abbc:	b9405be0 	ldr	w0, [sp, #88]
    a000abc0:	b9004be0 	str	w0, [sp, #72]
	arch_irq_unlock(key.key);
    a000abc4:	b9404be0 	ldr	w0, [sp, #72]
    a000abc8:	b9007fe0 	str	w0, [sp, #124]
	write_daif(key);
    a000abcc:	b9407fe0 	ldr	w0, [sp, #124]
    a000abd0:	f9003be0 	str	x0, [sp, #112]
MAKE_REG_HELPER(daif)
    a000abd4:	f9403be0 	ldr	x0, [sp, #112]
    a000abd8:	d51b4220 	msr	daif, x0
    a000abdc:	d503201f 	nop
}
    a000abe0:	d503201f 	nop
}
    a000abe4:	d503201f 	nop
			      virt_start, size, BASE_XLAT_LEVEL);

	k_spin_unlock(&xlat_lock, key);
	return ret;
    a000abe8:	b9408fe0 	ldr	w0, [sp, #140]
}
    a000abec:	a8c97bfd 	ldp	x29, x30, [sp], #144
    a000abf0:	d65f03c0 	ret

00000000a000abf4 <get_region_desc>:

#endif /* CONFIG_USERSPACE */

static uint64_t get_region_desc(uint32_t attrs)
{
    a000abf4:	d10083ff 	sub	sp, sp, #0x20
    a000abf8:	b9000fe0 	str	w0, [sp, #12]
	unsigned int mem_type;
	uint64_t desc = 0U;
    a000abfc:	f9000fff 	str	xzr, [sp, #24]

	/* NS bit for security memory access from secure state */
	desc |= (attrs & MT_NS) ? PTE_BLOCK_DESC_NS : 0;
    a000ac00:	b9400fe0 	ldr	w0, [sp, #12]
    a000ac04:	8b000000 	add	x0, x0, x0
    a000ac08:	927b0000 	and	x0, x0, #0x20
    a000ac0c:	f9400fe1 	ldr	x1, [sp, #24]
    a000ac10:	aa000020 	orr	x0, x1, x0
    a000ac14:	f9000fe0 	str	x0, [sp, #24]
	 *     10      RO   NA
	 *     11      RO   RO
	 */

	/* AP bits for Data access permission */
	desc |= (attrs & MT_RW) ? PTE_BLOCK_DESC_AP_RW : PTE_BLOCK_DESC_AP_RO;
    a000ac18:	b9400fe0 	ldr	w0, [sp, #12]
    a000ac1c:	121d0000 	and	w0, w0, #0x8
    a000ac20:	7100001f 	cmp	w0, #0x0
    a000ac24:	54000060 	b.eq	a000ac30 <get_region_desc+0x3c>  // b.none
    a000ac28:	d2800000 	mov	x0, #0x0                   	// #0
    a000ac2c:	14000002 	b	a000ac34 <get_region_desc+0x40>
    a000ac30:	d2801000 	mov	x0, #0x80                  	// #128
    a000ac34:	f9400fe1 	ldr	x1, [sp, #24]
    a000ac38:	aa000020 	orr	x0, x1, x0
    a000ac3c:	f9000fe0 	str	x0, [sp, #24]

	/* Mirror permissions to EL0 */
	desc |= (attrs & MT_RW_AP_ELx) ?
		 PTE_BLOCK_DESC_AP_ELx : PTE_BLOCK_DESC_AP_EL_HIGHER;
    a000ac40:	b9400fe0 	ldr	w0, [sp, #12]
    a000ac44:	53017c00 	lsr	w0, w0, #1
    a000ac48:	2a0003e0 	mov	w0, w0
    a000ac4c:	927a0000 	and	x0, x0, #0x40
	desc |= (attrs & MT_RW_AP_ELx) ?
    a000ac50:	f9400fe1 	ldr	x1, [sp, #24]
    a000ac54:	aa000020 	orr	x0, x1, x0
    a000ac58:	f9000fe0 	str	x0, [sp, #24]

	/* the access flag */
	desc |= PTE_BLOCK_DESC_AF;
    a000ac5c:	f9400fe0 	ldr	x0, [sp, #24]
    a000ac60:	b2760000 	orr	x0, x0, #0x400
    a000ac64:	f9000fe0 	str	x0, [sp, #24]

	/* memory attribute index field */
	mem_type = MT_TYPE(attrs);
    a000ac68:	b9400fe0 	ldr	w0, [sp, #12]
    a000ac6c:	12000800 	and	w0, w0, #0x7
    a000ac70:	b90017e0 	str	w0, [sp, #20]
	desc |= PTE_BLOCK_DESC_MEMTYPE(mem_type);
    a000ac74:	b94017e0 	ldr	w0, [sp, #20]
    a000ac78:	531e7400 	lsl	w0, w0, #2
    a000ac7c:	2a0003e0 	mov	w0, w0
    a000ac80:	f9400fe1 	ldr	x1, [sp, #24]
    a000ac84:	aa000020 	orr	x0, x1, x0
    a000ac88:	f9000fe0 	str	x0, [sp, #24]

	switch (mem_type) {
    a000ac8c:	b94017e0 	ldr	w0, [sp, #20]
    a000ac90:	7100081f 	cmp	w0, #0x2
    a000ac94:	540000c9 	b.ls	a000acac <get_region_desc+0xb8>  // b.plast
    a000ac98:	b94017e0 	ldr	w0, [sp, #20]
    a000ac9c:	51000c00 	sub	w0, w0, #0x3
    a000aca0:	7100041f 	cmp	w0, #0x1
    a000aca4:	54000608 	b.hi	a000ad64 <get_region_desc+0x170>  // b.pmore
    a000aca8:	1400000b 	b	a000acd4 <get_region_desc+0xe0>
		/* Access to Device memory and non-cacheable memory are coherent
		 * for all observers in the system and are treated as
		 * Outer shareable, so, for these 2 types of memory,
		 * it is not strictly needed to set shareability field
		 */
		desc |= PTE_BLOCK_DESC_OUTER_SHARE;
    a000acac:	f9400fe0 	ldr	x0, [sp, #24]
    a000acb0:	b2770000 	orr	x0, x0, #0x200
    a000acb4:	f9000fe0 	str	x0, [sp, #24]
		/* Map device memory as execute-never */
		desc |= PTE_BLOCK_DESC_PXN;
    a000acb8:	f9400fe0 	ldr	x0, [sp, #24]
    a000acbc:	b24b0000 	orr	x0, x0, #0x20000000000000
    a000acc0:	f9000fe0 	str	x0, [sp, #24]
		desc |= PTE_BLOCK_DESC_UXN;
    a000acc4:	f9400fe0 	ldr	x0, [sp, #24]
    a000acc8:	b24a0000 	orr	x0, x0, #0x40000000000000
    a000accc:	f9000fe0 	str	x0, [sp, #24]
		break;
    a000acd0:	14000025 	b	a000ad64 <get_region_desc+0x170>
	case MT_NORMAL_NC:
	case MT_NORMAL:
		/* Make Normal RW memory as execute never */
		if ((attrs & MT_RW) || (attrs & MT_P_EXECUTE_NEVER))
    a000acd4:	b9400fe0 	ldr	w0, [sp, #12]
    a000acd8:	121d0000 	and	w0, w0, #0x8
    a000acdc:	7100001f 	cmp	w0, #0x0
    a000ace0:	540000a1 	b.ne	a000acf4 <get_region_desc+0x100>  // b.any
    a000ace4:	b9400fe0 	ldr	w0, [sp, #12]
    a000ace8:	121b0000 	and	w0, w0, #0x20
    a000acec:	7100001f 	cmp	w0, #0x0
    a000acf0:	54000080 	b.eq	a000ad00 <get_region_desc+0x10c>  // b.none
			desc |= PTE_BLOCK_DESC_PXN;
    a000acf4:	f9400fe0 	ldr	x0, [sp, #24]
    a000acf8:	b24b0000 	orr	x0, x0, #0x20000000000000
    a000acfc:	f9000fe0 	str	x0, [sp, #24]

		if (((attrs & MT_RW) && (attrs & MT_RW_AP_ELx)) ||
    a000ad00:	b9400fe0 	ldr	w0, [sp, #12]
    a000ad04:	121d0000 	and	w0, w0, #0x8
    a000ad08:	7100001f 	cmp	w0, #0x0
    a000ad0c:	540000a0 	b.eq	a000ad20 <get_region_desc+0x12c>  // b.none
    a000ad10:	b9400fe0 	ldr	w0, [sp, #12]
    a000ad14:	12190000 	and	w0, w0, #0x80
    a000ad18:	7100001f 	cmp	w0, #0x0
    a000ad1c:	540000a1 	b.ne	a000ad30 <get_region_desc+0x13c>  // b.any
		     (attrs & MT_U_EXECUTE_NEVER))
    a000ad20:	b9400fe0 	ldr	w0, [sp, #12]
    a000ad24:	121a0000 	and	w0, w0, #0x40
		if (((attrs & MT_RW) && (attrs & MT_RW_AP_ELx)) ||
    a000ad28:	7100001f 	cmp	w0, #0x0
    a000ad2c:	54000080 	b.eq	a000ad3c <get_region_desc+0x148>  // b.none
			desc |= PTE_BLOCK_DESC_UXN;
    a000ad30:	f9400fe0 	ldr	x0, [sp, #24]
    a000ad34:	b24a0000 	orr	x0, x0, #0x40000000000000
    a000ad38:	f9000fe0 	str	x0, [sp, #24]

		if (mem_type == MT_NORMAL)
    a000ad3c:	b94017e0 	ldr	w0, [sp, #20]
    a000ad40:	7100101f 	cmp	w0, #0x4
    a000ad44:	540000a1 	b.ne	a000ad58 <get_region_desc+0x164>  // b.any
			desc |= PTE_BLOCK_DESC_INNER_SHARE;
    a000ad48:	f9400fe0 	ldr	x0, [sp, #24]
    a000ad4c:	b2780400 	orr	x0, x0, #0x300
    a000ad50:	f9000fe0 	str	x0, [sp, #24]
    a000ad54:	14000004 	b	a000ad64 <get_region_desc+0x170>
		else
			desc |= PTE_BLOCK_DESC_OUTER_SHARE;
    a000ad58:	f9400fe0 	ldr	x0, [sp, #24]
    a000ad5c:	b2770000 	orr	x0, x0, #0x200
    a000ad60:	f9000fe0 	str	x0, [sp, #24]
	}

	return desc;
    a000ad64:	f9400fe0 	ldr	x0, [sp, #24]
}
    a000ad68:	910083ff 	add	sp, sp, #0x20
    a000ad6c:	d65f03c0 	ret

00000000a000ad70 <__add_map>:

static int __add_map(struct arm_mmu_ptables *ptables, const char *name,
		     uintptr_t phys, uintptr_t virt, size_t size, uint32_t attrs)
{
    a000ad70:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a000ad74:	910003fd 	mov	x29, sp
    a000ad78:	f9001fe0 	str	x0, [sp, #56]
    a000ad7c:	f9001be1 	str	x1, [sp, #48]
    a000ad80:	f90017e2 	str	x2, [sp, #40]
    a000ad84:	f90013e3 	str	x3, [sp, #32]
    a000ad88:	f9000fe4 	str	x4, [sp, #24]
    a000ad8c:	b90017e5 	str	w5, [sp, #20]
	uint64_t desc = get_region_desc(attrs);
    a000ad90:	b94017e0 	ldr	w0, [sp, #20]
    a000ad94:	97ffff98 	bl	a000abf4 <get_region_desc>
    a000ad98:	f90027e0 	str	x0, [sp, #72]
	bool may_overwrite = !(attrs & MT_NO_OVERWRITE);
    a000ad9c:	b94017e0 	ldr	w0, [sp, #20]
    a000ada0:	12180000 	and	w0, w0, #0x100
    a000ada4:	7100001f 	cmp	w0, #0x0
    a000ada8:	1a9f17e0 	cset	w0, eq  // eq = none
    a000adac:	39011fe0 	strb	w0, [sp, #71]

	MMU_DEBUG("mmap [%s]: virt %lx phys %lx size %lx attr %llx\n",
		  name, virt, phys, size, desc);
	__ASSERT(((virt | phys | size) & (CONFIG_MMU_PAGE_SIZE - 1)) == 0,
		 "address/size are not page aligned\n");
	desc |= phys;
    a000adb0:	f94027e1 	ldr	x1, [sp, #72]
    a000adb4:	f94017e0 	ldr	x0, [sp, #40]
    a000adb8:	aa000020 	orr	x0, x1, x0
    a000adbc:	f90027e0 	str	x0, [sp, #72]
	return set_mapping(ptables, virt, size, desc, may_overwrite);
    a000adc0:	39411fe4 	ldrb	w4, [sp, #71]
    a000adc4:	f94027e3 	ldr	x3, [sp, #72]
    a000adc8:	f9400fe2 	ldr	x2, [sp, #24]
    a000adcc:	f94013e1 	ldr	x1, [sp, #32]
    a000add0:	f9401fe0 	ldr	x0, [sp, #56]
    a000add4:	97fffca6 	bl	a000a06c <set_mapping>
}
    a000add8:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a000addc:	d65f03c0 	ret

00000000a000ade0 <add_map>:

static int add_map(struct arm_mmu_ptables *ptables, const char *name,
		   uintptr_t phys, uintptr_t virt, size_t size, uint32_t attrs)
{
    a000ade0:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
    a000ade4:	910003fd 	mov	x29, sp
    a000ade8:	f9001fe0 	str	x0, [sp, #56]
    a000adec:	f9001be1 	str	x1, [sp, #48]
    a000adf0:	f90017e2 	str	x2, [sp, #40]
    a000adf4:	f90013e3 	str	x3, [sp, #32]
    a000adf8:	f9000fe4 	str	x4, [sp, #24]
    a000adfc:	b90017e5 	str	w5, [sp, #20]
    a000ae00:	b00001e0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000ae04:	913e8000 	add	x0, x0, #0xfa0
    a000ae08:	f90037e0 	str	x0, [sp, #104]
    a000ae0c:	d53b4220 	mrs	x0, daif
    a000ae10:	f90033e0 	str	x0, [sp, #96]
    a000ae14:	f94033e0 	ldr	x0, [sp, #96]
    a000ae18:	d503201f 	nop
	key = read_daif();
    a000ae1c:	b9005fe0 	str	w0, [sp, #92]
	__asm__ volatile ("msr DAIFSet, %0"
    a000ae20:	d50342df 	msr	daifset, #0x2
}
    a000ae24:	d503201f 	nop
	return key;
    a000ae28:	b9405fe0 	ldr	w0, [sp, #92]
	k.key = arch_irq_lock();
    a000ae2c:	b90053e0 	str	w0, [sp, #80]
	return k;
    a000ae30:	b94053e0 	ldr	w0, [sp, #80]
    a000ae34:	b9005be0 	str	w0, [sp, #88]
	k_spinlock_key_t key;
	int ret;

	key = k_spin_lock(&xlat_lock);
	ret = __add_map(ptables, name, phys, virt, size, attrs);
    a000ae38:	b94017e5 	ldr	w5, [sp, #20]
    a000ae3c:	f9400fe4 	ldr	x4, [sp, #24]
    a000ae40:	f94013e3 	ldr	x3, [sp, #32]
    a000ae44:	f94017e2 	ldr	x2, [sp, #40]
    a000ae48:	f9401be1 	ldr	x1, [sp, #48]
    a000ae4c:	f9401fe0 	ldr	x0, [sp, #56]
    a000ae50:	97ffffc8 	bl	a000ad70 <__add_map>
    a000ae54:	b9008fe0 	str	w0, [sp, #140]
    a000ae58:	b00001e0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000ae5c:	913e8000 	add	x0, x0, #0xfa0
    a000ae60:	f90043e0 	str	x0, [sp, #128]
    a000ae64:	b9405be0 	ldr	w0, [sp, #88]
    a000ae68:	b9004be0 	str	w0, [sp, #72]
	arch_irq_unlock(key.key);
    a000ae6c:	b9404be0 	ldr	w0, [sp, #72]
    a000ae70:	b9007fe0 	str	w0, [sp, #124]
	write_daif(key);
    a000ae74:	b9407fe0 	ldr	w0, [sp, #124]
    a000ae78:	f9003be0 	str	x0, [sp, #112]
MAKE_REG_HELPER(daif)
    a000ae7c:	f9403be0 	ldr	x0, [sp, #112]
    a000ae80:	d51b4220 	msr	daif, x0
    a000ae84:	d503201f 	nop
}
    a000ae88:	d503201f 	nop
}
    a000ae8c:	d503201f 	nop
	k_spin_unlock(&xlat_lock, key);
	return ret;
    a000ae90:	b9408fe0 	ldr	w0, [sp, #140]
}
    a000ae94:	a8c97bfd 	ldp	x29, x30, [sp], #144
    a000ae98:	d65f03c0 	ret

00000000a000ae9c <invalidate_tlb_all>:
	return ret;
}

static void invalidate_tlb_all(void)
{
	__asm__ volatile (
    a000ae9c:	d508871f 	tlbi	vmalle1
    a000aea0:	d5033f9f 	dsb	sy
    a000aea4:	d5033fdf 	isb
	"tlbi vmalle1; dsb sy; isb"
	: : : "memory");
}
    a000aea8:	d503201f 	nop
    a000aeac:	d65f03c0 	ret

00000000a000aeb0 <add_arm_mmu_flat_range>:
};

static inline void add_arm_mmu_flat_range(struct arm_mmu_ptables *ptables,
					  const struct arm_mmu_flat_range *range,
					  uint32_t extra_flags)
{
    a000aeb0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    a000aeb4:	910003fd 	mov	x29, sp
    a000aeb8:	f90017e0 	str	x0, [sp, #40]
    a000aebc:	f90013e1 	str	x1, [sp, #32]
    a000aec0:	b9001fe2 	str	w2, [sp, #28]
	uintptr_t address = (uintptr_t)range->start;
    a000aec4:	f94013e0 	ldr	x0, [sp, #32]
    a000aec8:	f9400400 	ldr	x0, [x0, #8]
    a000aecc:	f9001fe0 	str	x0, [sp, #56]
	size_t size = (uintptr_t)range->end - address;
    a000aed0:	f94013e0 	ldr	x0, [sp, #32]
    a000aed4:	f9400800 	ldr	x0, [x0, #16]
    a000aed8:	aa0003e1 	mov	x1, x0
    a000aedc:	f9401fe0 	ldr	x0, [sp, #56]
    a000aee0:	cb000020 	sub	x0, x1, x0
    a000aee4:	f9001be0 	str	x0, [sp, #48]

	if (size) {
    a000aee8:	f9401be0 	ldr	x0, [sp, #48]
    a000aeec:	f100001f 	cmp	x0, #0x0
    a000aef0:	540001c0 	b.eq	a000af28 <add_arm_mmu_flat_range+0x78>  // b.none
		/* MMU not yet active: must use unlocked version */
		__add_map(ptables, range->name, address, address,
    a000aef4:	f94013e0 	ldr	x0, [sp, #32]
    a000aef8:	f9400006 	ldr	x6, [x0]
			  size, range->attrs | extra_flags);
    a000aefc:	f94013e0 	ldr	x0, [sp, #32]
    a000af00:	b9401801 	ldr	w1, [x0, #24]
		__add_map(ptables, range->name, address, address,
    a000af04:	b9401fe0 	ldr	w0, [sp, #28]
    a000af08:	2a000020 	orr	w0, w1, w0
    a000af0c:	2a0003e5 	mov	w5, w0
    a000af10:	f9401be4 	ldr	x4, [sp, #48]
    a000af14:	f9401fe3 	ldr	x3, [sp, #56]
    a000af18:	f9401fe2 	ldr	x2, [sp, #56]
    a000af1c:	aa0603e1 	mov	x1, x6
    a000af20:	f94017e0 	ldr	x0, [sp, #40]
    a000af24:	97ffff93 	bl	a000ad70 <__add_map>
	}
}
    a000af28:	d503201f 	nop
    a000af2c:	a8c47bfd 	ldp	x29, x30, [sp], #64
    a000af30:	d65f03c0 	ret

00000000a000af34 <add_arm_mmu_region>:

static inline void add_arm_mmu_region(struct arm_mmu_ptables *ptables,
				      const struct arm_mmu_region *region,
				      uint32_t extra_flags)
{
    a000af34:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a000af38:	910003fd 	mov	x29, sp
    a000af3c:	f90017e0 	str	x0, [sp, #40]
    a000af40:	f90013e1 	str	x1, [sp, #32]
    a000af44:	b9001fe2 	str	w2, [sp, #28]
	if (region->size || region->attrs) {
    a000af48:	f94013e0 	ldr	x0, [sp, #32]
    a000af4c:	f9400800 	ldr	x0, [x0, #16]
    a000af50:	f100001f 	cmp	x0, #0x0
    a000af54:	540000a1 	b.ne	a000af68 <add_arm_mmu_region+0x34>  // b.any
    a000af58:	f94013e0 	ldr	x0, [sp, #32]
    a000af5c:	b9402000 	ldr	w0, [x0, #32]
    a000af60:	7100001f 	cmp	w0, #0x0
    a000af64:	54000220 	b.eq	a000afa8 <add_arm_mmu_region+0x74>  // b.none
		/* MMU not yet active: must use unlocked version */
		__add_map(ptables, region->name, region->base_pa, region->base_va,
    a000af68:	f94013e0 	ldr	x0, [sp, #32]
    a000af6c:	f9400c06 	ldr	x6, [x0, #24]
    a000af70:	f94013e0 	ldr	x0, [sp, #32]
    a000af74:	f9400002 	ldr	x2, [x0]
    a000af78:	f94013e0 	ldr	x0, [sp, #32]
    a000af7c:	f9400403 	ldr	x3, [x0, #8]
    a000af80:	f94013e0 	ldr	x0, [sp, #32]
    a000af84:	f9400804 	ldr	x4, [x0, #16]
			  region->size, region->attrs | extra_flags);
    a000af88:	f94013e0 	ldr	x0, [sp, #32]
    a000af8c:	b9402001 	ldr	w1, [x0, #32]
		__add_map(ptables, region->name, region->base_pa, region->base_va,
    a000af90:	b9401fe0 	ldr	w0, [sp, #28]
    a000af94:	2a000020 	orr	w0, w1, w0
    a000af98:	2a0003e5 	mov	w5, w0
    a000af9c:	aa0603e1 	mov	x1, x6
    a000afa0:	f94017e0 	ldr	x0, [sp, #40]
    a000afa4:	97ffff73 	bl	a000ad70 <__add_map>
	}
}
    a000afa8:	d503201f 	nop
    a000afac:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a000afb0:	d65f03c0 	ret

00000000a000afb4 <setup_page_tables>:

static void setup_page_tables(struct arm_mmu_ptables *ptables)
{
    a000afb4:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a000afb8:	910003fd 	mov	x29, sp
    a000afbc:	f9000fe0 	str	x0, [sp, #24]
	unsigned int index;
	const struct arm_mmu_flat_range *range;
	const struct arm_mmu_region *region;
	uintptr_t max_va = 0, max_pa = 0;
    a000afc0:	f90023ff 	str	xzr, [sp, #64]
    a000afc4:	f9001fff 	str	xzr, [sp, #56]

	MMU_DEBUG("xlat tables:\n");
	for (index = 0U; index < CONFIG_MAX_XLAT_TABLES; index++)
    a000afc8:	b9004fff 	str	wzr, [sp, #76]
    a000afcc:	14000004 	b	a000afdc <setup_page_tables+0x28>
    a000afd0:	b9404fe0 	ldr	w0, [sp, #76]
    a000afd4:	11000400 	add	w0, w0, #0x1
    a000afd8:	b9004fe0 	str	w0, [sp, #76]
    a000afdc:	b9404fe0 	ldr	w0, [sp, #76]
    a000afe0:	71003c1f 	cmp	w0, #0xf
    a000afe4:	54ffff69 	b.ls	a000afd0 <setup_page_tables+0x1c>  // b.plast
		MMU_DEBUG("%d: %p\n", index, xlat_tables + index * Ln_XLAT_NUM_ENTRIES);

	for (index = 0U; index < mmu_config.num_regions; index++) {
    a000afe8:	b9004fff 	str	wzr, [sp, #76]
    a000afec:	14000020 	b	a000b06c <setup_page_tables+0xb8>
		region = &mmu_config.mmu_regions[index];
    a000aff0:	d00000c0 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a000aff4:	9117a000 	add	x0, x0, #0x5e8
    a000aff8:	f9400401 	ldr	x1, [x0, #8]
    a000affc:	b9404fe2 	ldr	w2, [sp, #76]
    a000b000:	d2800500 	mov	x0, #0x28                  	// #40
    a000b004:	9b007c40 	mul	x0, x2, x0
    a000b008:	8b000020 	add	x0, x1, x0
    a000b00c:	f9001be0 	str	x0, [sp, #48]
		max_va = MAX(max_va, region->base_va + region->size);
    a000b010:	f9401be0 	ldr	x0, [sp, #48]
    a000b014:	f9400401 	ldr	x1, [x0, #8]
    a000b018:	f9401be0 	ldr	x0, [sp, #48]
    a000b01c:	f9400800 	ldr	x0, [x0, #16]
    a000b020:	8b000020 	add	x0, x1, x0
    a000b024:	f94023e2 	ldr	x2, [sp, #64]
    a000b028:	f94023e1 	ldr	x1, [sp, #64]
    a000b02c:	eb00005f 	cmp	x2, x0
    a000b030:	9a802020 	csel	x0, x1, x0, cs  // cs = hs, nlast
    a000b034:	f90023e0 	str	x0, [sp, #64]
		max_pa = MAX(max_pa, region->base_pa + region->size);
    a000b038:	f9401be0 	ldr	x0, [sp, #48]
    a000b03c:	f9400001 	ldr	x1, [x0]
    a000b040:	f9401be0 	ldr	x0, [sp, #48]
    a000b044:	f9400800 	ldr	x0, [x0, #16]
    a000b048:	8b000020 	add	x0, x1, x0
    a000b04c:	f9401fe2 	ldr	x2, [sp, #56]
    a000b050:	f9401fe1 	ldr	x1, [sp, #56]
    a000b054:	eb00005f 	cmp	x2, x0
    a000b058:	9a802020 	csel	x0, x1, x0, cs  // cs = hs, nlast
    a000b05c:	f9001fe0 	str	x0, [sp, #56]
	for (index = 0U; index < mmu_config.num_regions; index++) {
    a000b060:	b9404fe0 	ldr	w0, [sp, #76]
    a000b064:	11000400 	add	w0, w0, #0x1
    a000b068:	b9004fe0 	str	w0, [sp, #76]
    a000b06c:	b00000c0 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a000b070:	9117a000 	add	x0, x0, #0x5e8
    a000b074:	b9400000 	ldr	w0, [x0]
    a000b078:	b9404fe1 	ldr	w1, [sp, #76]
    a000b07c:	6b00003f 	cmp	w1, w0
    a000b080:	54fffb83 	b.cc	a000aff0 <setup_page_tables+0x3c>  // b.lo, b.ul, b.last

	__ASSERT(max_va <= (1ULL << CONFIG_ARM64_VA_BITS),
		 "Maximum VA not supported\n");
	__ASSERT(max_pa <= (1ULL << CONFIG_ARM64_PA_BITS),
		 "Maximum PA not supported\n");
	printf("This code is executing\n");
    a000b084:	b00000c0 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a000b088:	910fe000 	add	x0, x0, #0x3f8
    a000b08c:	940004d4 	bl	a000c3dc <printf>
	/* setup translation table for zephyr execution regions */
	for (index = 0U; index < ARRAY_SIZE(mmu_zephyr_ranges); index++) {
    a000b090:	b9004fff 	str	wzr, [sp, #76]
    a000b094:	1400000e 	b	a000b0cc <setup_page_tables+0x118>
		range = &mmu_zephyr_ranges[index];
    a000b098:	b9404fe0 	ldr	w0, [sp, #76]
    a000b09c:	d37be801 	lsl	x1, x0, #5
    a000b0a0:	b00000c0 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a000b0a4:	91184000 	add	x0, x0, #0x610
    a000b0a8:	8b000020 	add	x0, x1, x0
    a000b0ac:	f90017e0 	str	x0, [sp, #40]
		add_arm_mmu_flat_range(ptables, range, 0);
    a000b0b0:	52800002 	mov	w2, #0x0                   	// #0
    a000b0b4:	f94017e1 	ldr	x1, [sp, #40]
    a000b0b8:	f9400fe0 	ldr	x0, [sp, #24]
    a000b0bc:	97ffff7d 	bl	a000aeb0 <add_arm_mmu_flat_range>
	for (index = 0U; index < ARRAY_SIZE(mmu_zephyr_ranges); index++) {
    a000b0c0:	b9404fe0 	ldr	w0, [sp, #76]
    a000b0c4:	11000400 	add	w0, w0, #0x1
    a000b0c8:	b9004fe0 	str	w0, [sp, #76]
    a000b0cc:	b9404fe0 	ldr	w0, [sp, #76]
    a000b0d0:	7100201f 	cmp	w0, #0x8
    a000b0d4:	54fffe29 	b.ls	a000b098 <setup_page_tables+0xe4>  // b.plast

	/*
	 * Create translation tables for user provided platform regions.
	 * Those must not conflict with our default mapping.
	 */
	for (index = 0U; index < mmu_config.num_regions; index++) {
    a000b0d8:	b9004fff 	str	wzr, [sp, #76]
    a000b0dc:	14000010 	b	a000b11c <setup_page_tables+0x168>
		region = &mmu_config.mmu_regions[index];
    a000b0e0:	b00000c0 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a000b0e4:	9117a000 	add	x0, x0, #0x5e8
    a000b0e8:	f9400401 	ldr	x1, [x0, #8]
    a000b0ec:	b9404fe2 	ldr	w2, [sp, #76]
    a000b0f0:	d2800500 	mov	x0, #0x28                  	// #40
    a000b0f4:	9b007c40 	mul	x0, x2, x0
    a000b0f8:	8b000020 	add	x0, x1, x0
    a000b0fc:	f9001be0 	str	x0, [sp, #48]
		add_arm_mmu_region(ptables, region, MT_NO_OVERWRITE);
    a000b100:	52802002 	mov	w2, #0x100                 	// #256
    a000b104:	f9401be1 	ldr	x1, [sp, #48]
    a000b108:	f9400fe0 	ldr	x0, [sp, #24]
    a000b10c:	97ffff8a 	bl	a000af34 <add_arm_mmu_region>
	for (index = 0U; index < mmu_config.num_regions; index++) {
    a000b110:	b9404fe0 	ldr	w0, [sp, #76]
    a000b114:	11000400 	add	w0, w0, #0x1
    a000b118:	b9004fe0 	str	w0, [sp, #76]
    a000b11c:	b00000c0 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a000b120:	9117a000 	add	x0, x0, #0x5e8
    a000b124:	b9400000 	ldr	w0, [x0]
    a000b128:	b9404fe1 	ldr	w1, [sp, #76]
    a000b12c:	6b00003f 	cmp	w1, w0
    a000b130:	54fffd83 	b.cc	a000b0e0 <setup_page_tables+0x12c>  // b.lo, b.ul, b.last
	}

	invalidate_tlb_all();
    a000b134:	97ffff5a 	bl	a000ae9c <invalidate_tlb_all>
}
    a000b138:	d503201f 	nop
    a000b13c:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a000b140:	d65f03c0 	ret

00000000a000b144 <get_tcr>:

/* Translation table control register settings */
static uint64_t get_tcr(int el)
{
    a000b144:	d100c3ff 	sub	sp, sp, #0x30
    a000b148:	b9000fe0 	str	w0, [sp, #12]
	uint64_t tcr;
	uint64_t va_bits = CONFIG_ARM64_VA_BITS;
    a000b14c:	d2800400 	mov	x0, #0x20                  	// #32
    a000b150:	f90013e0 	str	x0, [sp, #32]
	uint64_t tcr_ps_bits;

	tcr_ps_bits = TCR_PS_BITS;
    a000b154:	f9000fff 	str	xzr, [sp, #24]

	if (el == 1) {
    a000b158:	b9400fe0 	ldr	w0, [sp, #12]
    a000b15c:	7100041f 	cmp	w0, #0x1
    a000b160:	54000101 	b.ne	a000b180 <get_tcr+0x3c>  // b.any
		tcr = (tcr_ps_bits << TCR_EL1_IPS_SHIFT);
    a000b164:	f9400fe0 	ldr	x0, [sp, #24]
    a000b168:	d3607c00 	lsl	x0, x0, #32
    a000b16c:	f90017e0 	str	x0, [sp, #40]
		/*
		 * TCR_EL1.EPD1: Disable translation table walk for addresses
		 * that are translated using TTBR1_EL1.
		 */
		tcr |= TCR_EPD1_DISABLE;
    a000b170:	f94017e0 	ldr	x0, [sp, #40]
    a000b174:	b2690000 	orr	x0, x0, #0x800000
    a000b178:	f90017e0 	str	x0, [sp, #40]
    a000b17c:	14000004 	b	a000b18c <get_tcr+0x48>
	} else
		tcr = (tcr_ps_bits << TCR_EL3_PS_SHIFT);
    a000b180:	f9400fe0 	ldr	x0, [sp, #24]
    a000b184:	d370bc00 	lsl	x0, x0, #16
    a000b188:	f90017e0 	str	x0, [sp, #40]

	tcr |= TCR_T0SZ(va_bits);
    a000b18c:	d2800801 	mov	x1, #0x40                  	// #64
    a000b190:	f94013e0 	ldr	x0, [sp, #32]
    a000b194:	cb000020 	sub	x0, x1, x0
    a000b198:	f94017e1 	ldr	x1, [sp, #40]
    a000b19c:	aa000020 	orr	x0, x1, x0
    a000b1a0:	f90017e0 	str	x0, [sp, #40]
	/*
	 * Translation table walk is cacheable, inner/outer WBWA and
	 * inner shareable
	 */
	tcr |= TCR_TG0_4K | TCR_SHARED_INNER | TCR_ORGN_WBWA | TCR_IRGN_WBWA;
    a000b1a4:	f94017e1 	ldr	x1, [sp, #40]
    a000b1a8:	d286a000 	mov	x0, #0x3500                	// #13568
    a000b1ac:	aa000020 	orr	x0, x1, x0
    a000b1b0:	f90017e0 	str	x0, [sp, #40]

	return tcr;
    a000b1b4:	f94017e0 	ldr	x0, [sp, #40]
}
    a000b1b8:	9100c3ff 	add	sp, sp, #0x30
    a000b1bc:	d65f03c0 	ret

00000000a000b1c0 <enable_mmu_el1>:

static void enable_mmu_el1(struct arm_mmu_ptables *ptables, unsigned int flags)
{
    a000b1c0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a000b1c4:	910003fd 	mov	x29, sp
    a000b1c8:	f9000fe0 	str	x0, [sp, #24]
    a000b1cc:	b90017e1 	str	w1, [sp, #20]
    a000b1d0:	d2808000 	mov	x0, #0x400                 	// #1024
    a000b1d4:	f2a88180 	movk	x0, #0x440c, lsl #16
    a000b1d8:	f2d77fe0 	movk	x0, #0xbbff, lsl #32
    a000b1dc:	f90013e0 	str	x0, [sp, #32]
MAKE_REG_HELPER_EL123(mair)
    a000b1e0:	f94013e0 	ldr	x0, [sp, #32]
    a000b1e4:	d518a200 	msr	mair_el1, x0
    a000b1e8:	d503201f 	nop
	ARG_UNUSED(flags);
	uint64_t val;

	/* Set MAIR, TCR and TBBR registers */
	write_mair_el1(MEMORY_ATTRIBUTES);
	write_tcr_el1(get_tcr(1));
    a000b1ec:	52800020 	mov	w0, #0x1                   	// #1
    a000b1f0:	97ffffd5 	bl	a000b144 <get_tcr>
    a000b1f4:	f90017e0 	str	x0, [sp, #40]
MAKE_REG_HELPER_EL123(tcr)
    a000b1f8:	f94017e0 	ldr	x0, [sp, #40]
    a000b1fc:	d5182040 	msr	tcr_el1, x0
    a000b200:	d503201f 	nop
	write_ttbr0_el1((uint64_t)ptables->base_xlat_table);
    a000b204:	f9400fe0 	ldr	x0, [sp, #24]
    a000b208:	f9400000 	ldr	x0, [x0]
    a000b20c:	f9001be0 	str	x0, [sp, #48]
MAKE_REG_HELPER_EL123(ttbr0)
    a000b210:	f9401be0 	ldr	x0, [sp, #48]
    a000b214:	d5182000 	msr	ttbr0_el1, x0
    a000b218:	d503201f 	nop

	/* Ensure these changes are seen before MMU is enabled */
	isb();
    a000b21c:	d5033fdf 	isb

	/* Invalidate all data caches before enable them */
	sys_cache_data_all(K_CACHE_INVD);
    a000b220:	52800040 	mov	w0, #0x2                   	// #2
    a000b224:	97fffa5e 	bl	a0009b9c <sys_cache_data_all>
MAKE_REG_HELPER_EL123(sctlr)
    a000b228:	d5381000 	mrs	x0, sctlr_el1
    a000b22c:	f9001fe0 	str	x0, [sp, #56]
    a000b230:	f9401fe0 	ldr	x0, [sp, #56]
    a000b234:	d503201f 	nop

	/* Enable the MMU and data cache */
	val = read_sctlr_el1();
    a000b238:	f90027e0 	str	x0, [sp, #72]
	write_sctlr_el1(val | SCTLR_M_BIT | SCTLR_C_BIT);
    a000b23c:	f94027e1 	ldr	x1, [sp, #72]
    a000b240:	d28000a0 	mov	x0, #0x5                   	// #5
    a000b244:	aa000020 	orr	x0, x1, x0
    a000b248:	f90023e0 	str	x0, [sp, #64]
    a000b24c:	f94023e0 	ldr	x0, [sp, #64]
    a000b250:	d5181000 	msr	sctlr_el1, x0
    a000b254:	d503201f 	nop

	/* Ensure the MMU enable takes effect immediately */
	isb();
    a000b258:	d5033fdf 	isb

	MMU_DEBUG("MMU enabled with dcache\n");
}
    a000b25c:	d503201f 	nop
    a000b260:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a000b264:	d65f03c0 	ret

00000000a000b268 <z_arm64_mm_init>:
 *
 * This function provides the default configuration mechanism for the Memory
 * Management Unit (MMU).
 */
void z_arm64_mm_init(bool is_primary_core)
{
    a000b268:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a000b26c:	910003fd 	mov	x29, sp
    a000b270:	39007fe0 	strb	w0, [sp, #31]
	unsigned int flags = 0U;
    a000b274:	b9002fff 	str	wzr, [sp, #44]
	__ASSERT((read_sctlr_el1() & SCTLR_M_BIT) == 0, "MMU is already enabled\n");

	/*
	 * Only booting core setup up the page tables.
	 */
	if (is_primary_core) {
    a000b278:	39407fe0 	ldrb	w0, [sp, #31]
    a000b27c:	7100001f 	cmp	w0, #0x0
    a000b280:	54000120 	b.eq	a000b2a4 <z_arm64_mm_init+0x3c>  // b.none
		kernel_ptables.base_xlat_table = new_table();
    a000b284:	97fffa57 	bl	a0009be0 <new_table>
    a000b288:	aa0003e1 	mov	x1, x0
    a000b28c:	900001e0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000b290:	913e8000 	add	x0, x0, #0xfa0
    a000b294:	f9000001 	str	x1, [x0]
		setup_page_tables(&kernel_ptables);
    a000b298:	900001e0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000b29c:	913e8000 	add	x0, x0, #0xfa0
    a000b2a0:	97ffff45 	bl	a000afb4 <setup_page_tables>
	}

	/* currently only EL1 is supported */
	enable_mmu_el1(&kernel_ptables, flags);
    a000b2a4:	b9402fe1 	ldr	w1, [sp, #44]
    a000b2a8:	900001e0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000b2ac:	913e8000 	add	x0, x0, #0xfa0
    a000b2b0:	97ffffc4 	bl	a000b1c0 <enable_mmu_el1>
}
    a000b2b4:	d503201f 	nop
    a000b2b8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a000b2bc:	d65f03c0 	ret

00000000a000b2c0 <is_ptable_active>:
#ifdef CONFIG_USERSPACE

static void z_arm64_swap_ptables(struct k_thread *incoming);

static inline bool is_ptable_active(struct arm_mmu_ptables *ptables)
{
    a000b2c0:	d10083ff 	sub	sp, sp, #0x20
    a000b2c4:	f90007e0 	str	x0, [sp, #8]
	return read_sysreg(ttbr0_el1) == (uintptr_t)ptables->base_xlat_table;
    a000b2c8:	d5382000 	mrs	x0, ttbr0_el1
    a000b2cc:	f9000fe0 	str	x0, [sp, #24]
    a000b2d0:	f9400fe0 	ldr	x0, [sp, #24]
    a000b2d4:	f94007e1 	ldr	x1, [sp, #8]
    a000b2d8:	f9400021 	ldr	x1, [x1]
    a000b2dc:	eb01001f 	cmp	x0, x1
    a000b2e0:	1a9f17e0 	cset	w0, eq  // eq = none
    a000b2e4:	12001c00 	and	w0, w0, #0xff
}
    a000b2e8:	910083ff 	add	sp, sp, #0x20
    a000b2ec:	d65f03c0 	ret

00000000a000b2f0 <arch_mem_domain_max_partitions_get>:

int arch_mem_domain_max_partitions_get(void)
{
	return CONFIG_MAX_DOMAIN_PARTITIONS;
    a000b2f0:	52800200 	mov	w0, #0x10                  	// #16
}
    a000b2f4:	d65f03c0 	ret

00000000a000b2f8 <arch_mem_domain_init>:

int arch_mem_domain_init(struct k_mem_domain *domain)
{
    a000b2f8:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    a000b2fc:	910003fd 	mov	x29, sp
    a000b300:	f9000fe0 	str	x0, [sp, #24]
	struct arm_mmu_ptables *domain_ptables = &domain->arch.ptables;
    a000b304:	f9400fe0 	ldr	x0, [sp, #24]
    a000b308:	f90037e0 	str	x0, [sp, #104]
    a000b30c:	900001e0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000b310:	913e8000 	add	x0, x0, #0xfa0
    a000b314:	f90027e0 	str	x0, [sp, #72]
MAKE_REG_HELPER(daif)
    a000b318:	d53b4220 	mrs	x0, daif
    a000b31c:	f90023e0 	str	x0, [sp, #64]
    a000b320:	f94023e0 	ldr	x0, [sp, #64]
    a000b324:	d503201f 	nop
	key = read_daif();
    a000b328:	b9003fe0 	str	w0, [sp, #60]
	__asm__ volatile ("msr DAIFSet, %0"
    a000b32c:	d50342df 	msr	daifset, #0x2
}
    a000b330:	d503201f 	nop
	return key;
    a000b334:	b9403fe0 	ldr	w0, [sp, #60]
	k.key = arch_irq_lock();
    a000b338:	b90033e0 	str	w0, [sp, #48]
	return k;
    a000b33c:	b94033e0 	ldr	w0, [sp, #48]
    a000b340:	b9003be0 	str	w0, [sp, #56]

	MMU_DEBUG("%s\n", __func__);

	key = k_spin_lock(&xlat_lock);
	domain_ptables->base_xlat_table =
		dup_table(kernel_ptables.base_xlat_table, BASE_XLAT_LEVEL);
    a000b344:	900001e0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000b348:	913e8000 	add	x0, x0, #0xfa0
    a000b34c:	f9400000 	ldr	x0, [x0]
    a000b350:	52800021 	mov	w1, #0x1                   	// #1
    a000b354:	97fffc10 	bl	a000a394 <dup_table>
    a000b358:	aa0003e1 	mov	x1, x0
	domain_ptables->base_xlat_table =
    a000b35c:	f94037e0 	ldr	x0, [sp, #104]
    a000b360:	f9000001 	str	x1, [x0]
    a000b364:	900001e0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000b368:	913e8000 	add	x0, x0, #0xfa0
    a000b36c:	f90033e0 	str	x0, [sp, #96]
    a000b370:	b9403be0 	ldr	w0, [sp, #56]
    a000b374:	b9002be0 	str	w0, [sp, #40]
	arch_irq_unlock(key.key);
    a000b378:	b9402be0 	ldr	w0, [sp, #40]
    a000b37c:	b9005fe0 	str	w0, [sp, #92]
	write_daif(key);
    a000b380:	b9405fe0 	ldr	w0, [sp, #92]
    a000b384:	f9002be0 	str	x0, [sp, #80]
MAKE_REG_HELPER(daif)
    a000b388:	f9402be0 	ldr	x0, [sp, #80]
    a000b38c:	d51b4220 	msr	daif, x0
    a000b390:	d503201f 	nop
}
    a000b394:	d503201f 	nop
}
    a000b398:	d503201f 	nop
	k_spin_unlock(&xlat_lock, key);
	if (!domain_ptables->base_xlat_table) {
    a000b39c:	f94037e0 	ldr	x0, [sp, #104]
    a000b3a0:	f9400000 	ldr	x0, [x0]
    a000b3a4:	f100001f 	cmp	x0, #0x0
    a000b3a8:	54000061 	b.ne	a000b3b4 <arch_mem_domain_init+0xbc>  // b.any
		return -ENOMEM;
    a000b3ac:	12800160 	mov	w0, #0xfffffff4            	// #-12
    a000b3b0:	14000008 	b	a000b3d0 <arch_mem_domain_init+0xd8>
	}
	sys_slist_append(&domain_list, &domain->arch.node);
    a000b3b4:	f9400fe0 	ldr	x0, [sp, #24]
    a000b3b8:	91002000 	add	x0, x0, #0x8
    a000b3bc:	aa0003e1 	mov	x1, x0
    a000b3c0:	900001e0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000b3c4:	913ea000 	add	x0, x0, #0xfa8
    a000b3c8:	97fff9ca 	bl	a0009af0 <sys_slist_append>
	return 0;
    a000b3cc:	52800000 	mov	w0, #0x0                   	// #0
}
    a000b3d0:	a8c77bfd 	ldp	x29, x30, [sp], #112
    a000b3d4:	d65f03c0 	ret

00000000a000b3d8 <private_map>:

static int private_map(struct arm_mmu_ptables *ptables, const char *name,
		       uintptr_t phys, uintptr_t virt, size_t size, uint32_t attrs)
{
    a000b3d8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a000b3dc:	910003fd 	mov	x29, sp
    a000b3e0:	f9001fe0 	str	x0, [sp, #56]
    a000b3e4:	f9001be1 	str	x1, [sp, #48]
    a000b3e8:	f90017e2 	str	x2, [sp, #40]
    a000b3ec:	f90013e3 	str	x3, [sp, #32]
    a000b3f0:	f9000fe4 	str	x4, [sp, #24]
    a000b3f4:	b90017e5 	str	w5, [sp, #20]
	int ret;

	ret = privatize_page_range(ptables, &kernel_ptables, virt, size, name);
    a000b3f8:	f9401be4 	ldr	x4, [sp, #48]
    a000b3fc:	f9400fe3 	ldr	x3, [sp, #24]
    a000b400:	f94013e2 	ldr	x2, [sp, #32]
    a000b404:	900001e0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000b408:	913e8001 	add	x1, x0, #0xfa0
    a000b40c:	f9401fe0 	ldr	x0, [sp, #56]
    a000b410:	97fffca4 	bl	a000a6a0 <privatize_page_range>
    a000b414:	b9004fe0 	str	w0, [sp, #76]
	__ASSERT(ret == 0, "privatize_page_range() returned %d", ret);
	ret = add_map(ptables, name, phys, virt, size, attrs);
    a000b418:	b94017e5 	ldr	w5, [sp, #20]
    a000b41c:	f9400fe4 	ldr	x4, [sp, #24]
    a000b420:	f94013e3 	ldr	x3, [sp, #32]
    a000b424:	f94017e2 	ldr	x2, [sp, #40]
    a000b428:	f9401be1 	ldr	x1, [sp, #48]
    a000b42c:	f9401fe0 	ldr	x0, [sp, #56]
    a000b430:	97fffe6c 	bl	a000ade0 <add_map>
    a000b434:	b9004fe0 	str	w0, [sp, #76]
	__ASSERT(ret == 0, "add_map() returned %d", ret);
	if (is_ptable_active(ptables)) {
    a000b438:	f9401fe0 	ldr	x0, [sp, #56]
    a000b43c:	97ffffa1 	bl	a000b2c0 <is_ptable_active>
    a000b440:	12001c00 	and	w0, w0, #0xff
    a000b444:	7100001f 	cmp	w0, #0x0
    a000b448:	54000040 	b.eq	a000b450 <private_map+0x78>  // b.none
		invalidate_tlb_all();
    a000b44c:	97fffe94 	bl	a000ae9c <invalidate_tlb_all>
	}

	return ret;
    a000b450:	b9404fe0 	ldr	w0, [sp, #76]
}
    a000b454:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a000b458:	d65f03c0 	ret

00000000a000b45c <reset_map>:

static int reset_map(struct arm_mmu_ptables *ptables, const char *name,
		     uintptr_t addr, size_t size)
{
    a000b45c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    a000b460:	910003fd 	mov	x29, sp
    a000b464:	f90017e0 	str	x0, [sp, #40]
    a000b468:	f90013e1 	str	x1, [sp, #32]
    a000b46c:	f9000fe2 	str	x2, [sp, #24]
    a000b470:	f9000be3 	str	x3, [sp, #16]
	int ret;

	ret = globalize_page_range(ptables, &kernel_ptables, addr, size, name);
    a000b474:	f94013e4 	ldr	x4, [sp, #32]
    a000b478:	f9400be3 	ldr	x3, [sp, #16]
    a000b47c:	f9400fe2 	ldr	x2, [sp, #24]
    a000b480:	900001e0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000b484:	913e8001 	add	x1, x0, #0xfa0
    a000b488:	f94017e0 	ldr	x0, [sp, #40]
    a000b48c:	97fffda9 	bl	a000ab30 <globalize_page_range>
    a000b490:	b9003fe0 	str	w0, [sp, #60]
	__ASSERT(ret == 0, "globalize_page_range() returned %d", ret);
	if (is_ptable_active(ptables)) {
    a000b494:	f94017e0 	ldr	x0, [sp, #40]
    a000b498:	97ffff8a 	bl	a000b2c0 <is_ptable_active>
    a000b49c:	12001c00 	and	w0, w0, #0xff
    a000b4a0:	7100001f 	cmp	w0, #0x0
    a000b4a4:	54000040 	b.eq	a000b4ac <reset_map+0x50>  // b.none
		invalidate_tlb_all();
    a000b4a8:	97fffe7d 	bl	a000ae9c <invalidate_tlb_all>
	}

	return ret;
    a000b4ac:	b9403fe0 	ldr	w0, [sp, #60]
}
    a000b4b0:	a8c47bfd 	ldp	x29, x30, [sp], #64
    a000b4b4:	d65f03c0 	ret

00000000a000b4b8 <arch_mem_domain_partition_add>:

int arch_mem_domain_partition_add(struct k_mem_domain *domain,
				  uint32_t partition_id)
{
    a000b4b8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a000b4bc:	910003fd 	mov	x29, sp
    a000b4c0:	f9000fe0 	str	x0, [sp, #24]
    a000b4c4:	b90017e1 	str	w1, [sp, #20]
	struct arm_mmu_ptables *domain_ptables = &domain->arch.ptables;
    a000b4c8:	f9400fe0 	ldr	x0, [sp, #24]
    a000b4cc:	f90017e0 	str	x0, [sp, #40]
	struct k_mem_partition *ptn = &domain->partitions[partition_id];
    a000b4d0:	b94017e1 	ldr	w1, [sp, #20]
    a000b4d4:	d2800300 	mov	x0, #0x18                  	// #24
    a000b4d8:	9b007c20 	mul	x0, x1, x0
    a000b4dc:	91004000 	add	x0, x0, #0x10
    a000b4e0:	f9400fe1 	ldr	x1, [sp, #24]
    a000b4e4:	8b000020 	add	x0, x1, x0
    a000b4e8:	f90013e0 	str	x0, [sp, #32]

	return private_map(domain_ptables, "partition", ptn->start, ptn->start,
    a000b4ec:	f94013e0 	ldr	x0, [sp, #32]
    a000b4f0:	f9400001 	ldr	x1, [x0]
    a000b4f4:	f94013e0 	ldr	x0, [sp, #32]
    a000b4f8:	f9400002 	ldr	x2, [x0]
    a000b4fc:	f94013e0 	ldr	x0, [sp, #32]
    a000b500:	f9400403 	ldr	x3, [x0, #8]
			   ptn->size, ptn->attr.attrs | MT_NORMAL);
    a000b504:	f94013e0 	ldr	x0, [sp, #32]
    a000b508:	b9401000 	ldr	w0, [x0, #16]
	return private_map(domain_ptables, "partition", ptn->start, ptn->start,
    a000b50c:	321e0000 	orr	w0, w0, #0x4
    a000b510:	2a0003e5 	mov	w5, w0
    a000b514:	aa0303e4 	mov	x4, x3
    a000b518:	aa0203e3 	mov	x3, x2
    a000b51c:	aa0103e2 	mov	x2, x1
    a000b520:	b00000c0 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a000b524:	91106001 	add	x1, x0, #0x418
    a000b528:	f94017e0 	ldr	x0, [sp, #40]
    a000b52c:	97ffffab 	bl	a000b3d8 <private_map>
}
    a000b530:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a000b534:	d65f03c0 	ret

00000000a000b538 <map_thread_stack>:
			 ptn->start, ptn->size);
}

static int map_thread_stack(struct k_thread *thread,
			    struct arm_mmu_ptables *ptables)
{
    a000b538:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a000b53c:	910003fd 	mov	x29, sp
    a000b540:	f9000fe0 	str	x0, [sp, #24]
    a000b544:	f9000be1 	str	x1, [sp, #16]
	return private_map(ptables, "thread_stack", thread->stack_info.start,
    a000b548:	f9400fe0 	ldr	x0, [sp, #24]
    a000b54c:	f9406801 	ldr	x1, [x0, #208]
    a000b550:	f9400fe0 	ldr	x0, [sp, #24]
    a000b554:	f9406802 	ldr	x2, [x0, #208]
    a000b558:	f9400fe0 	ldr	x0, [sp, #24]
    a000b55c:	f9406c00 	ldr	x0, [x0, #216]
    a000b560:	52801d85 	mov	w5, #0xec                  	// #236
    a000b564:	aa0003e4 	mov	x4, x0
    a000b568:	aa0203e3 	mov	x3, x2
    a000b56c:	aa0103e2 	mov	x2, x1
    a000b570:	b00000c0 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a000b574:	91110001 	add	x1, x0, #0x440
    a000b578:	f9400be0 	ldr	x0, [sp, #16]
    a000b57c:	97ffff97 	bl	a000b3d8 <private_map>
			    thread->stack_info.start, thread->stack_info.size,
			    MT_P_RW_U_RW | MT_NORMAL);
}
    a000b580:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a000b584:	d65f03c0 	ret

00000000a000b588 <arch_mem_domain_thread_add>:

int arch_mem_domain_thread_add(struct k_thread *thread)
{
    a000b588:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a000b58c:	910003fd 	mov	x29, sp
    a000b590:	f9000fe0 	str	x0, [sp, #24]
	struct arm_mmu_ptables *old_ptables, *domain_ptables;
	struct k_mem_domain *domain;
	bool is_user, is_migration;
	int ret = 0;
    a000b594:	b9004fff 	str	wzr, [sp, #76]

	domain = thread->mem_domain_info.mem_domain;
    a000b598:	f9400fe0 	ldr	x0, [sp, #24]
    a000b59c:	f9407c00 	ldr	x0, [x0, #248]
    a000b5a0:	f90023e0 	str	x0, [sp, #64]
	domain_ptables = &domain->arch.ptables;
    a000b5a4:	f94023e0 	ldr	x0, [sp, #64]
    a000b5a8:	f9001fe0 	str	x0, [sp, #56]
	old_ptables = thread->arch.ptables;
    a000b5ac:	f9400fe0 	ldr	x0, [sp, #24]
    a000b5b0:	f9409400 	ldr	x0, [x0, #296]
    a000b5b4:	f9001be0 	str	x0, [sp, #48]

	is_user = (thread->base.user_options & K_USER) != 0;
    a000b5b8:	f9400fe0 	ldr	x0, [sp, #24]
    a000b5bc:	39406000 	ldrb	w0, [x0, #24]
    a000b5c0:	92401c00 	and	x0, x0, #0xff
    a000b5c4:	927e0000 	and	x0, x0, #0x4
    a000b5c8:	f100001f 	cmp	x0, #0x0
    a000b5cc:	1a9f07e0 	cset	w0, ne  // ne = any
    a000b5d0:	3900bfe0 	strb	w0, [sp, #47]
	is_migration = (old_ptables != NULL) && is_user;
    a000b5d4:	f9401be0 	ldr	x0, [sp, #48]
    a000b5d8:	f100001f 	cmp	x0, #0x0
    a000b5dc:	540000c0 	b.eq	a000b5f4 <arch_mem_domain_thread_add+0x6c>  // b.none
    a000b5e0:	3940bfe0 	ldrb	w0, [sp, #47]
    a000b5e4:	7100001f 	cmp	w0, #0x0
    a000b5e8:	54000060 	b.eq	a000b5f4 <arch_mem_domain_thread_add+0x6c>  // b.none
    a000b5ec:	52800020 	mov	w0, #0x1                   	// #1
    a000b5f0:	14000002 	b	a000b5f8 <arch_mem_domain_thread_add+0x70>
    a000b5f4:	52800000 	mov	w0, #0x0                   	// #0
    a000b5f8:	3900bbe0 	strb	w0, [sp, #46]
    a000b5fc:	3940bbe0 	ldrb	w0, [sp, #46]
    a000b600:	12000000 	and	w0, w0, #0x1
    a000b604:	3900bbe0 	strb	w0, [sp, #46]

	if (is_migration) {
    a000b608:	3940bbe0 	ldrb	w0, [sp, #46]
    a000b60c:	7100001f 	cmp	w0, #0x0
    a000b610:	540000a0 	b.eq	a000b624 <arch_mem_domain_thread_add+0x9c>  // b.none
		ret = map_thread_stack(thread, domain_ptables);
    a000b614:	f9401fe1 	ldr	x1, [sp, #56]
    a000b618:	f9400fe0 	ldr	x0, [sp, #24]
    a000b61c:	97ffffc7 	bl	a000b538 <map_thread_stack>
    a000b620:	b9004fe0 	str	w0, [sp, #76]
	}

	thread->arch.ptables = domain_ptables;
    a000b624:	f9400fe0 	ldr	x0, [sp, #24]
    a000b628:	f9401fe1 	ldr	x1, [sp, #56]
    a000b62c:	f9009401 	str	x1, [x0, #296]
	if (thread == _current) {
    a000b630:	900001e0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000b634:	913f8000 	add	x0, x0, #0xfe0
    a000b638:	f9400800 	ldr	x0, [x0, #16]
    a000b63c:	f9400fe1 	ldr	x1, [sp, #24]
    a000b640:	eb00003f 	cmp	x1, x0
    a000b644:	54000141 	b.ne	a000b66c <arch_mem_domain_thread_add+0xe4>  // b.any
		if (!is_ptable_active(domain_ptables)) {
    a000b648:	f9401fe0 	ldr	x0, [sp, #56]
    a000b64c:	97ffff1d 	bl	a000b2c0 <is_ptable_active>
    a000b650:	12001c00 	and	w0, w0, #0xff
    a000b654:	52000000 	eor	w0, w0, #0x1
    a000b658:	12001c00 	and	w0, w0, #0xff
    a000b65c:	7100001f 	cmp	w0, #0x0
    a000b660:	54000060 	b.eq	a000b66c <arch_mem_domain_thread_add+0xe4>  // b.none
			z_arm64_swap_ptables(thread);
    a000b664:	f9400fe0 	ldr	x0, [sp, #24]
    a000b668:	94000036 	bl	a000b740 <z_arm64_swap_ptables>
		/* the thread could be running on another CPU right now */
		z_arm64_mem_cfg_ipi();
#endif
	}

	if (is_migration) {
    a000b66c:	3940bbe0 	ldrb	w0, [sp, #46]
    a000b670:	7100001f 	cmp	w0, #0x0
    a000b674:	54000180 	b.eq	a000b6a4 <arch_mem_domain_thread_add+0x11c>  // b.none
		ret = reset_map(old_ptables, __func__, thread->stack_info.start,
    a000b678:	f9400fe0 	ldr	x0, [sp, #24]
    a000b67c:	f9406801 	ldr	x1, [x0, #208]
    a000b680:	f9400fe0 	ldr	x0, [sp, #24]
    a000b684:	f9406c00 	ldr	x0, [x0, #216]
    a000b688:	aa0003e3 	mov	x3, x0
    a000b68c:	aa0103e2 	mov	x2, x1
    a000b690:	b00000c0 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a000b694:	911cc001 	add	x1, x0, #0x730
    a000b698:	f9401be0 	ldr	x0, [sp, #48]
    a000b69c:	97ffff70 	bl	a000b45c <reset_map>
    a000b6a0:	b9004fe0 	str	w0, [sp, #76]
				thread->stack_info.size);
	}

	return ret;
    a000b6a4:	b9404fe0 	ldr	w0, [sp, #76]
}
    a000b6a8:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a000b6ac:	d65f03c0 	ret

00000000a000b6b0 <arch_mem_domain_thread_remove>:

int arch_mem_domain_thread_remove(struct k_thread *thread)
{
    a000b6b0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a000b6b4:	910003fd 	mov	x29, sp
    a000b6b8:	f9000fe0 	str	x0, [sp, #24]
	struct arm_mmu_ptables *domain_ptables;
	struct k_mem_domain *domain;

	domain = thread->mem_domain_info.mem_domain;
    a000b6bc:	f9400fe0 	ldr	x0, [sp, #24]
    a000b6c0:	f9407c00 	ldr	x0, [x0, #248]
    a000b6c4:	f90017e0 	str	x0, [sp, #40]
	domain_ptables = &domain->arch.ptables;
    a000b6c8:	f94017e0 	ldr	x0, [sp, #40]
    a000b6cc:	f90013e0 	str	x0, [sp, #32]

	if ((thread->base.user_options & K_USER) == 0) {
    a000b6d0:	f9400fe0 	ldr	x0, [sp, #24]
    a000b6d4:	39406000 	ldrb	w0, [x0, #24]
    a000b6d8:	92401c00 	and	x0, x0, #0xff
    a000b6dc:	927e0000 	and	x0, x0, #0x4
    a000b6e0:	f100001f 	cmp	x0, #0x0
    a000b6e4:	54000061 	b.ne	a000b6f0 <arch_mem_domain_thread_remove+0x40>  // b.any
		return 0;
    a000b6e8:	52800000 	mov	w0, #0x0                   	// #0
    a000b6ec:	14000013 	b	a000b738 <arch_mem_domain_thread_remove+0x88>
	}

	if ((thread->base.thread_state & _THREAD_DEAD) == 0) {
    a000b6f0:	f9400fe0 	ldr	x0, [sp, #24]
    a000b6f4:	39406400 	ldrb	w0, [x0, #25]
    a000b6f8:	92401c00 	and	x0, x0, #0xff
    a000b6fc:	927d0000 	and	x0, x0, #0x8
    a000b700:	f100001f 	cmp	x0, #0x0
    a000b704:	54000061 	b.ne	a000b710 <arch_mem_domain_thread_remove+0x60>  // b.any
		return 0;
    a000b708:	52800000 	mov	w0, #0x0                   	// #0
    a000b70c:	1400000b 	b	a000b738 <arch_mem_domain_thread_remove+0x88>
	}

	return reset_map(domain_ptables, __func__, thread->stack_info.start,
    a000b710:	f9400fe0 	ldr	x0, [sp, #24]
    a000b714:	f9406801 	ldr	x1, [x0, #208]
    a000b718:	f9400fe0 	ldr	x0, [sp, #24]
    a000b71c:	f9406c00 	ldr	x0, [x0, #216]
    a000b720:	aa0003e3 	mov	x3, x0
    a000b724:	aa0103e2 	mov	x2, x1
    a000b728:	b00000c0 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a000b72c:	911d4001 	add	x1, x0, #0x750
    a000b730:	f94013e0 	ldr	x0, [sp, #32]
    a000b734:	97ffff4a 	bl	a000b45c <reset_map>
			 thread->stack_info.size);
}
    a000b738:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a000b73c:	d65f03c0 	ret

00000000a000b740 <z_arm64_swap_ptables>:

static void z_arm64_swap_ptables(struct k_thread *incoming)
{
    a000b740:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a000b744:	910003fd 	mov	x29, sp
    a000b748:	f9000fe0 	str	x0, [sp, #24]
	struct arm_mmu_ptables *ptables = incoming->arch.ptables;
    a000b74c:	f9400fe0 	ldr	x0, [sp, #24]
    a000b750:	f9409400 	ldr	x0, [x0, #296]
    a000b754:	f90017e0 	str	x0, [sp, #40]

	if (!is_ptable_active(ptables)) {
    a000b758:	f94017e0 	ldr	x0, [sp, #40]
    a000b75c:	97fffed9 	bl	a000b2c0 <is_ptable_active>
    a000b760:	12001c00 	and	w0, w0, #0xff
    a000b764:	52000000 	eor	w0, w0, #0x1
    a000b768:	12001c00 	and	w0, w0, #0xff
    a000b76c:	7100001f 	cmp	w0, #0x0
    a000b770:	54000080 	b.eq	a000b780 <z_arm64_swap_ptables+0x40>  // b.none
		z_arm64_set_ttbr0((uintptr_t)ptables->base_xlat_table);
    a000b774:	f94017e0 	ldr	x0, [sp, #40]
    a000b778:	f9400000 	ldr	x0, [x0]
    a000b77c:	94000021 	bl	a000b800 <z_arm64_set_ttbr0>
	}
}
    a000b780:	d503201f 	nop
    a000b784:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a000b788:	d65f03c0 	ret

00000000a000b78c <z_arm64_thread_mem_domains_init>:

void z_arm64_thread_mem_domains_init(struct k_thread *incoming)
{
    a000b78c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a000b790:	910003fd 	mov	x29, sp
    a000b794:	f9000fe0 	str	x0, [sp, #24]
	struct arm_mmu_ptables *ptables;

	if ((incoming->base.user_options & K_USER) == 0)
    a000b798:	f9400fe0 	ldr	x0, [sp, #24]
    a000b79c:	39406000 	ldrb	w0, [x0, #24]
    a000b7a0:	92401c00 	and	x0, x0, #0xff
    a000b7a4:	927e0000 	and	x0, x0, #0x4
    a000b7a8:	f100001f 	cmp	x0, #0x0
    a000b7ac:	54000140 	b.eq	a000b7d4 <z_arm64_thread_mem_domains_init+0x48>  // b.none
		return;

	ptables = incoming->arch.ptables;
    a000b7b0:	f9400fe0 	ldr	x0, [sp, #24]
    a000b7b4:	f9409400 	ldr	x0, [x0, #296]
    a000b7b8:	f90017e0 	str	x0, [sp, #40]

	/* Map the thread stack */
	map_thread_stack(incoming, ptables);
    a000b7bc:	f94017e1 	ldr	x1, [sp, #40]
    a000b7c0:	f9400fe0 	ldr	x0, [sp, #24]
    a000b7c4:	97ffff5d 	bl	a000b538 <map_thread_stack>

	z_arm64_swap_ptables(incoming);
    a000b7c8:	f9400fe0 	ldr	x0, [sp, #24]
    a000b7cc:	97ffffdd 	bl	a000b740 <z_arm64_swap_ptables>
    a000b7d0:	14000002 	b	a000b7d8 <z_arm64_thread_mem_domains_init+0x4c>
		return;
    a000b7d4:	d503201f 	nop
}
    a000b7d8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a000b7dc:	d65f03c0 	ret

00000000a000b7e0 <z_arm64_swap_mem_domains>:

void z_arm64_swap_mem_domains(struct k_thread *incoming)
{
    a000b7e0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a000b7e4:	910003fd 	mov	x29, sp
    a000b7e8:	f9000fe0 	str	x0, [sp, #24]
	z_arm64_swap_ptables(incoming);
    a000b7ec:	f9400fe0 	ldr	x0, [sp, #24]
    a000b7f0:	97ffffd4 	bl	a000b740 <z_arm64_swap_ptables>
}
    a000b7f4:	d503201f 	nop
    a000b7f8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a000b7fc:	d65f03c0 	ret

00000000a000b800 <z_arm64_set_ttbr0>:

GTEXT(z_arm64_set_ttbr0)
SECTION_FUNC(TEXT, z_arm64_set_ttbr0)

	/* Disable all the caches */
	mrs	x2, sctlr_el1
    a000b800:	d5381002 	mrs	x2, sctlr_el1
	mov_imm	x1, (SCTLR_M_BIT | SCTLR_C_BIT | SCTLR_I_BIT)
    a000b804:	d2a00001 	movz	x1, #0x0, lsl #16
    a000b808:	f28200a1 	movk	x1, #0x1005
	and	x1, x2, x1
    a000b80c:	8a010041 	and	x1, x2, x1
	msr	sctlr_el1, x1
    a000b810:	d5181001 	msr	sctlr_el1, x1
	isb
    a000b814:	d5033fdf 	isb

	/* Switch the TTBR0 */
	msr	ttbr0_el1, x0
    a000b818:	d5182000 	msr	ttbr0_el1, x0
	isb
    a000b81c:	d5033fdf 	isb

	/* Invalidate the TLBs */
	tlbi	vmalle1
    a000b820:	d508871f 	tlbi	vmalle1
	dsb	sy
    a000b824:	d5033f9f 	dsb	sy
	isb
    a000b828:	d5033fdf 	isb

	/* Restore the saved SCTLR_EL1 */
	msr	sctlr_el1, x2
    a000b82c:	d5181002 	msr	sctlr_el1, x2
	isb
    a000b830:	d5033fdf 	isb

	ret
    a000b834:	d65f03c0 	ret

00000000a000b838 <arch_user_string_nlen>:
	mov	x3, x0
    a000b838:	aa0003e3 	mov	x3, x0
	mov	x0, #0
    a000b83c:	d2800000 	mov	x0, #0x0                   	// #0
	mov	x4, #0
    a000b840:	d2800004 	mov	x4, #0x0                   	// #0

00000000a000b844 <strlen_loop>:
	cmp	x0, x1
    a000b844:	eb01001f 	cmp	x0, x1
	beq	strlen_done
    a000b848:	540000e0 	b.eq	a000b864 <strlen_done>  // b.none

00000000a000b84c <z_arm64_user_string_nlen_fault_start>:
	ldrb	w5, [x3, x0]
    a000b84c:	38606865 	ldrb	w5, [x3, x0]

00000000a000b850 <z_arm64_user_string_nlen_fault_end>:
	cbz	x5, strlen_done
    a000b850:	b40000a5 	cbz	x5, a000b864 <strlen_done>
	add	x0, x0, #1
    a000b854:	91000400 	add	x0, x0, #0x1
	b	strlen_loop
    a000b858:	17fffffb 	b	a000b844 <strlen_loop>

00000000a000b85c <z_arm64_user_string_nlen_fixup>:
	mov	x4, #-1
    a000b85c:	92800004 	mov	x4, #0xffffffffffffffff    	// #-1
	mov	x0, #0
    a000b860:	d2800000 	mov	x0, #0x0                   	// #0

00000000a000b864 <strlen_done>:
	str	w4, [x2]
    a000b864:	b9000044 	str	w4, [x2]
	ret
    a000b868:	d65f03c0 	ret

00000000a000b86c <arch_buffer_validate>:
	add	x1, x1, x0
    a000b86c:	8b000021 	add	x1, x1, x0
	mrs	x3, DAIF
    a000b870:	d53b4223 	mrs	x3, daif
	msr	DAIFSET, #DAIFSET_IRQ_BIT
    a000b874:	d50342df 	msr	daifset, #0x2

00000000a000b878 <abv_loop>:
	cbnz	w2, 1f
    a000b878:	35000062 	cbnz	w2, a000b884 <abv_loop+0xc>
	at	S1E0R, x0
    a000b87c:	d5087840 	at	s1e0r, x0
	b	2f
    a000b880:	14000002 	b	a000b888 <abv_loop+0x10>
1:	at	S1E0W, x0
    a000b884:	d5087860 	at	s1e0w, x0
2:	orr	x0, x0, #(MEM_DOMAIN_ALIGN_AND_SIZE - 1)
    a000b888:	b2402c00 	orr	x0, x0, #0xfff
	add	x0, x0, #1
    a000b88c:	91000400 	add	x0, x0, #0x1
	isb
    a000b890:	d5033fdf 	isb
	mrs	x4, PAR_EL1
    a000b894:	d5387404 	mrs	x4, par_el1
	tbnz	x4, #0, abv_fail
    a000b898:	370000c4 	tbnz	w4, #0, a000b8b0 <abv_fail>
	cmp	x0, x1
    a000b89c:	eb01001f 	cmp	x0, x1
	blo	abv_loop
    a000b8a0:	54fffec3 	b.cc	a000b878 <abv_loop>  // b.lo, b.ul, b.last
	msr	DAIF, x3
    a000b8a4:	d51b4223 	msr	daif, x3
	mov	x0, #0
    a000b8a8:	d2800000 	mov	x0, #0x0                   	// #0
	ret
    a000b8ac:	d65f03c0 	ret

00000000a000b8b0 <abv_fail>:
	msr	DAIF, x3
    a000b8b0:	d51b4223 	msr	daif, x3
	mov	x0, #-1
    a000b8b4:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
	ret
    a000b8b8:	d65f03c0 	ret

00000000a000b8bc <z_arm64_userspace_enter>:
 */

GTEXT(z_arm64_userspace_enter)
SECTION_FUNC(TEXT, z_arm64_userspace_enter)

	msr	DAIFSET, #DAIFSET_IRQ_BIT
    a000b8bc:	d50342df 	msr	daifset, #0x2
	/*
	 * When a kernel thread is moved to user mode it doesn't have any
	 * SP_EL0 set yet. We set it here for the first time pointing to the
	 * beginning of the user accessible part of the stack (the top).
	 */
	msr	sp_el0, x1
    a000b8c0:	d5184101 	msr	sp_el0, x1
	 * Set SP_EL1 to point at the end of the ESF. Since we have relocated
	 * the ESF at the beginning of the privileged stack area, when the ESF
	 * is popped out by z_arm64_exit_exc() the SP_EL1 will be at the right
	 * location for when the next exception will come.
	 */
	mov	sp, x0
    a000b8c4:	9100001f 	mov	sp, x0

	/* we have to fake our exception depth count too */
	mrs	x0, tpidrro_el0
    a000b8c8:	d53bd060 	mrs	x0, tpidrro_el0
	mov	x1, #TPIDRROEL0_EXC_UNIT
    a000b8cc:	d2e02001 	mov	x1, #0x100000000000000     	// #72057594037927936
	bic	x0, x0, #TPIDRROEL0_EXC_DEPTH
    a000b8d0:	9240dc00 	and	x0, x0, #0xffffffffffffff
	add	x0, x0, x1
    a000b8d4:	8b010000 	add	x0, x0, x1
	msr	tpidrro_el0, x0
    a000b8d8:	d51bd060 	msr	tpidrro_el0, x0

	b	z_arm64_exit_exc
    a000b8dc:	17fff84e 	b	a0009a14 <z_arm64_exit_exc>

00000000a000b8e0 <arch_dcache_all>:
 * ops:  K_CACHE_INVD: invalidate
 *	 K_CACHE_WB: clean
 *	 K_CACHE_WB_INVD: clean and invalidate
 */
int arch_dcache_all(int op)
{
    a000b8e0:	d10183ff 	sub	sp, sp, #0x60
    a000b8e4:	b9000fe0 	str	w0, [sp, #12]
	uint32_t clidr_el1, csselr_el1, ccsidr_el1;
	uint8_t loc, ctype, cache_level, line_size, way_pos;
	uint32_t max_ways, max_sets, dc_val, set, way;

	if (op != K_CACHE_INVD && op != K_CACHE_WB && op != K_CACHE_WB_INVD)
    a000b8e8:	b9400fe0 	ldr	w0, [sp, #12]
    a000b8ec:	7100081f 	cmp	w0, #0x2
    a000b8f0:	54000120 	b.eq	a000b914 <arch_dcache_all+0x34>  // b.none
    a000b8f4:	b9400fe0 	ldr	w0, [sp, #12]
    a000b8f8:	7100041f 	cmp	w0, #0x1
    a000b8fc:	540000c0 	b.eq	a000b914 <arch_dcache_all+0x34>  // b.none
    a000b900:	b9400fe0 	ldr	w0, [sp, #12]
    a000b904:	71000c1f 	cmp	w0, #0x3
    a000b908:	54000060 	b.eq	a000b914 <arch_dcache_all+0x34>  // b.none
		return -ENOTSUP;
    a000b90c:	128010a0 	mov	w0, #0xffffff7a            	// #-134
    a000b910:	1400007f 	b	a000bb0c <arch_dcache_all+0x22c>

	/* Data barrier before start */
	dsb();
    a000b914:	d5033f9f 	dsb	sy
MAKE_REG_HELPER(clidr_el1);
    a000b918:	d5390020 	mrs	x0, clidr_el1
    a000b91c:	f90017e0 	str	x0, [sp, #40]
    a000b920:	f94017e0 	ldr	x0, [sp, #40]
    a000b924:	d503201f 	nop

	clidr_el1 = read_clidr_el1();
    a000b928:	b90053e0 	str	w0, [sp, #80]

	loc = (clidr_el1 >> CLIDR_EL1_LOC_SHIFT) & CLIDR_EL1_LOC_MASK;
    a000b92c:	b94053e0 	ldr	w0, [sp, #80]
    a000b930:	53187c00 	lsr	w0, w0, #24
    a000b934:	12001c00 	and	w0, w0, #0xff
    a000b938:	12000800 	and	w0, w0, #0x7
    a000b93c:	39013fe0 	strb	w0, [sp, #79]
	if (!loc)
    a000b940:	39413fe0 	ldrb	w0, [sp, #79]
    a000b944:	7100001f 	cmp	w0, #0x0
    a000b948:	54000061 	b.ne	a000b954 <arch_dcache_all+0x74>  // b.any
		return 0;
    a000b94c:	52800000 	mov	w0, #0x0                   	// #0
    a000b950:	1400006f 	b	a000bb0c <arch_dcache_all+0x22c>

	for (cache_level = 0; cache_level < loc; cache_level++) {
    a000b954:	39017fff 	strb	wzr, [sp, #95]
    a000b958:	14000062 	b	a000bae0 <arch_dcache_all+0x200>
		ctype = (clidr_el1 >> CLIDR_EL1_CTYPE_SHIFT(cache_level))
    a000b95c:	39417fe1 	ldrb	w1, [sp, #95]
    a000b960:	2a0103e0 	mov	w0, w1
    a000b964:	0b000000 	add	w0, w0, w0
    a000b968:	0b010000 	add	w0, w0, w1
    a000b96c:	b94053e1 	ldr	w1, [sp, #80]
    a000b970:	1ac02420 	lsr	w0, w1, w0
				& CLIDR_EL1_CTYPE_MASK;
    a000b974:	12001c00 	and	w0, w0, #0xff
		ctype = (clidr_el1 >> CLIDR_EL1_CTYPE_SHIFT(cache_level))
    a000b978:	12000800 	and	w0, w0, #0x7
    a000b97c:	39013be0 	strb	w0, [sp, #78]
		/* No data cache, continue */
		if (ctype < 2)
    a000b980:	39413be0 	ldrb	w0, [sp, #78]
    a000b984:	7100041f 	cmp	w0, #0x1
    a000b988:	54000a49 	b.ls	a000bad0 <arch_dcache_all+0x1f0>  // b.plast
			continue;

		/* select cache level */
		csselr_el1 = cache_level << 1;
    a000b98c:	39417fe0 	ldrb	w0, [sp, #95]
    a000b990:	0b000000 	add	w0, w0, w0
    a000b994:	b9004be0 	str	w0, [sp, #72]
		write_csselr_el1(csselr_el1);
    a000b998:	b9404be0 	ldr	w0, [sp, #72]
    a000b99c:	f9000fe0 	str	x0, [sp, #24]
MAKE_REG_HELPER(csselr_el1);
    a000b9a0:	f9400fe0 	ldr	x0, [sp, #24]
    a000b9a4:	d51a0000 	msr	csselr_el1, x0
    a000b9a8:	d503201f 	nop
		isb();
    a000b9ac:	d5033fdf 	isb
MAKE_REG_HELPER(ccsidr_el1);
    a000b9b0:	d5390000 	mrs	x0, ccsidr_el1
    a000b9b4:	f90013e0 	str	x0, [sp, #32]
    a000b9b8:	f94013e0 	ldr	x0, [sp, #32]
    a000b9bc:	d503201f 	nop

		ccsidr_el1 = read_ccsidr_el1();
    a000b9c0:	b90047e0 	str	w0, [sp, #68]
		line_size = (ccsidr_el1 >> CCSIDR_EL1_LN_SZ_SHIFT
				& CCSIDR_EL1_LN_SZ_MASK) + 4;
    a000b9c4:	b94047e0 	ldr	w0, [sp, #68]
    a000b9c8:	12001c00 	and	w0, w0, #0xff
    a000b9cc:	12000800 	and	w0, w0, #0x7
    a000b9d0:	12001c00 	and	w0, w0, #0xff
		line_size = (ccsidr_el1 >> CCSIDR_EL1_LN_SZ_SHIFT
    a000b9d4:	11001000 	add	w0, w0, #0x4
    a000b9d8:	39010fe0 	strb	w0, [sp, #67]
		max_ways = (ccsidr_el1 >> CCSIDR_EL1_WAYS_SHIFT)
    a000b9dc:	b94047e0 	ldr	w0, [sp, #68]
    a000b9e0:	53037c00 	lsr	w0, w0, #3
    a000b9e4:	12002400 	and	w0, w0, #0x3ff
    a000b9e8:	b9003fe0 	str	w0, [sp, #60]
				& CCSIDR_EL1_WAYS_MASK;
		max_sets = (ccsidr_el1 >> CCSIDR_EL1_SETS_SHIFT)
    a000b9ec:	b94047e0 	ldr	w0, [sp, #68]
    a000b9f0:	530d7c00 	lsr	w0, w0, #13
    a000b9f4:	12003800 	and	w0, w0, #0x7fff
    a000b9f8:	b9003be0 	str	w0, [sp, #56]
				& CCSIDR_EL1_SETS_MASK;
		/* 32-log2(ways), bit position of way in DC operand */
		way_pos = __builtin_clz(max_ways);
    a000b9fc:	b9403fe0 	ldr	w0, [sp, #60]
    a000ba00:	5ac01000 	clz	w0, w0
    a000ba04:	3900dfe0 	strb	w0, [sp, #55]

		for (set = 0; set <= max_sets; set++) {
    a000ba08:	b9005bff 	str	wzr, [sp, #88]
    a000ba0c:	1400002c 	b	a000babc <arch_dcache_all+0x1dc>
			for (way = 0; way <= max_ways; way++) {
    a000ba10:	b90057ff 	str	wzr, [sp, #84]
    a000ba14:	14000023 	b	a000baa0 <arch_dcache_all+0x1c0>
				/* way number, aligned to pos in DC operand */
				dc_val = way << way_pos;
    a000ba18:	3940dfe0 	ldrb	w0, [sp, #55]
    a000ba1c:	b94057e1 	ldr	w1, [sp, #84]
    a000ba20:	1ac02020 	lsl	w0, w1, w0
    a000ba24:	b90033e0 	str	w0, [sp, #48]
				/* cache level, aligned to pos in DC operand */
				dc_val |= csselr_el1;
    a000ba28:	b94033e1 	ldr	w1, [sp, #48]
    a000ba2c:	b9404be0 	ldr	w0, [sp, #72]
    a000ba30:	2a000020 	orr	w0, w1, w0
    a000ba34:	b90033e0 	str	w0, [sp, #48]
				/* set number, aligned to pos in DC operand */
				dc_val |= set << line_size;
    a000ba38:	39410fe0 	ldrb	w0, [sp, #67]
    a000ba3c:	b9405be1 	ldr	w1, [sp, #88]
    a000ba40:	1ac02020 	lsl	w0, w1, w0
    a000ba44:	b94033e1 	ldr	w1, [sp, #48]
    a000ba48:	2a000020 	orr	w0, w1, w0
    a000ba4c:	b90033e0 	str	w0, [sp, #48]

				if (op == K_CACHE_INVD) {
    a000ba50:	b9400fe0 	ldr	w0, [sp, #12]
    a000ba54:	7100081f 	cmp	w0, #0x2
    a000ba58:	54000081 	b.ne	a000ba68 <arch_dcache_all+0x188>  // b.any
					dc_ops("isw", dc_val);
    a000ba5c:	b94033e0 	ldr	w0, [sp, #48]
    a000ba60:	d5087640 	dc	isw, x0
    a000ba64:	1400000c 	b	a000ba94 <arch_dcache_all+0x1b4>
				} else if (op == K_CACHE_WB_INVD) {
    a000ba68:	b9400fe0 	ldr	w0, [sp, #12]
    a000ba6c:	71000c1f 	cmp	w0, #0x3
    a000ba70:	54000081 	b.ne	a000ba80 <arch_dcache_all+0x1a0>  // b.any
					dc_ops("cisw", dc_val);
    a000ba74:	b94033e0 	ldr	w0, [sp, #48]
    a000ba78:	d5087e40 	dc	cisw, x0
    a000ba7c:	14000006 	b	a000ba94 <arch_dcache_all+0x1b4>
				} else if (op == K_CACHE_WB) {
    a000ba80:	b9400fe0 	ldr	w0, [sp, #12]
    a000ba84:	7100041f 	cmp	w0, #0x1
    a000ba88:	54000061 	b.ne	a000ba94 <arch_dcache_all+0x1b4>  // b.any
					dc_ops("csw", dc_val);
    a000ba8c:	b94033e0 	ldr	w0, [sp, #48]
    a000ba90:	d5087a40 	dc	csw, x0
			for (way = 0; way <= max_ways; way++) {
    a000ba94:	b94057e0 	ldr	w0, [sp, #84]
    a000ba98:	11000400 	add	w0, w0, #0x1
    a000ba9c:	b90057e0 	str	w0, [sp, #84]
    a000baa0:	b94057e1 	ldr	w1, [sp, #84]
    a000baa4:	b9403fe0 	ldr	w0, [sp, #60]
    a000baa8:	6b00003f 	cmp	w1, w0
    a000baac:	54fffb69 	b.ls	a000ba18 <arch_dcache_all+0x138>  // b.plast
		for (set = 0; set <= max_sets; set++) {
    a000bab0:	b9405be0 	ldr	w0, [sp, #88]
    a000bab4:	11000400 	add	w0, w0, #0x1
    a000bab8:	b9005be0 	str	w0, [sp, #88]
    a000babc:	b9405be1 	ldr	w1, [sp, #88]
    a000bac0:	b9403be0 	ldr	w0, [sp, #56]
    a000bac4:	6b00003f 	cmp	w1, w0
    a000bac8:	54fffa49 	b.ls	a000ba10 <arch_dcache_all+0x130>  // b.plast
    a000bacc:	14000002 	b	a000bad4 <arch_dcache_all+0x1f4>
			continue;
    a000bad0:	d503201f 	nop
	for (cache_level = 0; cache_level < loc; cache_level++) {
    a000bad4:	39417fe0 	ldrb	w0, [sp, #95]
    a000bad8:	11000400 	add	w0, w0, #0x1
    a000badc:	39017fe0 	strb	w0, [sp, #95]
    a000bae0:	39417fe1 	ldrb	w1, [sp, #95]
    a000bae4:	39413fe0 	ldrb	w0, [sp, #79]
    a000bae8:	6b00003f 	cmp	w1, w0
    a000baec:	54fff383 	b.cc	a000b95c <arch_dcache_all+0x7c>  // b.lo, b.ul, b.last
    a000baf0:	f9000bff 	str	xzr, [sp, #16]
MAKE_REG_HELPER(csselr_el1);
    a000baf4:	f9400be0 	ldr	x0, [sp, #16]
    a000baf8:	d51a0000 	msr	csselr_el1, x0
    a000bafc:	d503201f 	nop
		}
	}

	/* Restore csselr_el1 to level 0 */
	write_csselr_el1(0);
	dsb();
    a000bb00:	d5033f9f 	dsb	sy
	isb();
    a000bb04:	d5033fdf 	isb

	return 0;
    a000bb08:	52800000 	mov	w0, #0x0                   	// #0
}
    a000bb0c:	910183ff 	add	sp, sp, #0x60
    a000bb10:	d65f03c0 	ret

00000000a000bb14 <arch_syscall_invoke2>:
{
    a000bb14:	d10083ff 	sub	sp, sp, #0x20
    a000bb18:	f9000fe0 	str	x0, [sp, #24]
    a000bb1c:	f9000be1 	str	x1, [sp, #16]
    a000bb20:	f90007e2 	str	x2, [sp, #8]
	register uint64_t ret __asm__("x0") = arg1;
    a000bb24:	f9400fe0 	ldr	x0, [sp, #24]
	register uint64_t r1 __asm__("x1") = arg2;
    a000bb28:	f9400be1 	ldr	x1, [sp, #16]
	register uint64_t r8 __asm__("x8") = call_id;
    a000bb2c:	f94007e8 	ldr	x8, [sp, #8]
	__asm__ volatile("svc %[svid]\n"
    a000bb30:	d4000061 	svc	#0x3
}
    a000bb34:	910083ff 	add	sp, sp, #0x20
    a000bb38:	d65f03c0 	ret

00000000a000bb3c <arch_syscall_invoke1>:
{
    a000bb3c:	d10043ff 	sub	sp, sp, #0x10
    a000bb40:	f90007e0 	str	x0, [sp, #8]
    a000bb44:	f90003e1 	str	x1, [sp]
	register uint64_t ret __asm__("x0") = arg1;
    a000bb48:	f94007e0 	ldr	x0, [sp, #8]
	register uint64_t r8 __asm__("x8") = call_id;
    a000bb4c:	f94003e8 	ldr	x8, [sp]
	__asm__ volatile("svc %[svid]\n"
    a000bb50:	d4000061 	svc	#0x3
}
    a000bb54:	910043ff 	add	sp, sp, #0x10
    a000bb58:	d65f03c0 	ret

00000000a000bb5c <arch_syscall_invoke0>:
{
    a000bb5c:	d10043ff 	sub	sp, sp, #0x10
    a000bb60:	f90007e0 	str	x0, [sp, #8]
	register uint64_t r8 __asm__("x8") = call_id;
    a000bb64:	f94007e8 	ldr	x8, [sp, #8]
	__asm__ volatile("svc %[svid]\n"
    a000bb68:	d4000061 	svc	#0x3
}
    a000bb6c:	910043ff 	add	sp, sp, #0x10
    a000bb70:	d65f03c0 	ret

00000000a000bb74 <arch_is_user_context>:
{
    a000bb74:	d10043ff 	sub	sp, sp, #0x10
MAKE_REG_HELPER(tpidrro_el0);
    a000bb78:	d53bd060 	mrs	x0, tpidrro_el0
    a000bb7c:	f90007e0 	str	x0, [sp, #8]
    a000bb80:	f94007e0 	ldr	x0, [sp, #8]
    a000bb84:	d503201f 	nop
	return (read_tpidrro_el0() & TPIDRROEL0_IN_EL0) != 0;
    a000bb88:	92400000 	and	x0, x0, #0x1
    a000bb8c:	f100001f 	cmp	x0, #0x0
    a000bb90:	1a9f07e0 	cset	w0, ne  // ne = any
    a000bb94:	12001c00 	and	w0, w0, #0xff
}
    a000bb98:	910043ff 	add	sp, sp, #0x10
    a000bb9c:	d65f03c0 	ret

00000000a000bba0 <z_errno>:

extern int * z_impl_z_errno(void);

__pinned_func
static inline int * z_errno(void)
{
    a000bba0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a000bba4:	910003fd 	mov	x29, sp
	bool ret = false;
    a000bba8:	39007fff 	strb	wzr, [sp, #31]
	ret = arch_is_user_context();
    a000bbac:	97fffff2 	bl	a000bb74 <arch_is_user_context>
    a000bbb0:	39007fe0 	strb	w0, [sp, #31]
	return ret;
    a000bbb4:	39407fe0 	ldrb	w0, [sp, #31]
#ifdef CONFIG_USERSPACE
	if (z_syscall_trap()) {
    a000bbb8:	7100001f 	cmp	w0, #0x0
    a000bbbc:	54000080 	b.eq	a000bbcc <z_errno+0x2c>  // b.none
		/* coverity[OVERRUN] */
		return (int *) arch_syscall_invoke0(K_SYSCALL_Z_ERRNO);
    a000bbc0:	d2802b60 	mov	x0, #0x15b                 	// #347
    a000bbc4:	97ffffe6 	bl	a000bb5c <arch_syscall_invoke0>
    a000bbc8:	14000002 	b	a000bbd0 <z_errno+0x30>
	}
#endif
	compiler_barrier();
	return z_impl_z_errno();
    a000bbcc:	94001455 	bl	a0010d20 <z_impl_z_errno>
}
    a000bbd0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a000bbd4:	d65f03c0 	ret

00000000a000bbd8 <sys_mutex_init>:
 * and the mutex was not created with SYS_MUTEX_DEFINE().
 *
 * @param mutex Address of the mutex.
 */
static inline void sys_mutex_init(struct sys_mutex *mutex)
{
    a000bbd8:	d10043ff 	sub	sp, sp, #0x10
    a000bbdc:	f90007e0 	str	x0, [sp, #8]
	ARG_UNUSED(mutex);

	/* Nothing to do, kernel-side data structures are initialized at
	 * boot
	 */
}
    a000bbe0:	d503201f 	nop
    a000bbe4:	910043ff 	add	sp, sp, #0x10
    a000bbe8:	d65f03c0 	ret

00000000a000bbec <sys_mutex_lock>:
 * @retval -EAGAIN Waiting period timed out.
 * @retval -EACCES Caller has no access to provided mutex address
 * @retval -EINVAL Provided mutex not recognized by the kernel
 */
static inline int sys_mutex_lock(struct sys_mutex *mutex, k_timeout_t timeout)
{
    a000bbec:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a000bbf0:	910003fd 	mov	x29, sp
    a000bbf4:	f9000fe0 	str	x0, [sp, #24]
    a000bbf8:	f9000be1 	str	x1, [sp, #16]
	/* For now, make the syscall unconditionally */
	return z_sys_mutex_kernel_lock(mutex, timeout);
    a000bbfc:	f9400be1 	ldr	x1, [sp, #16]
    a000bc00:	f9400fe0 	ldr	x0, [sp, #24]
    a000bc04:	9400000a 	bl	a000bc2c <z_sys_mutex_kernel_lock>
}
    a000bc08:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a000bc0c:	d65f03c0 	ret

00000000a000bc10 <sys_mutex_unlock>:
 * @retval -EINVAL Provided mutex not recognized by the kernel or mutex wasn't
 *                 locked
 * @retval -EPERM Caller does not own the mutex
 */
static inline int sys_mutex_unlock(struct sys_mutex *mutex)
{
    a000bc10:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a000bc14:	910003fd 	mov	x29, sp
    a000bc18:	f9000fe0 	str	x0, [sp, #24]
	/* For now, make the syscall unconditionally */
	return z_sys_mutex_kernel_unlock(mutex);
    a000bc1c:	f9400fe0 	ldr	x0, [sp, #24]
    a000bc20:	9400001b 	bl	a000bc8c <z_sys_mutex_kernel_unlock>
}
    a000bc24:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a000bc28:	d65f03c0 	ret

00000000a000bc2c <z_sys_mutex_kernel_lock>:

extern int z_impl_z_sys_mutex_kernel_lock(struct sys_mutex * mutex, k_timeout_t timeout);

__pinned_func
static inline int z_sys_mutex_kernel_lock(struct sys_mutex * mutex, k_timeout_t timeout)
{
    a000bc2c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a000bc30:	910003fd 	mov	x29, sp
    a000bc34:	f9000fe0 	str	x0, [sp, #24]
    a000bc38:	f9000be1 	str	x1, [sp, #16]
	bool ret = false;
    a000bc3c:	3900bfff 	strb	wzr, [sp, #47]
	ret = arch_is_user_context();
    a000bc40:	97ffffcd 	bl	a000bb74 <arch_is_user_context>
    a000bc44:	3900bfe0 	strb	w0, [sp, #47]
	return ret;
    a000bc48:	3940bfe0 	ldrb	w0, [sp, #47]
#ifdef CONFIG_USERSPACE
	if (z_syscall_trap()) {
    a000bc4c:	7100001f 	cmp	w0, #0x0
    a000bc50:	54000140 	b.eq	a000bc78 <z_sys_mutex_kernel_lock+0x4c>  // b.none
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke2(*(uintptr_t *)&mutex, *(uintptr_t *)&timeout, K_SYSCALL_Z_SYS_MUTEX_KERNEL_LOCK);
    a000bc54:	910063e0 	add	x0, sp, #0x18
    a000bc58:	f9400003 	ldr	x3, [x0]
    a000bc5c:	910043e0 	add	x0, sp, #0x10
    a000bc60:	f9400000 	ldr	x0, [x0]
    a000bc64:	d2802c02 	mov	x2, #0x160                 	// #352
    a000bc68:	aa0003e1 	mov	x1, x0
    a000bc6c:	aa0303e0 	mov	x0, x3
    a000bc70:	97ffffa9 	bl	a000bb14 <arch_syscall_invoke2>
    a000bc74:	14000004 	b	a000bc84 <z_sys_mutex_kernel_lock+0x58>
	}
#endif
	compiler_barrier();
	return z_impl_z_sys_mutex_kernel_lock(mutex, timeout);
    a000bc78:	f9400fe0 	ldr	x0, [sp, #24]
    a000bc7c:	f9400be1 	ldr	x1, [sp, #16]
    a000bc80:	97fff417 	bl	a0008cdc <z_impl_z_sys_mutex_kernel_lock>
}
    a000bc84:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a000bc88:	d65f03c0 	ret

00000000a000bc8c <z_sys_mutex_kernel_unlock>:

extern int z_impl_z_sys_mutex_kernel_unlock(struct sys_mutex * mutex);

__pinned_func
static inline int z_sys_mutex_kernel_unlock(struct sys_mutex * mutex)
{
    a000bc8c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a000bc90:	910003fd 	mov	x29, sp
    a000bc94:	f9000fe0 	str	x0, [sp, #24]
	bool ret = false;
    a000bc98:	3900bfff 	strb	wzr, [sp, #47]
	ret = arch_is_user_context();
    a000bc9c:	97ffffb6 	bl	a000bb74 <arch_is_user_context>
    a000bca0:	3900bfe0 	strb	w0, [sp, #47]
	return ret;
    a000bca4:	3940bfe0 	ldrb	w0, [sp, #47]
#ifdef CONFIG_USERSPACE
	if (z_syscall_trap()) {
    a000bca8:	7100001f 	cmp	w0, #0x0
    a000bcac:	540000c0 	b.eq	a000bcc4 <z_sys_mutex_kernel_unlock+0x38>  // b.none
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke1(*(uintptr_t *)&mutex, K_SYSCALL_Z_SYS_MUTEX_KERNEL_UNLOCK);
    a000bcb0:	910063e0 	add	x0, sp, #0x18
    a000bcb4:	f9400000 	ldr	x0, [x0]
    a000bcb8:	d2802c21 	mov	x1, #0x161                 	// #353
    a000bcbc:	97ffffa0 	bl	a000bb3c <arch_syscall_invoke1>
    a000bcc0:	14000003 	b	a000bccc <z_sys_mutex_kernel_unlock+0x40>
	}
#endif
	compiler_barrier();
	return z_impl_z_sys_mutex_kernel_unlock(mutex);
    a000bcc4:	f9400fe0 	ldr	x0, [sp, #24]
    a000bcc8:	97fff442 	bl	a0008dd0 <z_impl_z_sys_mutex_kernel_unlock>
}
    a000bccc:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a000bcd0:	d65f03c0 	ret

00000000a000bcd4 <malloc>:
Z_GENERIC_SECTION(POOL_SECTION) static struct sys_heap z_malloc_heap;
Z_GENERIC_SECTION(POOL_SECTION) struct sys_mutex z_malloc_heap_mutex;
Z_GENERIC_SECTION(POOL_SECTION) static char z_malloc_heap_mem[HEAP_BYTES];

void *malloc(size_t size)
{
    a000bcd4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a000bcd8:	910003fd 	mov	x29, sp
    a000bcdc:	f9000fe0 	str	x0, [sp, #24]
	int lock_ret;

	lock_ret = sys_mutex_lock(&z_malloc_heap_mutex, K_FOREVER);
    a000bce0:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    a000bce4:	aa0003e1 	mov	x1, x0
    a000bce8:	f00000c0 	adrp	x0, a0026000 <z_malloc_heap>
    a000bcec:	91006000 	add	x0, x0, #0x18
    a000bcf0:	97ffffbf 	bl	a000bbec <sys_mutex_lock>
    a000bcf4:	b9002fe0 	str	w0, [sp, #44]
	__ASSERT_NO_MSG(lock_ret == 0);

	void *ret = sys_heap_aligned_alloc(&z_malloc_heap,
    a000bcf8:	f9400fe2 	ldr	x2, [sp, #24]
    a000bcfc:	d2800201 	mov	x1, #0x10                  	// #16
    a000bd00:	f00000c0 	adrp	x0, a0026000 <z_malloc_heap>
    a000bd04:	91000000 	add	x0, x0, #0x0
    a000bd08:	97ffe780 	bl	a0005b08 <sys_heap_aligned_alloc>
    a000bd0c:	f90013e0 	str	x0, [sp, #32]
					   __alignof__(z_max_align_t),
					   size);
	if (ret == NULL && size != 0) {
    a000bd10:	f94013e0 	ldr	x0, [sp, #32]
    a000bd14:	f100001f 	cmp	x0, #0x0
    a000bd18:	54000101 	b.ne	a000bd38 <malloc+0x64>  // b.any
    a000bd1c:	f9400fe0 	ldr	x0, [sp, #24]
    a000bd20:	f100001f 	cmp	x0, #0x0
    a000bd24:	540000a0 	b.eq	a000bd38 <malloc+0x64>  // b.none
		errno = ENOMEM;
    a000bd28:	97ffff9e 	bl	a000bba0 <z_errno>
    a000bd2c:	aa0003e1 	mov	x1, x0
    a000bd30:	52800180 	mov	w0, #0xc                   	// #12
    a000bd34:	b9000020 	str	w0, [x1]
	}

	(void) sys_mutex_unlock(&z_malloc_heap_mutex);
    a000bd38:	f00000c0 	adrp	x0, a0026000 <z_malloc_heap>
    a000bd3c:	91006000 	add	x0, x0, #0x18
    a000bd40:	97ffffb4 	bl	a000bc10 <sys_mutex_unlock>

	return ret;
    a000bd44:	f94013e0 	ldr	x0, [sp, #32]
}
    a000bd48:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a000bd4c:	d65f03c0 	ret

00000000a000bd50 <malloc_prepare>:

static int malloc_prepare(const struct device *unused)
{
    a000bd50:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a000bd54:	910003fd 	mov	x29, sp
    a000bd58:	f9000fe0 	str	x0, [sp, #24]
	ARG_UNUSED(unused);

	sys_heap_init(&z_malloc_heap, z_malloc_heap_mem, HEAP_BYTES);
    a000bd5c:	d2900002 	mov	x2, #0x8000                	// #32768
    a000bd60:	f00000c0 	adrp	x0, a0026000 <z_malloc_heap>
    a000bd64:	91008001 	add	x1, x0, #0x20
    a000bd68:	f00000c0 	adrp	x0, a0026000 <z_malloc_heap>
    a000bd6c:	91000000 	add	x0, x0, #0x0
    a000bd70:	97ffe7f4 	bl	a0005d40 <sys_heap_init>
	sys_mutex_init(&z_malloc_heap_mutex);
    a000bd74:	f00000c0 	adrp	x0, a0026000 <z_malloc_heap>
    a000bd78:	91006000 	add	x0, x0, #0x18
    a000bd7c:	97ffff97 	bl	a000bbd8 <sys_mutex_init>

	return 0;
    a000bd80:	52800000 	mov	w0, #0x0                   	// #0
}
    a000bd84:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a000bd88:	d65f03c0 	ret

00000000a000bd8c <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
    a000bd8c:	d10083ff 	sub	sp, sp, #0x20
    a000bd90:	f90007e0 	str	x0, [sp, #8]
	size_t n = 0;
    a000bd94:	f9000fff 	str	xzr, [sp, #24]

	while (*s != '\0') {
    a000bd98:	14000007 	b	a000bdb4 <strlen+0x28>
		s++;
    a000bd9c:	f94007e0 	ldr	x0, [sp, #8]
    a000bda0:	91000400 	add	x0, x0, #0x1
    a000bda4:	f90007e0 	str	x0, [sp, #8]
		n++;
    a000bda8:	f9400fe0 	ldr	x0, [sp, #24]
    a000bdac:	91000400 	add	x0, x0, #0x1
    a000bdb0:	f9000fe0 	str	x0, [sp, #24]
	while (*s != '\0') {
    a000bdb4:	f94007e0 	ldr	x0, [sp, #8]
    a000bdb8:	39400000 	ldrb	w0, [x0]
    a000bdbc:	7100001f 	cmp	w0, #0x0
    a000bdc0:	54fffee1 	b.ne	a000bd9c <strlen+0x10>  // b.any
	}

	return n;
    a000bdc4:	f9400fe0 	ldr	x0, [sp, #24]
}
    a000bdc8:	910083ff 	add	sp, sp, #0x20
    a000bdcc:	d65f03c0 	ret

00000000a000bdd0 <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
    a000bdd0:	d10083ff 	sub	sp, sp, #0x20
    a000bdd4:	f90007e0 	str	x0, [sp, #8]
    a000bdd8:	f90003e1 	str	x1, [sp]
	size_t n = 0;
    a000bddc:	f9000fff 	str	xzr, [sp, #24]

	while (*s != '\0' && n < maxlen) {
    a000bde0:	14000007 	b	a000bdfc <strnlen+0x2c>
		s++;
    a000bde4:	f94007e0 	ldr	x0, [sp, #8]
    a000bde8:	91000400 	add	x0, x0, #0x1
    a000bdec:	f90007e0 	str	x0, [sp, #8]
		n++;
    a000bdf0:	f9400fe0 	ldr	x0, [sp, #24]
    a000bdf4:	91000400 	add	x0, x0, #0x1
    a000bdf8:	f9000fe0 	str	x0, [sp, #24]
	while (*s != '\0' && n < maxlen) {
    a000bdfc:	f94007e0 	ldr	x0, [sp, #8]
    a000be00:	39400000 	ldrb	w0, [x0]
    a000be04:	7100001f 	cmp	w0, #0x0
    a000be08:	540000a0 	b.eq	a000be1c <strnlen+0x4c>  // b.none
    a000be0c:	f9400fe1 	ldr	x1, [sp, #24]
    a000be10:	f94003e0 	ldr	x0, [sp]
    a000be14:	eb00003f 	cmp	x1, x0
    a000be18:	54fffe63 	b.cc	a000bde4 <strnlen+0x14>  // b.lo, b.ul, b.last
	}

	return n;
    a000be1c:	f9400fe0 	ldr	x0, [sp, #24]
}
    a000be20:	910083ff 	add	sp, sp, #0x20
    a000be24:	d65f03c0 	ret

00000000a000be28 <strcmp>:
 *
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
    a000be28:	d10043ff 	sub	sp, sp, #0x10
    a000be2c:	f90007e0 	str	x0, [sp, #8]
    a000be30:	f90003e1 	str	x1, [sp]
	while ((*s1 == *s2) && (*s1 != '\0')) {
    a000be34:	14000007 	b	a000be50 <strcmp+0x28>
		s1++;
    a000be38:	f94007e0 	ldr	x0, [sp, #8]
    a000be3c:	91000400 	add	x0, x0, #0x1
    a000be40:	f90007e0 	str	x0, [sp, #8]
		s2++;
    a000be44:	f94003e0 	ldr	x0, [sp]
    a000be48:	91000400 	add	x0, x0, #0x1
    a000be4c:	f90003e0 	str	x0, [sp]
	while ((*s1 == *s2) && (*s1 != '\0')) {
    a000be50:	f94007e0 	ldr	x0, [sp, #8]
    a000be54:	39400001 	ldrb	w1, [x0]
    a000be58:	f94003e0 	ldr	x0, [sp]
    a000be5c:	39400000 	ldrb	w0, [x0]
    a000be60:	6b00003f 	cmp	w1, w0
    a000be64:	540000a1 	b.ne	a000be78 <strcmp+0x50>  // b.any
    a000be68:	f94007e0 	ldr	x0, [sp, #8]
    a000be6c:	39400000 	ldrb	w0, [x0]
    a000be70:	7100001f 	cmp	w0, #0x0
    a000be74:	54fffe21 	b.ne	a000be38 <strcmp+0x10>  // b.any
	}

	return *s1 - *s2;
    a000be78:	f94007e0 	ldr	x0, [sp, #8]
    a000be7c:	39400000 	ldrb	w0, [x0]
    a000be80:	2a0003e1 	mov	w1, w0
    a000be84:	f94003e0 	ldr	x0, [sp]
    a000be88:	39400000 	ldrb	w0, [x0]
    a000be8c:	4b000020 	sub	w0, w1, w0
}
    a000be90:	910043ff 	add	sp, sp, #0x10
    a000be94:	d65f03c0 	ret

00000000a000be98 <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *ZRESTRICT d, const void *ZRESTRICT s, size_t n)
{
    a000be98:	d100c3ff 	sub	sp, sp, #0x30
    a000be9c:	f9000fe0 	str	x0, [sp, #24]
    a000bea0:	f9000be1 	str	x1, [sp, #16]
    a000bea4:	f90007e2 	str	x2, [sp, #8]
	/* attempt word-sized copying only if buffers have identical alignment */

	unsigned char *d_byte = (unsigned char *)d;
    a000bea8:	f9400fe0 	ldr	x0, [sp, #24]
    a000beac:	f90017e0 	str	x0, [sp, #40]
	const unsigned char *s_byte = (const unsigned char *)s;
    a000beb0:	f9400be0 	ldr	x0, [sp, #16]
    a000beb4:	f90013e0 	str	x0, [sp, #32]
	}
#endif

	/* do byte-sized copying until finished */

	while (n > 0) {
    a000beb8:	1400000c 	b	a000bee8 <memcpy+0x50>
		*(d_byte++) = *(s_byte++);
    a000bebc:	f94013e1 	ldr	x1, [sp, #32]
    a000bec0:	91000420 	add	x0, x1, #0x1
    a000bec4:	f90013e0 	str	x0, [sp, #32]
    a000bec8:	f94017e0 	ldr	x0, [sp, #40]
    a000becc:	91000402 	add	x2, x0, #0x1
    a000bed0:	f90017e2 	str	x2, [sp, #40]
    a000bed4:	39400021 	ldrb	w1, [x1]
    a000bed8:	39000001 	strb	w1, [x0]
		n--;
    a000bedc:	f94007e0 	ldr	x0, [sp, #8]
    a000bee0:	d1000400 	sub	x0, x0, #0x1
    a000bee4:	f90007e0 	str	x0, [sp, #8]
	while (n > 0) {
    a000bee8:	f94007e0 	ldr	x0, [sp, #8]
    a000beec:	f100001f 	cmp	x0, #0x0
    a000bef0:	54fffe61 	b.ne	a000bebc <memcpy+0x24>  // b.any
	}

	return d;
    a000bef4:	f9400fe0 	ldr	x0, [sp, #24]
}
    a000bef8:	9100c3ff 	add	sp, sp, #0x30
    a000befc:	d65f03c0 	ret

00000000a000bf00 <memset>:
 *
 * @return pointer to start of buffer
 */

void *memset(void *buf, int c, size_t n)
{
    a000bf00:	d100c3ff 	sub	sp, sp, #0x30
    a000bf04:	f9000fe0 	str	x0, [sp, #24]
    a000bf08:	b90017e1 	str	w1, [sp, #20]
    a000bf0c:	f90007e2 	str	x2, [sp, #8]
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
    a000bf10:	f9400fe0 	ldr	x0, [sp, #24]
    a000bf14:	f90017e0 	str	x0, [sp, #40]
	unsigned char c_byte = (unsigned char)c;
    a000bf18:	b94017e0 	ldr	w0, [sp, #20]
    a000bf1c:	39009fe0 	strb	w0, [sp, #39]
	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
    a000bf20:	14000009 	b	a000bf44 <memset+0x44>
		*(d_byte++) = c_byte;
    a000bf24:	f94017e0 	ldr	x0, [sp, #40]
    a000bf28:	91000401 	add	x1, x0, #0x1
    a000bf2c:	f90017e1 	str	x1, [sp, #40]
    a000bf30:	39409fe1 	ldrb	w1, [sp, #39]
    a000bf34:	39000001 	strb	w1, [x0]
		n--;
    a000bf38:	f94007e0 	ldr	x0, [sp, #8]
    a000bf3c:	d1000400 	sub	x0, x0, #0x1
    a000bf40:	f90007e0 	str	x0, [sp, #8]
	while (n > 0) {
    a000bf44:	f94007e0 	ldr	x0, [sp, #8]
    a000bf48:	f100001f 	cmp	x0, #0x0
    a000bf4c:	54fffec1 	b.ne	a000bf24 <memset+0x24>  // b.any
	}

	return buf;
    a000bf50:	f9400fe0 	ldr	x0, [sp, #24]
}
    a000bf54:	9100c3ff 	add	sp, sp, #0x30
    a000bf58:	d65f03c0 	ret

00000000a000bf5c <arch_syscall_invoke2>:
{
    a000bf5c:	d10083ff 	sub	sp, sp, #0x20
    a000bf60:	f9000fe0 	str	x0, [sp, #24]
    a000bf64:	f9000be1 	str	x1, [sp, #16]
    a000bf68:	f90007e2 	str	x2, [sp, #8]
	register uint64_t ret __asm__("x0") = arg1;
    a000bf6c:	f9400fe0 	ldr	x0, [sp, #24]
	register uint64_t r1 __asm__("x1") = arg2;
    a000bf70:	f9400be1 	ldr	x1, [sp, #16]
	register uint64_t r8 __asm__("x8") = call_id;
    a000bf74:	f94007e8 	ldr	x8, [sp, #8]
	__asm__ volatile("svc %[svid]\n"
    a000bf78:	d4000061 	svc	#0x3
}
    a000bf7c:	910083ff 	add	sp, sp, #0x20
    a000bf80:	d65f03c0 	ret

00000000a000bf84 <arch_is_user_context>:
{
    a000bf84:	d10043ff 	sub	sp, sp, #0x10
    a000bf88:	d53bd060 	mrs	x0, tpidrro_el0
    a000bf8c:	f90007e0 	str	x0, [sp, #8]
    a000bf90:	f94007e0 	ldr	x0, [sp, #8]
    a000bf94:	d503201f 	nop
	return (read_tpidrro_el0() & TPIDRROEL0_IN_EL0) != 0;
    a000bf98:	92400000 	and	x0, x0, #0x1
    a000bf9c:	f100001f 	cmp	x0, #0x0
    a000bfa0:	1a9f07e0 	cset	w0, ne  // ne = any
    a000bfa4:	12001c00 	and	w0, w0, #0xff
}
    a000bfa8:	910043ff 	add	sp, sp, #0x10
    a000bfac:	d65f03c0 	ret

00000000a000bfb0 <zephyr_fputc>:

extern int z_impl_zephyr_fputc(int c, FILE * stream);

__pinned_func
static inline int zephyr_fputc(int c, FILE * stream)
{
    a000bfb0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a000bfb4:	910003fd 	mov	x29, sp
    a000bfb8:	b9001fe0 	str	w0, [sp, #28]
    a000bfbc:	f9000be1 	str	x1, [sp, #16]
	bool ret = false;
    a000bfc0:	3900bfff 	strb	wzr, [sp, #47]
	ret = arch_is_user_context();
    a000bfc4:	97fffff0 	bl	a000bf84 <arch_is_user_context>
    a000bfc8:	3900bfe0 	strb	w0, [sp, #47]
	return ret;
    a000bfcc:	3940bfe0 	ldrb	w0, [sp, #47]
#ifdef CONFIG_USERSPACE
	if (z_syscall_trap()) {
    a000bfd0:	7100001f 	cmp	w0, #0x0
    a000bfd4:	54000140 	b.eq	a000bffc <zephyr_fputc+0x4c>  // b.none
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke2(*(uintptr_t *)&c, *(uintptr_t *)&stream, K_SYSCALL_ZEPHYR_FPUTC);
    a000bfd8:	910073e0 	add	x0, sp, #0x1c
    a000bfdc:	f9400003 	ldr	x3, [x0]
    a000bfe0:	910043e0 	add	x0, sp, #0x10
    a000bfe4:	f9400000 	ldr	x0, [x0]
    a000bfe8:	d2802842 	mov	x2, #0x142                 	// #322
    a000bfec:	aa0003e1 	mov	x1, x0
    a000bff0:	aa0303e0 	mov	x0, x3
    a000bff4:	97ffffda 	bl	a000bf5c <arch_syscall_invoke2>
    a000bff8:	14000004 	b	a000c008 <zephyr_fputc+0x58>
	}
#endif
	compiler_barrier();
	return z_impl_zephyr_fputc(c, stream);
    a000bffc:	b9401fe0 	ldr	w0, [sp, #28]
    a000c000:	f9400be1 	ldr	x1, [sp, #16]
    a000c004:	9400002a 	bl	a000c0ac <z_impl_zephyr_fputc>
}
    a000c008:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a000c00c:	d65f03c0 	ret

00000000a000c010 <size_mul_overflow>:
{
	return __builtin_mul_overflow(a, b, result);
}

static inline bool size_mul_overflow(size_t a, size_t b, size_t *result)
{
    a000c010:	d10083ff 	sub	sp, sp, #0x20
    a000c014:	f9000fe0 	str	x0, [sp, #24]
    a000c018:	f9000be1 	str	x1, [sp, #16]
    a000c01c:	f90007e2 	str	x2, [sp, #8]
	return __builtin_mul_overflow(a, b, result);
    a000c020:	d2800002 	mov	x2, #0x0                   	// #0
    a000c024:	f9400fe1 	ldr	x1, [sp, #24]
    a000c028:	f9400be0 	ldr	x0, [sp, #16]
    a000c02c:	9b007c23 	mul	x3, x1, x0
    a000c030:	9bc07c20 	umulh	x0, x1, x0
    a000c034:	aa0303e4 	mov	x4, x3
    a000c038:	aa0003e5 	mov	x5, x0
    a000c03c:	aa0503e6 	mov	x6, x5
    a000c040:	d2800007 	mov	x7, #0x0                   	// #0
    a000c044:	f10000df 	cmp	x6, #0x0
    a000c048:	54000040 	b.eq	a000c050 <size_mul_overflow+0x40>  // b.none
    a000c04c:	d2800022 	mov	x2, #0x1                   	// #1
    a000c050:	aa0403e0 	mov	x0, x4
    a000c054:	aa0003e1 	mov	x1, x0
    a000c058:	f94007e0 	ldr	x0, [sp, #8]
    a000c05c:	f9000001 	str	x1, [x0]
    a000c060:	aa0203e0 	mov	x0, x2
    a000c064:	12000000 	and	w0, w0, #0x1
    a000c068:	12001c00 	and	w0, w0, #0xff
}
    a000c06c:	910083ff 	add	sp, sp, #0x20
    a000c070:	d65f03c0 	ret

00000000a000c074 <_stdout_hook_default>:
#include <sys/libc-hooks.h>
#include <syscall_handler.h>
#include <string.h>

static int _stdout_hook_default(int c)
{
    a000c074:	d10043ff 	sub	sp, sp, #0x10
    a000c078:	b9000fe0 	str	w0, [sp, #12]
	(void)(c);  /* Prevent warning about unused argument */

	return EOF;
    a000c07c:	12800000 	mov	w0, #0xffffffff            	// #-1
}
    a000c080:	910043ff 	add	sp, sp, #0x10
    a000c084:	d65f03c0 	ret

00000000a000c088 <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
    a000c088:	d10043ff 	sub	sp, sp, #0x10
    a000c08c:	f90007e0 	str	x0, [sp, #8]
	_stdout_hook = hook;
    a000c090:	f0000460 	adrp	x0, a009b000 <twom1000.10>
    a000c094:	91004000 	add	x0, x0, #0x10
    a000c098:	f94007e1 	ldr	x1, [sp, #8]
    a000c09c:	f9000001 	str	x1, [x0]
}
    a000c0a0:	d503201f 	nop
    a000c0a4:	910043ff 	add	sp, sp, #0x10
    a000c0a8:	d65f03c0 	ret

00000000a000c0ac <z_impl_zephyr_fputc>:

int z_impl_zephyr_fputc(int c, FILE *stream)
{
    a000c0ac:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a000c0b0:	910003fd 	mov	x29, sp
    a000c0b4:	b9001fe0 	str	w0, [sp, #28]
    a000c0b8:	f9000be1 	str	x1, [sp, #16]
	return (stream == stdout || stream == stderr) ? _stdout_hook(c) : EOF;
    a000c0bc:	f9400be0 	ldr	x0, [sp, #16]
    a000c0c0:	f100081f 	cmp	x0, #0x2
    a000c0c4:	54000080 	b.eq	a000c0d4 <z_impl_zephyr_fputc+0x28>  // b.none
    a000c0c8:	f9400be0 	ldr	x0, [sp, #16]
    a000c0cc:	f1000c1f 	cmp	x0, #0x3
    a000c0d0:	540000e1 	b.ne	a000c0ec <z_impl_zephyr_fputc+0x40>  // b.any
    a000c0d4:	f0000460 	adrp	x0, a009b000 <twom1000.10>
    a000c0d8:	91004000 	add	x0, x0, #0x10
    a000c0dc:	f9400001 	ldr	x1, [x0]
    a000c0e0:	b9401fe0 	ldr	w0, [sp, #28]
    a000c0e4:	d63f0020 	blr	x1
    a000c0e8:	14000002 	b	a000c0f0 <z_impl_zephyr_fputc+0x44>
    a000c0ec:	12800000 	mov	w0, #0xffffffff            	// #-1
}
    a000c0f0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a000c0f4:	d65f03c0 	ret

00000000a000c0f8 <z_vrfy_zephyr_fputc>:

#ifdef CONFIG_USERSPACE
static inline int z_vrfy_zephyr_fputc(int c, FILE *stream)
{
    a000c0f8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a000c0fc:	910003fd 	mov	x29, sp
    a000c100:	b9001fe0 	str	w0, [sp, #28]
    a000c104:	f9000be1 	str	x1, [sp, #16]
	return z_impl_zephyr_fputc(c, stream);
    a000c108:	f9400be1 	ldr	x1, [sp, #16]
    a000c10c:	b9401fe0 	ldr	w0, [sp, #28]
    a000c110:	97ffffe7 	bl	a000c0ac <z_impl_zephyr_fputc>
}
    a000c114:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a000c118:	d65f03c0 	ret

00000000a000c11c <z_mrsh_zephyr_fputc>:
#include <syscalls/libc-hooks.h>

extern int z_vrfy_zephyr_fputc(int c, FILE * stream);
uintptr_t z_mrsh_zephyr_fputc(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a000c11c:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a000c120:	910003fd 	mov	x29, sp
    a000c124:	f90027e0 	str	x0, [sp, #72]
    a000c128:	f90023e1 	str	x1, [sp, #64]
    a000c12c:	f9001fe2 	str	x2, [sp, #56]
    a000c130:	f9001be3 	str	x3, [sp, #48]
    a000c134:	f90017e4 	str	x4, [sp, #40]
    a000c138:	f90013e5 	str	x5, [sp, #32]
    a000c13c:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a000c140:	f00001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000c144:	913f8000 	add	x0, x0, #0xfe0
    a000c148:	f9400800 	ldr	x0, [x0, #16]
    a000c14c:	f9400fe1 	ldr	x1, [sp, #24]
    a000c150:	f9008401 	str	x1, [x0, #264]
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_zephyr_fputc(*(int*)&arg0, *(FILE **)&arg1)
    a000c154:	910123e0 	add	x0, sp, #0x48
    a000c158:	b9400002 	ldr	w2, [x0]
    a000c15c:	910103e0 	add	x0, sp, #0x40
    a000c160:	f9400000 	ldr	x0, [x0]
    a000c164:	aa0003e1 	mov	x1, x0
    a000c168:	2a0203e0 	mov	w0, w2
    a000c16c:	97ffffe3 	bl	a000c0f8 <z_vrfy_zephyr_fputc>
    a000c170:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a000c174:	f00001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000c178:	913f8000 	add	x0, x0, #0xfe0
    a000c17c:	f9400800 	ldr	x0, [x0, #16]
    a000c180:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a000c184:	b9805fe0 	ldrsw	x0, [sp, #92]
}
    a000c188:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a000c18c:	d65f03c0 	ret

00000000a000c190 <fputc>:
#include <syscalls/zephyr_fputc_mrsh.c>
#endif

int fputc(int c, FILE *stream)
{
    a000c190:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a000c194:	910003fd 	mov	x29, sp
    a000c198:	b9001fe0 	str	w0, [sp, #28]
    a000c19c:	f9000be1 	str	x1, [sp, #16]
	return zephyr_fputc(c, stream);
    a000c1a0:	f9400be1 	ldr	x1, [sp, #16]
    a000c1a4:	b9401fe0 	ldr	w0, [sp, #28]
    a000c1a8:	97ffff82 	bl	a000bfb0 <zephyr_fputc>
}
    a000c1ac:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a000c1b0:	d65f03c0 	ret

00000000a000c1b4 <z_impl_zephyr_fwrite>:
	return len == ret ? 0 : EOF;
}

size_t z_impl_zephyr_fwrite(const void *ZRESTRICT ptr, size_t size,
			    size_t nitems, FILE *ZRESTRICT stream)
{
    a000c1b4:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a000c1b8:	910003fd 	mov	x29, sp
    a000c1bc:	f90017e0 	str	x0, [sp, #40]
    a000c1c0:	f90013e1 	str	x1, [sp, #32]
    a000c1c4:	f9000fe2 	str	x2, [sp, #24]
    a000c1c8:	f9000be3 	str	x3, [sp, #16]
	size_t i;
	size_t j;
	const unsigned char *p;

	if ((stream != stdout && stream != stderr) ||
    a000c1cc:	f9400be0 	ldr	x0, [sp, #16]
    a000c1d0:	f100081f 	cmp	x0, #0x2
    a000c1d4:	54000080 	b.eq	a000c1e4 <z_impl_zephyr_fwrite+0x30>  // b.none
    a000c1d8:	f9400be0 	ldr	x0, [sp, #16]
    a000c1dc:	f1000c1f 	cmp	x0, #0x3
    a000c1e0:	540000e1 	b.ne	a000c1fc <z_impl_zephyr_fwrite+0x48>  // b.any
    a000c1e4:	f9400fe0 	ldr	x0, [sp, #24]
    a000c1e8:	f100001f 	cmp	x0, #0x0
    a000c1ec:	54000080 	b.eq	a000c1fc <z_impl_zephyr_fwrite+0x48>  // b.none
	    (nitems == 0) || (size == 0)) {
    a000c1f0:	f94013e0 	ldr	x0, [sp, #32]
    a000c1f4:	f100001f 	cmp	x0, #0x0
    a000c1f8:	54000061 	b.ne	a000c204 <z_impl_zephyr_fwrite+0x50>  // b.any
		return 0;
    a000c1fc:	d2800000 	mov	x0, #0x0                   	// #0
    a000c200:	14000022 	b	a000c288 <z_impl_zephyr_fwrite+0xd4>
	}

	p = ptr;
    a000c204:	f94017e0 	ldr	x0, [sp, #40]
    a000c208:	f9001fe0 	str	x0, [sp, #56]
	i = nitems;
    a000c20c:	f9400fe0 	ldr	x0, [sp, #24]
    a000c210:	f90027e0 	str	x0, [sp, #72]
	do {
		j = size;
    a000c214:	f94013e0 	ldr	x0, [sp, #32]
    a000c218:	f90023e0 	str	x0, [sp, #64]
		do {
			if (_stdout_hook((int) *p++) == EOF) {
    a000c21c:	f0000460 	adrp	x0, a009b000 <twom1000.10>
    a000c220:	91004000 	add	x0, x0, #0x10
    a000c224:	f9400001 	ldr	x1, [x0]
    a000c228:	f9401fe0 	ldr	x0, [sp, #56]
    a000c22c:	91000402 	add	x2, x0, #0x1
    a000c230:	f9001fe2 	str	x2, [sp, #56]
    a000c234:	39400000 	ldrb	w0, [x0]
    a000c238:	d63f0020 	blr	x1
    a000c23c:	3100041f 	cmn	w0, #0x1
    a000c240:	540001c0 	b.eq	a000c278 <z_impl_zephyr_fwrite+0xc4>  // b.none
				goto done;
			}
			j--;
    a000c244:	f94023e0 	ldr	x0, [sp, #64]
    a000c248:	d1000400 	sub	x0, x0, #0x1
    a000c24c:	f90023e0 	str	x0, [sp, #64]
		} while (j > 0);
    a000c250:	f94023e0 	ldr	x0, [sp, #64]
    a000c254:	f100001f 	cmp	x0, #0x0
    a000c258:	54fffe21 	b.ne	a000c21c <z_impl_zephyr_fwrite+0x68>  // b.any

		i--;
    a000c25c:	f94027e0 	ldr	x0, [sp, #72]
    a000c260:	d1000400 	sub	x0, x0, #0x1
    a000c264:	f90027e0 	str	x0, [sp, #72]
	} while (i > 0);
    a000c268:	f94027e0 	ldr	x0, [sp, #72]
    a000c26c:	f100001f 	cmp	x0, #0x0
    a000c270:	54fffd21 	b.ne	a000c214 <z_impl_zephyr_fwrite+0x60>  // b.any

done:
    a000c274:	14000002 	b	a000c27c <z_impl_zephyr_fwrite+0xc8>
				goto done;
    a000c278:	d503201f 	nop
	return (nitems - i);
    a000c27c:	f9400fe1 	ldr	x1, [sp, #24]
    a000c280:	f94027e0 	ldr	x0, [sp, #72]
    a000c284:	cb000020 	sub	x0, x1, x0
}
    a000c288:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a000c28c:	d65f03c0 	ret

00000000a000c290 <z_vrfy_zephyr_fwrite>:

#ifdef CONFIG_USERSPACE
static inline size_t z_vrfy_zephyr_fwrite(const void *ZRESTRICT ptr,
					  size_t size, size_t nitems,
					  FILE *ZRESTRICT stream)
{
    a000c290:	d10a83ff 	sub	sp, sp, #0x2a0
    a000c294:	a9007bfd 	stp	x29, x30, [sp]
    a000c298:	910003fd 	mov	x29, sp
    a000c29c:	f90017e0 	str	x0, [sp, #40]
    a000c2a0:	f90013e1 	str	x1, [sp, #32]
    a000c2a4:	f9000fe2 	str	x2, [sp, #24]
    a000c2a8:	f9000be3 	str	x3, [sp, #16]

	Z_OOPS(Z_SYSCALL_MEMORY_ARRAY_READ(ptr, nitems, size));
    a000c2ac:	910a43e0 	add	x0, sp, #0x290
    a000c2b0:	aa0003e2 	mov	x2, x0
    a000c2b4:	f94013e1 	ldr	x1, [sp, #32]
    a000c2b8:	f9400fe0 	ldr	x0, [sp, #24]
    a000c2bc:	97ffff55 	bl	a000c010 <size_mul_overflow>
    a000c2c0:	12001c00 	and	w0, w0, #0xff
    a000c2c4:	390a7be0 	strb	w0, [sp, #670]
    a000c2c8:	394a7be0 	ldrb	w0, [sp, #670]
    a000c2cc:	7100001f 	cmp	w0, #0x0
    a000c2d0:	394a7be0 	ldrb	w0, [sp, #670]
    a000c2d4:	7100001f 	cmp	w0, #0x0
    a000c2d8:	540001c1 	b.ne	a000c310 <z_vrfy_zephyr_fwrite+0x80>  // b.any
    a000c2dc:	f9414be0 	ldr	x0, [sp, #656]
    a000c2e0:	52800002 	mov	w2, #0x0                   	// #0
    a000c2e4:	aa0003e1 	mov	x1, x0
    a000c2e8:	f94017e0 	ldr	x0, [sp, #40]
    a000c2ec:	97fffd60 	bl	a000b86c <arch_buffer_validate>
    a000c2f0:	7100001f 	cmp	w0, #0x0
    a000c2f4:	1a9f07e0 	cset	w0, ne  // ne = any
    a000c2f8:	390a7fe0 	strb	w0, [sp, #671]
    a000c2fc:	394a7fe0 	ldrb	w0, [sp, #671]
    a000c300:	7100001f 	cmp	w0, #0x0
    a000c304:	394a7fe0 	ldrb	w0, [sp, #671]
    a000c308:	7100001f 	cmp	w0, #0x0
    a000c30c:	54000060 	b.eq	a000c318 <z_vrfy_zephyr_fwrite+0x88>  // b.none
    a000c310:	52800020 	mov	w0, #0x1                   	// #1
    a000c314:	14000002 	b	a000c31c <z_vrfy_zephyr_fwrite+0x8c>
    a000c318:	52800000 	mov	w0, #0x0                   	// #0
    a000c31c:	7100001f 	cmp	w0, #0x0
    a000c320:	540000c0 	b.eq	a000c338 <z_vrfy_zephyr_fwrite+0xa8>  // b.none
    a000c324:	f00001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000c328:	913f8000 	add	x0, x0, #0xfe0
    a000c32c:	f9400800 	ldr	x0, [x0, #16]
    a000c330:	f9408400 	ldr	x0, [x0, #264]
    a000c334:	97fff389 	bl	a0009158 <arch_syscall_oops>
	return z_impl_zephyr_fwrite((const void *ZRESTRICT)ptr, size,
    a000c338:	f9400be3 	ldr	x3, [sp, #16]
    a000c33c:	f9400fe2 	ldr	x2, [sp, #24]
    a000c340:	f94013e1 	ldr	x1, [sp, #32]
    a000c344:	f94017e0 	ldr	x0, [sp, #40]
    a000c348:	97ffff9b 	bl	a000c1b4 <z_impl_zephyr_fwrite>
				    nitems, (FILE *ZRESTRICT)stream);
}
    a000c34c:	a9407bfd 	ldp	x29, x30, [sp]
    a000c350:	910a83ff 	add	sp, sp, #0x2a0
    a000c354:	d65f03c0 	ret

00000000a000c358 <z_mrsh_zephyr_fwrite>:
#include <syscalls/libc-hooks.h>

extern size_t z_vrfy_zephyr_fwrite(const void *ZRESTRICT ptr, size_t size, size_t nitems, FILE *ZRESTRICT stream);
uintptr_t z_mrsh_zephyr_fwrite(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a000c358:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a000c35c:	910003fd 	mov	x29, sp
    a000c360:	f90027e0 	str	x0, [sp, #72]
    a000c364:	f90023e1 	str	x1, [sp, #64]
    a000c368:	f9001fe2 	str	x2, [sp, #56]
    a000c36c:	f9001be3 	str	x3, [sp, #48]
    a000c370:	f90017e4 	str	x4, [sp, #40]
    a000c374:	f90013e5 	str	x5, [sp, #32]
    a000c378:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a000c37c:	f00001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000c380:	913f8000 	add	x0, x0, #0xfe0
    a000c384:	f9400800 	ldr	x0, [x0, #16]
    a000c388:	f9400fe1 	ldr	x1, [sp, #24]
    a000c38c:	f9008401 	str	x1, [x0, #264]
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	size_t ret = z_vrfy_zephyr_fwrite(*(const void *ZRESTRICT*)&arg0, *(size_t*)&arg1, *(size_t*)&arg2, *(FILE *ZRESTRICT*)&arg3)
    a000c390:	910123e0 	add	x0, sp, #0x48
    a000c394:	f9400004 	ldr	x4, [x0]
    a000c398:	910103e0 	add	x0, sp, #0x40
    a000c39c:	f9400001 	ldr	x1, [x0]
    a000c3a0:	9100e3e0 	add	x0, sp, #0x38
    a000c3a4:	f9400002 	ldr	x2, [x0]
    a000c3a8:	9100c3e0 	add	x0, sp, #0x30
    a000c3ac:	f9400000 	ldr	x0, [x0]
    a000c3b0:	aa0003e3 	mov	x3, x0
    a000c3b4:	aa0403e0 	mov	x0, x4
    a000c3b8:	97ffffb6 	bl	a000c290 <z_vrfy_zephyr_fwrite>
    a000c3bc:	f9002fe0 	str	x0, [sp, #88]
;
	_current->syscall_frame = NULL;
    a000c3c0:	f00001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000c3c4:	913f8000 	add	x0, x0, #0xfe0
    a000c3c8:	f9400800 	ldr	x0, [x0, #16]
    a000c3cc:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a000c3d0:	f9402fe0 	ldr	x0, [sp, #88]
}
    a000c3d4:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a000c3d8:	d65f03c0 	ret

00000000a000c3dc <printf>:

	return r;
}

int printf(const char *ZRESTRICT format, ...)
{
    a000c3dc:	a9ad7bfd 	stp	x29, x30, [sp, #-304]!
    a000c3e0:	910003fd 	mov	x29, sp
    a000c3e4:	f9001fe0 	str	x0, [sp, #56]
    a000c3e8:	f9007fe1 	str	x1, [sp, #248]
    a000c3ec:	f90083e2 	str	x2, [sp, #256]
    a000c3f0:	f90087e3 	str	x3, [sp, #264]
    a000c3f4:	f9008be4 	str	x4, [sp, #272]
    a000c3f8:	f9008fe5 	str	x5, [sp, #280]
    a000c3fc:	f90093e6 	str	x6, [sp, #288]
    a000c400:	f90097e7 	str	x7, [sp, #296]
    a000c404:	3d801fe0 	str	q0, [sp, #112]
    a000c408:	3d8023e1 	str	q1, [sp, #128]
    a000c40c:	3d8027e2 	str	q2, [sp, #144]
    a000c410:	3d802be3 	str	q3, [sp, #160]
    a000c414:	3d802fe4 	str	q4, [sp, #176]
    a000c418:	3d8033e5 	str	q5, [sp, #192]
    a000c41c:	3d8037e6 	str	q6, [sp, #208]
    a000c420:	3d803be7 	str	q7, [sp, #224]
	va_list vargs;
	int     r;

	va_start(vargs, format);
    a000c424:	9104c3e0 	add	x0, sp, #0x130
    a000c428:	f90027e0 	str	x0, [sp, #72]
    a000c42c:	9104c3e0 	add	x0, sp, #0x130
    a000c430:	f9002be0 	str	x0, [sp, #80]
    a000c434:	9103c3e0 	add	x0, sp, #0xf0
    a000c438:	f9002fe0 	str	x0, [sp, #88]
    a000c43c:	128006e0 	mov	w0, #0xffffffc8            	// #-56
    a000c440:	b90063e0 	str	w0, [sp, #96]
    a000c444:	12800fe0 	mov	w0, #0xffffff80            	// #-128
    a000c448:	b90067e0 	str	w0, [sp, #100]
	r = cbvprintf(fputc, DESC(stdout), format, vargs);
    a000c44c:	910043e2 	add	x2, sp, #0x10
    a000c450:	910123e3 	add	x3, sp, #0x48
    a000c454:	a9400460 	ldp	x0, x1, [x3]
    a000c458:	a9000440 	stp	x0, x1, [x2]
    a000c45c:	a9410460 	ldp	x0, x1, [x3, #16]
    a000c460:	a9010440 	stp	x0, x1, [x2, #16]
    a000c464:	910043e0 	add	x0, sp, #0x10
    a000c468:	aa0003e3 	mov	x3, x0
    a000c46c:	f9401fe2 	ldr	x2, [sp, #56]
    a000c470:	d2800041 	mov	x1, #0x2                   	// #2
    a000c474:	90000000 	adrp	x0, a000c000 <zephyr_fputc+0x50>
    a000c478:	91064000 	add	x0, x0, #0x190
    a000c47c:	97ffec96 	bl	a00076d4 <cbvprintf>
    a000c480:	b9006fe0 	str	w0, [sp, #108]
	va_end(vargs);

	return r;
    a000c484:	b9406fe0 	ldr	w0, [sp, #108]
}
    a000c488:	a8d37bfd 	ldp	x29, x30, [sp], #304
    a000c48c:	d65f03c0 	ret

00000000a000c490 <pthread_attr_setstack>:
 *
 * See IEEE 1003.1
 */
int pthread_attr_setstack(pthread_attr_t *attr, void *stackaddr,
			  size_t stacksize)
{
    a000c490:	d10083ff 	sub	sp, sp, #0x20
    a000c494:	f9000fe0 	str	x0, [sp, #24]
    a000c498:	f9000be1 	str	x1, [sp, #16]
    a000c49c:	f90007e2 	str	x2, [sp, #8]
	if (stackaddr == NULL) {
    a000c4a0:	f9400be0 	ldr	x0, [sp, #16]
    a000c4a4:	f100001f 	cmp	x0, #0x0
    a000c4a8:	54000061 	b.ne	a000c4b4 <pthread_attr_setstack+0x24>  // b.any
		return EACCES;
    a000c4ac:	528001a0 	mov	w0, #0xd                   	// #13
    a000c4b0:	14000008 	b	a000c4d0 <pthread_attr_setstack+0x40>
	}

	attr->stack = stackaddr;
    a000c4b4:	f9400fe0 	ldr	x0, [sp, #24]
    a000c4b8:	f9400be1 	ldr	x1, [sp, #16]
    a000c4bc:	f9000401 	str	x1, [x0, #8]
	attr->stacksize = stacksize;
    a000c4c0:	f9400fe0 	ldr	x0, [sp, #24]
    a000c4c4:	f94007e1 	ldr	x1, [sp, #8]
    a000c4c8:	f9000801 	str	x1, [x0, #16]
	return 0;
    a000c4cc:	52800000 	mov	w0, #0x0                   	// #0
}
    a000c4d0:	910083ff 	add	sp, sp, #0x20
    a000c4d4:	d65f03c0 	ret

00000000a000c4d8 <pthread_attr_init>:
 * @brief Initialise threads attribute object
 *
 * See IEEE 1003.1
 */
int pthread_attr_init(pthread_attr_t *attr)
{
    a000c4d8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a000c4dc:	910003fd 	mov	x29, sp
    a000c4e0:	f9000fe0 	str	x0, [sp, #24]

	if (attr == NULL) {
    a000c4e4:	f9400fe0 	ldr	x0, [sp, #24]
    a000c4e8:	f100001f 	cmp	x0, #0x0
    a000c4ec:	54000061 	b.ne	a000c4f8 <pthread_attr_init+0x20>  // b.any
		return ENOMEM;
    a000c4f0:	52800180 	mov	w0, #0xc                   	// #12
    a000c4f4:	14000007 	b	a000c510 <pthread_attr_init+0x38>
	}

	(void)memcpy(attr, &init_pthread_attrs, sizeof(pthread_attr_t));
    a000c4f8:	d2800602 	mov	x2, #0x30                  	// #48
    a000c4fc:	900000c0 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a000c500:	911dc001 	add	x1, x0, #0x770
    a000c504:	f9400fe0 	ldr	x0, [sp, #24]
    a000c508:	97fffe64 	bl	a000be98 <memcpy>

	return 0;
    a000c50c:	52800000 	mov	w0, #0x0                   	// #0
}
    a000c510:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a000c514:	d65f03c0 	ret

00000000a000c518 <arch_syscall_invoke0>:
{
    a000c518:	d10043ff 	sub	sp, sp, #0x10
    a000c51c:	f90007e0 	str	x0, [sp, #8]
	register uint64_t r8 __asm__("x8") = call_id;
    a000c520:	f94007e8 	ldr	x8, [sp, #8]
	__asm__ volatile("svc %[svid]\n"
    a000c524:	d4000061 	svc	#0x3
}
    a000c528:	910043ff 	add	sp, sp, #0x10
    a000c52c:	d65f03c0 	ret

00000000a000c530 <arch_is_user_context>:
{
    a000c530:	d10043ff 	sub	sp, sp, #0x10
    a000c534:	d53bd060 	mrs	x0, tpidrro_el0
    a000c538:	f90007e0 	str	x0, [sp, #8]
    a000c53c:	f94007e0 	ldr	x0, [sp, #8]
    a000c540:	d503201f 	nop
	return (read_tpidrro_el0() & TPIDRROEL0_IN_EL0) != 0;
    a000c544:	92400000 	and	x0, x0, #0x1
    a000c548:	f100001f 	cmp	x0, #0x0
    a000c54c:	1a9f07e0 	cset	w0, ne  // ne = any
    a000c550:	12001c00 	and	w0, w0, #0xff
}
    a000c554:	910043ff 	add	sp, sp, #0x10
    a000c558:	d65f03c0 	ret

00000000a000c55c <k_ticks_to_ns_floor64>:
 * Truncates to the next lowest output unit.
 *
 * @return The converted time value
 */
static TIME_CONSTEXPR inline uint64_t k_ticks_to_ns_floor64(uint64_t t)
{
    a000c55c:	d10103ff 	sub	sp, sp, #0x40
    a000c560:	f90007e0 	str	x0, [sp, #8]
    a000c564:	f94007e0 	ldr	x0, [sp, #8]
    a000c568:	f9001fe0 	str	x0, [sp, #56]
    a000c56c:	52800c80 	mov	w0, #0x64                  	// #100
    a000c570:	b90037e0 	str	w0, [sp, #52]
    a000c574:	52994000 	mov	w0, #0xca00                	// #51712
    a000c578:	72a77340 	movk	w0, #0x3b9a, lsl #16
    a000c57c:	b90033e0 	str	w0, [sp, #48]
    a000c580:	52800020 	mov	w0, #0x1                   	// #1
    a000c584:	3900bfe0 	strb	w0, [sp, #47]
    a000c588:	3900bbff 	strb	wzr, [sp, #46]
    a000c58c:	3900b7ff 	strb	wzr, [sp, #45]
    a000c590:	3900b3ff 	strb	wzr, [sp, #44]
		(to_hz > from_hz) && ((to_hz % from_hz) == 0U);
    a000c594:	3940bfe0 	ldrb	w0, [sp, #47]
    a000c598:	7100001f 	cmp	w0, #0x0
    a000c59c:	540001e0 	b.eq	a000c5d8 <k_ticks_to_ns_floor64+0x7c>  // b.none
	bool mul_ratio = const_hz &&
    a000c5a0:	b94037e1 	ldr	w1, [sp, #52]
    a000c5a4:	b94033e0 	ldr	w0, [sp, #48]
    a000c5a8:	6b00003f 	cmp	w1, w0
    a000c5ac:	54000162 	b.cs	a000c5d8 <k_ticks_to_ns_floor64+0x7c>  // b.hs, b.nlast
		(to_hz > from_hz) && ((to_hz % from_hz) == 0U);
    a000c5b0:	b94033e0 	ldr	w0, [sp, #48]
    a000c5b4:	b94037e1 	ldr	w1, [sp, #52]
    a000c5b8:	1ac10802 	udiv	w2, w0, w1
    a000c5bc:	b94037e1 	ldr	w1, [sp, #52]
    a000c5c0:	1b017c41 	mul	w1, w2, w1
    a000c5c4:	4b010000 	sub	w0, w0, w1
    a000c5c8:	7100001f 	cmp	w0, #0x0
    a000c5cc:	54000061 	b.ne	a000c5d8 <k_ticks_to_ns_floor64+0x7c>  // b.any
    a000c5d0:	52800020 	mov	w0, #0x1                   	// #1
    a000c5d4:	14000002 	b	a000c5dc <k_ticks_to_ns_floor64+0x80>
    a000c5d8:	52800000 	mov	w0, #0x0                   	// #0
	bool mul_ratio = const_hz &&
    a000c5dc:	3900afe0 	strb	w0, [sp, #43]
    a000c5e0:	3940afe0 	ldrb	w0, [sp, #43]
    a000c5e4:	12000000 	and	w0, w0, #0x1
    a000c5e8:	3900afe0 	strb	w0, [sp, #43]
		(from_hz > to_hz) && ((from_hz % to_hz) == 0U);
    a000c5ec:	3940bfe0 	ldrb	w0, [sp, #47]
    a000c5f0:	7100001f 	cmp	w0, #0x0
    a000c5f4:	540001e0 	b.eq	a000c630 <k_ticks_to_ns_floor64+0xd4>  // b.none
	bool div_ratio = const_hz &&
    a000c5f8:	b94037e1 	ldr	w1, [sp, #52]
    a000c5fc:	b94033e0 	ldr	w0, [sp, #48]
    a000c600:	6b00003f 	cmp	w1, w0
    a000c604:	54000169 	b.ls	a000c630 <k_ticks_to_ns_floor64+0xd4>  // b.plast
		(from_hz > to_hz) && ((from_hz % to_hz) == 0U);
    a000c608:	b94037e0 	ldr	w0, [sp, #52]
    a000c60c:	b94033e1 	ldr	w1, [sp, #48]
    a000c610:	1ac10802 	udiv	w2, w0, w1
    a000c614:	b94033e1 	ldr	w1, [sp, #48]
    a000c618:	1b017c41 	mul	w1, w2, w1
    a000c61c:	4b010000 	sub	w0, w0, w1
    a000c620:	7100001f 	cmp	w0, #0x0
    a000c624:	54000061 	b.ne	a000c630 <k_ticks_to_ns_floor64+0xd4>  // b.any
    a000c628:	52800020 	mov	w0, #0x1                   	// #1
    a000c62c:	14000002 	b	a000c634 <k_ticks_to_ns_floor64+0xd8>
    a000c630:	52800000 	mov	w0, #0x0                   	// #0
	bool div_ratio = const_hz &&
    a000c634:	3900abe0 	strb	w0, [sp, #42]
    a000c638:	3940abe0 	ldrb	w0, [sp, #42]
    a000c63c:	12000000 	and	w0, w0, #0x1
    a000c640:	3900abe0 	strb	w0, [sp, #42]
	if (from_hz == to_hz) {
    a000c644:	b94037e1 	ldr	w1, [sp, #52]
    a000c648:	b94033e0 	ldr	w0, [sp, #48]
    a000c64c:	6b00003f 	cmp	w1, w0
    a000c650:	54000121 	b.ne	a000c674 <k_ticks_to_ns_floor64+0x118>  // b.any
		return result32 ? ((uint32_t)t) : t;
    a000c654:	3940bbe0 	ldrb	w0, [sp, #46]
    a000c658:	7100001f 	cmp	w0, #0x0
    a000c65c:	54000080 	b.eq	a000c66c <k_ticks_to_ns_floor64+0x110>  // b.none
    a000c660:	f9401fe0 	ldr	x0, [sp, #56]
    a000c664:	2a0003e0 	mov	w0, w0
    a000c668:	14000089 	b	a000c88c <k_ticks_to_ns_floor64+0x330>
    a000c66c:	f9401fe0 	ldr	x0, [sp, #56]
    a000c670:	14000087 	b	a000c88c <k_ticks_to_ns_floor64+0x330>
	uint64_t off = 0;
    a000c674:	f90013ff 	str	xzr, [sp, #32]
	if (!mul_ratio) {
    a000c678:	3940afe0 	ldrb	w0, [sp, #43]
    a000c67c:	52000000 	eor	w0, w0, #0x1
    a000c680:	12001c00 	and	w0, w0, #0xff
    a000c684:	7100001f 	cmp	w0, #0x0
    a000c688:	54000300 	b.eq	a000c6e8 <k_ticks_to_ns_floor64+0x18c>  // b.none
		uint32_t rdivisor = div_ratio ? (from_hz / to_hz) : from_hz;
    a000c68c:	3940abe0 	ldrb	w0, [sp, #42]
    a000c690:	7100001f 	cmp	w0, #0x0
    a000c694:	540000a0 	b.eq	a000c6a8 <k_ticks_to_ns_floor64+0x14c>  // b.none
    a000c698:	b94037e1 	ldr	w1, [sp, #52]
    a000c69c:	b94033e0 	ldr	w0, [sp, #48]
    a000c6a0:	1ac00820 	udiv	w0, w1, w0
    a000c6a4:	14000002 	b	a000c6ac <k_ticks_to_ns_floor64+0x150>
    a000c6a8:	b94037e0 	ldr	w0, [sp, #52]
    a000c6ac:	b9001fe0 	str	w0, [sp, #28]
		if (round_up) {
    a000c6b0:	3940b7e0 	ldrb	w0, [sp, #45]
    a000c6b4:	7100001f 	cmp	w0, #0x0
    a000c6b8:	540000a0 	b.eq	a000c6cc <k_ticks_to_ns_floor64+0x170>  // b.none
			off = rdivisor - 1U;
    a000c6bc:	b9401fe0 	ldr	w0, [sp, #28]
    a000c6c0:	51000400 	sub	w0, w0, #0x1
    a000c6c4:	2a0003e0 	mov	w0, w0
    a000c6c8:	f90013e0 	str	x0, [sp, #32]
		if (round_off) {
    a000c6cc:	3940b3e0 	ldrb	w0, [sp, #44]
    a000c6d0:	7100001f 	cmp	w0, #0x0
    a000c6d4:	540000a0 	b.eq	a000c6e8 <k_ticks_to_ns_floor64+0x18c>  // b.none
			off = rdivisor / 2U;
    a000c6d8:	b9401fe0 	ldr	w0, [sp, #28]
    a000c6dc:	53017c00 	lsr	w0, w0, #1
    a000c6e0:	2a0003e0 	mov	w0, w0
    a000c6e4:	f90013e0 	str	x0, [sp, #32]
	if (div_ratio) {
    a000c6e8:	3940abe0 	ldrb	w0, [sp, #42]
    a000c6ec:	7100001f 	cmp	w0, #0x0
    a000c6f0:	54000360 	b.eq	a000c75c <k_ticks_to_ns_floor64+0x200>  // b.none
		t += off;
    a000c6f4:	f9401fe1 	ldr	x1, [sp, #56]
    a000c6f8:	f94013e0 	ldr	x0, [sp, #32]
    a000c6fc:	8b000020 	add	x0, x1, x0
    a000c700:	f9001fe0 	str	x0, [sp, #56]
		if (result32 && (t < BIT64(32))) {
    a000c704:	3940bbe0 	ldrb	w0, [sp, #46]
    a000c708:	7100001f 	cmp	w0, #0x0
    a000c70c:	540001a0 	b.eq	a000c740 <k_ticks_to_ns_floor64+0x1e4>  // b.none
    a000c710:	f9401fe1 	ldr	x1, [sp, #56]
    a000c714:	b2407fe0 	mov	x0, #0xffffffff            	// #4294967295
    a000c718:	eb00003f 	cmp	x1, x0
    a000c71c:	54000128 	b.hi	a000c740 <k_ticks_to_ns_floor64+0x1e4>  // b.pmore
			return ((uint32_t)t) / (from_hz / to_hz);
    a000c720:	f9401fe0 	ldr	x0, [sp, #56]
    a000c724:	2a0003e2 	mov	w2, w0
    a000c728:	b94037e1 	ldr	w1, [sp, #52]
    a000c72c:	b94033e0 	ldr	w0, [sp, #48]
    a000c730:	1ac00820 	udiv	w0, w1, w0
    a000c734:	1ac00840 	udiv	w0, w2, w0
    a000c738:	2a0003e0 	mov	w0, w0
    a000c73c:	14000054 	b	a000c88c <k_ticks_to_ns_floor64+0x330>
			return t / ((uint64_t)from_hz / to_hz);
    a000c740:	b94037e1 	ldr	w1, [sp, #52]
    a000c744:	b94033e0 	ldr	w0, [sp, #48]
    a000c748:	1ac00820 	udiv	w0, w1, w0
    a000c74c:	2a0003e0 	mov	w0, w0
    a000c750:	f9401fe1 	ldr	x1, [sp, #56]
    a000c754:	9ac00820 	udiv	x0, x1, x0
    a000c758:	1400004d 	b	a000c88c <k_ticks_to_ns_floor64+0x330>
	} else if (mul_ratio) {
    a000c75c:	3940afe0 	ldrb	w0, [sp, #43]
    a000c760:	7100001f 	cmp	w0, #0x0
    a000c764:	54000260 	b.eq	a000c7b0 <k_ticks_to_ns_floor64+0x254>  // b.none
		if (result32) {
    a000c768:	3940bbe0 	ldrb	w0, [sp, #46]
    a000c76c:	7100001f 	cmp	w0, #0x0
    a000c770:	54000120 	b.eq	a000c794 <k_ticks_to_ns_floor64+0x238>  // b.none
			return ((uint32_t)t) * (to_hz / from_hz);
    a000c774:	f9401fe0 	ldr	x0, [sp, #56]
    a000c778:	2a0003e2 	mov	w2, w0
    a000c77c:	b94033e1 	ldr	w1, [sp, #48]
    a000c780:	b94037e0 	ldr	w0, [sp, #52]
    a000c784:	1ac00820 	udiv	w0, w1, w0
    a000c788:	1b007c40 	mul	w0, w2, w0
    a000c78c:	2a0003e0 	mov	w0, w0
    a000c790:	1400003f 	b	a000c88c <k_ticks_to_ns_floor64+0x330>
			return t * ((uint64_t)to_hz / from_hz);
    a000c794:	b94033e1 	ldr	w1, [sp, #48]
    a000c798:	b94037e0 	ldr	w0, [sp, #52]
    a000c79c:	1ac00820 	udiv	w0, w1, w0
    a000c7a0:	2a0003e1 	mov	w1, w0
    a000c7a4:	f9401fe0 	ldr	x0, [sp, #56]
    a000c7a8:	9b007c20 	mul	x0, x1, x0
    a000c7ac:	14000038 	b	a000c88c <k_ticks_to_ns_floor64+0x330>
		if (result32) {
    a000c7b0:	3940bbe0 	ldrb	w0, [sp, #46]
    a000c7b4:	7100001f 	cmp	w0, #0x0
    a000c7b8:	54000140 	b.eq	a000c7e0 <k_ticks_to_ns_floor64+0x284>  // b.none
			return (uint32_t)((t * to_hz + off) / from_hz);
    a000c7bc:	b94033e1 	ldr	w1, [sp, #48]
    a000c7c0:	f9401fe0 	ldr	x0, [sp, #56]
    a000c7c4:	9b007c21 	mul	x1, x1, x0
    a000c7c8:	f94013e0 	ldr	x0, [sp, #32]
    a000c7cc:	8b000021 	add	x1, x1, x0
    a000c7d0:	b94037e0 	ldr	w0, [sp, #52]
    a000c7d4:	9ac00820 	udiv	x0, x1, x0
    a000c7d8:	2a0003e0 	mov	w0, w0
    a000c7dc:	1400002c 	b	a000c88c <k_ticks_to_ns_floor64+0x330>
		} else if (const_hz && Z_TMCVT_USE_FAST_ALGO(from_hz, to_hz)) {
    a000c7e0:	3940bfe0 	ldrb	w0, [sp, #47]
    a000c7e4:	7100001f 	cmp	w0, #0x0
    a000c7e8:	54000300 	b.eq	a000c848 <k_ticks_to_ns_floor64+0x2ec>  // b.none
    a000c7ec:	b94037e1 	ldr	w1, [sp, #52]
    a000c7f0:	d2867000 	mov	x0, #0x3380                	// #13184
    a000c7f4:	f2a03c20 	movk	x0, #0x1e1, lsl #16
    a000c7f8:	9b007c21 	mul	x1, x1, x0
    a000c7fc:	b27f7be0 	mov	x0, #0xfffffffe            	// #4294967294
    a000c800:	8b000021 	add	x1, x1, x0
    a000c804:	320107e0 	mov	w0, #0x80000001            	// #-2147483647
    a000c808:	f2f00000 	movk	x0, #0x8000, lsl #48
    a000c80c:	9bc07c20 	umulh	x0, x1, x0
    a000c810:	d35ffc01 	lsr	x1, x0, #31
    a000c814:	b94033e0 	ldr	w0, [sp, #48]
    a000c818:	9b007c21 	mul	x1, x1, x0
    a000c81c:	b2407fe0 	mov	x0, #0xffffffff            	// #4294967295
    a000c820:	eb00003f 	cmp	x1, x0
    a000c824:	54000128 	b.hi	a000c848 <k_ticks_to_ns_floor64+0x2ec>  // b.pmore
			return ((t * to_hz + off) / from_hz);
    a000c828:	b94033e1 	ldr	w1, [sp, #48]
    a000c82c:	f9401fe0 	ldr	x0, [sp, #56]
    a000c830:	9b007c21 	mul	x1, x1, x0
    a000c834:	f94013e0 	ldr	x0, [sp, #32]
    a000c838:	8b000021 	add	x1, x1, x0
    a000c83c:	b94037e0 	ldr	w0, [sp, #52]
    a000c840:	9ac00820 	udiv	x0, x1, x0
    a000c844:	14000012 	b	a000c88c <k_ticks_to_ns_floor64+0x330>
			return (t / from_hz) * to_hz + ((t % from_hz) * to_hz + off) / from_hz;
    a000c848:	b94037e0 	ldr	w0, [sp, #52]
    a000c84c:	f9401fe1 	ldr	x1, [sp, #56]
    a000c850:	9ac00821 	udiv	x1, x1, x0
    a000c854:	b94033e0 	ldr	w0, [sp, #48]
    a000c858:	9b007c22 	mul	x2, x1, x0
    a000c85c:	b94037e1 	ldr	w1, [sp, #52]
    a000c860:	f9401fe0 	ldr	x0, [sp, #56]
    a000c864:	9ac10803 	udiv	x3, x0, x1
    a000c868:	9b017c61 	mul	x1, x3, x1
    a000c86c:	cb010001 	sub	x1, x0, x1
    a000c870:	b94033e0 	ldr	w0, [sp, #48]
    a000c874:	9b007c21 	mul	x1, x1, x0
    a000c878:	f94013e0 	ldr	x0, [sp, #32]
    a000c87c:	8b000021 	add	x1, x1, x0
    a000c880:	b94037e0 	ldr	w0, [sp, #52]
    a000c884:	9ac00820 	udiv	x0, x1, x0
    a000c888:	8b000040 	add	x0, x2, x0
	/* Generated.  Do not edit.  See above. */
	return z_tmcvt(t, Z_HZ_ticks, Z_HZ_ns, true, false, false, false);
}
    a000c88c:	910103ff 	add	sp, sp, #0x40
    a000c890:	d65f03c0 	ret

00000000a000c894 <z_errno>:
{
    a000c894:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a000c898:	910003fd 	mov	x29, sp
	bool ret = false;
    a000c89c:	39007fff 	strb	wzr, [sp, #31]
	ret = arch_is_user_context();
    a000c8a0:	97ffff24 	bl	a000c530 <arch_is_user_context>
    a000c8a4:	39007fe0 	strb	w0, [sp, #31]
	return ret;
    a000c8a8:	39407fe0 	ldrb	w0, [sp, #31]
	if (z_syscall_trap()) {
    a000c8ac:	7100001f 	cmp	w0, #0x0
    a000c8b0:	54000080 	b.eq	a000c8c0 <z_errno+0x2c>  // b.none
		return (int *) arch_syscall_invoke0(K_SYSCALL_Z_ERRNO);
    a000c8b4:	d2802b60 	mov	x0, #0x15b                 	// #347
    a000c8b8:	97ffff18 	bl	a000c518 <arch_syscall_invoke0>
    a000c8bc:	14000002 	b	a000c8c4 <z_errno+0x30>
	return z_impl_z_errno();
    a000c8c0:	94001118 	bl	a0010d20 <z_impl_z_errno>
}
    a000c8c4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a000c8c8:	d65f03c0 	ret

00000000a000c8cc <k_uptime_ticks>:
{
    a000c8cc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a000c8d0:	910003fd 	mov	x29, sp
	bool ret = false;
    a000c8d4:	39007fff 	strb	wzr, [sp, #31]
	ret = arch_is_user_context();
    a000c8d8:	97ffff16 	bl	a000c530 <arch_is_user_context>
    a000c8dc:	39007fe0 	strb	w0, [sp, #31]
	return ret;
    a000c8e0:	39407fe0 	ldrb	w0, [sp, #31]
	if (z_syscall_trap()) {
    a000c8e4:	7100001f 	cmp	w0, #0x0
    a000c8e8:	54000080 	b.eq	a000c8f8 <k_uptime_ticks+0x2c>  // b.none
		return (int64_t) arch_syscall_invoke0(K_SYSCALL_K_UPTIME_TICKS);
    a000c8ec:	d2801b00 	mov	x0, #0xd8                  	// #216
    a000c8f0:	97ffff0a 	bl	a000c518 <arch_syscall_invoke0>
    a000c8f4:	14000002 	b	a000c8fc <k_uptime_ticks+0x30>
	return z_impl_k_uptime_ticks();
    a000c8f8:	9400367f 	bl	a001a2f4 <z_impl_k_uptime_ticks>
}
    a000c8fc:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a000c900:	d65f03c0 	ret

00000000a000c904 <z_impl_clock_gettime>:
 * @brief Get clock time specified by clock_id.
 *
 * See IEEE 1003.1
 */
int z_impl_clock_gettime(clockid_t clock_id, struct timespec *ts)
{
    a000c904:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
    a000c908:	910003fd 	mov	x29, sp
    a000c90c:	b9001fe0 	str	w0, [sp, #28]
    a000c910:	f9000be1 	str	x1, [sp, #16]
	uint64_t elapsed_nsecs;
	struct timespec base;
	k_spinlock_key_t key;

	switch (clock_id) {
    a000c914:	b9401fe0 	ldr	w0, [sp, #28]
    a000c918:	7100041f 	cmp	w0, #0x1
    a000c91c:	540000e0 	b.eq	a000c938 <z_impl_clock_gettime+0x34>  // b.none
    a000c920:	b9401fe0 	ldr	w0, [sp, #28]
    a000c924:	7100101f 	cmp	w0, #0x4
    a000c928:	540004a1 	b.ne	a000c9bc <z_impl_clock_gettime+0xb8>  // b.any
	case CLOCK_MONOTONIC:
		base.tv_sec = 0;
    a000c92c:	f9001fff 	str	xzr, [sp, #56]
		base.tv_nsec = 0;
    a000c930:	f90023ff 	str	xzr, [sp, #64]
		break;
    a000c934:	14000028 	b	a000c9d4 <z_impl_clock_gettime+0xd0>
    a000c938:	f00001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000c93c:	913f2000 	add	x0, x0, #0xfc8
    a000c940:	f9002fe0 	str	x0, [sp, #88]
MAKE_REG_HELPER(daif)
    a000c944:	d53b4220 	mrs	x0, daif
    a000c948:	f9002be0 	str	x0, [sp, #80]
    a000c94c:	f9402be0 	ldr	x0, [sp, #80]
    a000c950:	d503201f 	nop
	key = read_daif();
    a000c954:	b9004fe0 	str	w0, [sp, #76]
	__asm__ volatile ("msr DAIFSet, %0"
    a000c958:	d50342df 	msr	daifset, #0x2
}
    a000c95c:	d503201f 	nop
	return key;
    a000c960:	b9404fe0 	ldr	w0, [sp, #76]
	k.key = arch_irq_lock();
    a000c964:	b9002be0 	str	w0, [sp, #40]
	return k;
    a000c968:	b9402be0 	ldr	w0, [sp, #40]
    a000c96c:	b90033e0 	str	w0, [sp, #48]

	case CLOCK_REALTIME:
		key = k_spin_lock(&rt_clock_base_lock);
		base = rt_clock_base;
    a000c970:	f00001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000c974:	913ee000 	add	x0, x0, #0xfb8
    a000c978:	a9400400 	ldp	x0, x1, [x0]
    a000c97c:	a90387e0 	stp	x0, x1, [sp, #56]
    a000c980:	f00001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000c984:	913f2000 	add	x0, x0, #0xfc8
    a000c988:	f9003be0 	str	x0, [sp, #112]
    a000c98c:	b94033e0 	ldr	w0, [sp, #48]
    a000c990:	b90023e0 	str	w0, [sp, #32]
	arch_irq_unlock(key.key);
    a000c994:	b94023e0 	ldr	w0, [sp, #32]
    a000c998:	b9006fe0 	str	w0, [sp, #108]
	write_daif(key);
    a000c99c:	b9406fe0 	ldr	w0, [sp, #108]
    a000c9a0:	f90033e0 	str	x0, [sp, #96]
MAKE_REG_HELPER(daif)
    a000c9a4:	f94033e0 	ldr	x0, [sp, #96]
    a000c9a8:	d51b4220 	msr	daif, x0
    a000c9ac:	d503201f 	nop
}
    a000c9b0:	d503201f 	nop
}
    a000c9b4:	d503201f 	nop
		k_spin_unlock(&rt_clock_base_lock, key);
		break;
    a000c9b8:	14000007 	b	a000c9d4 <z_impl_clock_gettime+0xd0>

	default:
		errno = EINVAL;
    a000c9bc:	97ffffb6 	bl	a000c894 <z_errno>
    a000c9c0:	aa0003e1 	mov	x1, x0
    a000c9c4:	528002c0 	mov	w0, #0x16                  	// #22
    a000c9c8:	b9000020 	str	w0, [x1]
		return -1;
    a000c9cc:	12800000 	mov	w0, #0xffffffff            	// #-1
    a000c9d0:	1400003d 	b	a000cac4 <z_impl_clock_gettime+0x1c0>
	}

	elapsed_nsecs = k_ticks_to_ns_floor64(k_uptime_ticks());
    a000c9d4:	97ffffbe 	bl	a000c8cc <k_uptime_ticks>
    a000c9d8:	97fffee1 	bl	a000c55c <k_ticks_to_ns_floor64>
    a000c9dc:	f9003fe0 	str	x0, [sp, #120]
	ts->tv_sec = (int32_t) (elapsed_nsecs / NSEC_PER_SEC);
    a000c9e0:	f9403fe0 	ldr	x0, [sp, #120]
    a000c9e4:	d349fc01 	lsr	x1, x0, #9
    a000c9e8:	d28b4a60 	mov	x0, #0x5a53                	// #23123
    a000c9ec:	f2b41360 	movk	x0, #0xa09b, lsl #16
    a000c9f0:	f2d705e0 	movk	x0, #0xb82f, lsl #32
    a000c9f4:	f2e00880 	movk	x0, #0x44, lsl #48
    a000c9f8:	9bc07c20 	umulh	x0, x1, x0
    a000c9fc:	d34bfc00 	lsr	x0, x0, #11
    a000ca00:	93407c01 	sxtw	x1, w0
    a000ca04:	f9400be0 	ldr	x0, [sp, #16]
    a000ca08:	f9000001 	str	x1, [x0]
	ts->tv_nsec = (int32_t) (elapsed_nsecs % NSEC_PER_SEC);
    a000ca0c:	f9403fe1 	ldr	x1, [sp, #120]
    a000ca10:	d349fc22 	lsr	x2, x1, #9
    a000ca14:	d28b4a60 	mov	x0, #0x5a53                	// #23123
    a000ca18:	f2b41360 	movk	x0, #0xa09b, lsl #16
    a000ca1c:	f2d705e0 	movk	x0, #0xb82f, lsl #32
    a000ca20:	f2e00880 	movk	x0, #0x44, lsl #48
    a000ca24:	9bc07c40 	umulh	x0, x2, x0
    a000ca28:	d34bfc00 	lsr	x0, x0, #11
    a000ca2c:	d2994002 	mov	x2, #0xca00                	// #51712
    a000ca30:	f2a77342 	movk	x2, #0x3b9a, lsl #16
    a000ca34:	9b027c00 	mul	x0, x0, x2
    a000ca38:	cb000020 	sub	x0, x1, x0
    a000ca3c:	93407c01 	sxtw	x1, w0
    a000ca40:	f9400be0 	ldr	x0, [sp, #16]
    a000ca44:	f9000401 	str	x1, [x0, #8]

	ts->tv_sec += base.tv_sec;
    a000ca48:	f9400be0 	ldr	x0, [sp, #16]
    a000ca4c:	f9400001 	ldr	x1, [x0]
    a000ca50:	f9401fe0 	ldr	x0, [sp, #56]
    a000ca54:	8b000021 	add	x1, x1, x0
    a000ca58:	f9400be0 	ldr	x0, [sp, #16]
    a000ca5c:	f9000001 	str	x1, [x0]
	ts->tv_nsec += base.tv_nsec;
    a000ca60:	f9400be0 	ldr	x0, [sp, #16]
    a000ca64:	f9400401 	ldr	x1, [x0, #8]
    a000ca68:	f94023e0 	ldr	x0, [sp, #64]
    a000ca6c:	8b000021 	add	x1, x1, x0
    a000ca70:	f9400be0 	ldr	x0, [sp, #16]
    a000ca74:	f9000401 	str	x1, [x0, #8]
	if (ts->tv_nsec >= NSEC_PER_SEC) {
    a000ca78:	f9400be0 	ldr	x0, [sp, #16]
    a000ca7c:	f9400401 	ldr	x1, [x0, #8]
    a000ca80:	d2993fe0 	mov	x0, #0xc9ff                	// #51711
    a000ca84:	f2a77340 	movk	x0, #0x3b9a, lsl #16
    a000ca88:	eb00003f 	cmp	x1, x0
    a000ca8c:	540001ad 	b.le	a000cac0 <z_impl_clock_gettime+0x1bc>
		ts->tv_sec++;
    a000ca90:	f9400be0 	ldr	x0, [sp, #16]
    a000ca94:	f9400000 	ldr	x0, [x0]
    a000ca98:	91000401 	add	x1, x0, #0x1
    a000ca9c:	f9400be0 	ldr	x0, [sp, #16]
    a000caa0:	f9000001 	str	x1, [x0]
		ts->tv_nsec -= NSEC_PER_SEC;
    a000caa4:	f9400be0 	ldr	x0, [sp, #16]
    a000caa8:	f9400401 	ldr	x1, [x0, #8]
    a000caac:	92993fe0 	mov	x0, #0xffffffffffff3600    	// #-51712
    a000cab0:	f2b88ca0 	movk	x0, #0xc465, lsl #16
    a000cab4:	8b000021 	add	x1, x1, x0
    a000cab8:	f9400be0 	ldr	x0, [sp, #16]
    a000cabc:	f9000401 	str	x1, [x0, #8]
	}

	return 0;
    a000cac0:	52800000 	mov	w0, #0x0                   	// #0
}
    a000cac4:	a8c87bfd 	ldp	x29, x30, [sp], #128
    a000cac8:	d65f03c0 	ret

00000000a000cacc <z_vrfy_clock_gettime>:

#ifdef CONFIG_USERSPACE
int z_vrfy_clock_gettime(clockid_t clock_id, struct timespec *ts)
{
    a000cacc:	a9a17bfd 	stp	x29, x30, [sp, #-496]!
    a000cad0:	910003fd 	mov	x29, sp
    a000cad4:	b9001fe0 	str	w0, [sp, #28]
    a000cad8:	f9000be1 	str	x1, [sp, #16]
	Z_OOPS(Z_SYSCALL_MEMORY_WRITE(ts, sizeof(*ts)));
    a000cadc:	52800022 	mov	w2, #0x1                   	// #1
    a000cae0:	d2800201 	mov	x1, #0x10                  	// #16
    a000cae4:	f9400be0 	ldr	x0, [sp, #16]
    a000cae8:	97fffb61 	bl	a000b86c <arch_buffer_validate>
    a000caec:	7100001f 	cmp	w0, #0x0
    a000caf0:	1a9f07e0 	cset	w0, ne  // ne = any
    a000caf4:	3907bfe0 	strb	w0, [sp, #495]
    a000caf8:	3947bfe0 	ldrb	w0, [sp, #495]
    a000cafc:	7100001f 	cmp	w0, #0x0
    a000cb00:	3947bfe0 	ldrb	w0, [sp, #495]
    a000cb04:	7100001f 	cmp	w0, #0x0
    a000cb08:	540000c0 	b.eq	a000cb20 <z_vrfy_clock_gettime+0x54>  // b.none
    a000cb0c:	f00001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000cb10:	913f8000 	add	x0, x0, #0xfe0
    a000cb14:	f9400800 	ldr	x0, [x0, #16]
    a000cb18:	f9408400 	ldr	x0, [x0, #264]
    a000cb1c:	97fff18f 	bl	a0009158 <arch_syscall_oops>
	return z_impl_clock_gettime(clock_id, ts);
    a000cb20:	f9400be1 	ldr	x1, [sp, #16]
    a000cb24:	b9401fe0 	ldr	w0, [sp, #28]
    a000cb28:	97ffff77 	bl	a000c904 <z_impl_clock_gettime>
}
    a000cb2c:	a8df7bfd 	ldp	x29, x30, [sp], #496
    a000cb30:	d65f03c0 	ret

00000000a000cb34 <z_mrsh_clock_gettime>:
#include <syscalls/time.h>

extern int z_vrfy_clock_gettime(clockid_t clock_id, struct timespec * ts);
uintptr_t z_mrsh_clock_gettime(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a000cb34:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a000cb38:	910003fd 	mov	x29, sp
    a000cb3c:	f90027e0 	str	x0, [sp, #72]
    a000cb40:	f90023e1 	str	x1, [sp, #64]
    a000cb44:	f9001fe2 	str	x2, [sp, #56]
    a000cb48:	f9001be3 	str	x3, [sp, #48]
    a000cb4c:	f90017e4 	str	x4, [sp, #40]
    a000cb50:	f90013e5 	str	x5, [sp, #32]
    a000cb54:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a000cb58:	f00001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000cb5c:	913f8000 	add	x0, x0, #0xfe0
    a000cb60:	f9400800 	ldr	x0, [x0, #16]
    a000cb64:	f9400fe1 	ldr	x1, [sp, #24]
    a000cb68:	f9008401 	str	x1, [x0, #264]
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_clock_gettime(*(clockid_t*)&arg0, *(struct timespec **)&arg1)
    a000cb6c:	910123e0 	add	x0, sp, #0x48
    a000cb70:	b9400002 	ldr	w2, [x0]
    a000cb74:	910103e0 	add	x0, sp, #0x40
    a000cb78:	f9400000 	ldr	x0, [x0]
    a000cb7c:	aa0003e1 	mov	x1, x0
    a000cb80:	2a0203e0 	mov	w0, w2
    a000cb84:	97ffffd2 	bl	a000cacc <z_vrfy_clock_gettime>
    a000cb88:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a000cb8c:	f00001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000cb90:	913f8000 	add	x0, x0, #0xfe0
    a000cb94:	f9400800 	ldr	x0, [x0, #16]
    a000cb98:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a000cb9c:	b9805fe0 	ldrsw	x0, [sp, #92]
}
    a000cba0:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a000cba4:	d65f03c0 	ret

00000000a000cba8 <arch_syscall_invoke1>:
{
    a000cba8:	d10043ff 	sub	sp, sp, #0x10
    a000cbac:	f90007e0 	str	x0, [sp, #8]
    a000cbb0:	f90003e1 	str	x1, [sp]
	register uint64_t ret __asm__("x0") = arg1;
    a000cbb4:	f94007e0 	ldr	x0, [sp, #8]
	register uint64_t r8 __asm__("x8") = call_id;
    a000cbb8:	f94003e8 	ldr	x8, [sp]
	__asm__ volatile("svc %[svid]\n"
    a000cbbc:	d4000061 	svc	#0x3
}
    a000cbc0:	910043ff 	add	sp, sp, #0x10
    a000cbc4:	d65f03c0 	ret

00000000a000cbc8 <arch_is_user_context>:
{
    a000cbc8:	d10043ff 	sub	sp, sp, #0x10
MAKE_REG_HELPER(tpidrro_el0);
    a000cbcc:	d53bd060 	mrs	x0, tpidrro_el0
    a000cbd0:	f90007e0 	str	x0, [sp, #8]
    a000cbd4:	f94007e0 	ldr	x0, [sp, #8]
    a000cbd8:	d503201f 	nop
	return (read_tpidrro_el0() & TPIDRROEL0_IN_EL0) != 0;
    a000cbdc:	92400000 	and	x0, x0, #0x1
    a000cbe0:	f100001f 	cmp	x0, #0x0
    a000cbe4:	1a9f07e0 	cset	w0, ne  // ne = any
    a000cbe8:	12001c00 	and	w0, w0, #0xff
}
    a000cbec:	910043ff 	add	sp, sp, #0x10
    a000cbf0:	d65f03c0 	ret

00000000a000cbf4 <k_ms_to_ticks_ceil64>:
{
    a000cbf4:	d10103ff 	sub	sp, sp, #0x40
    a000cbf8:	f90007e0 	str	x0, [sp, #8]
    a000cbfc:	f94007e0 	ldr	x0, [sp, #8]
    a000cc00:	f9001fe0 	str	x0, [sp, #56]
    a000cc04:	52807d00 	mov	w0, #0x3e8                 	// #1000
    a000cc08:	b90037e0 	str	w0, [sp, #52]
    a000cc0c:	52800c80 	mov	w0, #0x64                  	// #100
    a000cc10:	b90033e0 	str	w0, [sp, #48]
    a000cc14:	52800020 	mov	w0, #0x1                   	// #1
    a000cc18:	3900bfe0 	strb	w0, [sp, #47]
    a000cc1c:	3900bbff 	strb	wzr, [sp, #46]
    a000cc20:	52800020 	mov	w0, #0x1                   	// #1
    a000cc24:	3900b7e0 	strb	w0, [sp, #45]
    a000cc28:	3900b3ff 	strb	wzr, [sp, #44]
		(to_hz > from_hz) && ((to_hz % from_hz) == 0U);
    a000cc2c:	3940bfe0 	ldrb	w0, [sp, #47]
    a000cc30:	7100001f 	cmp	w0, #0x0
    a000cc34:	540001e0 	b.eq	a000cc70 <k_ms_to_ticks_ceil64+0x7c>  // b.none
	bool mul_ratio = const_hz &&
    a000cc38:	b94037e1 	ldr	w1, [sp, #52]
    a000cc3c:	b94033e0 	ldr	w0, [sp, #48]
    a000cc40:	6b00003f 	cmp	w1, w0
    a000cc44:	54000162 	b.cs	a000cc70 <k_ms_to_ticks_ceil64+0x7c>  // b.hs, b.nlast
		(to_hz > from_hz) && ((to_hz % from_hz) == 0U);
    a000cc48:	b94033e0 	ldr	w0, [sp, #48]
    a000cc4c:	b94037e1 	ldr	w1, [sp, #52]
    a000cc50:	1ac10802 	udiv	w2, w0, w1
    a000cc54:	b94037e1 	ldr	w1, [sp, #52]
    a000cc58:	1b017c41 	mul	w1, w2, w1
    a000cc5c:	4b010000 	sub	w0, w0, w1
    a000cc60:	7100001f 	cmp	w0, #0x0
    a000cc64:	54000061 	b.ne	a000cc70 <k_ms_to_ticks_ceil64+0x7c>  // b.any
    a000cc68:	52800020 	mov	w0, #0x1                   	// #1
    a000cc6c:	14000002 	b	a000cc74 <k_ms_to_ticks_ceil64+0x80>
    a000cc70:	52800000 	mov	w0, #0x0                   	// #0
	bool mul_ratio = const_hz &&
    a000cc74:	3900afe0 	strb	w0, [sp, #43]
    a000cc78:	3940afe0 	ldrb	w0, [sp, #43]
    a000cc7c:	12000000 	and	w0, w0, #0x1
    a000cc80:	3900afe0 	strb	w0, [sp, #43]
		(from_hz > to_hz) && ((from_hz % to_hz) == 0U);
    a000cc84:	3940bfe0 	ldrb	w0, [sp, #47]
    a000cc88:	7100001f 	cmp	w0, #0x0
    a000cc8c:	540001e0 	b.eq	a000ccc8 <k_ms_to_ticks_ceil64+0xd4>  // b.none
	bool div_ratio = const_hz &&
    a000cc90:	b94037e1 	ldr	w1, [sp, #52]
    a000cc94:	b94033e0 	ldr	w0, [sp, #48]
    a000cc98:	6b00003f 	cmp	w1, w0
    a000cc9c:	54000169 	b.ls	a000ccc8 <k_ms_to_ticks_ceil64+0xd4>  // b.plast
		(from_hz > to_hz) && ((from_hz % to_hz) == 0U);
    a000cca0:	b94037e0 	ldr	w0, [sp, #52]
    a000cca4:	b94033e1 	ldr	w1, [sp, #48]
    a000cca8:	1ac10802 	udiv	w2, w0, w1
    a000ccac:	b94033e1 	ldr	w1, [sp, #48]
    a000ccb0:	1b017c41 	mul	w1, w2, w1
    a000ccb4:	4b010000 	sub	w0, w0, w1
    a000ccb8:	7100001f 	cmp	w0, #0x0
    a000ccbc:	54000061 	b.ne	a000ccc8 <k_ms_to_ticks_ceil64+0xd4>  // b.any
    a000ccc0:	52800020 	mov	w0, #0x1                   	// #1
    a000ccc4:	14000002 	b	a000cccc <k_ms_to_ticks_ceil64+0xd8>
    a000ccc8:	52800000 	mov	w0, #0x0                   	// #0
	bool div_ratio = const_hz &&
    a000cccc:	3900abe0 	strb	w0, [sp, #42]
    a000ccd0:	3940abe0 	ldrb	w0, [sp, #42]
    a000ccd4:	12000000 	and	w0, w0, #0x1
    a000ccd8:	3900abe0 	strb	w0, [sp, #42]
	if (from_hz == to_hz) {
    a000ccdc:	b94037e1 	ldr	w1, [sp, #52]
    a000cce0:	b94033e0 	ldr	w0, [sp, #48]
    a000cce4:	6b00003f 	cmp	w1, w0
    a000cce8:	54000121 	b.ne	a000cd0c <k_ms_to_ticks_ceil64+0x118>  // b.any
		return result32 ? ((uint32_t)t) : t;
    a000ccec:	3940bbe0 	ldrb	w0, [sp, #46]
    a000ccf0:	7100001f 	cmp	w0, #0x0
    a000ccf4:	54000080 	b.eq	a000cd04 <k_ms_to_ticks_ceil64+0x110>  // b.none
    a000ccf8:	f9401fe0 	ldr	x0, [sp, #56]
    a000ccfc:	2a0003e0 	mov	w0, w0
    a000cd00:	14000089 	b	a000cf24 <k_ms_to_ticks_ceil64+0x330>
    a000cd04:	f9401fe0 	ldr	x0, [sp, #56]
    a000cd08:	14000087 	b	a000cf24 <k_ms_to_ticks_ceil64+0x330>
	uint64_t off = 0;
    a000cd0c:	f90013ff 	str	xzr, [sp, #32]
	if (!mul_ratio) {
    a000cd10:	3940afe0 	ldrb	w0, [sp, #43]
    a000cd14:	52000000 	eor	w0, w0, #0x1
    a000cd18:	12001c00 	and	w0, w0, #0xff
    a000cd1c:	7100001f 	cmp	w0, #0x0
    a000cd20:	54000300 	b.eq	a000cd80 <k_ms_to_ticks_ceil64+0x18c>  // b.none
		uint32_t rdivisor = div_ratio ? (from_hz / to_hz) : from_hz;
    a000cd24:	3940abe0 	ldrb	w0, [sp, #42]
    a000cd28:	7100001f 	cmp	w0, #0x0
    a000cd2c:	540000a0 	b.eq	a000cd40 <k_ms_to_ticks_ceil64+0x14c>  // b.none
    a000cd30:	b94037e1 	ldr	w1, [sp, #52]
    a000cd34:	b94033e0 	ldr	w0, [sp, #48]
    a000cd38:	1ac00820 	udiv	w0, w1, w0
    a000cd3c:	14000002 	b	a000cd44 <k_ms_to_ticks_ceil64+0x150>
    a000cd40:	b94037e0 	ldr	w0, [sp, #52]
    a000cd44:	b9001fe0 	str	w0, [sp, #28]
		if (round_up) {
    a000cd48:	3940b7e0 	ldrb	w0, [sp, #45]
    a000cd4c:	7100001f 	cmp	w0, #0x0
    a000cd50:	540000a0 	b.eq	a000cd64 <k_ms_to_ticks_ceil64+0x170>  // b.none
			off = rdivisor - 1U;
    a000cd54:	b9401fe0 	ldr	w0, [sp, #28]
    a000cd58:	51000400 	sub	w0, w0, #0x1
    a000cd5c:	2a0003e0 	mov	w0, w0
    a000cd60:	f90013e0 	str	x0, [sp, #32]
		if (round_off) {
    a000cd64:	3940b3e0 	ldrb	w0, [sp, #44]
    a000cd68:	7100001f 	cmp	w0, #0x0
    a000cd6c:	540000a0 	b.eq	a000cd80 <k_ms_to_ticks_ceil64+0x18c>  // b.none
			off = rdivisor / 2U;
    a000cd70:	b9401fe0 	ldr	w0, [sp, #28]
    a000cd74:	53017c00 	lsr	w0, w0, #1
    a000cd78:	2a0003e0 	mov	w0, w0
    a000cd7c:	f90013e0 	str	x0, [sp, #32]
	if (div_ratio) {
    a000cd80:	3940abe0 	ldrb	w0, [sp, #42]
    a000cd84:	7100001f 	cmp	w0, #0x0
    a000cd88:	54000360 	b.eq	a000cdf4 <k_ms_to_ticks_ceil64+0x200>  // b.none
		t += off;
    a000cd8c:	f9401fe1 	ldr	x1, [sp, #56]
    a000cd90:	f94013e0 	ldr	x0, [sp, #32]
    a000cd94:	8b000020 	add	x0, x1, x0
    a000cd98:	f9001fe0 	str	x0, [sp, #56]
		if (result32 && (t < BIT64(32))) {
    a000cd9c:	3940bbe0 	ldrb	w0, [sp, #46]
    a000cda0:	7100001f 	cmp	w0, #0x0
    a000cda4:	540001a0 	b.eq	a000cdd8 <k_ms_to_ticks_ceil64+0x1e4>  // b.none
    a000cda8:	f9401fe1 	ldr	x1, [sp, #56]
    a000cdac:	b2407fe0 	mov	x0, #0xffffffff            	// #4294967295
    a000cdb0:	eb00003f 	cmp	x1, x0
    a000cdb4:	54000128 	b.hi	a000cdd8 <k_ms_to_ticks_ceil64+0x1e4>  // b.pmore
			return ((uint32_t)t) / (from_hz / to_hz);
    a000cdb8:	f9401fe0 	ldr	x0, [sp, #56]
    a000cdbc:	2a0003e2 	mov	w2, w0
    a000cdc0:	b94037e1 	ldr	w1, [sp, #52]
    a000cdc4:	b94033e0 	ldr	w0, [sp, #48]
    a000cdc8:	1ac00820 	udiv	w0, w1, w0
    a000cdcc:	1ac00840 	udiv	w0, w2, w0
    a000cdd0:	2a0003e0 	mov	w0, w0
    a000cdd4:	14000054 	b	a000cf24 <k_ms_to_ticks_ceil64+0x330>
			return t / ((uint64_t)from_hz / to_hz);
    a000cdd8:	b94037e1 	ldr	w1, [sp, #52]
    a000cddc:	b94033e0 	ldr	w0, [sp, #48]
    a000cde0:	1ac00820 	udiv	w0, w1, w0
    a000cde4:	2a0003e0 	mov	w0, w0
    a000cde8:	f9401fe1 	ldr	x1, [sp, #56]
    a000cdec:	9ac00820 	udiv	x0, x1, x0
    a000cdf0:	1400004d 	b	a000cf24 <k_ms_to_ticks_ceil64+0x330>
	} else if (mul_ratio) {
    a000cdf4:	3940afe0 	ldrb	w0, [sp, #43]
    a000cdf8:	7100001f 	cmp	w0, #0x0
    a000cdfc:	54000260 	b.eq	a000ce48 <k_ms_to_ticks_ceil64+0x254>  // b.none
		if (result32) {
    a000ce00:	3940bbe0 	ldrb	w0, [sp, #46]
    a000ce04:	7100001f 	cmp	w0, #0x0
    a000ce08:	54000120 	b.eq	a000ce2c <k_ms_to_ticks_ceil64+0x238>  // b.none
			return ((uint32_t)t) * (to_hz / from_hz);
    a000ce0c:	f9401fe0 	ldr	x0, [sp, #56]
    a000ce10:	2a0003e2 	mov	w2, w0
    a000ce14:	b94033e1 	ldr	w1, [sp, #48]
    a000ce18:	b94037e0 	ldr	w0, [sp, #52]
    a000ce1c:	1ac00820 	udiv	w0, w1, w0
    a000ce20:	1b007c40 	mul	w0, w2, w0
    a000ce24:	2a0003e0 	mov	w0, w0
    a000ce28:	1400003f 	b	a000cf24 <k_ms_to_ticks_ceil64+0x330>
			return t * ((uint64_t)to_hz / from_hz);
    a000ce2c:	b94033e1 	ldr	w1, [sp, #48]
    a000ce30:	b94037e0 	ldr	w0, [sp, #52]
    a000ce34:	1ac00820 	udiv	w0, w1, w0
    a000ce38:	2a0003e1 	mov	w1, w0
    a000ce3c:	f9401fe0 	ldr	x0, [sp, #56]
    a000ce40:	9b007c20 	mul	x0, x1, x0
    a000ce44:	14000038 	b	a000cf24 <k_ms_to_ticks_ceil64+0x330>
		if (result32) {
    a000ce48:	3940bbe0 	ldrb	w0, [sp, #46]
    a000ce4c:	7100001f 	cmp	w0, #0x0
    a000ce50:	54000140 	b.eq	a000ce78 <k_ms_to_ticks_ceil64+0x284>  // b.none
			return (uint32_t)((t * to_hz + off) / from_hz);
    a000ce54:	b94033e1 	ldr	w1, [sp, #48]
    a000ce58:	f9401fe0 	ldr	x0, [sp, #56]
    a000ce5c:	9b007c21 	mul	x1, x1, x0
    a000ce60:	f94013e0 	ldr	x0, [sp, #32]
    a000ce64:	8b000021 	add	x1, x1, x0
    a000ce68:	b94037e0 	ldr	w0, [sp, #52]
    a000ce6c:	9ac00820 	udiv	x0, x1, x0
    a000ce70:	2a0003e0 	mov	w0, w0
    a000ce74:	1400002c 	b	a000cf24 <k_ms_to_ticks_ceil64+0x330>
		} else if (const_hz && Z_TMCVT_USE_FAST_ALGO(from_hz, to_hz)) {
    a000ce78:	3940bfe0 	ldrb	w0, [sp, #47]
    a000ce7c:	7100001f 	cmp	w0, #0x0
    a000ce80:	54000300 	b.eq	a000cee0 <k_ms_to_ticks_ceil64+0x2ec>  // b.none
    a000ce84:	b94037e1 	ldr	w1, [sp, #52]
    a000ce88:	d2867000 	mov	x0, #0x3380                	// #13184
    a000ce8c:	f2a03c20 	movk	x0, #0x1e1, lsl #16
    a000ce90:	9b007c21 	mul	x1, x1, x0
    a000ce94:	b27f7be0 	mov	x0, #0xfffffffe            	// #4294967294
    a000ce98:	8b000021 	add	x1, x1, x0
    a000ce9c:	320107e0 	mov	w0, #0x80000001            	// #-2147483647
    a000cea0:	f2f00000 	movk	x0, #0x8000, lsl #48
    a000cea4:	9bc07c20 	umulh	x0, x1, x0
    a000cea8:	d35ffc01 	lsr	x1, x0, #31
    a000ceac:	b94033e0 	ldr	w0, [sp, #48]
    a000ceb0:	9b007c21 	mul	x1, x1, x0
    a000ceb4:	b2407fe0 	mov	x0, #0xffffffff            	// #4294967295
    a000ceb8:	eb00003f 	cmp	x1, x0
    a000cebc:	54000128 	b.hi	a000cee0 <k_ms_to_ticks_ceil64+0x2ec>  // b.pmore
			return ((t * to_hz + off) / from_hz);
    a000cec0:	b94033e1 	ldr	w1, [sp, #48]
    a000cec4:	f9401fe0 	ldr	x0, [sp, #56]
    a000cec8:	9b007c21 	mul	x1, x1, x0
    a000cecc:	f94013e0 	ldr	x0, [sp, #32]
    a000ced0:	8b000021 	add	x1, x1, x0
    a000ced4:	b94037e0 	ldr	w0, [sp, #52]
    a000ced8:	9ac00820 	udiv	x0, x1, x0
    a000cedc:	14000012 	b	a000cf24 <k_ms_to_ticks_ceil64+0x330>
			return (t / from_hz) * to_hz + ((t % from_hz) * to_hz + off) / from_hz;
    a000cee0:	b94037e0 	ldr	w0, [sp, #52]
    a000cee4:	f9401fe1 	ldr	x1, [sp, #56]
    a000cee8:	9ac00821 	udiv	x1, x1, x0
    a000ceec:	b94033e0 	ldr	w0, [sp, #48]
    a000cef0:	9b007c22 	mul	x2, x1, x0
    a000cef4:	b94037e1 	ldr	w1, [sp, #52]
    a000cef8:	f9401fe0 	ldr	x0, [sp, #56]
    a000cefc:	9ac10803 	udiv	x3, x0, x1
    a000cf00:	9b017c61 	mul	x1, x3, x1
    a000cf04:	cb010001 	sub	x1, x0, x1
    a000cf08:	b94033e0 	ldr	w0, [sp, #48]
    a000cf0c:	9b007c21 	mul	x1, x1, x0
    a000cf10:	f94013e0 	ldr	x0, [sp, #32]
    a000cf14:	8b000021 	add	x1, x1, x0
    a000cf18:	b94037e0 	ldr	w0, [sp, #52]
    a000cf1c:	9ac00820 	udiv	x0, x1, x0
    a000cf20:	8b000040 	add	x0, x2, x0
}
    a000cf24:	910103ff 	add	sp, sp, #0x40
    a000cf28:	d65f03c0 	ret

00000000a000cf2c <k_msleep>:
{
    a000cf2c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a000cf30:	910003fd 	mov	x29, sp
    a000cf34:	b9001fe0 	str	w0, [sp, #28]
	return k_sleep(Z_TIMEOUT_MS(ms));
    a000cf38:	b9401fe1 	ldr	w1, [sp, #28]
    a000cf3c:	b9401fe0 	ldr	w0, [sp, #28]
    a000cf40:	52800002 	mov	w2, #0x0                   	// #0
    a000cf44:	7100003f 	cmp	w1, #0x0
    a000cf48:	1a82a000 	csel	w0, w0, w2, ge  // ge = tcont
    a000cf4c:	93407c00 	sxtw	x0, w0
    a000cf50:	97ffff29 	bl	a000cbf4 <k_ms_to_ticks_ceil64>
    a000cf54:	94000003 	bl	a000cf60 <k_sleep>
}
    a000cf58:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a000cf5c:	d65f03c0 	ret

00000000a000cf60 <k_sleep>:
{
    a000cf60:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a000cf64:	910003fd 	mov	x29, sp
    a000cf68:	f9000fe0 	str	x0, [sp, #24]
	bool ret = false;
    a000cf6c:	3900bfff 	strb	wzr, [sp, #47]
	ret = arch_is_user_context();
    a000cf70:	97ffff16 	bl	a000cbc8 <arch_is_user_context>
    a000cf74:	3900bfe0 	strb	w0, [sp, #47]
	return ret;
    a000cf78:	3940bfe0 	ldrb	w0, [sp, #47]
	if (z_syscall_trap()) {
    a000cf7c:	7100001f 	cmp	w0, #0x0
    a000cf80:	540000c0 	b.eq	a000cf98 <k_sleep+0x38>  // b.none
		return (int32_t) arch_syscall_invoke1(*(uintptr_t *)&timeout, K_SYSCALL_K_SLEEP);
    a000cf84:	910063e0 	add	x0, sp, #0x18
    a000cf88:	f9400000 	ldr	x0, [x0]
    a000cf8c:	d2801761 	mov	x1, #0xbb                  	// #187
    a000cf90:	97ffff06 	bl	a000cba8 <arch_syscall_invoke1>
    a000cf94:	14000003 	b	a000cfa0 <k_sleep+0x40>
	return z_impl_k_sleep(timeout);
    a000cf98:	f9400fe0 	ldr	x0, [sp, #24]
    a000cf9c:	94002eda 	bl	a0018b04 <z_impl_k_sleep>
}
    a000cfa0:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a000cfa4:	d65f03c0 	ret

00000000a000cfa8 <k_busy_wait>:
{
    a000cfa8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a000cfac:	910003fd 	mov	x29, sp
    a000cfb0:	b9001fe0 	str	w0, [sp, #28]
	bool ret = false;
    a000cfb4:	3900bfff 	strb	wzr, [sp, #47]
	ret = arch_is_user_context();
    a000cfb8:	97ffff04 	bl	a000cbc8 <arch_is_user_context>
    a000cfbc:	3900bfe0 	strb	w0, [sp, #47]
	return ret;
    a000cfc0:	3940bfe0 	ldrb	w0, [sp, #47]
	if (z_syscall_trap()) {
    a000cfc4:	7100001f 	cmp	w0, #0x0
    a000cfc8:	540000c0 	b.eq	a000cfe0 <k_busy_wait+0x38>  // b.none
		arch_syscall_invoke1(*(uintptr_t *)&usec_to_wait, K_SYSCALL_K_BUSY_WAIT);
    a000cfcc:	910073e0 	add	x0, sp, #0x1c
    a000cfd0:	f9400000 	ldr	x0, [x0]
    a000cfd4:	d2801001 	mov	x1, #0x80                  	// #128
    a000cfd8:	97fffef4 	bl	a000cba8 <arch_syscall_invoke1>
		return;
    a000cfdc:	14000003 	b	a000cfe8 <k_busy_wait+0x40>
	z_impl_k_busy_wait(usec_to_wait);
    a000cfe0:	b9401fe0 	ldr	w0, [sp, #28]
    a000cfe4:	940034e5 	bl	a001a378 <z_impl_k_busy_wait>
}
    a000cfe8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a000cfec:	d65f03c0 	ret

00000000a000cff0 <usleep>:
 * @brief Suspend execution for microsecond intervals.
 *
 * See IEEE 1003.1
 */
int usleep(useconds_t useconds)
{
    a000cff0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a000cff4:	910003fd 	mov	x29, sp
    a000cff8:	f9000fe0 	str	x0, [sp, #24]
	if (useconds < USEC_PER_MSEC) {
    a000cffc:	f9400fe0 	ldr	x0, [sp, #24]
    a000d000:	f10f9c1f 	cmp	x0, #0x3e7
    a000d004:	54000088 	b.hi	a000d014 <usleep+0x24>  // b.pmore
		k_busy_wait(useconds);
    a000d008:	f9400fe0 	ldr	x0, [sp, #24]
    a000d00c:	97ffffe7 	bl	a000cfa8 <k_busy_wait>
    a000d010:	1400000a 	b	a000d038 <usleep+0x48>
	} else {
		k_msleep(useconds / USEC_PER_MSEC);
    a000d014:	f9400fe0 	ldr	x0, [sp, #24]
    a000d018:	d343fc01 	lsr	x1, x0, #3
    a000d01c:	d29ef9e0 	mov	x0, #0xf7cf                	// #63439
    a000d020:	f2bc6a60 	movk	x0, #0xe353, lsl #16
    a000d024:	f2d374a0 	movk	x0, #0x9ba5, lsl #32
    a000d028:	f2e41880 	movk	x0, #0x20c4, lsl #48
    a000d02c:	9bc07c20 	umulh	x0, x1, x0
    a000d030:	d344fc00 	lsr	x0, x0, #4
    a000d034:	97ffffbe 	bl	a000cf2c <k_msleep>
	}

	return 0;
    a000d038:	52800000 	mov	w0, #0x0                   	// #0
}
    a000d03c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a000d040:	d65f03c0 	ret

00000000a000d044 <gic_get_rdist>:

atomic_t nlpi_intid = ATOMIC_INIT(8192);
#endif

static inline mem_addr_t gic_get_rdist(void)
{
    a000d044:	d10043ff 	sub	sp, sp, #0x10
    a000d048:	d53bd060 	mrs	x0, tpidrro_el0
    a000d04c:	f90007e0 	str	x0, [sp, #8]
    a000d050:	f94007e0 	ldr	x0, [sp, #8]
    a000d054:	d503201f 	nop
#include <arch/arm64/lib_helpers.h>
#include <arch/arm64/tpidrro_el0.h>

static ALWAYS_INLINE _cpu_t *arch_curr_cpu(void)
{
	return (_cpu_t *)(read_tpidrro_el0() & TPIDRROEL0_CURR_CPU);
    a000d058:	927db000 	and	x0, x0, #0xfffffffffff8
	return gic_rdists[arch_curr_cpu()->id];
    a000d05c:	39409000 	ldrb	w0, [x0, #36]
    a000d060:	2a0003e1 	mov	w1, w0
    a000d064:	d00001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000d068:	913f2000 	add	x0, x0, #0xfc8
    a000d06c:	93407c21 	sxtw	x1, w1
    a000d070:	f8617800 	ldr	x0, [x0, x1, lsl #3]
}
    a000d074:	910043ff 	add	sp, sp, #0x10
    a000d078:	d65f03c0 	ret

00000000a000d07c <gic_wait_rwp>:
/*
 * Wait for register write pending
 * TODO: add timed wait
 */
static int gic_wait_rwp(uint32_t intid)
{
    a000d07c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    a000d080:	910003fd 	mov	x29, sp
    a000d084:	b9001fe0 	str	w0, [sp, #28]
	uint32_t rwp_mask;
	mem_addr_t base;

	if (intid < GIC_SPI_INT_BASE) {
    a000d088:	b9401fe0 	ldr	w0, [sp, #28]
    a000d08c:	71007c1f 	cmp	w0, #0x1f
    a000d090:	540000c8 	b.hi	a000d0a8 <gic_wait_rwp+0x2c>  // b.pmore
		base = (gic_get_rdist() + GICR_CTLR);
    a000d094:	97ffffec 	bl	a000d044 <gic_get_rdist>
    a000d098:	f9001be0 	str	x0, [sp, #48]
		rwp_mask = BIT(GICR_CTLR_RWP);
    a000d09c:	52800100 	mov	w0, #0x8                   	// #8
    a000d0a0:	b9003fe0 	str	w0, [sp, #60]
    a000d0a4:	14000005 	b	a000d0b8 <gic_wait_rwp+0x3c>
	} else {
		base = GICD_CTLR;
    a000d0a8:	d2a10000 	mov	x0, #0x8000000             	// #134217728
    a000d0ac:	f9001be0 	str	x0, [sp, #48]
		rwp_mask = BIT(GICD_CTLR_RWP);
    a000d0b0:	52b00000 	mov	w0, #0x80000000            	// #-2147483648
    a000d0b4:	b9003fe0 	str	w0, [sp, #60]
	}

	while (sys_read32(base) & rwp_mask)
    a000d0b8:	d503201f 	nop
    a000d0bc:	f9401be0 	ldr	x0, [sp, #48]
    a000d0c0:	f90017e0 	str	x0, [sp, #40]

static ALWAYS_INLINE uint32_t sys_read32(mem_addr_t addr)
{
	uint32_t val;

	__asm__ volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    a000d0c4:	f94017e0 	ldr	x0, [sp, #40]
    a000d0c8:	b9400000 	ldr	w0, [x0]
    a000d0cc:	b90027e0 	str	w0, [sp, #36]

	__DMB();
    a000d0d0:	d5033fbf 	dmb	sy
	return val;
    a000d0d4:	b94027e1 	ldr	w1, [sp, #36]
    a000d0d8:	b9403fe0 	ldr	w0, [sp, #60]
    a000d0dc:	0a000020 	and	w0, w1, w0
    a000d0e0:	7100001f 	cmp	w0, #0x0
    a000d0e4:	54fffec1 	b.ne	a000d0bc <gic_wait_rwp+0x40>  // b.any
		;

	return 0;
    a000d0e8:	52800000 	mov	w0, #0x0                   	// #0
}
    a000d0ec:	a8c47bfd 	ldp	x29, x30, [sp], #64
    a000d0f0:	d65f03c0 	ret

00000000a000d0f4 <arm_gic_irq_set_priority>:
}
#endif

void arm_gic_irq_set_priority(unsigned int intid,
			      unsigned int prio, uint32_t flags)
{
    a000d0f4:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    a000d0f8:	910003fd 	mov	x29, sp
    a000d0fc:	b9001fe0 	str	w0, [sp, #28]
    a000d100:	b9001be1 	str	w1, [sp, #24]
    a000d104:	b90017e2 	str	w2, [sp, #20]
	if (intid >= 8192) {
		arm_gic_lpi_set_priority(intid, prio);
		return;
	}
#endif
	uint32_t mask = BIT(intid & (GIC_NUM_INTR_PER_REG - 1));
    a000d108:	b9401fe0 	ldr	w0, [sp, #28]
    a000d10c:	12001000 	and	w0, w0, #0x1f
    a000d110:	d2800021 	mov	x1, #0x1                   	// #1
    a000d114:	9ac02020 	lsl	x0, x1, x0
    a000d118:	b9006be0 	str	w0, [sp, #104]
	uint32_t idx = intid / GIC_NUM_INTR_PER_REG;
    a000d11c:	b9401fe0 	ldr	w0, [sp, #28]
    a000d120:	53057c00 	lsr	w0, w0, #5
    a000d124:	b90067e0 	str	w0, [sp, #100]
	uint32_t shift;
	uint32_t val;
	mem_addr_t base = GET_DIST_BASE(intid);
    a000d128:	b9401fe0 	ldr	w0, [sp, #28]
    a000d12c:	71007c1f 	cmp	w0, #0x1f
    a000d130:	54000088 	b.hi	a000d140 <arm_gic_irq_set_priority+0x4c>  // b.pmore
    a000d134:	97ffffc4 	bl	a000d044 <gic_get_rdist>
    a000d138:	91404000 	add	x0, x0, #0x10, lsl #12
    a000d13c:	14000002 	b	a000d144 <arm_gic_irq_set_priority+0x50>
    a000d140:	d2a10000 	mov	x0, #0x8000000             	// #134217728
    a000d144:	f9002fe0 	str	x0, [sp, #88]

	/* Disable the interrupt */
	sys_write32(mask, ICENABLER(base, idx));
    a000d148:	b94067e0 	ldr	w0, [sp, #100]
    a000d14c:	531e7400 	lsl	w0, w0, #2
    a000d150:	2a0003e1 	mov	w1, w0
    a000d154:	f9402fe0 	ldr	x0, [sp, #88]
    a000d158:	8b000020 	add	x0, x1, x0
    a000d15c:	91060000 	add	x0, x0, #0x180
    a000d160:	b9406be1 	ldr	w1, [sp, #104]
    a000d164:	b90047e1 	str	w1, [sp, #68]
    a000d168:	f9001fe0 	str	x0, [sp, #56]
}

static ALWAYS_INLINE void sys_write32(uint32_t data, mem_addr_t addr)
{
	__DMB();
    a000d16c:	d5033fbf 	dmb	sy
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    a000d170:	b94047e0 	ldr	w0, [sp, #68]
    a000d174:	f9401fe1 	ldr	x1, [sp, #56]
    a000d178:	b9000020 	str	w0, [x1]
}
    a000d17c:	d503201f 	nop
	gic_wait_rwp(intid);
    a000d180:	b9401fe0 	ldr	w0, [sp, #28]
    a000d184:	97ffffbe 	bl	a000d07c <gic_wait_rwp>

	/* PRIORITYR registers provide byte access */
	sys_write8(prio & GIC_PRI_MASK, IPRIORITYR(base, intid));
    a000d188:	b9401be0 	ldr	w0, [sp, #24]
    a000d18c:	12001c02 	and	w2, w0, #0xff
    a000d190:	b9401fe1 	ldr	w1, [sp, #28]
    a000d194:	f9402fe0 	ldr	x0, [sp, #88]
    a000d198:	8b000020 	add	x0, x1, x0
    a000d19c:	91100000 	add	x0, x0, #0x400
    a000d1a0:	2a0203e1 	mov	w1, w2
    a000d1a4:	39014fe1 	strb	w1, [sp, #83]
    a000d1a8:	f90027e0 	str	x0, [sp, #72]
	__DMB();
    a000d1ac:	d5033fbf 	dmb	sy
	__asm__ volatile("strb %w0, [%1]" : : "r" (data), "r" (addr));
    a000d1b0:	39414fe0 	ldrb	w0, [sp, #83]
    a000d1b4:	f94027e1 	ldr	x1, [sp, #72]
    a000d1b8:	39000020 	strb	w0, [x1]
}
    a000d1bc:	d503201f 	nop

	/* Interrupt type config */
	if (!GIC_IS_SGI(intid)) {
    a000d1c0:	b9401fe0 	ldr	w0, [sp, #28]
    a000d1c4:	71003c1f 	cmp	w0, #0xf
    a000d1c8:	540006a9 	b.ls	a000d29c <arm_gic_irq_set_priority+0x1a8>  // b.plast
		idx = intid / GIC_NUM_CFG_PER_REG;
    a000d1cc:	b9401fe0 	ldr	w0, [sp, #28]
    a000d1d0:	53047c00 	lsr	w0, w0, #4
    a000d1d4:	b90067e0 	str	w0, [sp, #100]
		shift = (intid & (GIC_NUM_CFG_PER_REG - 1)) * 2;
    a000d1d8:	b9401fe0 	ldr	w0, [sp, #28]
    a000d1dc:	12000c00 	and	w0, w0, #0xf
    a000d1e0:	0b000000 	add	w0, w0, w0
    a000d1e4:	b90057e0 	str	w0, [sp, #84]

		val = sys_read32(ICFGR(base, idx));
    a000d1e8:	b94067e0 	ldr	w0, [sp, #100]
    a000d1ec:	531e7400 	lsl	w0, w0, #2
    a000d1f0:	2a0003e1 	mov	w1, w0
    a000d1f4:	f9402fe0 	ldr	x0, [sp, #88]
    a000d1f8:	8b000020 	add	x0, x1, x0
    a000d1fc:	91300000 	add	x0, x0, #0xc00
    a000d200:	f9001be0 	str	x0, [sp, #48]
	__asm__ volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    a000d204:	f9401be0 	ldr	x0, [sp, #48]
    a000d208:	b9400000 	ldr	w0, [x0]
    a000d20c:	b9002fe0 	str	w0, [sp, #44]
	__DMB();
    a000d210:	d5033fbf 	dmb	sy
	return val;
    a000d214:	b9402fe0 	ldr	w0, [sp, #44]
    a000d218:	b9006fe0 	str	w0, [sp, #108]
		val &= ~(GICD_ICFGR_MASK << shift);
    a000d21c:	b94057e0 	ldr	w0, [sp, #84]
    a000d220:	d2800061 	mov	x1, #0x3                   	// #3
    a000d224:	9ac02020 	lsl	x0, x1, x0
    a000d228:	2a2003e0 	mvn	w0, w0
    a000d22c:	b9406fe1 	ldr	w1, [sp, #108]
    a000d230:	0a000020 	and	w0, w1, w0
    a000d234:	b9006fe0 	str	w0, [sp, #108]
		if (flags & IRQ_TYPE_EDGE) {
    a000d238:	b94017e0 	ldr	w0, [sp, #20]
    a000d23c:	927e0000 	and	x0, x0, #0x4
    a000d240:	f100001f 	cmp	x0, #0x0
    a000d244:	54000100 	b.eq	a000d264 <arm_gic_irq_set_priority+0x170>  // b.none
			val |= (GICD_ICFGR_TYPE << shift);
    a000d248:	b94057e0 	ldr	w0, [sp, #84]
    a000d24c:	d2800041 	mov	x1, #0x2                   	// #2
    a000d250:	9ac02020 	lsl	x0, x1, x0
    a000d254:	2a0003e1 	mov	w1, w0
    a000d258:	b9406fe0 	ldr	w0, [sp, #108]
    a000d25c:	2a010000 	orr	w0, w0, w1
    a000d260:	b9006fe0 	str	w0, [sp, #108]
		}
		sys_write32(val, ICFGR(base, idx));
    a000d264:	b94067e0 	ldr	w0, [sp, #100]
    a000d268:	531e7400 	lsl	w0, w0, #2
    a000d26c:	2a0003e1 	mov	w1, w0
    a000d270:	f9402fe0 	ldr	x0, [sp, #88]
    a000d274:	8b000020 	add	x0, x1, x0
    a000d278:	91300000 	add	x0, x0, #0xc00
    a000d27c:	b9406fe1 	ldr	w1, [sp, #108]
    a000d280:	b9002be1 	str	w1, [sp, #40]
    a000d284:	f90013e0 	str	x0, [sp, #32]
	__DMB();
    a000d288:	d5033fbf 	dmb	sy
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    a000d28c:	b9402be0 	ldr	w0, [sp, #40]
    a000d290:	f94013e1 	ldr	x1, [sp, #32]
    a000d294:	b9000020 	str	w0, [x1]
}
    a000d298:	d503201f 	nop
	}
}
    a000d29c:	d503201f 	nop
    a000d2a0:	a8c77bfd 	ldp	x29, x30, [sp], #112
    a000d2a4:	d65f03c0 	ret

00000000a000d2a8 <arm_gic_irq_enable>:

void arm_gic_irq_enable(unsigned int intid)
{
    a000d2a8:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a000d2ac:	910003fd 	mov	x29, sp
    a000d2b0:	f9000bf3 	str	x19, [sp, #16]
    a000d2b4:	b9002fe0 	str	w0, [sp, #44]
	if (intid >= 8192) {
		arm_gic_lpi_setup(intid, true);
		return;
	}
#endif
	uint32_t mask = BIT(intid & (GIC_NUM_INTR_PER_REG - 1));
    a000d2b8:	b9402fe0 	ldr	w0, [sp, #44]
    a000d2bc:	12001000 	and	w0, w0, #0x1f
    a000d2c0:	d2800021 	mov	x1, #0x1                   	// #1
    a000d2c4:	9ac02020 	lsl	x0, x1, x0
    a000d2c8:	b9005fe0 	str	w0, [sp, #92]
	uint32_t idx = intid / GIC_NUM_INTR_PER_REG;
    a000d2cc:	b9402fe0 	ldr	w0, [sp, #44]
    a000d2d0:	53057c00 	lsr	w0, w0, #5
    a000d2d4:	b9005be0 	str	w0, [sp, #88]

	sys_write32(mask, ISENABLER(GET_DIST_BASE(intid), idx));
    a000d2d8:	b9402fe0 	ldr	w0, [sp, #44]
    a000d2dc:	71007c1f 	cmp	w0, #0x1f
    a000d2e0:	540000e8 	b.hi	a000d2fc <arm_gic_irq_enable+0x54>  // b.pmore
    a000d2e4:	97ffff58 	bl	a000d044 <gic_get_rdist>
    a000d2e8:	aa0003e1 	mov	x1, x0
    a000d2ec:	d2802000 	mov	x0, #0x100                 	// #256
    a000d2f0:	f2a00020 	movk	x0, #0x1, lsl #16
    a000d2f4:	8b000020 	add	x0, x1, x0
    a000d2f8:	14000003 	b	a000d304 <arm_gic_irq_enable+0x5c>
    a000d2fc:	d2802000 	mov	x0, #0x100                 	// #256
    a000d300:	f2a10000 	movk	x0, #0x800, lsl #16
    a000d304:	b9405be1 	ldr	w1, [sp, #88]
    a000d308:	531e7421 	lsl	w1, w1, #2
    a000d30c:	2a0103e1 	mov	w1, w1
    a000d310:	8b010000 	add	x0, x0, x1
    a000d314:	b9405fe1 	ldr	w1, [sp, #92]
    a000d318:	b9004fe1 	str	w1, [sp, #76]
    a000d31c:	f90023e0 	str	x0, [sp, #64]
	__DMB();
    a000d320:	d5033fbf 	dmb	sy
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    a000d324:	b9404fe0 	ldr	w0, [sp, #76]
    a000d328:	f94023e1 	ldr	x1, [sp, #64]
    a000d32c:	b9000020 	str	w0, [x1]
}
    a000d330:	d503201f 	nop
	/*
	 * Affinity routing is enabled for Non-secure state (GICD_CTLR.ARE_NS
	 * is set to '1' when GIC distributor is initialized) ,so need to set
	 * SPI's affinity, now set it to be the PE on which it is enabled.
	 */
	if (GIC_IS_SPI(intid))
    a000d334:	b9402fe0 	ldr	w0, [sp, #44]
    a000d338:	71007c1f 	cmp	w0, #0x1f
    a000d33c:	54000369 	b.ls	a000d3a8 <arm_gic_irq_enable+0x100>  // b.plast
    a000d340:	b9402fe0 	ldr	w0, [sp, #44]
    a000d344:	710fec1f 	cmp	w0, #0x3fb
    a000d348:	54000308 	b.hi	a000d3a8 <arm_gic_irq_enable+0x100>  // b.pmore
		sys_write64(MPIDR_TO_CORE(GET_MPIDR()),
    a000d34c:	d53800a0 	mrs	x0, mpidr_el1
    a000d350:	f9002be0 	str	x0, [sp, #80]
    a000d354:	f9402be0 	ldr	x0, [sp, #80]
    a000d358:	92401c13 	and	x19, x0, #0xff
				IROUTER(GET_DIST_BASE(intid), intid));
    a000d35c:	b9402fe0 	ldr	w0, [sp, #44]
    a000d360:	71007c1f 	cmp	w0, #0x1f
    a000d364:	54000088 	b.hi	a000d374 <arm_gic_irq_enable+0xcc>  // b.pmore
    a000d368:	97ffff37 	bl	a000d044 <gic_get_rdist>
    a000d36c:	91405800 	add	x0, x0, #0x16, lsl #12
    a000d370:	14000003 	b	a000d37c <arm_gic_irq_enable+0xd4>
    a000d374:	d28c0000 	mov	x0, #0x6000                	// #24576
    a000d378:	f2a10000 	movk	x0, #0x800, lsl #16
    a000d37c:	b9402fe1 	ldr	w1, [sp, #44]
    a000d380:	531d7021 	lsl	w1, w1, #3
    a000d384:	2a0103e1 	mov	w1, w1
		sys_write64(MPIDR_TO_CORE(GET_MPIDR()),
    a000d388:	8b010000 	add	x0, x0, x1
    a000d38c:	f9001ff3 	str	x19, [sp, #56]
    a000d390:	f9001be0 	str	x0, [sp, #48]
	return val;
}

static ALWAYS_INLINE void sys_write64(uint64_t data, mem_addr_t addr)
{
	__DMB();
    a000d394:	d5033fbf 	dmb	sy
	__asm__ volatile("str %x0, [%1]" : : "r" (data), "r" (addr));
    a000d398:	f9401fe0 	ldr	x0, [sp, #56]
    a000d39c:	f9401be1 	ldr	x1, [sp, #48]
    a000d3a0:	f9000020 	str	x0, [x1]
}
    a000d3a4:	d503201f 	nop
#endif
}
    a000d3a8:	d503201f 	nop
    a000d3ac:	f9400bf3 	ldr	x19, [sp, #16]
    a000d3b0:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a000d3b4:	d65f03c0 	ret

00000000a000d3b8 <arm_gic_get_active>:

	return (val & mask) != 0;
}

unsigned int arm_gic_get_active(void)
{
    a000d3b8:	d10043ff 	sub	sp, sp, #0x10
	int intid;

	/* (Pending -> Active / AP) or (AP -> AP) */
	intid = read_sysreg(ICC_IAR1_EL1);
    a000d3bc:	d538cc00 	mrs	x0, s3_0_c12_c12_0
    a000d3c0:	f90007e0 	str	x0, [sp, #8]
    a000d3c4:	f94007e0 	ldr	x0, [sp, #8]
    a000d3c8:	b90007e0 	str	w0, [sp, #4]

	return intid;
    a000d3cc:	b94007e0 	ldr	w0, [sp, #4]
}
    a000d3d0:	910043ff 	add	sp, sp, #0x10
    a000d3d4:	d65f03c0 	ret

00000000a000d3d8 <arm_gic_eoi>:

void arm_gic_eoi(unsigned int intid)
{
    a000d3d8:	d10043ff 	sub	sp, sp, #0x10
    a000d3dc:	b9000fe0 	str	w0, [sp, #12]
	 * Since ICC interface writes are not ordered against Device
	 * memory writes, a barrier is required to ensure the ordering.
	 * The dsb will also ensure *completion* of previous writes with
	 * DEVICE nGnRnE attribute.
	 */
	__DSB();
    a000d3e0:	d5033f9f 	dsb	sy

	/* (AP -> Pending) Or (Active -> Inactive) or (AP to AP) nested case */
	write_sysreg(intid, ICC_EOIR1_EL1);
    a000d3e4:	b9400fe0 	ldr	w0, [sp, #12]
    a000d3e8:	d518cc20 	msr	s3_0_c12_c12_1, x0
}
    a000d3ec:	d503201f 	nop
    a000d3f0:	910043ff 	add	sp, sp, #0x10
    a000d3f4:	d65f03c0 	ret

00000000a000d3f8 <gicv3_rdist_enable>:
 * clear ProcessorSleep and wait till ChildAsleep is cleared.
 * ProcessSleep to be cleared only when ChildAsleep is set
 * Check if redistributor is not powered already.
 */
static void gicv3_rdist_enable(mem_addr_t rdist)
{
    a000d3f8:	d10103ff 	sub	sp, sp, #0x40
    a000d3fc:	f90007e0 	str	x0, [sp, #8]
	if (!(sys_read32(rdist + GICR_WAKER) & BIT(GICR_WAKER_CA)))
    a000d400:	f94007e0 	ldr	x0, [sp, #8]
    a000d404:	91005000 	add	x0, x0, #0x14
    a000d408:	f9001fe0 	str	x0, [sp, #56]
	__asm__ volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    a000d40c:	f9401fe0 	ldr	x0, [sp, #56]
    a000d410:	b9400000 	ldr	w0, [x0]
    a000d414:	b90037e0 	str	w0, [sp, #52]
	__DMB();
    a000d418:	d5033fbf 	dmb	sy
	return val;
    a000d41c:	b94037e0 	ldr	w0, [sp, #52]
    a000d420:	2a0003e0 	mov	w0, w0
    a000d424:	927e0000 	and	x0, x0, #0x4
    a000d428:	f100001f 	cmp	x0, #0x0
    a000d42c:	54000420 	b.eq	a000d4b0 <gicv3_rdist_enable+0xb8>  // b.none
		return;

	sys_clear_bit(rdist + GICR_WAKER, GICR_WAKER_PS);
    a000d430:	f94007e0 	ldr	x0, [sp, #8]
    a000d434:	91005000 	add	x0, x0, #0x14
    a000d438:	f90017e0 	str	x0, [sp, #40]
    a000d43c:	52800020 	mov	w0, #0x1                   	// #1
    a000d440:	b90027e0 	str	w0, [sp, #36]
	*(volatile uint32_t *)addr = temp | (1 << bit);
}

static ALWAYS_INLINE void sys_clear_bit(mem_addr_t addr, unsigned int bit)
{
	uint32_t temp = *(volatile uint32_t *)addr;
    a000d444:	f94017e0 	ldr	x0, [sp, #40]
    a000d448:	b9400000 	ldr	w0, [x0]
    a000d44c:	b90023e0 	str	w0, [sp, #32]

	*(volatile uint32_t *)addr = temp & ~(1 << bit);
    a000d450:	b94027e0 	ldr	w0, [sp, #36]
    a000d454:	52800021 	mov	w1, #0x1                   	// #1
    a000d458:	1ac02020 	lsl	w0, w1, w0
    a000d45c:	2a2003e0 	mvn	w0, w0
    a000d460:	2a0003e2 	mov	w2, w0
    a000d464:	f94017e0 	ldr	x0, [sp, #40]
    a000d468:	b94023e1 	ldr	w1, [sp, #32]
    a000d46c:	0a010041 	and	w1, w2, w1
    a000d470:	b9000001 	str	w1, [x0]
}
    a000d474:	d503201f 	nop
	while (sys_read32(rdist + GICR_WAKER) & BIT(GICR_WAKER_CA))
    a000d478:	d503201f 	nop
    a000d47c:	f94007e0 	ldr	x0, [sp, #8]
    a000d480:	91005000 	add	x0, x0, #0x14
    a000d484:	f9000fe0 	str	x0, [sp, #24]
	__asm__ volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    a000d488:	f9400fe0 	ldr	x0, [sp, #24]
    a000d48c:	b9400000 	ldr	w0, [x0]
    a000d490:	b90017e0 	str	w0, [sp, #20]
	__DMB();
    a000d494:	d5033fbf 	dmb	sy
	return val;
    a000d498:	b94017e0 	ldr	w0, [sp, #20]
    a000d49c:	2a0003e0 	mov	w0, w0
    a000d4a0:	927e0000 	and	x0, x0, #0x4
    a000d4a4:	f100001f 	cmp	x0, #0x0
    a000d4a8:	54fffea1 	b.ne	a000d47c <gicv3_rdist_enable+0x84>  // b.any
    a000d4ac:	14000002 	b	a000d4b4 <gicv3_rdist_enable+0xbc>
		return;
    a000d4b0:	d503201f 	nop
		;
}
    a000d4b4:	910103ff 	add	sp, sp, #0x40
    a000d4b8:	d65f03c0 	ret

00000000a000d4bc <gicv3_cpuif_init>:

/*
 * Initialize the cpu interface. This should be called by each core.
 */
static void gicv3_cpuif_init(void)
{
    a000d4bc:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
    a000d4c0:	910003fd 	mov	x29, sp
	uint32_t icc_sre;
	uint32_t intid;

	mem_addr_t base = gic_get_rdist() + GICR_SGI_BASE_OFF;
    a000d4c4:	97fffee0 	bl	a000d044 <gic_get_rdist>
    a000d4c8:	91404000 	add	x0, x0, #0x10, lsl #12
    a000d4cc:	f9004be0 	str	x0, [sp, #144]

	/* Disable all sgi ppi */
	sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG), ICENABLER(base, 0));
    a000d4d0:	f9404be0 	ldr	x0, [sp, #144]
    a000d4d4:	91060000 	add	x0, x0, #0x180
    a000d4d8:	12800001 	mov	w1, #0xffffffff            	// #-1
    a000d4dc:	b90047e1 	str	w1, [sp, #68]
    a000d4e0:	f9001fe0 	str	x0, [sp, #56]
	__DMB();
    a000d4e4:	d5033fbf 	dmb	sy
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    a000d4e8:	b94047e0 	ldr	w0, [sp, #68]
    a000d4ec:	f9401fe1 	ldr	x1, [sp, #56]
    a000d4f0:	b9000020 	str	w0, [x1]
}
    a000d4f4:	d503201f 	nop
	/* Any sgi/ppi intid ie. 0-31 will select GICR_CTRL */
	gic_wait_rwp(0);
    a000d4f8:	52800000 	mov	w0, #0x0                   	// #0
    a000d4fc:	97fffee0 	bl	a000d07c <gic_wait_rwp>

	/* Clear pending */
	sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG), ICPENDR(base, 0));
    a000d500:	f9404be0 	ldr	x0, [sp, #144]
    a000d504:	910a0000 	add	x0, x0, #0x280
    a000d508:	12800001 	mov	w1, #0xffffffff            	// #-1
    a000d50c:	b90057e1 	str	w1, [sp, #84]
    a000d510:	f90027e0 	str	x0, [sp, #72]
	__DMB();
    a000d514:	d5033fbf 	dmb	sy
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    a000d518:	b94057e0 	ldr	w0, [sp, #84]
    a000d51c:	f94027e1 	ldr	x1, [sp, #72]
    a000d520:	b9000020 	str	w0, [x1]
}
    a000d524:	d503201f 	nop

	/* Configure all SGIs/PPIs as G1S or G1NS depending on Zephyr
	 * is run in EL1S or EL1NS respectively.
	 * All interrupts will be delivered as irq
	 */
	sys_write32(IGROUPR_VAL, IGROUPR(base, 0));
    a000d528:	f9404be0 	ldr	x0, [sp, #144]
    a000d52c:	91020000 	add	x0, x0, #0x80
    a000d530:	12800001 	mov	w1, #0xffffffff            	// #-1
    a000d534:	b90067e1 	str	w1, [sp, #100]
    a000d538:	f9002fe0 	str	x0, [sp, #88]
	__DMB();
    a000d53c:	d5033fbf 	dmb	sy
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    a000d540:	b94067e0 	ldr	w0, [sp, #100]
    a000d544:	f9402fe1 	ldr	x1, [sp, #88]
    a000d548:	b9000020 	str	w0, [x1]
}
    a000d54c:	d503201f 	nop
	sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG), IGROUPMODR(base, 0));
    a000d550:	f9404be0 	ldr	x0, [sp, #144]
    a000d554:	91340000 	add	x0, x0, #0xd00
    a000d558:	12800001 	mov	w1, #0xffffffff            	// #-1
    a000d55c:	b90077e1 	str	w1, [sp, #116]
    a000d560:	f90037e0 	str	x0, [sp, #104]
	__DMB();
    a000d564:	d5033fbf 	dmb	sy
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    a000d568:	b94077e0 	ldr	w0, [sp, #116]
    a000d56c:	f94037e1 	ldr	x1, [sp, #104]
    a000d570:	b9000020 	str	w0, [x1]
}
    a000d574:	d503201f 	nop

	/*
	 * Configure default priorities for SGI 0:15 and PPI 0:15.
	 */
	for (intid = 0; intid < GIC_SPI_INT_BASE;
    a000d578:	b9009fff 	str	wzr, [sp, #156]
    a000d57c:	14000011 	b	a000d5c0 <gicv3_cpuif_init+0x104>
	     intid += GIC_NUM_PRI_PER_REG) {
		sys_write32(GIC_INT_DEF_PRI_X4, IPRIORITYR(base, intid));
    a000d580:	b9409fe1 	ldr	w1, [sp, #156]
    a000d584:	f9404be0 	ldr	x0, [sp, #144]
    a000d588:	8b000020 	add	x0, x1, x0
    a000d58c:	91100000 	add	x0, x0, #0x400
    a000d590:	52941401 	mov	w1, #0xa0a0                	// #41120
    a000d594:	72b41401 	movk	w1, #0xa0a0, lsl #16
    a000d598:	b90037e1 	str	w1, [sp, #52]
    a000d59c:	f90017e0 	str	x0, [sp, #40]
	__DMB();
    a000d5a0:	d5033fbf 	dmb	sy
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    a000d5a4:	b94037e0 	ldr	w0, [sp, #52]
    a000d5a8:	f94017e1 	ldr	x1, [sp, #40]
    a000d5ac:	b9000020 	str	w0, [x1]
}
    a000d5b0:	d503201f 	nop
	     intid += GIC_NUM_PRI_PER_REG) {
    a000d5b4:	b9409fe0 	ldr	w0, [sp, #156]
    a000d5b8:	11001000 	add	w0, w0, #0x4
    a000d5bc:	b9009fe0 	str	w0, [sp, #156]
	for (intid = 0; intid < GIC_SPI_INT_BASE;
    a000d5c0:	b9409fe0 	ldr	w0, [sp, #156]
    a000d5c4:	71007c1f 	cmp	w0, #0x1f
    a000d5c8:	54fffdc9 	b.ls	a000d580 <gicv3_cpuif_init+0xc4>  // b.plast
	}

	/* Configure PPIs as level triggered */
	sys_write32(0, ICFGR(base, 1));
    a000d5cc:	f9404be0 	ldr	x0, [sp, #144]
    a000d5d0:	91301000 	add	x0, x0, #0xc04
    a000d5d4:	b90027ff 	str	wzr, [sp, #36]
    a000d5d8:	f9000fe0 	str	x0, [sp, #24]
	__DMB();
    a000d5dc:	d5033fbf 	dmb	sy
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    a000d5e0:	b94027e0 	ldr	w0, [sp, #36]
    a000d5e4:	f9400fe1 	ldr	x1, [sp, #24]
    a000d5e8:	b9000020 	str	w0, [x1]
}
    a000d5ec:	d503201f 	nop
	 * Check if system interface can be enabled.
	 * 'icc_sre_el3' needs to be configured at 'EL3'
	 * to allow access to 'icc_sre_el1' at 'EL1'
	 * eg: z_arch_el3_plat_init can be used by platform.
	 */
	icc_sre = read_sysreg(ICC_SRE_EL1);
    a000d5f0:	d538cca0 	mrs	x0, s3_0_c12_c12_5
    a000d5f4:	f90047e0 	str	x0, [sp, #136]
    a000d5f8:	f94047e0 	ldr	x0, [sp, #136]
    a000d5fc:	b90087e0 	str	w0, [sp, #132]

	if (!(icc_sre & ICC_SRE_ELx_SRE_BIT)) {
    a000d600:	b94087e0 	ldr	w0, [sp, #132]
    a000d604:	92400000 	and	x0, x0, #0x1
    a000d608:	f100001f 	cmp	x0, #0x0
    a000d60c:	54000141 	b.ne	a000d634 <gicv3_cpuif_init+0x178>  // b.any
		icc_sre = (icc_sre | ICC_SRE_ELx_SRE_BIT |
    a000d610:	b94087e0 	ldr	w0, [sp, #132]
    a000d614:	32000800 	orr	w0, w0, #0x7
    a000d618:	b90087e0 	str	w0, [sp, #132]
			   ICC_SRE_ELx_DIB_BIT | ICC_SRE_ELx_DFB_BIT);
		write_sysreg(icc_sre, ICC_SRE_EL1);
    a000d61c:	b94087e0 	ldr	w0, [sp, #132]
    a000d620:	d518cca0 	msr	s3_0_c12_c12_5, x0
		icc_sre = read_sysreg(ICC_SRE_EL1);
    a000d624:	d538cca0 	mrs	x0, s3_0_c12_c12_5
    a000d628:	f9003fe0 	str	x0, [sp, #120]
    a000d62c:	f9403fe0 	ldr	x0, [sp, #120]
    a000d630:	b90087e0 	str	w0, [sp, #132]

		__ASSERT_NO_MSG(icc_sre & ICC_SRE_ELx_SRE_BIT);
	}

	write_sysreg(GIC_IDLE_PRIO, ICC_PMR_EL1);
    a000d634:	52801fe0 	mov	w0, #0xff                  	// #255
    a000d638:	d5184600 	msr	s3_0_c4_c6_0, x0

	/* Allow group1 interrupts */
	write_sysreg(1, ICC_IGRPEN1_EL1);
    a000d63c:	52800020 	mov	w0, #0x1                   	// #1
    a000d640:	d518cce0 	msr	s3_0_c12_c12_7, x0
}
    a000d644:	d503201f 	nop
    a000d648:	a8ca7bfd 	ldp	x29, x30, [sp], #160
    a000d64c:	d65f03c0 	ret

00000000a000d650 <gicv3_dist_init>:

/*
 * TODO: Consider Zephyr in EL1NS.
 */
static void gicv3_dist_init(void)
{
    a000d650:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
    a000d654:	910003fd 	mov	x29, sp
	unsigned int num_ints;
	unsigned int intid;
	unsigned int idx;
	mem_addr_t base = GIC_DIST_BASE;
    a000d658:	d2a10000 	mov	x0, #0x8000000             	// #134217728
    a000d65c:	f90053e0 	str	x0, [sp, #160]
    a000d660:	d2800080 	mov	x0, #0x4                   	// #4
    a000d664:	f2a10000 	movk	x0, #0x800, lsl #16
    a000d668:	f90043e0 	str	x0, [sp, #128]
	__asm__ volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    a000d66c:	f94043e0 	ldr	x0, [sp, #128]
    a000d670:	b9400000 	ldr	w0, [x0]
    a000d674:	b9007fe0 	str	w0, [sp, #124]
	__DMB();
    a000d678:	d5033fbf 	dmb	sy
	return val;
    a000d67c:	b9407fe0 	ldr	w0, [sp, #124]

	num_ints = sys_read32(GICD_TYPER);
    a000d680:	b9009fe0 	str	w0, [sp, #156]
	num_ints &= GICD_TYPER_ITLINESNUM_MASK;
    a000d684:	b9409fe0 	ldr	w0, [sp, #156]
    a000d688:	12001000 	and	w0, w0, #0x1f
    a000d68c:	b9009fe0 	str	w0, [sp, #156]
	num_ints = (num_ints + 1) << 5;
    a000d690:	b9409fe0 	ldr	w0, [sp, #156]
    a000d694:	11000400 	add	w0, w0, #0x1
    a000d698:	531b6800 	lsl	w0, w0, #5
    a000d69c:	b9009fe0 	str	w0, [sp, #156]
    a000d6a0:	b90097ff 	str	wzr, [sp, #148]
    a000d6a4:	d2a10000 	mov	x0, #0x8000000             	// #134217728
    a000d6a8:	f90047e0 	str	x0, [sp, #136]
	__DMB();
    a000d6ac:	d5033fbf 	dmb	sy
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    a000d6b0:	b94097e0 	ldr	w0, [sp, #148]
    a000d6b4:	f94047e1 	ldr	x1, [sp, #136]
    a000d6b8:	b9000020 	str	w0, [x1]
}
    a000d6bc:	d503201f 	nop

	/* Disable the distributor */
	sys_write32(0, GICD_CTLR);
	gic_wait_rwp(GIC_SPI_INT_BASE);
    a000d6c0:	52800400 	mov	w0, #0x20                  	// #32
    a000d6c4:	97fffe6e 	bl	a000d07c <gic_wait_rwp>
#endif

	/*
	 * Default configuration of all SPIs
	 */
	for (intid = GIC_SPI_INT_BASE; intid < num_ints;
    a000d6c8:	52800400 	mov	w0, #0x20                  	// #32
    a000d6cc:	b900afe0 	str	w0, [sp, #172]
    a000d6d0:	1400003f 	b	a000d7cc <gicv3_dist_init+0x17c>
	     intid += GIC_NUM_INTR_PER_REG) {
		idx = intid / GIC_NUM_INTR_PER_REG;
    a000d6d4:	b940afe0 	ldr	w0, [sp, #172]
    a000d6d8:	53057c00 	lsr	w0, w0, #5
    a000d6dc:	b9009be0 	str	w0, [sp, #152]
		/* Disable interrupt */
		sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG),
			    ICENABLER(base, idx));
    a000d6e0:	b9409be0 	ldr	w0, [sp, #152]
    a000d6e4:	531e7400 	lsl	w0, w0, #2
    a000d6e8:	2a0003e1 	mov	w1, w0
    a000d6ec:	f94053e0 	ldr	x0, [sp, #160]
    a000d6f0:	8b000020 	add	x0, x1, x0
		sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG),
    a000d6f4:	91060000 	add	x0, x0, #0x180
    a000d6f8:	12800001 	mov	w1, #0xffffffff            	// #-1
    a000d6fc:	b9004fe1 	str	w1, [sp, #76]
    a000d700:	f90023e0 	str	x0, [sp, #64]
	__DMB();
    a000d704:	d5033fbf 	dmb	sy
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    a000d708:	b9404fe0 	ldr	w0, [sp, #76]
    a000d70c:	f94023e1 	ldr	x1, [sp, #64]
    a000d710:	b9000020 	str	w0, [x1]
}
    a000d714:	d503201f 	nop
		/* Clear pending */
		sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG),
			    ICPENDR(base, idx));
    a000d718:	b9409be0 	ldr	w0, [sp, #152]
    a000d71c:	531e7400 	lsl	w0, w0, #2
    a000d720:	2a0003e1 	mov	w1, w0
    a000d724:	f94053e0 	ldr	x0, [sp, #160]
    a000d728:	8b000020 	add	x0, x1, x0
		sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG),
    a000d72c:	910a0000 	add	x0, x0, #0x280
    a000d730:	12800001 	mov	w1, #0xffffffff            	// #-1
    a000d734:	b9005fe1 	str	w1, [sp, #92]
    a000d738:	f9002be0 	str	x0, [sp, #80]
	__DMB();
    a000d73c:	d5033fbf 	dmb	sy
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    a000d740:	b9405fe0 	ldr	w0, [sp, #92]
    a000d744:	f9402be1 	ldr	x1, [sp, #80]
    a000d748:	b9000020 	str	w0, [x1]
}
    a000d74c:	d503201f 	nop
		sys_write32(IGROUPR_VAL, IGROUPR(base, idx));
    a000d750:	b9409be0 	ldr	w0, [sp, #152]
    a000d754:	531e7400 	lsl	w0, w0, #2
    a000d758:	2a0003e1 	mov	w1, w0
    a000d75c:	f94053e0 	ldr	x0, [sp, #160]
    a000d760:	8b000020 	add	x0, x1, x0
    a000d764:	91020000 	add	x0, x0, #0x80
    a000d768:	12800001 	mov	w1, #0xffffffff            	// #-1
    a000d76c:	b9006fe1 	str	w1, [sp, #108]
    a000d770:	f90033e0 	str	x0, [sp, #96]
	__DMB();
    a000d774:	d5033fbf 	dmb	sy
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    a000d778:	b9406fe0 	ldr	w0, [sp, #108]
    a000d77c:	f94033e1 	ldr	x1, [sp, #96]
    a000d780:	b9000020 	str	w0, [x1]
}
    a000d784:	d503201f 	nop
		sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG),
			    IGROUPMODR(base, idx));
    a000d788:	b9409be0 	ldr	w0, [sp, #152]
    a000d78c:	531e7400 	lsl	w0, w0, #2
    a000d790:	2a0003e1 	mov	w1, w0
    a000d794:	f94053e0 	ldr	x0, [sp, #160]
    a000d798:	8b000020 	add	x0, x1, x0
		sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG),
    a000d79c:	91340000 	add	x0, x0, #0xd00
    a000d7a0:	12800001 	mov	w1, #0xffffffff            	// #-1
    a000d7a4:	b9007be1 	str	w1, [sp, #120]
    a000d7a8:	f9003be0 	str	x0, [sp, #112]
	__DMB();
    a000d7ac:	d5033fbf 	dmb	sy
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    a000d7b0:	b9407be0 	ldr	w0, [sp, #120]
    a000d7b4:	f9403be1 	ldr	x1, [sp, #112]
    a000d7b8:	b9000020 	str	w0, [x1]
}
    a000d7bc:	d503201f 	nop
	     intid += GIC_NUM_INTR_PER_REG) {
    a000d7c0:	b940afe0 	ldr	w0, [sp, #172]
    a000d7c4:	11008000 	add	w0, w0, #0x20
    a000d7c8:	b900afe0 	str	w0, [sp, #172]
	for (intid = GIC_SPI_INT_BASE; intid < num_ints;
    a000d7cc:	b940afe1 	ldr	w1, [sp, #172]
    a000d7d0:	b9409fe0 	ldr	w0, [sp, #156]
    a000d7d4:	6b00003f 	cmp	w1, w0
    a000d7d8:	54fff7e3 	b.cc	a000d6d4 <gicv3_dist_init+0x84>  // b.lo, b.ul, b.last

	}
	/* wait for rwp on GICD */
	gic_wait_rwp(GIC_SPI_INT_BASE);
    a000d7dc:	52800400 	mov	w0, #0x20                  	// #32
    a000d7e0:	97fffe27 	bl	a000d07c <gic_wait_rwp>

	/* Configure default priorities for all SPIs. */
	for (intid = GIC_SPI_INT_BASE; intid < num_ints;
    a000d7e4:	52800400 	mov	w0, #0x20                  	// #32
    a000d7e8:	b900afe0 	str	w0, [sp, #172]
    a000d7ec:	14000011 	b	a000d830 <gicv3_dist_init+0x1e0>
	     intid += GIC_NUM_PRI_PER_REG) {
		sys_write32(GIC_INT_DEF_PRI_X4, IPRIORITYR(base, intid));
    a000d7f0:	b940afe1 	ldr	w1, [sp, #172]
    a000d7f4:	f94053e0 	ldr	x0, [sp, #160]
    a000d7f8:	8b000020 	add	x0, x1, x0
    a000d7fc:	91100000 	add	x0, x0, #0x400
    a000d800:	52941401 	mov	w1, #0xa0a0                	// #41120
    a000d804:	72b41401 	movk	w1, #0xa0a0, lsl #16
    a000d808:	b9003fe1 	str	w1, [sp, #60]
    a000d80c:	f9001be0 	str	x0, [sp, #48]
	__DMB();
    a000d810:	d5033fbf 	dmb	sy
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    a000d814:	b9403fe0 	ldr	w0, [sp, #60]
    a000d818:	f9401be1 	ldr	x1, [sp, #48]
    a000d81c:	b9000020 	str	w0, [x1]
}
    a000d820:	d503201f 	nop
	     intid += GIC_NUM_PRI_PER_REG) {
    a000d824:	b940afe0 	ldr	w0, [sp, #172]
    a000d828:	11001000 	add	w0, w0, #0x4
    a000d82c:	b900afe0 	str	w0, [sp, #172]
	for (intid = GIC_SPI_INT_BASE; intid < num_ints;
    a000d830:	b940afe1 	ldr	w1, [sp, #172]
    a000d834:	b9409fe0 	ldr	w0, [sp, #156]
    a000d838:	6b00003f 	cmp	w1, w0
    a000d83c:	54fffda3 	b.cc	a000d7f0 <gicv3_dist_init+0x1a0>  // b.lo, b.ul, b.last
	}

	/* Configure all SPIs as active low, level triggered by default */
	for (intid = GIC_SPI_INT_BASE; intid < num_ints;
    a000d840:	52800400 	mov	w0, #0x20                  	// #32
    a000d844:	b900afe0 	str	w0, [sp, #172]
    a000d848:	14000014 	b	a000d898 <gicv3_dist_init+0x248>
	     intid += GIC_NUM_CFG_PER_REG) {
		idx = intid / GIC_NUM_CFG_PER_REG;
    a000d84c:	b940afe0 	ldr	w0, [sp, #172]
    a000d850:	53047c00 	lsr	w0, w0, #4
    a000d854:	b9009be0 	str	w0, [sp, #152]
		sys_write32(0, ICFGR(base, idx));
    a000d858:	b9409be0 	ldr	w0, [sp, #152]
    a000d85c:	531e7400 	lsl	w0, w0, #2
    a000d860:	2a0003e1 	mov	w1, w0
    a000d864:	f94053e0 	ldr	x0, [sp, #160]
    a000d868:	8b000020 	add	x0, x1, x0
    a000d86c:	91300000 	add	x0, x0, #0xc00
    a000d870:	b9002fff 	str	wzr, [sp, #44]
    a000d874:	f90013e0 	str	x0, [sp, #32]
	__DMB();
    a000d878:	d5033fbf 	dmb	sy
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    a000d87c:	b9402fe0 	ldr	w0, [sp, #44]
    a000d880:	f94013e1 	ldr	x1, [sp, #32]
    a000d884:	b9000020 	str	w0, [x1]
}
    a000d888:	d503201f 	nop
	     intid += GIC_NUM_CFG_PER_REG) {
    a000d88c:	b940afe0 	ldr	w0, [sp, #172]
    a000d890:	11004000 	add	w0, w0, #0x10
    a000d894:	b900afe0 	str	w0, [sp, #172]
	for (intid = GIC_SPI_INT_BASE; intid < num_ints;
    a000d898:	b940afe1 	ldr	w1, [sp, #172]
    a000d89c:	b9409fe0 	ldr	w0, [sp, #156]
    a000d8a0:	6b00003f 	cmp	w1, w0
    a000d8a4:	54fffd43 	b.cc	a000d84c <gicv3_dist_init+0x1fc>  // b.lo, b.ul, b.last
    a000d8a8:	52800440 	mov	w0, #0x22                  	// #34
    a000d8ac:	b9001fe0 	str	w0, [sp, #28]
    a000d8b0:	d2a10000 	mov	x0, #0x8000000             	// #134217728
    a000d8b4:	f9000be0 	str	x0, [sp, #16]
	__DMB();
    a000d8b8:	d5033fbf 	dmb	sy
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    a000d8bc:	b9401fe0 	ldr	w0, [sp, #28]
    a000d8c0:	f9400be1 	ldr	x1, [sp, #16]
    a000d8c4:	b9000020 	str	w0, [x1]
}
    a000d8c8:	d503201f 	nop
		    GICD_CTLR);
#else
	/* enable Group 1 secure interrupts */
	sys_set_bit(GICD_CTLR, GICD_CTLR_ENABLE_G1S);
#endif
}
    a000d8cc:	d503201f 	nop
    a000d8d0:	a8cb7bfd 	ldp	x29, x30, [sp], #176
    a000d8d4:	d65f03c0 	ret

00000000a000d8d8 <__arm_gic_init>:

static void __arm_gic_init(void)
{
    a000d8d8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a000d8dc:	910003fd 	mov	x29, sp
    a000d8e0:	d53bd060 	mrs	x0, tpidrro_el0
    a000d8e4:	f9000fe0 	str	x0, [sp, #24]
    a000d8e8:	f9400fe0 	ldr	x0, [sp, #24]
    a000d8ec:	d503201f 	nop
    a000d8f0:	927db000 	and	x0, x0, #0xfffffffffff8
	uint8_t cpu;

	cpu = arch_curr_cpu()->id;
    a000d8f4:	39409000 	ldrb	w0, [x0, #36]
    a000d8f8:	3900bfe0 	strb	w0, [sp, #47]
	gic_rdists[cpu] = GIC_RDIST_BASE + MPIDR_TO_CORE(GET_MPIDR()) * 0x20000;
    a000d8fc:	d53800a0 	mrs	x0, mpidr_el1
    a000d900:	f90013e0 	str	x0, [sp, #32]
    a000d904:	f94013e0 	ldr	x0, [sp, #32]
    a000d908:	92401c00 	and	x0, x0, #0xff
    a000d90c:	91101400 	add	x0, x0, #0x405
    a000d910:	3940bfe1 	ldrb	w1, [sp, #47]
    a000d914:	d36fb802 	lsl	x2, x0, #17
    a000d918:	d00001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000d91c:	913f2000 	add	x0, x0, #0xfc8
    a000d920:	93407c21 	sxtw	x1, w1
    a000d924:	f8217802 	str	x2, [x0, x1, lsl #3]
#ifdef CONFIG_GIC_V3_ITS
	/* Enable LPIs in Redistributor */
	gicv3_rdist_setup_lpis(gic_get_rdist());
#endif

	gicv3_rdist_enable(gic_get_rdist());
    a000d928:	97fffdc7 	bl	a000d044 <gic_get_rdist>
    a000d92c:	97fffeb3 	bl	a000d3f8 <gicv3_rdist_enable>

	gicv3_cpuif_init();
    a000d930:	97fffee3 	bl	a000d4bc <gicv3_cpuif_init>
}
    a000d934:	d503201f 	nop
    a000d938:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a000d93c:	d65f03c0 	ret

00000000a000d940 <arm_gic_init>:

int arm_gic_init(const struct device *unused)
{
    a000d940:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a000d944:	910003fd 	mov	x29, sp
    a000d948:	f9000fe0 	str	x0, [sp, #24]
	ARG_UNUSED(unused);

	gicv3_dist_init();
    a000d94c:	97ffff41 	bl	a000d650 <gicv3_dist_init>

	__arm_gic_init();
    a000d950:	97ffffe2 	bl	a000d8d8 <__arm_gic_init>

	return 0;
    a000d954:	52800000 	mov	w0, #0x0                   	// #0
}
    a000d958:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a000d95c:	d65f03c0 	ret

00000000a000d960 <arch_syscall_invoke2>:
{
    a000d960:	d10083ff 	sub	sp, sp, #0x20
    a000d964:	f9000fe0 	str	x0, [sp, #24]
    a000d968:	f9000be1 	str	x1, [sp, #16]
    a000d96c:	f90007e2 	str	x2, [sp, #8]
	register uint64_t ret __asm__("x0") = arg1;
    a000d970:	f9400fe0 	ldr	x0, [sp, #24]
	register uint64_t r1 __asm__("x1") = arg2;
    a000d974:	f9400be1 	ldr	x1, [sp, #16]
	register uint64_t r8 __asm__("x8") = call_id;
    a000d978:	f94007e8 	ldr	x8, [sp, #8]
	__asm__ volatile("svc %[svid]\n"
    a000d97c:	d4000061 	svc	#0x3
}
    a000d980:	910083ff 	add	sp, sp, #0x20
    a000d984:	d65f03c0 	ret

00000000a000d988 <arch_syscall_invoke1>:
{
    a000d988:	d10043ff 	sub	sp, sp, #0x10
    a000d98c:	f90007e0 	str	x0, [sp, #8]
    a000d990:	f90003e1 	str	x1, [sp]
	register uint64_t ret __asm__("x0") = arg1;
    a000d994:	f94007e0 	ldr	x0, [sp, #8]
	register uint64_t r8 __asm__("x8") = call_id;
    a000d998:	f94003e8 	ldr	x8, [sp]
	__asm__ volatile("svc %[svid]\n"
    a000d99c:	d4000061 	svc	#0x3
}
    a000d9a0:	910043ff 	add	sp, sp, #0x10
    a000d9a4:	d65f03c0 	ret

00000000a000d9a8 <z_impl_device_is_ready>:
 * is passed as argument.
 */
__syscall bool device_is_ready(const struct device *dev);

static inline bool z_impl_device_is_ready(const struct device *dev)
{
    a000d9a8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a000d9ac:	910003fd 	mov	x29, sp
    a000d9b0:	f9000fe0 	str	x0, [sp, #24]
	return z_device_is_ready(dev);
    a000d9b4:	f9400fe0 	ldr	x0, [sp, #24]
    a000d9b8:	94000cc0 	bl	a0010cb8 <z_device_is_ready>
    a000d9bc:	12001c00 	and	w0, w0, #0xff
}
    a000d9c0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a000d9c4:	d65f03c0 	ret

00000000a000d9c8 <device_is_ready>:

extern bool z_impl_device_is_ready(const struct device * dev);

__pinned_func
static inline bool device_is_ready(const struct device * dev)
{
    a000d9c8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a000d9cc:	910003fd 	mov	x29, sp
    a000d9d0:	f9000fe0 	str	x0, [sp, #24]
	bool ret = false;
    a000d9d4:	3900bfff 	strb	wzr, [sp, #47]
	ret = false;
    a000d9d8:	3900bfff 	strb	wzr, [sp, #47]
	return ret;
    a000d9dc:	3940bfe0 	ldrb	w0, [sp, #47]
#ifdef CONFIG_USERSPACE
	if (z_syscall_trap()) {
    a000d9e0:	7100001f 	cmp	w0, #0x0
    a000d9e4:	54000120 	b.eq	a000da08 <device_is_ready+0x40>  // b.none
		/* coverity[OVERRUN] */
		return (bool) arch_syscall_invoke1(*(uintptr_t *)&dev, K_SYSCALL_DEVICE_IS_READY);
    a000d9e8:	910063e0 	add	x0, sp, #0x18
    a000d9ec:	f9400000 	ldr	x0, [x0]
    a000d9f0:	d2800601 	mov	x1, #0x30                  	// #48
    a000d9f4:	97ffffe5 	bl	a000d988 <arch_syscall_invoke1>
    a000d9f8:	f100001f 	cmp	x0, #0x0
    a000d9fc:	1a9f07e0 	cset	w0, ne  // ne = any
    a000da00:	12001c00 	and	w0, w0, #0xff
    a000da04:	14000004 	b	a000da14 <device_is_ready+0x4c>
	}
#endif
	compiler_barrier();
	return z_impl_device_is_ready(dev);
    a000da08:	f9400fe0 	ldr	x0, [sp, #24]
    a000da0c:	97ffffe7 	bl	a000d9a8 <z_impl_device_is_ready>
    a000da10:	12001c00 	and	w0, w0, #0xff
}
    a000da14:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a000da18:	d65f03c0 	ret

00000000a000da1c <z_impl_uart_poll_out>:
__syscall void uart_poll_out(const struct device *dev,
			     unsigned char out_char);

static inline void z_impl_uart_poll_out(const struct device *dev,
					unsigned char out_char)
{
    a000da1c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a000da20:	910003fd 	mov	x29, sp
    a000da24:	f9000fe0 	str	x0, [sp, #24]
    a000da28:	39005fe1 	strb	w1, [sp, #23]
	const struct uart_driver_api *api =
    a000da2c:	f9400fe0 	ldr	x0, [sp, #24]
    a000da30:	f9400800 	ldr	x0, [x0, #16]
    a000da34:	f90017e0 	str	x0, [sp, #40]
		(const struct uart_driver_api *)dev->api;

	api->poll_out(dev, out_char);
    a000da38:	f94017e0 	ldr	x0, [sp, #40]
    a000da3c:	f9400402 	ldr	x2, [x0, #8]
    a000da40:	39405fe1 	ldrb	w1, [sp, #23]
    a000da44:	f9400fe0 	ldr	x0, [sp, #24]
    a000da48:	d63f0040 	blr	x2
}
    a000da4c:	d503201f 	nop
    a000da50:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a000da54:	d65f03c0 	ret

00000000a000da58 <uart_poll_out>:

extern void z_impl_uart_poll_out(const struct device * dev, unsigned char out_char);

__pinned_func
static inline void uart_poll_out(const struct device * dev, unsigned char out_char)
{
    a000da58:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a000da5c:	910003fd 	mov	x29, sp
    a000da60:	f9000fe0 	str	x0, [sp, #24]
    a000da64:	39005fe1 	strb	w1, [sp, #23]
	bool ret = false;
    a000da68:	3900bfff 	strb	wzr, [sp, #47]
	ret = false;
    a000da6c:	3900bfff 	strb	wzr, [sp, #47]
	return ret;
    a000da70:	3940bfe0 	ldrb	w0, [sp, #47]
#ifdef CONFIG_USERSPACE
	if (z_syscall_trap()) {
    a000da74:	7100001f 	cmp	w0, #0x0
    a000da78:	54000140 	b.eq	a000daa0 <uart_poll_out+0x48>  // b.none
		/* coverity[OVERRUN] */
		arch_syscall_invoke2(*(uintptr_t *)&dev, *(uintptr_t *)&out_char, K_SYSCALL_UART_POLL_OUT);
    a000da7c:	910063e0 	add	x0, sp, #0x18
    a000da80:	f9400003 	ldr	x3, [x0]
    a000da84:	91005fe0 	add	x0, sp, #0x17
    a000da88:	f9400000 	ldr	x0, [x0]
    a000da8c:	d28026c2 	mov	x2, #0x136                 	// #310
    a000da90:	aa0003e1 	mov	x1, x0
    a000da94:	aa0303e0 	mov	x0, x3
    a000da98:	97ffffb2 	bl	a000d960 <arch_syscall_invoke2>
		return;
    a000da9c:	14000004 	b	a000daac <uart_poll_out+0x54>
	}
#endif
	compiler_barrier();
	z_impl_uart_poll_out(dev, out_char);
    a000daa0:	f9400fe0 	ldr	x0, [sp, #24]
    a000daa4:	39405fe1 	ldrb	w1, [sp, #23]
    a000daa8:	97ffffdd 	bl	a000da1c <z_impl_uart_poll_out>
}
    a000daac:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a000dab0:	d65f03c0 	ret

00000000a000dab4 <console_out>:
 *
 * @return The character passed as input.
 */

static int console_out(int c)
{
    a000dab4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a000dab8:	910003fd 	mov	x29, sp
    a000dabc:	b9001fe0 	str	w0, [sp, #28]
		return c;
	}

#endif  /* CONFIG_UART_CONSOLE_DEBUG_SERVER_HOOKS */

	if ('\n' == c) {
    a000dac0:	b9401fe0 	ldr	w0, [sp, #28]
    a000dac4:	7100281f 	cmp	w0, #0xa
    a000dac8:	540000c1 	b.ne	a000dae0 <console_out+0x2c>  // b.any
		uart_poll_out(uart_console_dev, '\r');
    a000dacc:	d00001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000dad0:	913f4000 	add	x0, x0, #0xfd0
    a000dad4:	f9400000 	ldr	x0, [x0]
    a000dad8:	528001a1 	mov	w1, #0xd                   	// #13
    a000dadc:	97ffffdf 	bl	a000da58 <uart_poll_out>
	}
	uart_poll_out(uart_console_dev, c);
    a000dae0:	d00001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000dae4:	913f4000 	add	x0, x0, #0xfd0
    a000dae8:	f9400000 	ldr	x0, [x0]
    a000daec:	b9401fe1 	ldr	w1, [sp, #28]
    a000daf0:	12001c21 	and	w1, w1, #0xff
    a000daf4:	97ffffd9 	bl	a000da58 <uart_poll_out>

	return c;
    a000daf8:	b9401fe0 	ldr	w0, [sp, #28]
}
    a000dafc:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a000db00:	d65f03c0 	ret

00000000a000db04 <uart_console_hook_install>:
/**
 * @brief Install printk/stdout hook for UART console output
 */

static void uart_console_hook_install(void)
{
    a000db04:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    a000db08:	910003fd 	mov	x29, sp
#if defined(CONFIG_STDOUT_CONSOLE)
	__stdout_hook_install(console_out);
    a000db0c:	90000000 	adrp	x0, a000d000 <usleep+0x10>
    a000db10:	912ad000 	add	x0, x0, #0xab4
    a000db14:	97fff95d 	bl	a000c088 <__stdout_hook_install>
#endif
#if defined(CONFIG_PRINTK)
	__printk_hook_install(console_out);
    a000db18:	90000000 	adrp	x0, a000d000 <usleep+0x10>
    a000db1c:	912ad000 	add	x0, x0, #0xab4
    a000db20:	97ffd70a 	bl	a0003748 <__printk_hook_install>
#endif
}
    a000db24:	d503201f 	nop
    a000db28:	a8c17bfd 	ldp	x29, x30, [sp], #16
    a000db2c:	d65f03c0 	ret

00000000a000db30 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(const struct device *arg)
{
    a000db30:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a000db34:	910003fd 	mov	x29, sp
    a000db38:	f9000fe0 	str	x0, [sp, #24]

	ARG_UNUSED(arg);

	/* Claim console device */
	uart_console_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
    a000db3c:	d00001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000db40:	913f4000 	add	x0, x0, #0xfd0
    a000db44:	d00000a1 	adrp	x1, a0023000 <__rodata_region_start>
    a000db48:	91024021 	add	x1, x1, #0x90
    a000db4c:	f9000001 	str	x1, [x0]
	if (!device_is_ready(uart_console_dev)) {
    a000db50:	d00001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000db54:	913f4000 	add	x0, x0, #0xfd0
    a000db58:	f9400000 	ldr	x0, [x0]
    a000db5c:	97ffff9b 	bl	a000d9c8 <device_is_ready>
    a000db60:	12001c00 	and	w0, w0, #0xff
    a000db64:	52000000 	eor	w0, w0, #0x1
    a000db68:	12001c00 	and	w0, w0, #0xff
    a000db6c:	7100001f 	cmp	w0, #0x0
    a000db70:	54000060 	b.eq	a000db7c <uart_console_init+0x4c>  // b.none
		return -ENODEV;
    a000db74:	12800240 	mov	w0, #0xffffffed            	// #-19
    a000db78:	14000003 	b	a000db84 <uart_console_init+0x54>
	}

	uart_console_hook_install();
    a000db7c:	97ffffe2 	bl	a000db04 <uart_console_hook_install>

	return 0;
    a000db80:	52800000 	mov	w0, #0x0                   	// #0
}
    a000db84:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a000db88:	d65f03c0 	ret

00000000a000db8c <z_impl_ivshmem_get_mem>:
__syscall size_t ivshmem_get_mem(const struct device *dev,
				 uintptr_t *memmap);

static inline size_t z_impl_ivshmem_get_mem(const struct device *dev,
					    uintptr_t *memmap)
{
    a000db8c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a000db90:	910003fd 	mov	x29, sp
    a000db94:	f9000fe0 	str	x0, [sp, #24]
    a000db98:	f9000be1 	str	x1, [sp, #16]
	const struct ivshmem_driver_api *api =
    a000db9c:	f9400fe0 	ldr	x0, [sp, #24]
    a000dba0:	f9400800 	ldr	x0, [x0, #16]
    a000dba4:	f90017e0 	str	x0, [sp, #40]
		(const struct ivshmem_driver_api *)dev->api;

	return api->get_mem(dev, memmap);
    a000dba8:	f94017e0 	ldr	x0, [sp, #40]
    a000dbac:	f9400002 	ldr	x2, [x0]
    a000dbb0:	f9400be1 	ldr	x1, [sp, #16]
    a000dbb4:	f9400fe0 	ldr	x0, [sp, #24]
    a000dbb8:	d63f0040 	blr	x2
}
    a000dbbc:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a000dbc0:	d65f03c0 	ret

00000000a000dbc4 <z_impl_ivshmem_get_id>:
 * @return our VM ID or 0 if we are not running on doorbell version
 */
__syscall uint32_t ivshmem_get_id(const struct device *dev);

static inline uint32_t z_impl_ivshmem_get_id(const struct device *dev)
{
    a000dbc4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a000dbc8:	910003fd 	mov	x29, sp
    a000dbcc:	f9000fe0 	str	x0, [sp, #24]
	const struct ivshmem_driver_api *api =
    a000dbd0:	f9400fe0 	ldr	x0, [sp, #24]
    a000dbd4:	f9400800 	ldr	x0, [x0, #16]
    a000dbd8:	f90017e0 	str	x0, [sp, #40]
		(const struct ivshmem_driver_api *)dev->api;

	return api->get_id(dev);
    a000dbdc:	f94017e0 	ldr	x0, [sp, #40]
    a000dbe0:	f9400401 	ldr	x1, [x0, #8]
    a000dbe4:	f9400fe0 	ldr	x0, [sp, #24]
    a000dbe8:	d63f0020 	blr	x1
}
    a000dbec:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a000dbf0:	d65f03c0 	ret

00000000a000dbf4 <z_impl_ivshmem_get_vectors>:
 * @return the number of available interrupt vectors
 */
__syscall uint16_t ivshmem_get_vectors(const struct device *dev);

static inline uint16_t z_impl_ivshmem_get_vectors(const struct device *dev)
{
    a000dbf4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a000dbf8:	910003fd 	mov	x29, sp
    a000dbfc:	f9000fe0 	str	x0, [sp, #24]
	const struct ivshmem_driver_api *api =
    a000dc00:	f9400fe0 	ldr	x0, [sp, #24]
    a000dc04:	f9400800 	ldr	x0, [x0, #16]
    a000dc08:	f90017e0 	str	x0, [sp, #40]
		(const struct ivshmem_driver_api *)dev->api;

	return api->get_vectors(dev);
    a000dc0c:	f94017e0 	ldr	x0, [sp, #40]
    a000dc10:	f9400801 	ldr	x1, [x0, #16]
    a000dc14:	f9400fe0 	ldr	x0, [sp, #24]
    a000dc18:	d63f0020 	blr	x1
    a000dc1c:	12003c00 	and	w0, w0, #0xffff
}
    a000dc20:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a000dc24:	d65f03c0 	ret

00000000a000dc28 <z_impl_ivshmem_int_peer>:
__syscall int ivshmem_int_peer(const struct device *dev,
			       uint32_t peer_id, uint16_t vector);

static inline int z_impl_ivshmem_int_peer(const struct device *dev,
					  uint32_t peer_id, uint16_t vector)
{
    a000dc28:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a000dc2c:	910003fd 	mov	x29, sp
    a000dc30:	f9000fe0 	str	x0, [sp, #24]
    a000dc34:	b90017e1 	str	w1, [sp, #20]
    a000dc38:	790027e2 	strh	w2, [sp, #18]
	const struct ivshmem_driver_api *api =
    a000dc3c:	f9400fe0 	ldr	x0, [sp, #24]
    a000dc40:	f9400800 	ldr	x0, [x0, #16]
    a000dc44:	f90017e0 	str	x0, [sp, #40]
		(const struct ivshmem_driver_api *)dev->api;

	return api->int_peer(dev, peer_id, vector);
    a000dc48:	f94017e0 	ldr	x0, [sp, #40]
    a000dc4c:	f9400c03 	ldr	x3, [x0, #24]
    a000dc50:	794027e2 	ldrh	w2, [sp, #18]
    a000dc54:	b94017e1 	ldr	w1, [sp, #20]
    a000dc58:	f9400fe0 	ldr	x0, [sp, #24]
    a000dc5c:	d63f0060 	blr	x3
}
    a000dc60:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a000dc64:	d65f03c0 	ret

00000000a000dc68 <z_impl_ivshmem_register_handler>:
				       uint16_t vector);

static inline int z_impl_ivshmem_register_handler(const struct device *dev,
						  struct k_poll_signal *signal,
						  uint16_t vector)
{
    a000dc68:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    a000dc6c:	910003fd 	mov	x29, sp
    a000dc70:	f90017e0 	str	x0, [sp, #40]
    a000dc74:	f90013e1 	str	x1, [sp, #32]
    a000dc78:	79003fe2 	strh	w2, [sp, #30]
	const struct ivshmem_driver_api *api =
    a000dc7c:	f94017e0 	ldr	x0, [sp, #40]
    a000dc80:	f9400800 	ldr	x0, [x0, #16]
    a000dc84:	f9001fe0 	str	x0, [sp, #56]
		(const struct ivshmem_driver_api *)dev->api;

	return api->register_handler(dev, signal, vector);
    a000dc88:	f9401fe0 	ldr	x0, [sp, #56]
    a000dc8c:	f9401003 	ldr	x3, [x0, #32]
    a000dc90:	79403fe2 	ldrh	w2, [sp, #30]
    a000dc94:	f94013e1 	ldr	x1, [sp, #32]
    a000dc98:	f94017e0 	ldr	x0, [sp, #40]
    a000dc9c:	d63f0060 	blr	x3
}
    a000dca0:	a8c47bfd 	ldp	x29, x30, [sp], #64
    a000dca4:	d65f03c0 	ret

00000000a000dca8 <z_obj_validation_check>:

static inline int z_obj_validation_check(struct z_object *ko,
					 const void *obj,
					 enum k_objects otype,
					 enum _obj_init_check init)
{
    a000dca8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    a000dcac:	910003fd 	mov	x29, sp
    a000dcb0:	f90017e0 	str	x0, [sp, #40]
    a000dcb4:	f90013e1 	str	x1, [sp, #32]
    a000dcb8:	b9001fe2 	str	w2, [sp, #28]
    a000dcbc:	b9001be3 	str	w3, [sp, #24]
	int ret;

	ret = z_object_validate(ko, otype, init);
    a000dcc0:	b9401be2 	ldr	w2, [sp, #24]
    a000dcc4:	b9401fe1 	ldr	w1, [sp, #28]
    a000dcc8:	f94017e0 	ldr	x0, [sp, #40]
    a000dccc:	94003d7e 	bl	a001d2c4 <z_object_validate>
    a000dcd0:	b9003fe0 	str	w0, [sp, #60]
	}
#else
	ARG_UNUSED(obj);
#endif

	return ret;
    a000dcd4:	b9403fe0 	ldr	w0, [sp, #60]
}
    a000dcd8:	a8c47bfd 	ldp	x29, x30, [sp], #64
    a000dcdc:	d65f03c0 	ret

00000000a000dce0 <z_vrfy_ivshmem_get_mem>:
#include <syscall_handler.h>
#include <string.h>

static inline size_t z_vrfy_ivshmem_get_mem(const struct device *dev,
					    uintptr_t *memmap)
{
    a000dce0:	d10c03ff 	sub	sp, sp, #0x300
    a000dce4:	a9007bfd 	stp	x29, x30, [sp]
    a000dce8:	910003fd 	mov	x29, sp
    a000dcec:	f9000fe0 	str	x0, [sp, #24]
    a000dcf0:	f9000be1 	str	x1, [sp, #16]
	Z_OOPS(Z_SYSCALL_DRIVER_IVSHMEM(dev, get_mem));
    a000dcf4:	f9400fe0 	ldr	x0, [sp, #24]
    a000dcf8:	94003b4c 	bl	a001ca28 <z_object_find>
    a000dcfc:	52800003 	mov	w3, #0x0                   	// #0
    a000dd00:	528006a2 	mov	w2, #0x35                  	// #53
    a000dd04:	f9400fe1 	ldr	x1, [sp, #24]
    a000dd08:	97ffffe8 	bl	a000dca8 <z_obj_validation_check>
    a000dd0c:	7100001f 	cmp	w0, #0x0
    a000dd10:	1a9f07e0 	cset	w0, ne  // ne = any
    a000dd14:	390bbbe0 	strb	w0, [sp, #750]
    a000dd18:	394bbbe0 	ldrb	w0, [sp, #750]
    a000dd1c:	7100001f 	cmp	w0, #0x0
    a000dd20:	394bbbe0 	ldrb	w0, [sp, #750]
    a000dd24:	7100001f 	cmp	w0, #0x0
    a000dd28:	540001c1 	b.ne	a000dd60 <z_vrfy_ivshmem_get_mem+0x80>  // b.any
    a000dd2c:	f9400fe0 	ldr	x0, [sp, #24]
    a000dd30:	f9400800 	ldr	x0, [x0, #16]
    a000dd34:	f9017be0 	str	x0, [sp, #752]
    a000dd38:	f9417be0 	ldr	x0, [sp, #752]
    a000dd3c:	f9400000 	ldr	x0, [x0]
    a000dd40:	f100001f 	cmp	x0, #0x0
    a000dd44:	1a9f17e0 	cset	w0, eq  // eq = none
    a000dd48:	390bbfe0 	strb	w0, [sp, #751]
    a000dd4c:	394bbfe0 	ldrb	w0, [sp, #751]
    a000dd50:	7100001f 	cmp	w0, #0x0
    a000dd54:	394bbfe0 	ldrb	w0, [sp, #751]
    a000dd58:	7100001f 	cmp	w0, #0x0
    a000dd5c:	540000c0 	b.eq	a000dd74 <z_vrfy_ivshmem_get_mem+0x94>  // b.none
    a000dd60:	d00001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000dd64:	913f8000 	add	x0, x0, #0xfe0
    a000dd68:	f9400800 	ldr	x0, [x0, #16]
    a000dd6c:	f9408400 	ldr	x0, [x0, #264]
    a000dd70:	97ffecfa 	bl	a0009158 <arch_syscall_oops>
	Z_OOPS(Z_SYSCALL_MEMORY_WRITE(memmap, sizeof(uintptr_t)));
    a000dd74:	52800022 	mov	w2, #0x1                   	// #1
    a000dd78:	d2800101 	mov	x1, #0x8                   	// #8
    a000dd7c:	f9400be0 	ldr	x0, [sp, #16]
    a000dd80:	97fff6bb 	bl	a000b86c <arch_buffer_validate>
    a000dd84:	7100001f 	cmp	w0, #0x0
    a000dd88:	1a9f07e0 	cset	w0, ne  // ne = any
    a000dd8c:	390bffe0 	strb	w0, [sp, #767]
    a000dd90:	394bffe0 	ldrb	w0, [sp, #767]
    a000dd94:	7100001f 	cmp	w0, #0x0
    a000dd98:	394bffe0 	ldrb	w0, [sp, #767]
    a000dd9c:	7100001f 	cmp	w0, #0x0
    a000dda0:	540000c0 	b.eq	a000ddb8 <z_vrfy_ivshmem_get_mem+0xd8>  // b.none
    a000dda4:	d00001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000dda8:	913f8000 	add	x0, x0, #0xfe0
    a000ddac:	f9400800 	ldr	x0, [x0, #16]
    a000ddb0:	f9408400 	ldr	x0, [x0, #264]
    a000ddb4:	97ffece9 	bl	a0009158 <arch_syscall_oops>

	return z_impl_ivshmem_get_mem(dev, memmap);
    a000ddb8:	f9400be1 	ldr	x1, [sp, #16]
    a000ddbc:	f9400fe0 	ldr	x0, [sp, #24]
    a000ddc0:	97ffff73 	bl	a000db8c <z_impl_ivshmem_get_mem>
}
    a000ddc4:	a9407bfd 	ldp	x29, x30, [sp]
    a000ddc8:	910c03ff 	add	sp, sp, #0x300
    a000ddcc:	d65f03c0 	ret

00000000a000ddd0 <z_mrsh_ivshmem_get_mem>:
#include <syscalls/ivshmem.h>

extern size_t z_vrfy_ivshmem_get_mem(const struct device * dev, uintptr_t * memmap);
uintptr_t z_mrsh_ivshmem_get_mem(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a000ddd0:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a000ddd4:	910003fd 	mov	x29, sp
    a000ddd8:	f90027e0 	str	x0, [sp, #72]
    a000dddc:	f90023e1 	str	x1, [sp, #64]
    a000dde0:	f9001fe2 	str	x2, [sp, #56]
    a000dde4:	f9001be3 	str	x3, [sp, #48]
    a000dde8:	f90017e4 	str	x4, [sp, #40]
    a000ddec:	f90013e5 	str	x5, [sp, #32]
    a000ddf0:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a000ddf4:	d00001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000ddf8:	913f8000 	add	x0, x0, #0xfe0
    a000ddfc:	f9400800 	ldr	x0, [x0, #16]
    a000de00:	f9400fe1 	ldr	x1, [sp, #24]
    a000de04:	f9008401 	str	x1, [x0, #264]
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	size_t ret = z_vrfy_ivshmem_get_mem(*(const struct device **)&arg0, *(uintptr_t **)&arg1)
    a000de08:	910123e0 	add	x0, sp, #0x48
    a000de0c:	f9400002 	ldr	x2, [x0]
    a000de10:	910103e0 	add	x0, sp, #0x40
    a000de14:	f9400000 	ldr	x0, [x0]
    a000de18:	aa0003e1 	mov	x1, x0
    a000de1c:	aa0203e0 	mov	x0, x2
    a000de20:	97ffffb0 	bl	a000dce0 <z_vrfy_ivshmem_get_mem>
    a000de24:	f9002fe0 	str	x0, [sp, #88]
;
	_current->syscall_frame = NULL;
    a000de28:	d00001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000de2c:	913f8000 	add	x0, x0, #0xfe0
    a000de30:	f9400800 	ldr	x0, [x0, #16]
    a000de34:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a000de38:	f9402fe0 	ldr	x0, [sp, #88]
}
    a000de3c:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a000de40:	d65f03c0 	ret

00000000a000de44 <z_vrfy_ivshmem_get_id>:
#include <syscalls/ivshmem_get_mem_mrsh.c>

static inline uint32_t z_vrfy_ivshmem_get_id(const struct device *dev)
{
    a000de44:	d10903ff 	sub	sp, sp, #0x240
    a000de48:	a9007bfd 	stp	x29, x30, [sp]
    a000de4c:	910003fd 	mov	x29, sp
    a000de50:	f9000fe0 	str	x0, [sp, #24]
	Z_OOPS(Z_SYSCALL_DRIVER_IVSHMEM(dev, get_id));
    a000de54:	f9400fe0 	ldr	x0, [sp, #24]
    a000de58:	94003af4 	bl	a001ca28 <z_object_find>
    a000de5c:	52800003 	mov	w3, #0x0                   	// #0
    a000de60:	528006a2 	mov	w2, #0x35                  	// #53
    a000de64:	f9400fe1 	ldr	x1, [sp, #24]
    a000de68:	97ffff90 	bl	a000dca8 <z_obj_validation_check>
    a000de6c:	7100001f 	cmp	w0, #0x0
    a000de70:	1a9f07e0 	cset	w0, ne  // ne = any
    a000de74:	3908bfe0 	strb	w0, [sp, #559]
    a000de78:	3948bfe0 	ldrb	w0, [sp, #559]
    a000de7c:	7100001f 	cmp	w0, #0x0
    a000de80:	3948bfe0 	ldrb	w0, [sp, #559]
    a000de84:	7100001f 	cmp	w0, #0x0
    a000de88:	540001c1 	b.ne	a000dec0 <z_vrfy_ivshmem_get_id+0x7c>  // b.any
    a000de8c:	f9400fe0 	ldr	x0, [sp, #24]
    a000de90:	f9400800 	ldr	x0, [x0, #16]
    a000de94:	f9011be0 	str	x0, [sp, #560]
    a000de98:	f9411be0 	ldr	x0, [sp, #560]
    a000de9c:	f9400400 	ldr	x0, [x0, #8]
    a000dea0:	f100001f 	cmp	x0, #0x0
    a000dea4:	1a9f17e0 	cset	w0, eq  // eq = none
    a000dea8:	3908ffe0 	strb	w0, [sp, #575]
    a000deac:	3948ffe0 	ldrb	w0, [sp, #575]
    a000deb0:	7100001f 	cmp	w0, #0x0
    a000deb4:	3948ffe0 	ldrb	w0, [sp, #575]
    a000deb8:	7100001f 	cmp	w0, #0x0
    a000debc:	540000c0 	b.eq	a000ded4 <z_vrfy_ivshmem_get_id+0x90>  // b.none
    a000dec0:	d00001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000dec4:	913f8000 	add	x0, x0, #0xfe0
    a000dec8:	f9400800 	ldr	x0, [x0, #16]
    a000decc:	f9408400 	ldr	x0, [x0, #264]
    a000ded0:	97ffeca2 	bl	a0009158 <arch_syscall_oops>

	return z_impl_ivshmem_get_id(dev);
    a000ded4:	f9400fe0 	ldr	x0, [sp, #24]
    a000ded8:	97ffff3b 	bl	a000dbc4 <z_impl_ivshmem_get_id>
}
    a000dedc:	a9407bfd 	ldp	x29, x30, [sp]
    a000dee0:	910903ff 	add	sp, sp, #0x240
    a000dee4:	d65f03c0 	ret

00000000a000dee8 <z_mrsh_ivshmem_get_id>:
#include <syscalls/ivshmem.h>

extern uint32_t z_vrfy_ivshmem_get_id(const struct device * dev);
uintptr_t z_mrsh_ivshmem_get_id(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a000dee8:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a000deec:	910003fd 	mov	x29, sp
    a000def0:	f90027e0 	str	x0, [sp, #72]
    a000def4:	f90023e1 	str	x1, [sp, #64]
    a000def8:	f9001fe2 	str	x2, [sp, #56]
    a000defc:	f9001be3 	str	x3, [sp, #48]
    a000df00:	f90017e4 	str	x4, [sp, #40]
    a000df04:	f90013e5 	str	x5, [sp, #32]
    a000df08:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a000df0c:	d00001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000df10:	913f8000 	add	x0, x0, #0xfe0
    a000df14:	f9400800 	ldr	x0, [x0, #16]
    a000df18:	f9400fe1 	ldr	x1, [sp, #24]
    a000df1c:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	uint32_t ret = z_vrfy_ivshmem_get_id(*(const struct device **)&arg0)
    a000df20:	910123e0 	add	x0, sp, #0x48
    a000df24:	f9400000 	ldr	x0, [x0]
    a000df28:	97ffffc7 	bl	a000de44 <z_vrfy_ivshmem_get_id>
    a000df2c:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a000df30:	d00001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000df34:	913f8000 	add	x0, x0, #0xfe0
    a000df38:	f9400800 	ldr	x0, [x0, #16]
    a000df3c:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a000df40:	b9405fe0 	ldr	w0, [sp, #92]
}
    a000df44:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a000df48:	d65f03c0 	ret

00000000a000df4c <z_vrfy_ivshmem_get_vectors>:
#include <syscalls/ivshmem_get_id_mrsh.c>

static inline uint16_t z_vrfy_ivshmem_get_vectors(const struct device *dev)
{
    a000df4c:	d10903ff 	sub	sp, sp, #0x240
    a000df50:	a9007bfd 	stp	x29, x30, [sp]
    a000df54:	910003fd 	mov	x29, sp
    a000df58:	f9000fe0 	str	x0, [sp, #24]
	Z_OOPS(Z_SYSCALL_DRIVER_IVSHMEM(dev, get_vectors));
    a000df5c:	f9400fe0 	ldr	x0, [sp, #24]
    a000df60:	94003ab2 	bl	a001ca28 <z_object_find>
    a000df64:	52800003 	mov	w3, #0x0                   	// #0
    a000df68:	528006a2 	mov	w2, #0x35                  	// #53
    a000df6c:	f9400fe1 	ldr	x1, [sp, #24]
    a000df70:	97ffff4e 	bl	a000dca8 <z_obj_validation_check>
    a000df74:	7100001f 	cmp	w0, #0x0
    a000df78:	1a9f07e0 	cset	w0, ne  // ne = any
    a000df7c:	3908bfe0 	strb	w0, [sp, #559]
    a000df80:	3948bfe0 	ldrb	w0, [sp, #559]
    a000df84:	7100001f 	cmp	w0, #0x0
    a000df88:	3948bfe0 	ldrb	w0, [sp, #559]
    a000df8c:	7100001f 	cmp	w0, #0x0
    a000df90:	540001c1 	b.ne	a000dfc8 <z_vrfy_ivshmem_get_vectors+0x7c>  // b.any
    a000df94:	f9400fe0 	ldr	x0, [sp, #24]
    a000df98:	f9400800 	ldr	x0, [x0, #16]
    a000df9c:	f9011be0 	str	x0, [sp, #560]
    a000dfa0:	f9411be0 	ldr	x0, [sp, #560]
    a000dfa4:	f9400800 	ldr	x0, [x0, #16]
    a000dfa8:	f100001f 	cmp	x0, #0x0
    a000dfac:	1a9f17e0 	cset	w0, eq  // eq = none
    a000dfb0:	3908ffe0 	strb	w0, [sp, #575]
    a000dfb4:	3948ffe0 	ldrb	w0, [sp, #575]
    a000dfb8:	7100001f 	cmp	w0, #0x0
    a000dfbc:	3948ffe0 	ldrb	w0, [sp, #575]
    a000dfc0:	7100001f 	cmp	w0, #0x0
    a000dfc4:	540000c0 	b.eq	a000dfdc <z_vrfy_ivshmem_get_vectors+0x90>  // b.none
    a000dfc8:	d00001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000dfcc:	913f8000 	add	x0, x0, #0xfe0
    a000dfd0:	f9400800 	ldr	x0, [x0, #16]
    a000dfd4:	f9408400 	ldr	x0, [x0, #264]
    a000dfd8:	97ffec60 	bl	a0009158 <arch_syscall_oops>

	return z_impl_ivshmem_get_vectors(dev);
    a000dfdc:	f9400fe0 	ldr	x0, [sp, #24]
    a000dfe0:	97ffff05 	bl	a000dbf4 <z_impl_ivshmem_get_vectors>
    a000dfe4:	12003c00 	and	w0, w0, #0xffff
}
    a000dfe8:	a9407bfd 	ldp	x29, x30, [sp]
    a000dfec:	910903ff 	add	sp, sp, #0x240
    a000dff0:	d65f03c0 	ret

00000000a000dff4 <z_mrsh_ivshmem_get_vectors>:
#include <syscalls/ivshmem.h>

extern uint16_t z_vrfy_ivshmem_get_vectors(const struct device * dev);
uintptr_t z_mrsh_ivshmem_get_vectors(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a000dff4:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a000dff8:	910003fd 	mov	x29, sp
    a000dffc:	f90027e0 	str	x0, [sp, #72]
    a000e000:	f90023e1 	str	x1, [sp, #64]
    a000e004:	f9001fe2 	str	x2, [sp, #56]
    a000e008:	f9001be3 	str	x3, [sp, #48]
    a000e00c:	f90017e4 	str	x4, [sp, #40]
    a000e010:	f90013e5 	str	x5, [sp, #32]
    a000e014:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a000e018:	b00001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000e01c:	913f8000 	add	x0, x0, #0xfe0
    a000e020:	f9400800 	ldr	x0, [x0, #16]
    a000e024:	f9400fe1 	ldr	x1, [sp, #24]
    a000e028:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	uint16_t ret = z_vrfy_ivshmem_get_vectors(*(const struct device **)&arg0)
    a000e02c:	910123e0 	add	x0, sp, #0x48
    a000e030:	f9400000 	ldr	x0, [x0]
    a000e034:	97ffffc6 	bl	a000df4c <z_vrfy_ivshmem_get_vectors>
    a000e038:	7900bfe0 	strh	w0, [sp, #94]
;
	_current->syscall_frame = NULL;
    a000e03c:	b00001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000e040:	913f8000 	add	x0, x0, #0xfe0
    a000e044:	f9400800 	ldr	x0, [x0, #16]
    a000e048:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a000e04c:	7940bfe0 	ldrh	w0, [sp, #94]
}
    a000e050:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a000e054:	d65f03c0 	ret

00000000a000e058 <z_vrfy_ivshmem_int_peer>:
#include <syscalls/ivshmem_get_vectors_mrsh.c>

static inline int z_vrfy_ivshmem_int_peer(const struct device *dev,
					  uint32_t peer_id, uint16_t vector)
{
    a000e058:	d10903ff 	sub	sp, sp, #0x240
    a000e05c:	a9007bfd 	stp	x29, x30, [sp]
    a000e060:	910003fd 	mov	x29, sp
    a000e064:	f9000fe0 	str	x0, [sp, #24]
    a000e068:	b90017e1 	str	w1, [sp, #20]
    a000e06c:	790027e2 	strh	w2, [sp, #18]
	Z_OOPS(Z_SYSCALL_DRIVER_IVSHMEM(dev, int_peer));
    a000e070:	f9400fe0 	ldr	x0, [sp, #24]
    a000e074:	94003a6d 	bl	a001ca28 <z_object_find>
    a000e078:	52800003 	mov	w3, #0x0                   	// #0
    a000e07c:	528006a2 	mov	w2, #0x35                  	// #53
    a000e080:	f9400fe1 	ldr	x1, [sp, #24]
    a000e084:	97ffff09 	bl	a000dca8 <z_obj_validation_check>
    a000e088:	7100001f 	cmp	w0, #0x0
    a000e08c:	1a9f07e0 	cset	w0, ne  // ne = any
    a000e090:	3908bfe0 	strb	w0, [sp, #559]
    a000e094:	3948bfe0 	ldrb	w0, [sp, #559]
    a000e098:	7100001f 	cmp	w0, #0x0
    a000e09c:	3948bfe0 	ldrb	w0, [sp, #559]
    a000e0a0:	7100001f 	cmp	w0, #0x0
    a000e0a4:	540001c1 	b.ne	a000e0dc <z_vrfy_ivshmem_int_peer+0x84>  // b.any
    a000e0a8:	f9400fe0 	ldr	x0, [sp, #24]
    a000e0ac:	f9400800 	ldr	x0, [x0, #16]
    a000e0b0:	f9011be0 	str	x0, [sp, #560]
    a000e0b4:	f9411be0 	ldr	x0, [sp, #560]
    a000e0b8:	f9400c00 	ldr	x0, [x0, #24]
    a000e0bc:	f100001f 	cmp	x0, #0x0
    a000e0c0:	1a9f17e0 	cset	w0, eq  // eq = none
    a000e0c4:	3908ffe0 	strb	w0, [sp, #575]
    a000e0c8:	3948ffe0 	ldrb	w0, [sp, #575]
    a000e0cc:	7100001f 	cmp	w0, #0x0
    a000e0d0:	3948ffe0 	ldrb	w0, [sp, #575]
    a000e0d4:	7100001f 	cmp	w0, #0x0
    a000e0d8:	540000c0 	b.eq	a000e0f0 <z_vrfy_ivshmem_int_peer+0x98>  // b.none
    a000e0dc:	b00001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000e0e0:	913f8000 	add	x0, x0, #0xfe0
    a000e0e4:	f9400800 	ldr	x0, [x0, #16]
    a000e0e8:	f9408400 	ldr	x0, [x0, #264]
    a000e0ec:	97ffec1b 	bl	a0009158 <arch_syscall_oops>

	return z_impl_ivshmem_int_peer(dev, peer_id, vector);
    a000e0f0:	794027e2 	ldrh	w2, [sp, #18]
    a000e0f4:	b94017e1 	ldr	w1, [sp, #20]
    a000e0f8:	f9400fe0 	ldr	x0, [sp, #24]
    a000e0fc:	97fffecb 	bl	a000dc28 <z_impl_ivshmem_int_peer>
}
    a000e100:	a9407bfd 	ldp	x29, x30, [sp]
    a000e104:	910903ff 	add	sp, sp, #0x240
    a000e108:	d65f03c0 	ret

00000000a000e10c <z_mrsh_ivshmem_int_peer>:
#include <syscalls/ivshmem.h>

extern int z_vrfy_ivshmem_int_peer(const struct device * dev, uint32_t peer_id, uint16_t vector);
uintptr_t z_mrsh_ivshmem_int_peer(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a000e10c:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a000e110:	910003fd 	mov	x29, sp
    a000e114:	f90027e0 	str	x0, [sp, #72]
    a000e118:	f90023e1 	str	x1, [sp, #64]
    a000e11c:	f9001fe2 	str	x2, [sp, #56]
    a000e120:	f9001be3 	str	x3, [sp, #48]
    a000e124:	f90017e4 	str	x4, [sp, #40]
    a000e128:	f90013e5 	str	x5, [sp, #32]
    a000e12c:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a000e130:	b00001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000e134:	913f8000 	add	x0, x0, #0xfe0
    a000e138:	f9400800 	ldr	x0, [x0, #16]
    a000e13c:	f9400fe1 	ldr	x1, [sp, #24]
    a000e140:	f9008401 	str	x1, [x0, #264]
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_ivshmem_int_peer(*(const struct device **)&arg0, *(uint32_t*)&arg1, *(uint16_t*)&arg2)
    a000e144:	910123e0 	add	x0, sp, #0x48
    a000e148:	f9400003 	ldr	x3, [x0]
    a000e14c:	910103e0 	add	x0, sp, #0x40
    a000e150:	b9400001 	ldr	w1, [x0]
    a000e154:	9100e3e0 	add	x0, sp, #0x38
    a000e158:	79400000 	ldrh	w0, [x0]
    a000e15c:	2a0003e2 	mov	w2, w0
    a000e160:	aa0303e0 	mov	x0, x3
    a000e164:	97ffffbd 	bl	a000e058 <z_vrfy_ivshmem_int_peer>
    a000e168:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a000e16c:	b00001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000e170:	913f8000 	add	x0, x0, #0xfe0
    a000e174:	f9400800 	ldr	x0, [x0, #16]
    a000e178:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a000e17c:	b9805fe0 	ldrsw	x0, [sp, #92]
}
    a000e180:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a000e184:	d65f03c0 	ret

00000000a000e188 <z_vrfy_ivshmem_register_handler>:
#include <syscalls/ivshmem_int_peer_mrsh.c>

static inline int z_vrfy_ivshmem_register_handler(const struct device *dev,
						  struct k_poll_signal *signal,
						  uint16_t vector)
{
    a000e188:	d10ac3ff 	sub	sp, sp, #0x2b0
    a000e18c:	a9007bfd 	stp	x29, x30, [sp]
    a000e190:	910003fd 	mov	x29, sp
    a000e194:	f90017e0 	str	x0, [sp, #40]
    a000e198:	f90013e1 	str	x1, [sp, #32]
    a000e19c:	79003fe2 	strh	w2, [sp, #30]
	Z_OOPS(Z_SYSCALL_DRIVER_IVSHMEM(dev, register_handler));
    a000e1a0:	f94017e0 	ldr	x0, [sp, #40]
    a000e1a4:	94003a21 	bl	a001ca28 <z_object_find>
    a000e1a8:	52800003 	mov	w3, #0x0                   	// #0
    a000e1ac:	528006a2 	mov	w2, #0x35                  	// #53
    a000e1b0:	f94017e1 	ldr	x1, [sp, #40]
    a000e1b4:	97fffebd 	bl	a000dca8 <z_obj_validation_check>
    a000e1b8:	7100001f 	cmp	w0, #0x0
    a000e1bc:	1a9f07e0 	cset	w0, ne  // ne = any
    a000e1c0:	390a7be0 	strb	w0, [sp, #670]
    a000e1c4:	394a7be0 	ldrb	w0, [sp, #670]
    a000e1c8:	7100001f 	cmp	w0, #0x0
    a000e1cc:	394a7be0 	ldrb	w0, [sp, #670]
    a000e1d0:	7100001f 	cmp	w0, #0x0
    a000e1d4:	540001c1 	b.ne	a000e20c <z_vrfy_ivshmem_register_handler+0x84>  // b.any
    a000e1d8:	f94017e0 	ldr	x0, [sp, #40]
    a000e1dc:	f9400800 	ldr	x0, [x0, #16]
    a000e1e0:	f90153e0 	str	x0, [sp, #672]
    a000e1e4:	f94153e0 	ldr	x0, [sp, #672]
    a000e1e8:	f9401000 	ldr	x0, [x0, #32]
    a000e1ec:	f100001f 	cmp	x0, #0x0
    a000e1f0:	1a9f17e0 	cset	w0, eq  // eq = none
    a000e1f4:	390a7fe0 	strb	w0, [sp, #671]
    a000e1f8:	394a7fe0 	ldrb	w0, [sp, #671]
    a000e1fc:	7100001f 	cmp	w0, #0x0
    a000e200:	394a7fe0 	ldrb	w0, [sp, #671]
    a000e204:	7100001f 	cmp	w0, #0x0
    a000e208:	540000c0 	b.eq	a000e220 <z_vrfy_ivshmem_register_handler+0x98>  // b.none
    a000e20c:	b00001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000e210:	913f8000 	add	x0, x0, #0xfe0
    a000e214:	f9400800 	ldr	x0, [x0, #16]
    a000e218:	f9408400 	ldr	x0, [x0, #264]
    a000e21c:	97ffebcf 	bl	a0009158 <arch_syscall_oops>
	Z_OOPS(Z_SYSCALL_OBJ(signal, K_OBJ_POLL_SIGNAL));
    a000e220:	f94013e0 	ldr	x0, [sp, #32]
    a000e224:	94003a01 	bl	a001ca28 <z_object_find>
    a000e228:	52800003 	mov	w3, #0x0                   	// #0
    a000e22c:	528000c2 	mov	w2, #0x6                   	// #6
    a000e230:	f94013e1 	ldr	x1, [sp, #32]
    a000e234:	97fffe9d 	bl	a000dca8 <z_obj_validation_check>
    a000e238:	7100001f 	cmp	w0, #0x0
    a000e23c:	1a9f07e0 	cset	w0, ne  // ne = any
    a000e240:	390abfe0 	strb	w0, [sp, #687]
    a000e244:	394abfe0 	ldrb	w0, [sp, #687]
    a000e248:	7100001f 	cmp	w0, #0x0
    a000e24c:	394abfe0 	ldrb	w0, [sp, #687]
    a000e250:	7100001f 	cmp	w0, #0x0
    a000e254:	540000c0 	b.eq	a000e26c <z_vrfy_ivshmem_register_handler+0xe4>  // b.none
    a000e258:	b00001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000e25c:	913f8000 	add	x0, x0, #0xfe0
    a000e260:	f9400800 	ldr	x0, [x0, #16]
    a000e264:	f9408400 	ldr	x0, [x0, #264]
    a000e268:	97ffebbc 	bl	a0009158 <arch_syscall_oops>

	return z_impl_ivshmem_register_handler(dev, signal, vector);
    a000e26c:	79403fe2 	ldrh	w2, [sp, #30]
    a000e270:	f94013e1 	ldr	x1, [sp, #32]
    a000e274:	f94017e0 	ldr	x0, [sp, #40]
    a000e278:	97fffe7c 	bl	a000dc68 <z_impl_ivshmem_register_handler>
}
    a000e27c:	a9407bfd 	ldp	x29, x30, [sp]
    a000e280:	910ac3ff 	add	sp, sp, #0x2b0
    a000e284:	d65f03c0 	ret

00000000a000e288 <z_mrsh_ivshmem_register_handler>:
#include <syscalls/ivshmem.h>

extern int z_vrfy_ivshmem_register_handler(const struct device * dev, struct k_poll_signal * signal, uint16_t vector);
uintptr_t z_mrsh_ivshmem_register_handler(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a000e288:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a000e28c:	910003fd 	mov	x29, sp
    a000e290:	f90027e0 	str	x0, [sp, #72]
    a000e294:	f90023e1 	str	x1, [sp, #64]
    a000e298:	f9001fe2 	str	x2, [sp, #56]
    a000e29c:	f9001be3 	str	x3, [sp, #48]
    a000e2a0:	f90017e4 	str	x4, [sp, #40]
    a000e2a4:	f90013e5 	str	x5, [sp, #32]
    a000e2a8:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a000e2ac:	b00001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000e2b0:	913f8000 	add	x0, x0, #0xfe0
    a000e2b4:	f9400800 	ldr	x0, [x0, #16]
    a000e2b8:	f9400fe1 	ldr	x1, [sp, #24]
    a000e2bc:	f9008401 	str	x1, [x0, #264]
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_ivshmem_register_handler(*(const struct device **)&arg0, *(struct k_poll_signal **)&arg1, *(uint16_t*)&arg2)
    a000e2c0:	910123e0 	add	x0, sp, #0x48
    a000e2c4:	f9400003 	ldr	x3, [x0]
    a000e2c8:	910103e0 	add	x0, sp, #0x40
    a000e2cc:	f9400001 	ldr	x1, [x0]
    a000e2d0:	9100e3e0 	add	x0, sp, #0x38
    a000e2d4:	79400000 	ldrh	w0, [x0]
    a000e2d8:	2a0003e2 	mov	w2, w0
    a000e2dc:	aa0303e0 	mov	x0, x3
    a000e2e0:	97ffffaa 	bl	a000e188 <z_vrfy_ivshmem_register_handler>
    a000e2e4:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a000e2e8:	b00001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000e2ec:	913f8000 	add	x0, x0, #0xfe0
    a000e2f0:	f9400800 	ldr	x0, [x0, #16]
    a000e2f4:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a000e2f8:	b9805fe0 	ldrsw	x0, [sp, #92]
}
    a000e2fc:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a000e300:	d65f03c0 	ret

00000000a000e304 <pl011_enable>:
#define PL011_REGS(dev) \
	((volatile struct pl011_regs  *) \
	 ((const struct uart_device_config * const)(dev)->config)->base)

static void pl011_enable(const struct device *dev)
{
    a000e304:	d10043ff 	sub	sp, sp, #0x10
    a000e308:	f90007e0 	str	x0, [sp, #8]
	PL011_REGS(dev)->cr |=  PL011_CR_UARTEN;
    a000e30c:	f94007e0 	ldr	x0, [sp, #8]
    a000e310:	f9400400 	ldr	x0, [x0, #8]
    a000e314:	f9400000 	ldr	x0, [x0]
    a000e318:	b9403001 	ldr	w1, [x0, #48]
    a000e31c:	f94007e0 	ldr	x0, [sp, #8]
    a000e320:	f9400400 	ldr	x0, [x0, #8]
    a000e324:	f9400000 	ldr	x0, [x0]
    a000e328:	32000021 	orr	w1, w1, #0x1
    a000e32c:	b9003001 	str	w1, [x0, #48]
}
    a000e330:	d503201f 	nop
    a000e334:	910043ff 	add	sp, sp, #0x10
    a000e338:	d65f03c0 	ret

00000000a000e33c <pl011_disable>:

static void pl011_disable(const struct device *dev)
{
    a000e33c:	d10043ff 	sub	sp, sp, #0x10
    a000e340:	f90007e0 	str	x0, [sp, #8]
	PL011_REGS(dev)->cr &= ~PL011_CR_UARTEN;
    a000e344:	f94007e0 	ldr	x0, [sp, #8]
    a000e348:	f9400400 	ldr	x0, [x0, #8]
    a000e34c:	f9400000 	ldr	x0, [x0]
    a000e350:	b9403001 	ldr	w1, [x0, #48]
    a000e354:	f94007e0 	ldr	x0, [sp, #8]
    a000e358:	f9400400 	ldr	x0, [x0, #8]
    a000e35c:	f9400000 	ldr	x0, [x0]
    a000e360:	121f7821 	and	w1, w1, #0xfffffffe
    a000e364:	b9003001 	str	w1, [x0, #48]
}
    a000e368:	d503201f 	nop
    a000e36c:	910043ff 	add	sp, sp, #0x10
    a000e370:	d65f03c0 	ret

00000000a000e374 <pl011_enable_fifo>:

static void pl011_enable_fifo(const struct device *dev)
{
    a000e374:	d10043ff 	sub	sp, sp, #0x10
    a000e378:	f90007e0 	str	x0, [sp, #8]
	PL011_REGS(dev)->lcr_h |= PL011_LCRH_FEN;
    a000e37c:	f94007e0 	ldr	x0, [sp, #8]
    a000e380:	f9400400 	ldr	x0, [x0, #8]
    a000e384:	f9400000 	ldr	x0, [x0]
    a000e388:	b9402c01 	ldr	w1, [x0, #44]
    a000e38c:	f94007e0 	ldr	x0, [sp, #8]
    a000e390:	f9400400 	ldr	x0, [x0, #8]
    a000e394:	f9400000 	ldr	x0, [x0]
    a000e398:	321c0021 	orr	w1, w1, #0x10
    a000e39c:	b9002c01 	str	w1, [x0, #44]
}
    a000e3a0:	d503201f 	nop
    a000e3a4:	910043ff 	add	sp, sp, #0x10
    a000e3a8:	d65f03c0 	ret

00000000a000e3ac <pl011_disable_fifo>:

static void pl011_disable_fifo(const struct device *dev)
{
    a000e3ac:	d10043ff 	sub	sp, sp, #0x10
    a000e3b0:	f90007e0 	str	x0, [sp, #8]
	PL011_REGS(dev)->lcr_h &= ~PL011_LCRH_FEN;
    a000e3b4:	f94007e0 	ldr	x0, [sp, #8]
    a000e3b8:	f9400400 	ldr	x0, [x0, #8]
    a000e3bc:	f9400000 	ldr	x0, [x0]
    a000e3c0:	b9402c01 	ldr	w1, [x0, #44]
    a000e3c4:	f94007e0 	ldr	x0, [sp, #8]
    a000e3c8:	f9400400 	ldr	x0, [x0, #8]
    a000e3cc:	f9400000 	ldr	x0, [x0]
    a000e3d0:	121b7821 	and	w1, w1, #0xffffffef
    a000e3d4:	b9002c01 	str	w1, [x0, #44]
}
    a000e3d8:	d503201f 	nop
    a000e3dc:	910043ff 	add	sp, sp, #0x10
    a000e3e0:	d65f03c0 	ret

00000000a000e3e4 <pl011_set_baudrate>:

static int pl011_set_baudrate(const struct device *dev,
			      uint32_t clk, uint32_t baudrate)
{
    a000e3e4:	d10083ff 	sub	sp, sp, #0x20
    a000e3e8:	f90007e0 	str	x0, [sp, #8]
    a000e3ec:	b90007e1 	str	w1, [sp, #4]
    a000e3f0:	b90003e2 	str	w2, [sp]
	/* Avoiding float calculations, bauddiv is left shifted by 6 */
	uint64_t bauddiv = (((uint64_t)clk) << PL011_FBRD_WIDTH)
    a000e3f4:	b94007e0 	ldr	w0, [sp, #4]
    a000e3f8:	d37ae401 	lsl	x1, x0, #6
				/ (baudrate * 16U);
    a000e3fc:	b94003e0 	ldr	w0, [sp]
    a000e400:	531c6c00 	lsl	w0, w0, #4
    a000e404:	2a0003e0 	mov	w0, w0
	uint64_t bauddiv = (((uint64_t)clk) << PL011_FBRD_WIDTH)
    a000e408:	9ac00820 	udiv	x0, x1, x0
    a000e40c:	f9000fe0 	str	x0, [sp, #24]

	/* Valid bauddiv value
	 * uart_clk (min) >= 16 x baud_rate (max)
	 * uart_clk (max) <= 16 x 65535 x baud_rate (min)
	 */
	if ((bauddiv < (1u << PL011_FBRD_WIDTH))
    a000e410:	f9400fe0 	ldr	x0, [sp, #24]
    a000e414:	f100fc1f 	cmp	x0, #0x3f
    a000e418:	540000a9 	b.ls	a000e42c <pl011_set_baudrate+0x48>  // b.plast
		|| (bauddiv > (65535u << PL011_FBRD_WIDTH))) {
    a000e41c:	f9400fe1 	ldr	x1, [sp, #24]
    a000e420:	b27a3fe0 	mov	x0, #0x3fffc0              	// #4194240
    a000e424:	eb00003f 	cmp	x1, x0
    a000e428:	54000069 	b.ls	a000e434 <pl011_set_baudrate+0x50>  // b.plast
		return -EINVAL;
    a000e42c:	128002a0 	mov	w0, #0xffffffea            	// #-22
    a000e430:	14000018 	b	a000e490 <pl011_set_baudrate+0xac>
	}

	PL011_REGS(dev)->ibrd = bauddiv >> PL011_FBRD_WIDTH;
    a000e434:	f9400fe0 	ldr	x0, [sp, #24]
    a000e438:	d346fc01 	lsr	x1, x0, #6
    a000e43c:	f94007e0 	ldr	x0, [sp, #8]
    a000e440:	f9400400 	ldr	x0, [x0, #8]
    a000e444:	f9400000 	ldr	x0, [x0]
    a000e448:	b9002401 	str	w1, [x0, #36]
	PL011_REGS(dev)->fbrd = bauddiv & ((1u << PL011_FBRD_WIDTH) - 1u);
    a000e44c:	f9400fe0 	ldr	x0, [sp, #24]
    a000e450:	2a0003e1 	mov	w1, w0
    a000e454:	f94007e0 	ldr	x0, [sp, #8]
    a000e458:	f9400400 	ldr	x0, [x0, #8]
    a000e45c:	f9400000 	ldr	x0, [x0]
    a000e460:	12001421 	and	w1, w1, #0x3f
    a000e464:	b9002801 	str	w1, [x0, #40]

	__DMB();
    a000e468:	d5033fbf 	dmb	sy

	/* In order to internally update the contents of ibrd or fbrd, a
	 * lcr_h write must always be performed at the end
	 * ARM DDI 0183F, Pg 3-13
	 */
	PL011_REGS(dev)->lcr_h = PL011_REGS(dev)->lcr_h;
    a000e46c:	f94007e0 	ldr	x0, [sp, #8]
    a000e470:	f9400400 	ldr	x0, [x0, #8]
    a000e474:	f9400001 	ldr	x1, [x0]
    a000e478:	f94007e0 	ldr	x0, [sp, #8]
    a000e47c:	f9400400 	ldr	x0, [x0, #8]
    a000e480:	f9400000 	ldr	x0, [x0]
    a000e484:	b9402c21 	ldr	w1, [x1, #44]
    a000e488:	b9002c01 	str	w1, [x0, #44]

	return 0;
    a000e48c:	52800000 	mov	w0, #0x0                   	// #0
}
    a000e490:	910083ff 	add	sp, sp, #0x20
    a000e494:	d65f03c0 	ret

00000000a000e498 <pl011_is_readable>:

static bool pl011_is_readable(const struct device *dev)
{
    a000e498:	d10083ff 	sub	sp, sp, #0x20
    a000e49c:	f90007e0 	str	x0, [sp, #8]
	struct pl011_data *data = dev->data;
    a000e4a0:	f94007e0 	ldr	x0, [sp, #8]
    a000e4a4:	f9401000 	ldr	x0, [x0, #32]
    a000e4a8:	f9000fe0 	str	x0, [sp, #24]

	if (!data->sbsa &&
    a000e4ac:	f9400fe0 	ldr	x0, [sp, #24]
    a000e4b0:	39401000 	ldrb	w0, [x0, #4]
    a000e4b4:	52000000 	eor	w0, w0, #0x1
    a000e4b8:	12001c00 	and	w0, w0, #0xff
    a000e4bc:	7100001f 	cmp	w0, #0x0
    a000e4c0:	54000260 	b.eq	a000e50c <pl011_is_readable+0x74>  // b.none
	    (!(PL011_REGS(dev)->cr & PL011_CR_UARTEN) ||
    a000e4c4:	f94007e0 	ldr	x0, [sp, #8]
    a000e4c8:	f9400400 	ldr	x0, [x0, #8]
    a000e4cc:	f9400000 	ldr	x0, [x0]
    a000e4d0:	b9403000 	ldr	w0, [x0, #48]
    a000e4d4:	2a0003e0 	mov	w0, w0
    a000e4d8:	92400000 	and	x0, x0, #0x1
	if (!data->sbsa &&
    a000e4dc:	f100001f 	cmp	x0, #0x0
    a000e4e0:	54000120 	b.eq	a000e504 <pl011_is_readable+0x6c>  // b.none
	     !(PL011_REGS(dev)->cr & PL011_CR_RXE)))
    a000e4e4:	f94007e0 	ldr	x0, [sp, #8]
    a000e4e8:	f9400400 	ldr	x0, [x0, #8]
    a000e4ec:	f9400000 	ldr	x0, [x0]
    a000e4f0:	b9403000 	ldr	w0, [x0, #48]
    a000e4f4:	2a0003e0 	mov	w0, w0
    a000e4f8:	92770000 	and	x0, x0, #0x200
	    (!(PL011_REGS(dev)->cr & PL011_CR_UARTEN) ||
    a000e4fc:	f100001f 	cmp	x0, #0x0
    a000e500:	54000061 	b.ne	a000e50c <pl011_is_readable+0x74>  // b.any
		return false;
    a000e504:	52800000 	mov	w0, #0x0                   	// #0
    a000e508:	1400000a 	b	a000e530 <pl011_is_readable+0x98>

	return (PL011_REGS(dev)->fr & PL011_FR_RXFE) == 0U;
    a000e50c:	f94007e0 	ldr	x0, [sp, #8]
    a000e510:	f9400400 	ldr	x0, [x0, #8]
    a000e514:	f9400000 	ldr	x0, [x0]
    a000e518:	b9401800 	ldr	w0, [x0, #24]
    a000e51c:	2a0003e0 	mov	w0, w0
    a000e520:	927c0000 	and	x0, x0, #0x10
    a000e524:	f100001f 	cmp	x0, #0x0
    a000e528:	1a9f17e0 	cset	w0, eq  // eq = none
    a000e52c:	12001c00 	and	w0, w0, #0xff
}
    a000e530:	910083ff 	add	sp, sp, #0x20
    a000e534:	d65f03c0 	ret

00000000a000e538 <pl011_poll_in>:

static int pl011_poll_in(const struct device *dev, unsigned char *c)
{
    a000e538:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a000e53c:	910003fd 	mov	x29, sp
    a000e540:	f9000fe0 	str	x0, [sp, #24]
    a000e544:	f9000be1 	str	x1, [sp, #16]
	if (!pl011_is_readable(dev)) {
    a000e548:	f9400fe0 	ldr	x0, [sp, #24]
    a000e54c:	97ffffd3 	bl	a000e498 <pl011_is_readable>
    a000e550:	12001c00 	and	w0, w0, #0xff
    a000e554:	52000000 	eor	w0, w0, #0x1
    a000e558:	12001c00 	and	w0, w0, #0xff
    a000e55c:	7100001f 	cmp	w0, #0x0
    a000e560:	54000060 	b.eq	a000e56c <pl011_poll_in+0x34>  // b.none
		return -1;
    a000e564:	12800000 	mov	w0, #0xffffffff            	// #-1
    a000e568:	1400000d 	b	a000e59c <pl011_poll_in+0x64>
	}

	/* got a character */
	*c = (unsigned char)PL011_REGS(dev)->dr;
    a000e56c:	f9400fe0 	ldr	x0, [sp, #24]
    a000e570:	f9400400 	ldr	x0, [x0, #8]
    a000e574:	f9400000 	ldr	x0, [x0]
    a000e578:	b9400000 	ldr	w0, [x0]
    a000e57c:	12001c01 	and	w1, w0, #0xff
    a000e580:	f9400be0 	ldr	x0, [sp, #16]
    a000e584:	39000001 	strb	w1, [x0]

	return PL011_REGS(dev)->rsr & PL011_RSR_ERROR_MASK;
    a000e588:	f9400fe0 	ldr	x0, [sp, #24]
    a000e58c:	f9400400 	ldr	x0, [x0, #8]
    a000e590:	f9400000 	ldr	x0, [x0]
    a000e594:	b9400400 	ldr	w0, [x0, #4]
    a000e598:	12000c00 	and	w0, w0, #0xf
}
    a000e59c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a000e5a0:	d65f03c0 	ret

00000000a000e5a4 <pl011_poll_out>:

static void pl011_poll_out(const struct device *dev,
					     unsigned char c)
{
    a000e5a4:	d10043ff 	sub	sp, sp, #0x10
    a000e5a8:	f90007e0 	str	x0, [sp, #8]
    a000e5ac:	39001fe1 	strb	w1, [sp, #7]
	/* Wait for space in FIFO */
	while (PL011_REGS(dev)->fr & PL011_FR_TXFF) {
    a000e5b0:	d503201f 	nop
    a000e5b4:	f94007e0 	ldr	x0, [sp, #8]
    a000e5b8:	f9400400 	ldr	x0, [x0, #8]
    a000e5bc:	f9400000 	ldr	x0, [x0]
    a000e5c0:	b9401800 	ldr	w0, [x0, #24]
    a000e5c4:	2a0003e0 	mov	w0, w0
    a000e5c8:	927b0000 	and	x0, x0, #0x20
    a000e5cc:	f100001f 	cmp	x0, #0x0
    a000e5d0:	54ffff21 	b.ne	a000e5b4 <pl011_poll_out+0x10>  // b.any
		; /* Wait */
	}

	/* Send a character */
	PL011_REGS(dev)->dr = (uint32_t)c;
    a000e5d4:	f94007e0 	ldr	x0, [sp, #8]
    a000e5d8:	f9400400 	ldr	x0, [x0, #8]
    a000e5dc:	f9400000 	ldr	x0, [x0]
    a000e5e0:	39401fe1 	ldrb	w1, [sp, #7]
    a000e5e4:	b9000001 	str	w1, [x0]
}
    a000e5e8:	d503201f 	nop
    a000e5ec:	910043ff 	add	sp, sp, #0x10
    a000e5f0:	d65f03c0 	ret

00000000a000e5f4 <pl011_fifo_fill>:

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
static int pl011_fifo_fill(const struct device *dev,
				    const uint8_t *tx_data, int len)
{
    a000e5f4:	d100c3ff 	sub	sp, sp, #0x30
    a000e5f8:	f9000fe0 	str	x0, [sp, #24]
    a000e5fc:	f9000be1 	str	x1, [sp, #16]
    a000e600:	b9000fe2 	str	w2, [sp, #12]
	uint8_t num_tx = 0U;
    a000e604:	3900bfff 	strb	wzr, [sp, #47]

	while (!(PL011_REGS(dev)->fr & PL011_FR_TXFF) &&
    a000e608:	1400000c 	b	a000e638 <pl011_fifo_fill+0x44>
	       (len - num_tx > 0)) {
		PL011_REGS(dev)->dr = tx_data[num_tx++];
    a000e60c:	3940bfe0 	ldrb	w0, [sp, #47]
    a000e610:	11000401 	add	w1, w0, #0x1
    a000e614:	3900bfe1 	strb	w1, [sp, #47]
    a000e618:	92401c00 	and	x0, x0, #0xff
    a000e61c:	f9400be1 	ldr	x1, [sp, #16]
    a000e620:	8b000020 	add	x0, x1, x0
    a000e624:	39400001 	ldrb	w1, [x0]
    a000e628:	f9400fe0 	ldr	x0, [sp, #24]
    a000e62c:	f9400400 	ldr	x0, [x0, #8]
    a000e630:	f9400000 	ldr	x0, [x0]
    a000e634:	b9000001 	str	w1, [x0]
	while (!(PL011_REGS(dev)->fr & PL011_FR_TXFF) &&
    a000e638:	f9400fe0 	ldr	x0, [sp, #24]
    a000e63c:	f9400400 	ldr	x0, [x0, #8]
    a000e640:	f9400000 	ldr	x0, [x0]
    a000e644:	b9401800 	ldr	w0, [x0, #24]
    a000e648:	2a0003e0 	mov	w0, w0
    a000e64c:	927b0000 	and	x0, x0, #0x20
    a000e650:	f100001f 	cmp	x0, #0x0
    a000e654:	540000c1 	b.ne	a000e66c <pl011_fifo_fill+0x78>  // b.any
	       (len - num_tx > 0)) {
    a000e658:	3940bfe0 	ldrb	w0, [sp, #47]
    a000e65c:	b9400fe1 	ldr	w1, [sp, #12]
    a000e660:	4b000020 	sub	w0, w1, w0
	while (!(PL011_REGS(dev)->fr & PL011_FR_TXFF) &&
    a000e664:	7100001f 	cmp	w0, #0x0
    a000e668:	54fffd2c 	b.gt	a000e60c <pl011_fifo_fill+0x18>
	}
	return num_tx;
    a000e66c:	3940bfe0 	ldrb	w0, [sp, #47]
}
    a000e670:	9100c3ff 	add	sp, sp, #0x30
    a000e674:	d65f03c0 	ret

00000000a000e678 <pl011_fifo_read>:

static int pl011_fifo_read(const struct device *dev,
				    uint8_t *rx_data, const int len)
{
    a000e678:	d100c3ff 	sub	sp, sp, #0x30
    a000e67c:	f9000fe0 	str	x0, [sp, #24]
    a000e680:	f9000be1 	str	x1, [sp, #16]
    a000e684:	b9000fe2 	str	w2, [sp, #12]
	uint8_t num_rx = 0U;
    a000e688:	3900bfff 	strb	wzr, [sp, #47]

	while ((len - num_rx > 0) &&
    a000e68c:	1400000d 	b	a000e6c0 <pl011_fifo_read+0x48>
	       !(PL011_REGS(dev)->fr & PL011_FR_RXFE)) {
		rx_data[num_rx++] = PL011_REGS(dev)->dr;
    a000e690:	f9400fe0 	ldr	x0, [sp, #24]
    a000e694:	f9400400 	ldr	x0, [x0, #8]
    a000e698:	f9400000 	ldr	x0, [x0]
    a000e69c:	b9400002 	ldr	w2, [x0]
    a000e6a0:	3940bfe0 	ldrb	w0, [sp, #47]
    a000e6a4:	11000401 	add	w1, w0, #0x1
    a000e6a8:	3900bfe1 	strb	w1, [sp, #47]
    a000e6ac:	92401c00 	and	x0, x0, #0xff
    a000e6b0:	f9400be1 	ldr	x1, [sp, #16]
    a000e6b4:	8b000020 	add	x0, x1, x0
    a000e6b8:	12001c41 	and	w1, w2, #0xff
    a000e6bc:	39000001 	strb	w1, [x0]
	while ((len - num_rx > 0) &&
    a000e6c0:	3940bfe0 	ldrb	w0, [sp, #47]
    a000e6c4:	b9400fe1 	ldr	w1, [sp, #12]
    a000e6c8:	4b000020 	sub	w0, w1, w0
    a000e6cc:	7100001f 	cmp	w0, #0x0
    a000e6d0:	5400012d 	b.le	a000e6f4 <pl011_fifo_read+0x7c>
	       !(PL011_REGS(dev)->fr & PL011_FR_RXFE)) {
    a000e6d4:	f9400fe0 	ldr	x0, [sp, #24]
    a000e6d8:	f9400400 	ldr	x0, [x0, #8]
    a000e6dc:	f9400000 	ldr	x0, [x0]
    a000e6e0:	b9401800 	ldr	w0, [x0, #24]
    a000e6e4:	2a0003e0 	mov	w0, w0
    a000e6e8:	927c0000 	and	x0, x0, #0x10
	while ((len - num_rx > 0) &&
    a000e6ec:	f100001f 	cmp	x0, #0x0
    a000e6f0:	54fffd00 	b.eq	a000e690 <pl011_fifo_read+0x18>  // b.none
	}

	return num_rx;
    a000e6f4:	3940bfe0 	ldrb	w0, [sp, #47]
}
    a000e6f8:	9100c3ff 	add	sp, sp, #0x30
    a000e6fc:	d65f03c0 	ret

00000000a000e700 <pl011_irq_tx_enable>:

static void pl011_irq_tx_enable(const struct device *dev)
{
    a000e700:	d10043ff 	sub	sp, sp, #0x10
    a000e704:	f90007e0 	str	x0, [sp, #8]
	PL011_REGS(dev)->imsc |= PL011_IMSC_TXIM;
    a000e708:	f94007e0 	ldr	x0, [sp, #8]
    a000e70c:	f9400400 	ldr	x0, [x0, #8]
    a000e710:	f9400000 	ldr	x0, [x0]
    a000e714:	b9403801 	ldr	w1, [x0, #56]
    a000e718:	f94007e0 	ldr	x0, [sp, #8]
    a000e71c:	f9400400 	ldr	x0, [x0, #8]
    a000e720:	f9400000 	ldr	x0, [x0]
    a000e724:	321b0021 	orr	w1, w1, #0x20
    a000e728:	b9003801 	str	w1, [x0, #56]
}
    a000e72c:	d503201f 	nop
    a000e730:	910043ff 	add	sp, sp, #0x10
    a000e734:	d65f03c0 	ret

00000000a000e738 <pl011_irq_tx_disable>:

static void pl011_irq_tx_disable(const struct device *dev)
{
    a000e738:	d10043ff 	sub	sp, sp, #0x10
    a000e73c:	f90007e0 	str	x0, [sp, #8]
	PL011_REGS(dev)->imsc &= ~PL011_IMSC_TXIM;
    a000e740:	f94007e0 	ldr	x0, [sp, #8]
    a000e744:	f9400400 	ldr	x0, [x0, #8]
    a000e748:	f9400000 	ldr	x0, [x0]
    a000e74c:	b9403801 	ldr	w1, [x0, #56]
    a000e750:	f94007e0 	ldr	x0, [sp, #8]
    a000e754:	f9400400 	ldr	x0, [x0, #8]
    a000e758:	f9400000 	ldr	x0, [x0]
    a000e75c:	121a7821 	and	w1, w1, #0xffffffdf
    a000e760:	b9003801 	str	w1, [x0, #56]
}
    a000e764:	d503201f 	nop
    a000e768:	910043ff 	add	sp, sp, #0x10
    a000e76c:	d65f03c0 	ret

00000000a000e770 <pl011_irq_tx_complete>:

static int pl011_irq_tx_complete(const struct device *dev)
{
    a000e770:	d10043ff 	sub	sp, sp, #0x10
    a000e774:	f90007e0 	str	x0, [sp, #8]
	/* check for TX FIFO empty */
	return PL011_REGS(dev)->fr & PL011_FR_TXFE;
    a000e778:	f94007e0 	ldr	x0, [sp, #8]
    a000e77c:	f9400400 	ldr	x0, [x0, #8]
    a000e780:	f9400000 	ldr	x0, [x0]
    a000e784:	b9401800 	ldr	w0, [x0, #24]
    a000e788:	12190000 	and	w0, w0, #0x80
}
    a000e78c:	910043ff 	add	sp, sp, #0x10
    a000e790:	d65f03c0 	ret

00000000a000e794 <pl011_irq_tx_ready>:

static int pl011_irq_tx_ready(const struct device *dev)
{
    a000e794:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a000e798:	910003fd 	mov	x29, sp
    a000e79c:	f9000fe0 	str	x0, [sp, #24]
	struct pl011_data *data = dev->data;
    a000e7a0:	f9400fe0 	ldr	x0, [sp, #24]
    a000e7a4:	f9401000 	ldr	x0, [x0, #32]
    a000e7a8:	f90017e0 	str	x0, [sp, #40]

	if (!data->sbsa && !(PL011_REGS(dev)->cr & PL011_CR_TXE))
    a000e7ac:	f94017e0 	ldr	x0, [sp, #40]
    a000e7b0:	39401000 	ldrb	w0, [x0, #4]
    a000e7b4:	52000000 	eor	w0, w0, #0x1
    a000e7b8:	12001c00 	and	w0, w0, #0xff
    a000e7bc:	7100001f 	cmp	w0, #0x0
    a000e7c0:	54000160 	b.eq	a000e7ec <pl011_irq_tx_ready+0x58>  // b.none
    a000e7c4:	f9400fe0 	ldr	x0, [sp, #24]
    a000e7c8:	f9400400 	ldr	x0, [x0, #8]
    a000e7cc:	f9400000 	ldr	x0, [x0]
    a000e7d0:	b9403000 	ldr	w0, [x0, #48]
    a000e7d4:	2a0003e0 	mov	w0, w0
    a000e7d8:	92780000 	and	x0, x0, #0x100
    a000e7dc:	f100001f 	cmp	x0, #0x0
    a000e7e0:	54000061 	b.ne	a000e7ec <pl011_irq_tx_ready+0x58>  // b.any
		return false;
    a000e7e4:	52800000 	mov	w0, #0x0                   	// #0
    a000e7e8:	14000010 	b	a000e828 <pl011_irq_tx_ready+0x94>

	return ((PL011_REGS(dev)->imsc & PL011_IMSC_TXIM) &&
    a000e7ec:	f9400fe0 	ldr	x0, [sp, #24]
    a000e7f0:	f9400400 	ldr	x0, [x0, #8]
    a000e7f4:	f9400000 	ldr	x0, [x0]
    a000e7f8:	b9403800 	ldr	w0, [x0, #56]
    a000e7fc:	2a0003e0 	mov	w0, w0
    a000e800:	927b0000 	and	x0, x0, #0x20
    a000e804:	f100001f 	cmp	x0, #0x0
    a000e808:	540000e0 	b.eq	a000e824 <pl011_irq_tx_ready+0x90>  // b.none
		pl011_irq_tx_complete(dev));
    a000e80c:	f9400fe0 	ldr	x0, [sp, #24]
    a000e810:	97ffffd8 	bl	a000e770 <pl011_irq_tx_complete>
	return ((PL011_REGS(dev)->imsc & PL011_IMSC_TXIM) &&
    a000e814:	7100001f 	cmp	w0, #0x0
    a000e818:	54000060 	b.eq	a000e824 <pl011_irq_tx_ready+0x90>  // b.none
    a000e81c:	52800020 	mov	w0, #0x1                   	// #1
    a000e820:	14000002 	b	a000e828 <pl011_irq_tx_ready+0x94>
    a000e824:	52800000 	mov	w0, #0x0                   	// #0
}
    a000e828:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a000e82c:	d65f03c0 	ret

00000000a000e830 <pl011_irq_rx_enable>:

static void pl011_irq_rx_enable(const struct device *dev)
{
    a000e830:	d10043ff 	sub	sp, sp, #0x10
    a000e834:	f90007e0 	str	x0, [sp, #8]
	PL011_REGS(dev)->imsc |= PL011_IMSC_RXIM |
    a000e838:	f94007e0 	ldr	x0, [sp, #8]
    a000e83c:	f9400400 	ldr	x0, [x0, #8]
    a000e840:	f9400000 	ldr	x0, [x0]
    a000e844:	b9403802 	ldr	w2, [x0, #56]
    a000e848:	f94007e0 	ldr	x0, [sp, #8]
    a000e84c:	f9400400 	ldr	x0, [x0, #8]
    a000e850:	f9400000 	ldr	x0, [x0]
    a000e854:	52800a01 	mov	w1, #0x50                  	// #80
    a000e858:	2a010041 	orr	w1, w2, w1
    a000e85c:	b9003801 	str	w1, [x0, #56]
				 PL011_IMSC_RTIM;
}
    a000e860:	d503201f 	nop
    a000e864:	910043ff 	add	sp, sp, #0x10
    a000e868:	d65f03c0 	ret

00000000a000e86c <pl011_irq_rx_disable>:

static void pl011_irq_rx_disable(const struct device *dev)
{
    a000e86c:	d10043ff 	sub	sp, sp, #0x10
    a000e870:	f90007e0 	str	x0, [sp, #8]
	PL011_REGS(dev)->imsc &= ~(PL011_IMSC_RXIM |
    a000e874:	f94007e0 	ldr	x0, [sp, #8]
    a000e878:	f9400400 	ldr	x0, [x0, #8]
    a000e87c:	f9400000 	ldr	x0, [x0]
    a000e880:	b9403802 	ldr	w2, [x0, #56]
    a000e884:	f94007e0 	ldr	x0, [sp, #8]
    a000e888:	f9400400 	ldr	x0, [x0, #8]
    a000e88c:	f9400000 	ldr	x0, [x0]
    a000e890:	12800a01 	mov	w1, #0xffffffaf            	// #-81
    a000e894:	0a010041 	and	w1, w2, w1
    a000e898:	b9003801 	str	w1, [x0, #56]
				   PL011_IMSC_RTIM);
}
    a000e89c:	d503201f 	nop
    a000e8a0:	910043ff 	add	sp, sp, #0x10
    a000e8a4:	d65f03c0 	ret

00000000a000e8a8 <pl011_irq_rx_ready>:

static int pl011_irq_rx_ready(const struct device *dev)
{
    a000e8a8:	d10083ff 	sub	sp, sp, #0x20
    a000e8ac:	f90007e0 	str	x0, [sp, #8]
	struct pl011_data *data = dev->data;
    a000e8b0:	f94007e0 	ldr	x0, [sp, #8]
    a000e8b4:	f9401000 	ldr	x0, [x0, #32]
    a000e8b8:	f9000fe0 	str	x0, [sp, #24]

	if (!data->sbsa && !(PL011_REGS(dev)->cr & PL011_CR_RXE))
    a000e8bc:	f9400fe0 	ldr	x0, [sp, #24]
    a000e8c0:	39401000 	ldrb	w0, [x0, #4]
    a000e8c4:	52000000 	eor	w0, w0, #0x1
    a000e8c8:	12001c00 	and	w0, w0, #0xff
    a000e8cc:	7100001f 	cmp	w0, #0x0
    a000e8d0:	54000160 	b.eq	a000e8fc <pl011_irq_rx_ready+0x54>  // b.none
    a000e8d4:	f94007e0 	ldr	x0, [sp, #8]
    a000e8d8:	f9400400 	ldr	x0, [x0, #8]
    a000e8dc:	f9400000 	ldr	x0, [x0]
    a000e8e0:	b9403000 	ldr	w0, [x0, #48]
    a000e8e4:	2a0003e0 	mov	w0, w0
    a000e8e8:	92770000 	and	x0, x0, #0x200
    a000e8ec:	f100001f 	cmp	x0, #0x0
    a000e8f0:	54000061 	b.ne	a000e8fc <pl011_irq_rx_ready+0x54>  // b.any
		return false;
    a000e8f4:	52800000 	mov	w0, #0x0                   	// #0
    a000e8f8:	14000014 	b	a000e948 <pl011_irq_rx_ready+0xa0>

	return ((PL011_REGS(dev)->imsc & PL011_IMSC_RXIM) &&
    a000e8fc:	f94007e0 	ldr	x0, [sp, #8]
    a000e900:	f9400400 	ldr	x0, [x0, #8]
    a000e904:	f9400000 	ldr	x0, [x0]
    a000e908:	b9403800 	ldr	w0, [x0, #56]
    a000e90c:	2a0003e0 	mov	w0, w0
    a000e910:	927c0000 	and	x0, x0, #0x10
    a000e914:	f100001f 	cmp	x0, #0x0
    a000e918:	54000160 	b.eq	a000e944 <pl011_irq_rx_ready+0x9c>  // b.none
		(!(PL011_REGS(dev)->fr & PL011_FR_RXFE)));
    a000e91c:	f94007e0 	ldr	x0, [sp, #8]
    a000e920:	f9400400 	ldr	x0, [x0, #8]
    a000e924:	f9400000 	ldr	x0, [x0]
    a000e928:	b9401800 	ldr	w0, [x0, #24]
    a000e92c:	2a0003e0 	mov	w0, w0
    a000e930:	927c0000 	and	x0, x0, #0x10
	return ((PL011_REGS(dev)->imsc & PL011_IMSC_RXIM) &&
    a000e934:	f100001f 	cmp	x0, #0x0
    a000e938:	54000061 	b.ne	a000e944 <pl011_irq_rx_ready+0x9c>  // b.any
    a000e93c:	52800020 	mov	w0, #0x1                   	// #1
    a000e940:	14000002 	b	a000e948 <pl011_irq_rx_ready+0xa0>
    a000e944:	52800000 	mov	w0, #0x0                   	// #0
}
    a000e948:	910083ff 	add	sp, sp, #0x20
    a000e94c:	d65f03c0 	ret

00000000a000e950 <pl011_irq_err_enable>:

static void pl011_irq_err_enable(const struct device *dev)
{
    a000e950:	d10043ff 	sub	sp, sp, #0x10
    a000e954:	f90007e0 	str	x0, [sp, #8]
	/* enable framing, parity, break, and overrun */
	PL011_REGS(dev)->imsc |= PL011_IMSC_ERROR_MASK;
    a000e958:	f94007e0 	ldr	x0, [sp, #8]
    a000e95c:	f9400400 	ldr	x0, [x0, #8]
    a000e960:	f9400000 	ldr	x0, [x0]
    a000e964:	b9403801 	ldr	w1, [x0, #56]
    a000e968:	f94007e0 	ldr	x0, [sp, #8]
    a000e96c:	f9400400 	ldr	x0, [x0, #8]
    a000e970:	f9400000 	ldr	x0, [x0]
    a000e974:	32190c21 	orr	w1, w1, #0x780
    a000e978:	b9003801 	str	w1, [x0, #56]
}
    a000e97c:	d503201f 	nop
    a000e980:	910043ff 	add	sp, sp, #0x10
    a000e984:	d65f03c0 	ret

00000000a000e988 <pl011_irq_err_disable>:

static void pl011_irq_err_disable(const struct device *dev)
{
    a000e988:	d10043ff 	sub	sp, sp, #0x10
    a000e98c:	f90007e0 	str	x0, [sp, #8]
	PL011_REGS(dev)->imsc &= ~PL011_IMSC_ERROR_MASK;
    a000e990:	f94007e0 	ldr	x0, [sp, #8]
    a000e994:	f9400400 	ldr	x0, [x0, #8]
    a000e998:	f9400000 	ldr	x0, [x0]
    a000e99c:	b9403801 	ldr	w1, [x0, #56]
    a000e9a0:	f94007e0 	ldr	x0, [sp, #8]
    a000e9a4:	f9400400 	ldr	x0, [x0, #8]
    a000e9a8:	f9400000 	ldr	x0, [x0]
    a000e9ac:	12156c21 	and	w1, w1, #0xfffff87f
    a000e9b0:	b9003801 	str	w1, [x0, #56]
}
    a000e9b4:	d503201f 	nop
    a000e9b8:	910043ff 	add	sp, sp, #0x10
    a000e9bc:	d65f03c0 	ret

00000000a000e9c0 <pl011_irq_is_pending>:

static int pl011_irq_is_pending(const struct device *dev)
{
    a000e9c0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a000e9c4:	910003fd 	mov	x29, sp
    a000e9c8:	f9000fe0 	str	x0, [sp, #24]
	return pl011_irq_rx_ready(dev) || pl011_irq_tx_ready(dev);
    a000e9cc:	f9400fe0 	ldr	x0, [sp, #24]
    a000e9d0:	97ffffb6 	bl	a000e8a8 <pl011_irq_rx_ready>
    a000e9d4:	7100001f 	cmp	w0, #0x0
    a000e9d8:	540000a1 	b.ne	a000e9ec <pl011_irq_is_pending+0x2c>  // b.any
    a000e9dc:	f9400fe0 	ldr	x0, [sp, #24]
    a000e9e0:	97ffff6d 	bl	a000e794 <pl011_irq_tx_ready>
    a000e9e4:	7100001f 	cmp	w0, #0x0
    a000e9e8:	54000060 	b.eq	a000e9f4 <pl011_irq_is_pending+0x34>  // b.none
    a000e9ec:	52800020 	mov	w0, #0x1                   	// #1
    a000e9f0:	14000002 	b	a000e9f8 <pl011_irq_is_pending+0x38>
    a000e9f4:	52800000 	mov	w0, #0x0                   	// #0
}
    a000e9f8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a000e9fc:	d65f03c0 	ret

00000000a000ea00 <pl011_irq_update>:

static int pl011_irq_update(const struct device *dev)
{
    a000ea00:	d10043ff 	sub	sp, sp, #0x10
    a000ea04:	f90007e0 	str	x0, [sp, #8]
	return 1;
    a000ea08:	52800020 	mov	w0, #0x1                   	// #1
}
    a000ea0c:	910043ff 	add	sp, sp, #0x10
    a000ea10:	d65f03c0 	ret

00000000a000ea14 <pl011_irq_callback_set>:

static void pl011_irq_callback_set(const struct device *dev,
					    uart_irq_callback_user_data_t cb,
					    void *cb_data)
{
    a000ea14:	d100c3ff 	sub	sp, sp, #0x30
    a000ea18:	f9000fe0 	str	x0, [sp, #24]
    a000ea1c:	f9000be1 	str	x1, [sp, #16]
    a000ea20:	f90007e2 	str	x2, [sp, #8]
	struct pl011_data *data = dev->data;
    a000ea24:	f9400fe0 	ldr	x0, [sp, #24]
    a000ea28:	f9401000 	ldr	x0, [x0, #32]
    a000ea2c:	f90017e0 	str	x0, [sp, #40]

	data->irq_cb = cb;
    a000ea30:	f94017e0 	ldr	x0, [sp, #40]
    a000ea34:	f9400be1 	ldr	x1, [sp, #16]
    a000ea38:	f9000401 	str	x1, [x0, #8]
	data->irq_cb_data = cb_data;
    a000ea3c:	f94017e0 	ldr	x0, [sp, #40]
    a000ea40:	f94007e1 	ldr	x1, [sp, #8]
    a000ea44:	f9000801 	str	x1, [x0, #16]
}
    a000ea48:	d503201f 	nop
    a000ea4c:	9100c3ff 	add	sp, sp, #0x30
    a000ea50:	d65f03c0 	ret

00000000a000ea54 <pl011_init>:
	.irq_callback_set = pl011_irq_callback_set,
#endif /* CONFIG_UART_INTERRUPT_DRIVEN */
};

static int pl011_init(const struct device *dev)
{
    a000ea54:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    a000ea58:	910003fd 	mov	x29, sp
    a000ea5c:	f9000fe0 	str	x0, [sp, #24]
	const struct uart_device_config *config = dev->config;
    a000ea60:	f9400fe0 	ldr	x0, [sp, #24]
    a000ea64:	f9400400 	ldr	x0, [x0, #8]
    a000ea68:	f9001fe0 	str	x0, [sp, #56]
	struct pl011_data *data = dev->data;
    a000ea6c:	f9400fe0 	ldr	x0, [sp, #24]
    a000ea70:	f9401000 	ldr	x0, [x0, #32]
    a000ea74:	f9001be0 	str	x0, [sp, #48]
	/*
	 * If working in SBSA mode, we assume that UART is already configured,
	 * or does not require configuration at all (if UART is emulated by
	 * virtualization software).
	 */
	if (!data->sbsa) {
    a000ea78:	f9401be0 	ldr	x0, [sp, #48]
    a000ea7c:	39401000 	ldrb	w0, [x0, #4]
    a000ea80:	52000000 	eor	w0, w0, #0x1
    a000ea84:	12001c00 	and	w0, w0, #0xff
    a000ea88:	7100001f 	cmp	w0, #0x0
    a000ea8c:	540004e0 	b.eq	a000eb28 <pl011_init+0xd4>  // b.none
		/* disable the uart */
		pl011_disable(dev);
    a000ea90:	f9400fe0 	ldr	x0, [sp, #24]
    a000ea94:	97fffe2a 	bl	a000e33c <pl011_disable>
		pl011_disable_fifo(dev);
    a000ea98:	f9400fe0 	ldr	x0, [sp, #24]
    a000ea9c:	97fffe44 	bl	a000e3ac <pl011_disable_fifo>

		/* Set baud rate */
		ret = pl011_set_baudrate(dev, config->sys_clk_freq,
    a000eaa0:	f9401fe0 	ldr	x0, [sp, #56]
    a000eaa4:	b9400801 	ldr	w1, [x0, #8]
    a000eaa8:	f9401be0 	ldr	x0, [sp, #48]
    a000eaac:	b9400000 	ldr	w0, [x0]
    a000eab0:	2a0003e2 	mov	w2, w0
    a000eab4:	f9400fe0 	ldr	x0, [sp, #24]
    a000eab8:	97fffe4b 	bl	a000e3e4 <pl011_set_baudrate>
    a000eabc:	b9002fe0 	str	w0, [sp, #44]
					 data->baud_rate);
		if (ret != 0) {
    a000eac0:	b9402fe0 	ldr	w0, [sp, #44]
    a000eac4:	7100001f 	cmp	w0, #0x0
    a000eac8:	54000060 	b.eq	a000ead4 <pl011_init+0x80>  // b.none
			return ret;
    a000eacc:	b9402fe0 	ldr	w0, [sp, #44]
    a000ead0:	1400004b 	b	a000ebfc <pl011_init+0x1a8>
		}

		/* Setting the default character format */
		lcrh = PL011_REGS(dev)->lcr_h & ~(PL011_LCRH_FORMAT_MASK);
    a000ead4:	f9400fe0 	ldr	x0, [sp, #24]
    a000ead8:	f9400400 	ldr	x0, [x0, #8]
    a000eadc:	f9400000 	ldr	x0, [x0]
    a000eae0:	b9402c01 	ldr	w1, [x0, #44]
    a000eae4:	12801cc0 	mov	w0, #0xffffff19            	// #-231
    a000eae8:	0a000020 	and	w0, w1, w0
    a000eaec:	b9002be0 	str	w0, [sp, #40]
		lcrh &= ~(BIT(0) | BIT(7));
    a000eaf0:	b9402be1 	ldr	w1, [sp, #40]
    a000eaf4:	12801020 	mov	w0, #0xffffff7e            	// #-130
    a000eaf8:	0a000020 	and	w0, w1, w0
    a000eafc:	b9002be0 	str	w0, [sp, #40]
		lcrh |= PL011_LCRH_WLEN_SIZE(8) << PL011_LCRH_WLEN_SHIFT;
    a000eb00:	b9402be0 	ldr	w0, [sp, #40]
    a000eb04:	321b0400 	orr	w0, w0, #0x60
    a000eb08:	b9002be0 	str	w0, [sp, #40]
		PL011_REGS(dev)->lcr_h = lcrh;
    a000eb0c:	f9400fe0 	ldr	x0, [sp, #24]
    a000eb10:	f9400400 	ldr	x0, [x0, #8]
    a000eb14:	f9400000 	ldr	x0, [x0]
    a000eb18:	b9402be1 	ldr	w1, [sp, #40]
    a000eb1c:	b9002c01 	str	w1, [x0, #44]

		/* Enabling the FIFOs */
		pl011_enable_fifo(dev);
    a000eb20:	f9400fe0 	ldr	x0, [sp, #24]
    a000eb24:	97fffe14 	bl	a000e374 <pl011_enable_fifo>
	}
	/* initialize all IRQs as masked */
	PL011_REGS(dev)->imsc = 0U;
    a000eb28:	f9400fe0 	ldr	x0, [sp, #24]
    a000eb2c:	f9400400 	ldr	x0, [x0, #8]
    a000eb30:	f9400000 	ldr	x0, [x0]
    a000eb34:	b900381f 	str	wzr, [x0, #56]
	PL011_REGS(dev)->icr = PL011_IMSC_MASK_ALL;
    a000eb38:	f9400fe0 	ldr	x0, [sp, #24]
    a000eb3c:	f9400400 	ldr	x0, [x0, #8]
    a000eb40:	f9400000 	ldr	x0, [x0]
    a000eb44:	5280ffe1 	mov	w1, #0x7ff                 	// #2047
    a000eb48:	b9004401 	str	w1, [x0, #68]

	if (!data->sbsa) {
    a000eb4c:	f9401be0 	ldr	x0, [sp, #48]
    a000eb50:	39401000 	ldrb	w0, [x0, #4]
    a000eb54:	52000000 	eor	w0, w0, #0x1
    a000eb58:	12001c00 	and	w0, w0, #0xff
    a000eb5c:	7100001f 	cmp	w0, #0x0
    a000eb60:	54000340 	b.eq	a000ebc8 <pl011_init+0x174>  // b.none
		PL011_REGS(dev)->dmacr = 0U;
    a000eb64:	f9400fe0 	ldr	x0, [sp, #24]
    a000eb68:	f9400400 	ldr	x0, [x0, #8]
    a000eb6c:	f9400000 	ldr	x0, [x0]
    a000eb70:	b900481f 	str	wzr, [x0, #72]
		__ISB();
    a000eb74:	d5033fdf 	isb
		PL011_REGS(dev)->cr &= ~(BIT(14) | BIT(15) | BIT(1));
    a000eb78:	f9400fe0 	ldr	x0, [sp, #24]
    a000eb7c:	f9400400 	ldr	x0, [x0, #8]
    a000eb80:	f9400000 	ldr	x0, [x0]
    a000eb84:	b9403002 	ldr	w2, [x0, #48]
    a000eb88:	f9400fe0 	ldr	x0, [sp, #24]
    a000eb8c:	f9400400 	ldr	x0, [x0, #8]
    a000eb90:	f9400000 	ldr	x0, [x0]
    a000eb94:	12980041 	mov	w1, #0xffff3ffd            	// #-49155
    a000eb98:	0a010041 	and	w1, w2, w1
    a000eb9c:	b9003001 	str	w1, [x0, #48]
		PL011_REGS(dev)->cr |= PL011_CR_RXE | PL011_CR_TXE;
    a000eba0:	f9400fe0 	ldr	x0, [sp, #24]
    a000eba4:	f9400400 	ldr	x0, [x0, #8]
    a000eba8:	f9400000 	ldr	x0, [x0]
    a000ebac:	b9403001 	ldr	w1, [x0, #48]
    a000ebb0:	f9400fe0 	ldr	x0, [sp, #24]
    a000ebb4:	f9400400 	ldr	x0, [x0, #8]
    a000ebb8:	f9400000 	ldr	x0, [x0]
    a000ebbc:	32180421 	orr	w1, w1, #0x300
    a000ebc0:	b9003001 	str	w1, [x0, #48]
		__ISB();
    a000ebc4:	d5033fdf 	isb
	}
#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	config->irq_config_func(dev);
    a000ebc8:	f9401fe0 	ldr	x0, [sp, #56]
    a000ebcc:	f9400801 	ldr	x1, [x0, #16]
    a000ebd0:	f9400fe0 	ldr	x0, [sp, #24]
    a000ebd4:	d63f0020 	blr	x1
#endif
	if (!data->sbsa)
    a000ebd8:	f9401be0 	ldr	x0, [sp, #48]
    a000ebdc:	39401000 	ldrb	w0, [x0, #4]
    a000ebe0:	52000000 	eor	w0, w0, #0x1
    a000ebe4:	12001c00 	and	w0, w0, #0xff
    a000ebe8:	7100001f 	cmp	w0, #0x0
    a000ebec:	54000060 	b.eq	a000ebf8 <pl011_init+0x1a4>  // b.none
		pl011_enable(dev);
    a000ebf0:	f9400fe0 	ldr	x0, [sp, #24]
    a000ebf4:	97fffdc4 	bl	a000e304 <pl011_enable>

	return 0;
    a000ebf8:	52800000 	mov	w0, #0x0                   	// #0
}
    a000ebfc:	a8c47bfd 	ldp	x29, x30, [sp], #64
    a000ec00:	d65f03c0 	ret

00000000a000ec04 <pl011_isr>:

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
void pl011_isr(const struct device *dev)
{
    a000ec04:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a000ec08:	910003fd 	mov	x29, sp
    a000ec0c:	f9000fe0 	str	x0, [sp, #24]
	struct pl011_data *data = dev->data;
    a000ec10:	f9400fe0 	ldr	x0, [sp, #24]
    a000ec14:	f9401000 	ldr	x0, [x0, #32]
    a000ec18:	f90017e0 	str	x0, [sp, #40]

	/* Verify if the callback has been registered */
	if (data->irq_cb) {
    a000ec1c:	f94017e0 	ldr	x0, [sp, #40]
    a000ec20:	f9400400 	ldr	x0, [x0, #8]
    a000ec24:	f100001f 	cmp	x0, #0x0
    a000ec28:	54000100 	b.eq	a000ec48 <pl011_isr+0x44>  // b.none
		data->irq_cb(dev, data->irq_cb_data);
    a000ec2c:	f94017e0 	ldr	x0, [sp, #40]
    a000ec30:	f9400402 	ldr	x2, [x0, #8]
    a000ec34:	f94017e0 	ldr	x0, [sp, #40]
    a000ec38:	f9400800 	ldr	x0, [x0, #16]
    a000ec3c:	aa0003e1 	mov	x1, x0
    a000ec40:	f9400fe0 	ldr	x0, [sp, #24]
    a000ec44:	d63f0040 	blr	x2
	}
}
    a000ec48:	d503201f 	nop
    a000ec4c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a000ec50:	d65f03c0 	ret

00000000a000ec54 <pl011_irq_config_func_0>:
		    CONFIG_SERIAL_INIT_PRIORITY,
		    &pl011_driver_api);

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
static void pl011_irq_config_func_0(const struct device *dev)
{
    a000ec54:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a000ec58:	910003fd 	mov	x29, sp
    a000ec5c:	f9000fe0 	str	x0, [sp, #24]
#if DT_NUM_IRQS(DT_INST(0, arm_pl011)) == 1
	IRQ_CONNECT(DT_INST_IRQN(0),
    a000ec60:	52800002 	mov	w2, #0x0                   	// #0
    a000ec64:	52800001 	mov	w1, #0x0                   	// #0
    a000ec68:	52800420 	mov	w0, #0x21                  	// #33
    a000ec6c:	97ffe94b 	bl	a0009198 <z_arm64_irq_priority_set>
		    DT_INST_IRQ(0, priority),
		    pl011_isr,
		    DEVICE_DT_INST_GET(0),
		    0);
	irq_enable(DT_INST_IRQN(0));
    a000ec70:	52800420 	mov	w0, #0x21                  	// #33
    a000ec74:	97ffe941 	bl	a0009178 <arch_irq_enable>
		    pl011_isr,
		    DEVICE_DT_INST_GET(0),
		    0);
	irq_enable(DT_INST_IRQ_BY_NAME(0, rxtim, irq));
#endif
}
    a000ec78:	d503201f 	nop
    a000ec7c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a000ec80:	d65f03c0 	ret

00000000a000ec84 <z_impl_uart_err_check>:
{
    a000ec84:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a000ec88:	910003fd 	mov	x29, sp
    a000ec8c:	f9000fe0 	str	x0, [sp, #24]
	const struct uart_driver_api *api =
    a000ec90:	f9400fe0 	ldr	x0, [sp, #24]
    a000ec94:	f9400800 	ldr	x0, [x0, #16]
    a000ec98:	f90017e0 	str	x0, [sp, #40]
	if (api->err_check == NULL) {
    a000ec9c:	f94017e0 	ldr	x0, [sp, #40]
    a000eca0:	f9400800 	ldr	x0, [x0, #16]
    a000eca4:	f100001f 	cmp	x0, #0x0
    a000eca8:	54000061 	b.ne	a000ecb4 <z_impl_uart_err_check+0x30>  // b.any
		return -ENOSYS;
    a000ecac:	12800ae0 	mov	w0, #0xffffffa8            	// #-88
    a000ecb0:	14000005 	b	a000ecc4 <z_impl_uart_err_check+0x40>
	return api->err_check(dev);
    a000ecb4:	f94017e0 	ldr	x0, [sp, #40]
    a000ecb8:	f9400801 	ldr	x1, [x0, #16]
    a000ecbc:	f9400fe0 	ldr	x0, [sp, #24]
    a000ecc0:	d63f0020 	blr	x1
}
    a000ecc4:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a000ecc8:	d65f03c0 	ret

00000000a000eccc <z_impl_uart_poll_in>:
{
    a000eccc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a000ecd0:	910003fd 	mov	x29, sp
    a000ecd4:	f9000fe0 	str	x0, [sp, #24]
    a000ecd8:	f9000be1 	str	x1, [sp, #16]
	const struct uart_driver_api *api =
    a000ecdc:	f9400fe0 	ldr	x0, [sp, #24]
    a000ece0:	f9400800 	ldr	x0, [x0, #16]
    a000ece4:	f90017e0 	str	x0, [sp, #40]
	if (api->poll_in == NULL) {
    a000ece8:	f94017e0 	ldr	x0, [sp, #40]
    a000ecec:	f9400000 	ldr	x0, [x0]
    a000ecf0:	f100001f 	cmp	x0, #0x0
    a000ecf4:	54000061 	b.ne	a000ed00 <z_impl_uart_poll_in+0x34>  // b.any
		return -ENOSYS;
    a000ecf8:	12800ae0 	mov	w0, #0xffffffa8            	// #-88
    a000ecfc:	14000006 	b	a000ed14 <z_impl_uart_poll_in+0x48>
	return api->poll_in(dev, p_char);
    a000ed00:	f94017e0 	ldr	x0, [sp, #40]
    a000ed04:	f9400002 	ldr	x2, [x0]
    a000ed08:	f9400be1 	ldr	x1, [sp, #16]
    a000ed0c:	f9400fe0 	ldr	x0, [sp, #24]
    a000ed10:	d63f0040 	blr	x2
}
    a000ed14:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a000ed18:	d65f03c0 	ret

00000000a000ed1c <z_impl_uart_poll_in_u16>:
{
    a000ed1c:	d10043ff 	sub	sp, sp, #0x10
    a000ed20:	f90007e0 	str	x0, [sp, #8]
    a000ed24:	f90003e1 	str	x1, [sp]
	return -ENOTSUP;
    a000ed28:	128010a0 	mov	w0, #0xffffff7a            	// #-134
}
    a000ed2c:	910043ff 	add	sp, sp, #0x10
    a000ed30:	d65f03c0 	ret

00000000a000ed34 <z_impl_uart_poll_out>:
{
    a000ed34:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a000ed38:	910003fd 	mov	x29, sp
    a000ed3c:	f9000fe0 	str	x0, [sp, #24]
    a000ed40:	39005fe1 	strb	w1, [sp, #23]
	const struct uart_driver_api *api =
    a000ed44:	f9400fe0 	ldr	x0, [sp, #24]
    a000ed48:	f9400800 	ldr	x0, [x0, #16]
    a000ed4c:	f90017e0 	str	x0, [sp, #40]
	api->poll_out(dev, out_char);
    a000ed50:	f94017e0 	ldr	x0, [sp, #40]
    a000ed54:	f9400402 	ldr	x2, [x0, #8]
    a000ed58:	39405fe1 	ldrb	w1, [sp, #23]
    a000ed5c:	f9400fe0 	ldr	x0, [sp, #24]
    a000ed60:	d63f0040 	blr	x2
}
    a000ed64:	d503201f 	nop
    a000ed68:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a000ed6c:	d65f03c0 	ret

00000000a000ed70 <z_impl_uart_poll_out_u16>:
 */
__syscall void uart_poll_out_u16(const struct device *dev, uint16_t out_u16);

static inline void z_impl_uart_poll_out_u16(const struct device *dev,
					    uint16_t out_u16)
{
    a000ed70:	d10043ff 	sub	sp, sp, #0x10
    a000ed74:	f90007e0 	str	x0, [sp, #8]
    a000ed78:	79000fe1 	strh	w1, [sp, #6]
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	api->poll_out_u16(dev, out_u16);
#endif
}
    a000ed7c:	d503201f 	nop
    a000ed80:	910043ff 	add	sp, sp, #0x10
    a000ed84:	d65f03c0 	ret

00000000a000ed88 <z_impl_uart_configure>:
__syscall int uart_configure(const struct device *dev,
			     const struct uart_config *cfg);

static inline int z_impl_uart_configure(const struct device *dev,
					const struct uart_config *cfg)
{
    a000ed88:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a000ed8c:	910003fd 	mov	x29, sp
    a000ed90:	f9000fe0 	str	x0, [sp, #24]
    a000ed94:	f9000be1 	str	x1, [sp, #16]
	const struct uart_driver_api *api =
    a000ed98:	f9400fe0 	ldr	x0, [sp, #24]
    a000ed9c:	f9400800 	ldr	x0, [x0, #16]
    a000eda0:	f90017e0 	str	x0, [sp, #40]
				(const struct uart_driver_api *)dev->api;

	if (api->configure == NULL) {
    a000eda4:	f94017e0 	ldr	x0, [sp, #40]
    a000eda8:	f9400c00 	ldr	x0, [x0, #24]
    a000edac:	f100001f 	cmp	x0, #0x0
    a000edb0:	54000061 	b.ne	a000edbc <z_impl_uart_configure+0x34>  // b.any
		return -ENOSYS;
    a000edb4:	12800ae0 	mov	w0, #0xffffffa8            	// #-88
    a000edb8:	14000006 	b	a000edd0 <z_impl_uart_configure+0x48>
	}
	return api->configure(dev, cfg);
    a000edbc:	f94017e0 	ldr	x0, [sp, #40]
    a000edc0:	f9400c02 	ldr	x2, [x0, #24]
    a000edc4:	f9400be1 	ldr	x1, [sp, #16]
    a000edc8:	f9400fe0 	ldr	x0, [sp, #24]
    a000edcc:	d63f0040 	blr	x2
}
    a000edd0:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a000edd4:	d65f03c0 	ret

00000000a000edd8 <z_impl_uart_config_get>:
__syscall int uart_config_get(const struct device *dev,
			      struct uart_config *cfg);

static inline int z_impl_uart_config_get(const struct device *dev,
					 struct uart_config *cfg)
{
    a000edd8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a000eddc:	910003fd 	mov	x29, sp
    a000ede0:	f9000fe0 	str	x0, [sp, #24]
    a000ede4:	f9000be1 	str	x1, [sp, #16]
	const struct uart_driver_api *api =
    a000ede8:	f9400fe0 	ldr	x0, [sp, #24]
    a000edec:	f9400800 	ldr	x0, [x0, #16]
    a000edf0:	f90017e0 	str	x0, [sp, #40]
				(const struct uart_driver_api *)dev->api;

	if (api->config_get == NULL) {
    a000edf4:	f94017e0 	ldr	x0, [sp, #40]
    a000edf8:	f9401000 	ldr	x0, [x0, #32]
    a000edfc:	f100001f 	cmp	x0, #0x0
    a000ee00:	54000061 	b.ne	a000ee0c <z_impl_uart_config_get+0x34>  // b.any
		return -ENOSYS;
    a000ee04:	12800ae0 	mov	w0, #0xffffffa8            	// #-88
    a000ee08:	14000006 	b	a000ee20 <z_impl_uart_config_get+0x48>
	}

	return api->config_get(dev, cfg);
    a000ee0c:	f94017e0 	ldr	x0, [sp, #40]
    a000ee10:	f9401002 	ldr	x2, [x0, #32]
    a000ee14:	f9400be1 	ldr	x1, [sp, #16]
    a000ee18:	f9400fe0 	ldr	x0, [sp, #24]
    a000ee1c:	d63f0040 	blr	x2
}
    a000ee20:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a000ee24:	d65f03c0 	ret

00000000a000ee28 <z_impl_uart_irq_tx_enable>:
 * @param dev UART device instance.
 */
__syscall void uart_irq_tx_enable(const struct device *dev);

static inline void z_impl_uart_irq_tx_enable(const struct device *dev)
{
    a000ee28:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a000ee2c:	910003fd 	mov	x29, sp
    a000ee30:	f9000fe0 	str	x0, [sp, #24]
#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	const struct uart_driver_api *api =
    a000ee34:	f9400fe0 	ldr	x0, [sp, #24]
    a000ee38:	f9400800 	ldr	x0, [x0, #16]
    a000ee3c:	f90017e0 	str	x0, [sp, #40]
		(const struct uart_driver_api *)dev->api;

	if (api->irq_tx_enable != NULL) {
    a000ee40:	f94017e0 	ldr	x0, [sp, #40]
    a000ee44:	f9401c00 	ldr	x0, [x0, #56]
    a000ee48:	f100001f 	cmp	x0, #0x0
    a000ee4c:	540000a0 	b.eq	a000ee60 <z_impl_uart_irq_tx_enable+0x38>  // b.none
		api->irq_tx_enable(dev);
    a000ee50:	f94017e0 	ldr	x0, [sp, #40]
    a000ee54:	f9401c01 	ldr	x1, [x0, #56]
    a000ee58:	f9400fe0 	ldr	x0, [sp, #24]
    a000ee5c:	d63f0020 	blr	x1
	}
#endif
}
    a000ee60:	d503201f 	nop
    a000ee64:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a000ee68:	d65f03c0 	ret

00000000a000ee6c <z_impl_uart_irq_tx_disable>:
 * @param dev UART device instance.
 */
__syscall void uart_irq_tx_disable(const struct device *dev);

static inline void z_impl_uart_irq_tx_disable(const struct device *dev)
{
    a000ee6c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a000ee70:	910003fd 	mov	x29, sp
    a000ee74:	f9000fe0 	str	x0, [sp, #24]
#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	const struct uart_driver_api *api =
    a000ee78:	f9400fe0 	ldr	x0, [sp, #24]
    a000ee7c:	f9400800 	ldr	x0, [x0, #16]
    a000ee80:	f90017e0 	str	x0, [sp, #40]
		(const struct uart_driver_api *)dev->api;

	if (api->irq_tx_disable != NULL) {
    a000ee84:	f94017e0 	ldr	x0, [sp, #40]
    a000ee88:	f9402000 	ldr	x0, [x0, #64]
    a000ee8c:	f100001f 	cmp	x0, #0x0
    a000ee90:	540000a0 	b.eq	a000eea4 <z_impl_uart_irq_tx_disable+0x38>  // b.none
		api->irq_tx_disable(dev);
    a000ee94:	f94017e0 	ldr	x0, [sp, #40]
    a000ee98:	f9402001 	ldr	x1, [x0, #64]
    a000ee9c:	f9400fe0 	ldr	x0, [sp, #24]
    a000eea0:	d63f0020 	blr	x1
	}
#endif
}
    a000eea4:	d503201f 	nop
    a000eea8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a000eeac:	d65f03c0 	ret

00000000a000eeb0 <z_impl_uart_irq_rx_enable>:
 * @param dev UART device instance.
 */
__syscall void uart_irq_rx_enable(const struct device *dev);

static inline void z_impl_uart_irq_rx_enable(const struct device *dev)
{
    a000eeb0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a000eeb4:	910003fd 	mov	x29, sp
    a000eeb8:	f9000fe0 	str	x0, [sp, #24]
#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	const struct uart_driver_api *api =
    a000eebc:	f9400fe0 	ldr	x0, [sp, #24]
    a000eec0:	f9400800 	ldr	x0, [x0, #16]
    a000eec4:	f90017e0 	str	x0, [sp, #40]
		(const struct uart_driver_api *)dev->api;

	if (api->irq_rx_enable != NULL) {
    a000eec8:	f94017e0 	ldr	x0, [sp, #40]
    a000eecc:	f9402800 	ldr	x0, [x0, #80]
    a000eed0:	f100001f 	cmp	x0, #0x0
    a000eed4:	540000a0 	b.eq	a000eee8 <z_impl_uart_irq_rx_enable+0x38>  // b.none
		api->irq_rx_enable(dev);
    a000eed8:	f94017e0 	ldr	x0, [sp, #40]
    a000eedc:	f9402801 	ldr	x1, [x0, #80]
    a000eee0:	f9400fe0 	ldr	x0, [sp, #24]
    a000eee4:	d63f0020 	blr	x1
	}
#endif
}
    a000eee8:	d503201f 	nop
    a000eeec:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a000eef0:	d65f03c0 	ret

00000000a000eef4 <z_impl_uart_irq_rx_disable>:
 * @param dev UART device instance.
 */
__syscall void uart_irq_rx_disable(const struct device *dev);

static inline void z_impl_uart_irq_rx_disable(const struct device *dev)
{
    a000eef4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a000eef8:	910003fd 	mov	x29, sp
    a000eefc:	f9000fe0 	str	x0, [sp, #24]
#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	const struct uart_driver_api *api =
    a000ef00:	f9400fe0 	ldr	x0, [sp, #24]
    a000ef04:	f9400800 	ldr	x0, [x0, #16]
    a000ef08:	f90017e0 	str	x0, [sp, #40]
		(const struct uart_driver_api *)dev->api;

	if (api->irq_rx_disable != NULL) {
    a000ef0c:	f94017e0 	ldr	x0, [sp, #40]
    a000ef10:	f9402c00 	ldr	x0, [x0, #88]
    a000ef14:	f100001f 	cmp	x0, #0x0
    a000ef18:	540000a0 	b.eq	a000ef2c <z_impl_uart_irq_rx_disable+0x38>  // b.none
		api->irq_rx_disable(dev);
    a000ef1c:	f94017e0 	ldr	x0, [sp, #40]
    a000ef20:	f9402c01 	ldr	x1, [x0, #88]
    a000ef24:	f9400fe0 	ldr	x0, [sp, #24]
    a000ef28:	d63f0020 	blr	x1
	}
#endif
}
    a000ef2c:	d503201f 	nop
    a000ef30:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a000ef34:	d65f03c0 	ret

00000000a000ef38 <z_impl_uart_irq_err_enable>:
 * @param dev UART device instance.
 */
__syscall void uart_irq_err_enable(const struct device *dev);

static inline void z_impl_uart_irq_err_enable(const struct device *dev)
{
    a000ef38:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a000ef3c:	910003fd 	mov	x29, sp
    a000ef40:	f9000fe0 	str	x0, [sp, #24]
#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	const struct uart_driver_api *api =
    a000ef44:	f9400fe0 	ldr	x0, [sp, #24]
    a000ef48:	f9400800 	ldr	x0, [x0, #16]
    a000ef4c:	f90017e0 	str	x0, [sp, #40]
		(const struct uart_driver_api *)dev->api;

	if (api->irq_err_enable) {
    a000ef50:	f94017e0 	ldr	x0, [sp, #40]
    a000ef54:	f9403800 	ldr	x0, [x0, #112]
    a000ef58:	f100001f 	cmp	x0, #0x0
    a000ef5c:	540000a0 	b.eq	a000ef70 <z_impl_uart_irq_err_enable+0x38>  // b.none
		api->irq_err_enable(dev);
    a000ef60:	f94017e0 	ldr	x0, [sp, #40]
    a000ef64:	f9403801 	ldr	x1, [x0, #112]
    a000ef68:	f9400fe0 	ldr	x0, [sp, #24]
    a000ef6c:	d63f0020 	blr	x1
	}
#endif
}
    a000ef70:	d503201f 	nop
    a000ef74:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a000ef78:	d65f03c0 	ret

00000000a000ef7c <z_impl_uart_irq_err_disable>:
 * @param dev UART device instance.
 */
__syscall void uart_irq_err_disable(const struct device *dev);

static inline void z_impl_uart_irq_err_disable(const struct device *dev)
{
    a000ef7c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a000ef80:	910003fd 	mov	x29, sp
    a000ef84:	f9000fe0 	str	x0, [sp, #24]
#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	const struct uart_driver_api *api =
    a000ef88:	f9400fe0 	ldr	x0, [sp, #24]
    a000ef8c:	f9400800 	ldr	x0, [x0, #16]
    a000ef90:	f90017e0 	str	x0, [sp, #40]
		(const struct uart_driver_api *)dev->api;

	if (api->irq_err_disable) {
    a000ef94:	f94017e0 	ldr	x0, [sp, #40]
    a000ef98:	f9403c00 	ldr	x0, [x0, #120]
    a000ef9c:	f100001f 	cmp	x0, #0x0
    a000efa0:	540000a0 	b.eq	a000efb4 <z_impl_uart_irq_err_disable+0x38>  // b.none
		api->irq_err_disable(dev);
    a000efa4:	f94017e0 	ldr	x0, [sp, #40]
    a000efa8:	f9403c01 	ldr	x1, [x0, #120]
    a000efac:	f9400fe0 	ldr	x0, [sp, #24]
    a000efb0:	d63f0020 	blr	x1
	}
#endif
}
    a000efb4:	d503201f 	nop
    a000efb8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a000efbc:	d65f03c0 	ret

00000000a000efc0 <z_impl_uart_irq_is_pending>:
 * @retval -ENOTSUP If API is not enabled.
 */
__syscall int uart_irq_is_pending(const struct device *dev);

static inline int z_impl_uart_irq_is_pending(const struct device *dev)
{
    a000efc0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a000efc4:	910003fd 	mov	x29, sp
    a000efc8:	f9000fe0 	str	x0, [sp, #24]
#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	const struct uart_driver_api *api =
    a000efcc:	f9400fe0 	ldr	x0, [sp, #24]
    a000efd0:	f9400800 	ldr	x0, [x0, #16]
    a000efd4:	f90017e0 	str	x0, [sp, #40]
		(const struct uart_driver_api *)dev->api;

	if (api->irq_is_pending == NULL) {
    a000efd8:	f94017e0 	ldr	x0, [sp, #40]
    a000efdc:	f9404000 	ldr	x0, [x0, #128]
    a000efe0:	f100001f 	cmp	x0, #0x0
    a000efe4:	54000061 	b.ne	a000eff0 <z_impl_uart_irq_is_pending+0x30>  // b.any
		return -ENOSYS;
    a000efe8:	12800ae0 	mov	w0, #0xffffffa8            	// #-88
    a000efec:	14000005 	b	a000f000 <z_impl_uart_irq_is_pending+0x40>
	}
	return api->irq_is_pending(dev);
    a000eff0:	f94017e0 	ldr	x0, [sp, #40]
    a000eff4:	f9404001 	ldr	x1, [x0, #128]
    a000eff8:	f9400fe0 	ldr	x0, [sp, #24]
    a000effc:	d63f0020 	blr	x1
#endif
	return -ENOTSUP;
}
    a000f000:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a000f004:	d65f03c0 	ret

00000000a000f008 <z_impl_uart_irq_update>:
 * @retval -ENOTSUP If API is not enabled.
 */
__syscall int uart_irq_update(const struct device *dev);

static inline int z_impl_uart_irq_update(const struct device *dev)
{
    a000f008:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a000f00c:	910003fd 	mov	x29, sp
    a000f010:	f9000fe0 	str	x0, [sp, #24]
#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	const struct uart_driver_api *api =
    a000f014:	f9400fe0 	ldr	x0, [sp, #24]
    a000f018:	f9400800 	ldr	x0, [x0, #16]
    a000f01c:	f90017e0 	str	x0, [sp, #40]
		(const struct uart_driver_api *)dev->api;

	if (api->irq_update == NULL) {
    a000f020:	f94017e0 	ldr	x0, [sp, #40]
    a000f024:	f9404400 	ldr	x0, [x0, #136]
    a000f028:	f100001f 	cmp	x0, #0x0
    a000f02c:	54000061 	b.ne	a000f038 <z_impl_uart_irq_update+0x30>  // b.any
		return -ENOSYS;
    a000f030:	12800ae0 	mov	w0, #0xffffffa8            	// #-88
    a000f034:	14000005 	b	a000f048 <z_impl_uart_irq_update+0x40>
	}
	return api->irq_update(dev);
    a000f038:	f94017e0 	ldr	x0, [sp, #40]
    a000f03c:	f9404401 	ldr	x1, [x0, #136]
    a000f040:	f9400fe0 	ldr	x0, [sp, #24]
    a000f044:	d63f0020 	blr	x1
#endif
	return -ENOTSUP;
}
    a000f048:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a000f04c:	d65f03c0 	ret

00000000a000f050 <z_obj_validation_check>:
{
    a000f050:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    a000f054:	910003fd 	mov	x29, sp
    a000f058:	f90017e0 	str	x0, [sp, #40]
    a000f05c:	f90013e1 	str	x1, [sp, #32]
    a000f060:	b9001fe2 	str	w2, [sp, #28]
    a000f064:	b9001be3 	str	w3, [sp, #24]
	ret = z_object_validate(ko, otype, init);
    a000f068:	b9401be2 	ldr	w2, [sp, #24]
    a000f06c:	b9401fe1 	ldr	w1, [sp, #28]
    a000f070:	f94017e0 	ldr	x0, [sp, #40]
    a000f074:	94003894 	bl	a001d2c4 <z_object_validate>
    a000f078:	b9003fe0 	str	w0, [sp, #60]
	return ret;
    a000f07c:	b9403fe0 	ldr	w0, [sp, #60]
}
    a000f080:	a8c47bfd 	ldp	x29, x30, [sp], #64
    a000f084:	d65f03c0 	ret

00000000a000f088 <z_vrfy_uart_err_check>:
	{							 \
		Z_OOPS(Z_SYSCALL_DRIVER_UART(dev, op_)); \
		z_impl_uart_ ## op_(dev); \
	}

UART_SIMPLE(err_check)
    a000f088:	d10903ff 	sub	sp, sp, #0x240
    a000f08c:	a9007bfd 	stp	x29, x30, [sp]
    a000f090:	910003fd 	mov	x29, sp
    a000f094:	f9000fe0 	str	x0, [sp, #24]
    a000f098:	f9400fe0 	ldr	x0, [sp, #24]
    a000f09c:	94003663 	bl	a001ca28 <z_object_find>
    a000f0a0:	52800003 	mov	w3, #0x0                   	// #0
    a000f0a4:	52800602 	mov	w2, #0x30                  	// #48
    a000f0a8:	f9400fe1 	ldr	x1, [sp, #24]
    a000f0ac:	97ffffe9 	bl	a000f050 <z_obj_validation_check>
    a000f0b0:	7100001f 	cmp	w0, #0x0
    a000f0b4:	1a9f07e0 	cset	w0, ne  // ne = any
    a000f0b8:	3908bfe0 	strb	w0, [sp, #559]
    a000f0bc:	3948bfe0 	ldrb	w0, [sp, #559]
    a000f0c0:	7100001f 	cmp	w0, #0x0
    a000f0c4:	3948bfe0 	ldrb	w0, [sp, #559]
    a000f0c8:	7100001f 	cmp	w0, #0x0
    a000f0cc:	540001c1 	b.ne	a000f104 <z_vrfy_uart_err_check+0x7c>  // b.any
    a000f0d0:	f9400fe0 	ldr	x0, [sp, #24]
    a000f0d4:	f9400800 	ldr	x0, [x0, #16]
    a000f0d8:	f9011be0 	str	x0, [sp, #560]
    a000f0dc:	f9411be0 	ldr	x0, [sp, #560]
    a000f0e0:	f9400800 	ldr	x0, [x0, #16]
    a000f0e4:	f100001f 	cmp	x0, #0x0
    a000f0e8:	1a9f17e0 	cset	w0, eq  // eq = none
    a000f0ec:	3908ffe0 	strb	w0, [sp, #575]
    a000f0f0:	3948ffe0 	ldrb	w0, [sp, #575]
    a000f0f4:	7100001f 	cmp	w0, #0x0
    a000f0f8:	3948ffe0 	ldrb	w0, [sp, #575]
    a000f0fc:	7100001f 	cmp	w0, #0x0
    a000f100:	540000c0 	b.eq	a000f118 <z_vrfy_uart_err_check+0x90>  // b.none
    a000f104:	900001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000f108:	913f8000 	add	x0, x0, #0xfe0
    a000f10c:	f9400800 	ldr	x0, [x0, #16]
    a000f110:	f9408400 	ldr	x0, [x0, #264]
    a000f114:	97ffe811 	bl	a0009158 <arch_syscall_oops>
    a000f118:	f9400fe0 	ldr	x0, [sp, #24]
    a000f11c:	97fffeda 	bl	a000ec84 <z_impl_uart_err_check>
    a000f120:	a9407bfd 	ldp	x29, x30, [sp]
    a000f124:	910903ff 	add	sp, sp, #0x240
    a000f128:	d65f03c0 	ret

00000000a000f12c <z_mrsh_uart_err_check>:
#include <syscalls/uart.h>

extern int z_vrfy_uart_err_check(const struct device * dev);
uintptr_t z_mrsh_uart_err_check(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a000f12c:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a000f130:	910003fd 	mov	x29, sp
    a000f134:	f90027e0 	str	x0, [sp, #72]
    a000f138:	f90023e1 	str	x1, [sp, #64]
    a000f13c:	f9001fe2 	str	x2, [sp, #56]
    a000f140:	f9001be3 	str	x3, [sp, #48]
    a000f144:	f90017e4 	str	x4, [sp, #40]
    a000f148:	f90013e5 	str	x5, [sp, #32]
    a000f14c:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a000f150:	900001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000f154:	913f8000 	add	x0, x0, #0xfe0
    a000f158:	f9400800 	ldr	x0, [x0, #16]
    a000f15c:	f9400fe1 	ldr	x1, [sp, #24]
    a000f160:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_uart_err_check(*(const struct device **)&arg0)
    a000f164:	910123e0 	add	x0, sp, #0x48
    a000f168:	f9400000 	ldr	x0, [x0]
    a000f16c:	97ffffc7 	bl	a000f088 <z_vrfy_uart_err_check>
    a000f170:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a000f174:	900001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000f178:	913f8000 	add	x0, x0, #0xfe0
    a000f17c:	f9400800 	ldr	x0, [x0, #16]
    a000f180:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a000f184:	b9805fe0 	ldrsw	x0, [sp, #92]
}
    a000f188:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a000f18c:	d65f03c0 	ret

00000000a000f190 <z_vrfy_uart_poll_in>:
#include <syscalls/uart_err_check_mrsh.c>

static inline int z_vrfy_uart_poll_in(const struct device *dev,
				      unsigned char *p_char)
{
    a000f190:	d10c03ff 	sub	sp, sp, #0x300
    a000f194:	a9007bfd 	stp	x29, x30, [sp]
    a000f198:	910003fd 	mov	x29, sp
    a000f19c:	f9000fe0 	str	x0, [sp, #24]
    a000f1a0:	f9000be1 	str	x1, [sp, #16]
	Z_OOPS(Z_SYSCALL_DRIVER_UART(dev, poll_in));
    a000f1a4:	f9400fe0 	ldr	x0, [sp, #24]
    a000f1a8:	94003620 	bl	a001ca28 <z_object_find>
    a000f1ac:	52800003 	mov	w3, #0x0                   	// #0
    a000f1b0:	52800602 	mov	w2, #0x30                  	// #48
    a000f1b4:	f9400fe1 	ldr	x1, [sp, #24]
    a000f1b8:	97ffffa6 	bl	a000f050 <z_obj_validation_check>
    a000f1bc:	7100001f 	cmp	w0, #0x0
    a000f1c0:	1a9f07e0 	cset	w0, ne  // ne = any
    a000f1c4:	390bbbe0 	strb	w0, [sp, #750]
    a000f1c8:	394bbbe0 	ldrb	w0, [sp, #750]
    a000f1cc:	7100001f 	cmp	w0, #0x0
    a000f1d0:	394bbbe0 	ldrb	w0, [sp, #750]
    a000f1d4:	7100001f 	cmp	w0, #0x0
    a000f1d8:	540001c1 	b.ne	a000f210 <z_vrfy_uart_poll_in+0x80>  // b.any
    a000f1dc:	f9400fe0 	ldr	x0, [sp, #24]
    a000f1e0:	f9400800 	ldr	x0, [x0, #16]
    a000f1e4:	f9017be0 	str	x0, [sp, #752]
    a000f1e8:	f9417be0 	ldr	x0, [sp, #752]
    a000f1ec:	f9400000 	ldr	x0, [x0]
    a000f1f0:	f100001f 	cmp	x0, #0x0
    a000f1f4:	1a9f17e0 	cset	w0, eq  // eq = none
    a000f1f8:	390bbfe0 	strb	w0, [sp, #751]
    a000f1fc:	394bbfe0 	ldrb	w0, [sp, #751]
    a000f200:	7100001f 	cmp	w0, #0x0
    a000f204:	394bbfe0 	ldrb	w0, [sp, #751]
    a000f208:	7100001f 	cmp	w0, #0x0
    a000f20c:	540000c0 	b.eq	a000f224 <z_vrfy_uart_poll_in+0x94>  // b.none
    a000f210:	900001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000f214:	913f8000 	add	x0, x0, #0xfe0
    a000f218:	f9400800 	ldr	x0, [x0, #16]
    a000f21c:	f9408400 	ldr	x0, [x0, #264]
    a000f220:	97ffe7ce 	bl	a0009158 <arch_syscall_oops>
	Z_OOPS(Z_SYSCALL_MEMORY_WRITE(p_char, sizeof(unsigned char)));
    a000f224:	52800022 	mov	w2, #0x1                   	// #1
    a000f228:	d2800021 	mov	x1, #0x1                   	// #1
    a000f22c:	f9400be0 	ldr	x0, [sp, #16]
    a000f230:	97fff18f 	bl	a000b86c <arch_buffer_validate>
    a000f234:	7100001f 	cmp	w0, #0x0
    a000f238:	1a9f07e0 	cset	w0, ne  // ne = any
    a000f23c:	390bffe0 	strb	w0, [sp, #767]
    a000f240:	394bffe0 	ldrb	w0, [sp, #767]
    a000f244:	7100001f 	cmp	w0, #0x0
    a000f248:	394bffe0 	ldrb	w0, [sp, #767]
    a000f24c:	7100001f 	cmp	w0, #0x0
    a000f250:	540000c0 	b.eq	a000f268 <z_vrfy_uart_poll_in+0xd8>  // b.none
    a000f254:	900001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000f258:	913f8000 	add	x0, x0, #0xfe0
    a000f25c:	f9400800 	ldr	x0, [x0, #16]
    a000f260:	f9408400 	ldr	x0, [x0, #264]
    a000f264:	97ffe7bd 	bl	a0009158 <arch_syscall_oops>
	return z_impl_uart_poll_in(dev, p_char);
    a000f268:	f9400be1 	ldr	x1, [sp, #16]
    a000f26c:	f9400fe0 	ldr	x0, [sp, #24]
    a000f270:	97fffe97 	bl	a000eccc <z_impl_uart_poll_in>
}
    a000f274:	a9407bfd 	ldp	x29, x30, [sp]
    a000f278:	910c03ff 	add	sp, sp, #0x300
    a000f27c:	d65f03c0 	ret

00000000a000f280 <z_mrsh_uart_poll_in>:
#include <syscalls/uart.h>

extern int z_vrfy_uart_poll_in(const struct device * dev, unsigned char * p_char);
uintptr_t z_mrsh_uart_poll_in(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a000f280:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a000f284:	910003fd 	mov	x29, sp
    a000f288:	f90027e0 	str	x0, [sp, #72]
    a000f28c:	f90023e1 	str	x1, [sp, #64]
    a000f290:	f9001fe2 	str	x2, [sp, #56]
    a000f294:	f9001be3 	str	x3, [sp, #48]
    a000f298:	f90017e4 	str	x4, [sp, #40]
    a000f29c:	f90013e5 	str	x5, [sp, #32]
    a000f2a0:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a000f2a4:	900001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000f2a8:	913f8000 	add	x0, x0, #0xfe0
    a000f2ac:	f9400800 	ldr	x0, [x0, #16]
    a000f2b0:	f9400fe1 	ldr	x1, [sp, #24]
    a000f2b4:	f9008401 	str	x1, [x0, #264]
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_uart_poll_in(*(const struct device **)&arg0, *(unsigned char **)&arg1)
    a000f2b8:	910123e0 	add	x0, sp, #0x48
    a000f2bc:	f9400002 	ldr	x2, [x0]
    a000f2c0:	910103e0 	add	x0, sp, #0x40
    a000f2c4:	f9400000 	ldr	x0, [x0]
    a000f2c8:	aa0003e1 	mov	x1, x0
    a000f2cc:	aa0203e0 	mov	x0, x2
    a000f2d0:	97ffffb0 	bl	a000f190 <z_vrfy_uart_poll_in>
    a000f2d4:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a000f2d8:	900001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000f2dc:	913f8000 	add	x0, x0, #0xfe0
    a000f2e0:	f9400800 	ldr	x0, [x0, #16]
    a000f2e4:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a000f2e8:	b9805fe0 	ldrsw	x0, [sp, #92]
}
    a000f2ec:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a000f2f0:	d65f03c0 	ret

00000000a000f2f4 <z_vrfy_uart_poll_in_u16>:
#include <syscalls/uart_poll_in_mrsh.c>

static inline int z_vrfy_uart_poll_in_u16(const struct device *dev,
					  uint16_t *p_u16)
{
    a000f2f4:	d10c03ff 	sub	sp, sp, #0x300
    a000f2f8:	a9007bfd 	stp	x29, x30, [sp]
    a000f2fc:	910003fd 	mov	x29, sp
    a000f300:	f9000fe0 	str	x0, [sp, #24]
    a000f304:	f9000be1 	str	x1, [sp, #16]
	Z_OOPS(Z_SYSCALL_DRIVER_UART(dev, poll_in));
    a000f308:	f9400fe0 	ldr	x0, [sp, #24]
    a000f30c:	940035c7 	bl	a001ca28 <z_object_find>
    a000f310:	52800003 	mov	w3, #0x0                   	// #0
    a000f314:	52800602 	mov	w2, #0x30                  	// #48
    a000f318:	f9400fe1 	ldr	x1, [sp, #24]
    a000f31c:	97ffff4d 	bl	a000f050 <z_obj_validation_check>
    a000f320:	7100001f 	cmp	w0, #0x0
    a000f324:	1a9f07e0 	cset	w0, ne  // ne = any
    a000f328:	390bbbe0 	strb	w0, [sp, #750]
    a000f32c:	394bbbe0 	ldrb	w0, [sp, #750]
    a000f330:	7100001f 	cmp	w0, #0x0
    a000f334:	394bbbe0 	ldrb	w0, [sp, #750]
    a000f338:	7100001f 	cmp	w0, #0x0
    a000f33c:	540001c1 	b.ne	a000f374 <z_vrfy_uart_poll_in_u16+0x80>  // b.any
    a000f340:	f9400fe0 	ldr	x0, [sp, #24]
    a000f344:	f9400800 	ldr	x0, [x0, #16]
    a000f348:	f9017be0 	str	x0, [sp, #752]
    a000f34c:	f9417be0 	ldr	x0, [sp, #752]
    a000f350:	f9400000 	ldr	x0, [x0]
    a000f354:	f100001f 	cmp	x0, #0x0
    a000f358:	1a9f17e0 	cset	w0, eq  // eq = none
    a000f35c:	390bbfe0 	strb	w0, [sp, #751]
    a000f360:	394bbfe0 	ldrb	w0, [sp, #751]
    a000f364:	7100001f 	cmp	w0, #0x0
    a000f368:	394bbfe0 	ldrb	w0, [sp, #751]
    a000f36c:	7100001f 	cmp	w0, #0x0
    a000f370:	540000c0 	b.eq	a000f388 <z_vrfy_uart_poll_in_u16+0x94>  // b.none
    a000f374:	900001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000f378:	913f8000 	add	x0, x0, #0xfe0
    a000f37c:	f9400800 	ldr	x0, [x0, #16]
    a000f380:	f9408400 	ldr	x0, [x0, #264]
    a000f384:	97ffe775 	bl	a0009158 <arch_syscall_oops>
	Z_OOPS(Z_SYSCALL_MEMORY_WRITE(p_u16, sizeof(uint16_t)));
    a000f388:	52800022 	mov	w2, #0x1                   	// #1
    a000f38c:	d2800041 	mov	x1, #0x2                   	// #2
    a000f390:	f9400be0 	ldr	x0, [sp, #16]
    a000f394:	97fff136 	bl	a000b86c <arch_buffer_validate>
    a000f398:	7100001f 	cmp	w0, #0x0
    a000f39c:	1a9f07e0 	cset	w0, ne  // ne = any
    a000f3a0:	390bffe0 	strb	w0, [sp, #767]
    a000f3a4:	394bffe0 	ldrb	w0, [sp, #767]
    a000f3a8:	7100001f 	cmp	w0, #0x0
    a000f3ac:	394bffe0 	ldrb	w0, [sp, #767]
    a000f3b0:	7100001f 	cmp	w0, #0x0
    a000f3b4:	540000c0 	b.eq	a000f3cc <z_vrfy_uart_poll_in_u16+0xd8>  // b.none
    a000f3b8:	900001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000f3bc:	913f8000 	add	x0, x0, #0xfe0
    a000f3c0:	f9400800 	ldr	x0, [x0, #16]
    a000f3c4:	f9408400 	ldr	x0, [x0, #264]
    a000f3c8:	97ffe764 	bl	a0009158 <arch_syscall_oops>
	return z_impl_uart_poll_in_u16(dev, p_u16);
    a000f3cc:	f9400be1 	ldr	x1, [sp, #16]
    a000f3d0:	f9400fe0 	ldr	x0, [sp, #24]
    a000f3d4:	97fffe52 	bl	a000ed1c <z_impl_uart_poll_in_u16>
}
    a000f3d8:	a9407bfd 	ldp	x29, x30, [sp]
    a000f3dc:	910c03ff 	add	sp, sp, #0x300
    a000f3e0:	d65f03c0 	ret

00000000a000f3e4 <z_mrsh_uart_poll_in_u16>:
#include <syscalls/uart.h>

extern int z_vrfy_uart_poll_in_u16(const struct device * dev, uint16_t * p_u16);
uintptr_t z_mrsh_uart_poll_in_u16(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a000f3e4:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a000f3e8:	910003fd 	mov	x29, sp
    a000f3ec:	f90027e0 	str	x0, [sp, #72]
    a000f3f0:	f90023e1 	str	x1, [sp, #64]
    a000f3f4:	f9001fe2 	str	x2, [sp, #56]
    a000f3f8:	f9001be3 	str	x3, [sp, #48]
    a000f3fc:	f90017e4 	str	x4, [sp, #40]
    a000f400:	f90013e5 	str	x5, [sp, #32]
    a000f404:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a000f408:	900001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000f40c:	913f8000 	add	x0, x0, #0xfe0
    a000f410:	f9400800 	ldr	x0, [x0, #16]
    a000f414:	f9400fe1 	ldr	x1, [sp, #24]
    a000f418:	f9008401 	str	x1, [x0, #264]
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_uart_poll_in_u16(*(const struct device **)&arg0, *(uint16_t **)&arg1)
    a000f41c:	910123e0 	add	x0, sp, #0x48
    a000f420:	f9400002 	ldr	x2, [x0]
    a000f424:	910103e0 	add	x0, sp, #0x40
    a000f428:	f9400000 	ldr	x0, [x0]
    a000f42c:	aa0003e1 	mov	x1, x0
    a000f430:	aa0203e0 	mov	x0, x2
    a000f434:	97ffffb0 	bl	a000f2f4 <z_vrfy_uart_poll_in_u16>
    a000f438:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a000f43c:	900001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000f440:	913f8000 	add	x0, x0, #0xfe0
    a000f444:	f9400800 	ldr	x0, [x0, #16]
    a000f448:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a000f44c:	b9805fe0 	ldrsw	x0, [sp, #92]
}
    a000f450:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a000f454:	d65f03c0 	ret

00000000a000f458 <z_vrfy_uart_poll_out>:
#include <syscalls/uart_poll_in_u16_mrsh.c>

static inline void z_vrfy_uart_poll_out(const struct device *dev,
					unsigned char out_char)
{
    a000f458:	d10903ff 	sub	sp, sp, #0x240
    a000f45c:	a9007bfd 	stp	x29, x30, [sp]
    a000f460:	910003fd 	mov	x29, sp
    a000f464:	f9000fe0 	str	x0, [sp, #24]
    a000f468:	39005fe1 	strb	w1, [sp, #23]
	Z_OOPS(Z_SYSCALL_DRIVER_UART(dev, poll_out));
    a000f46c:	f9400fe0 	ldr	x0, [sp, #24]
    a000f470:	9400356e 	bl	a001ca28 <z_object_find>
    a000f474:	52800003 	mov	w3, #0x0                   	// #0
    a000f478:	52800602 	mov	w2, #0x30                  	// #48
    a000f47c:	f9400fe1 	ldr	x1, [sp, #24]
    a000f480:	97fffef4 	bl	a000f050 <z_obj_validation_check>
    a000f484:	7100001f 	cmp	w0, #0x0
    a000f488:	1a9f07e0 	cset	w0, ne  // ne = any
    a000f48c:	3908bfe0 	strb	w0, [sp, #559]
    a000f490:	3948bfe0 	ldrb	w0, [sp, #559]
    a000f494:	7100001f 	cmp	w0, #0x0
    a000f498:	3948bfe0 	ldrb	w0, [sp, #559]
    a000f49c:	7100001f 	cmp	w0, #0x0
    a000f4a0:	540001c1 	b.ne	a000f4d8 <z_vrfy_uart_poll_out+0x80>  // b.any
    a000f4a4:	f9400fe0 	ldr	x0, [sp, #24]
    a000f4a8:	f9400800 	ldr	x0, [x0, #16]
    a000f4ac:	f9011be0 	str	x0, [sp, #560]
    a000f4b0:	f9411be0 	ldr	x0, [sp, #560]
    a000f4b4:	f9400400 	ldr	x0, [x0, #8]
    a000f4b8:	f100001f 	cmp	x0, #0x0
    a000f4bc:	1a9f17e0 	cset	w0, eq  // eq = none
    a000f4c0:	3908ffe0 	strb	w0, [sp, #575]
    a000f4c4:	3948ffe0 	ldrb	w0, [sp, #575]
    a000f4c8:	7100001f 	cmp	w0, #0x0
    a000f4cc:	3948ffe0 	ldrb	w0, [sp, #575]
    a000f4d0:	7100001f 	cmp	w0, #0x0
    a000f4d4:	540000c0 	b.eq	a000f4ec <z_vrfy_uart_poll_out+0x94>  // b.none
    a000f4d8:	900001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000f4dc:	913f8000 	add	x0, x0, #0xfe0
    a000f4e0:	f9400800 	ldr	x0, [x0, #16]
    a000f4e4:	f9408400 	ldr	x0, [x0, #264]
    a000f4e8:	97ffe71c 	bl	a0009158 <arch_syscall_oops>
	z_impl_uart_poll_out((const struct device *)dev, out_char);
    a000f4ec:	39405fe1 	ldrb	w1, [sp, #23]
    a000f4f0:	f9400fe0 	ldr	x0, [sp, #24]
    a000f4f4:	97fffe10 	bl	a000ed34 <z_impl_uart_poll_out>
}
    a000f4f8:	d503201f 	nop
    a000f4fc:	a9407bfd 	ldp	x29, x30, [sp]
    a000f500:	910903ff 	add	sp, sp, #0x240
    a000f504:	d65f03c0 	ret

00000000a000f508 <z_mrsh_uart_poll_out>:
#include <syscalls/uart.h>

extern void z_vrfy_uart_poll_out(const struct device * dev, unsigned char out_char);
uintptr_t z_mrsh_uart_poll_out(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a000f508:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a000f50c:	910003fd 	mov	x29, sp
    a000f510:	f90027e0 	str	x0, [sp, #72]
    a000f514:	f90023e1 	str	x1, [sp, #64]
    a000f518:	f9001fe2 	str	x2, [sp, #56]
    a000f51c:	f9001be3 	str	x3, [sp, #48]
    a000f520:	f90017e4 	str	x4, [sp, #40]
    a000f524:	f90013e5 	str	x5, [sp, #32]
    a000f528:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a000f52c:	900001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000f530:	913f8000 	add	x0, x0, #0xfe0
    a000f534:	f9400800 	ldr	x0, [x0, #16]
    a000f538:	f9400fe1 	ldr	x1, [sp, #24]
    a000f53c:	f9008401 	str	x1, [x0, #264]
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_uart_poll_out(*(const struct device **)&arg0, *(unsigned char*)&arg1)
    a000f540:	910123e0 	add	x0, sp, #0x48
    a000f544:	f9400002 	ldr	x2, [x0]
    a000f548:	910103e0 	add	x0, sp, #0x40
    a000f54c:	39400000 	ldrb	w0, [x0]
    a000f550:	2a0003e1 	mov	w1, w0
    a000f554:	aa0203e0 	mov	x0, x2
    a000f558:	97ffffc0 	bl	a000f458 <z_vrfy_uart_poll_out>
;
	_current->syscall_frame = NULL;
    a000f55c:	900001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000f560:	913f8000 	add	x0, x0, #0xfe0
    a000f564:	f9400800 	ldr	x0, [x0, #16]
    a000f568:	f900841f 	str	xzr, [x0, #264]
	return 0;
    a000f56c:	d2800000 	mov	x0, #0x0                   	// #0
}
    a000f570:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a000f574:	d65f03c0 	ret

00000000a000f578 <z_vrfy_uart_poll_out_u16>:
#include <syscalls/uart_poll_out_mrsh.c>

static inline void z_vrfy_uart_poll_out_u16(const struct device *dev,
					    uint16_t out_u16)
{
    a000f578:	d10903ff 	sub	sp, sp, #0x240
    a000f57c:	a9007bfd 	stp	x29, x30, [sp]
    a000f580:	910003fd 	mov	x29, sp
    a000f584:	f9000fe0 	str	x0, [sp, #24]
    a000f588:	79002fe1 	strh	w1, [sp, #22]
	Z_OOPS(Z_SYSCALL_DRIVER_UART(dev, poll_out));
    a000f58c:	f9400fe0 	ldr	x0, [sp, #24]
    a000f590:	94003526 	bl	a001ca28 <z_object_find>
    a000f594:	52800003 	mov	w3, #0x0                   	// #0
    a000f598:	52800602 	mov	w2, #0x30                  	// #48
    a000f59c:	f9400fe1 	ldr	x1, [sp, #24]
    a000f5a0:	97fffeac 	bl	a000f050 <z_obj_validation_check>
    a000f5a4:	7100001f 	cmp	w0, #0x0
    a000f5a8:	1a9f07e0 	cset	w0, ne  // ne = any
    a000f5ac:	3908bfe0 	strb	w0, [sp, #559]
    a000f5b0:	3948bfe0 	ldrb	w0, [sp, #559]
    a000f5b4:	7100001f 	cmp	w0, #0x0
    a000f5b8:	3948bfe0 	ldrb	w0, [sp, #559]
    a000f5bc:	7100001f 	cmp	w0, #0x0
    a000f5c0:	540001c1 	b.ne	a000f5f8 <z_vrfy_uart_poll_out_u16+0x80>  // b.any
    a000f5c4:	f9400fe0 	ldr	x0, [sp, #24]
    a000f5c8:	f9400800 	ldr	x0, [x0, #16]
    a000f5cc:	f9011be0 	str	x0, [sp, #560]
    a000f5d0:	f9411be0 	ldr	x0, [sp, #560]
    a000f5d4:	f9400400 	ldr	x0, [x0, #8]
    a000f5d8:	f100001f 	cmp	x0, #0x0
    a000f5dc:	1a9f17e0 	cset	w0, eq  // eq = none
    a000f5e0:	3908ffe0 	strb	w0, [sp, #575]
    a000f5e4:	3948ffe0 	ldrb	w0, [sp, #575]
    a000f5e8:	7100001f 	cmp	w0, #0x0
    a000f5ec:	3948ffe0 	ldrb	w0, [sp, #575]
    a000f5f0:	7100001f 	cmp	w0, #0x0
    a000f5f4:	540000c0 	b.eq	a000f60c <z_vrfy_uart_poll_out_u16+0x94>  // b.none
    a000f5f8:	900001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000f5fc:	913f8000 	add	x0, x0, #0xfe0
    a000f600:	f9400800 	ldr	x0, [x0, #16]
    a000f604:	f9408400 	ldr	x0, [x0, #264]
    a000f608:	97ffe6d4 	bl	a0009158 <arch_syscall_oops>
	z_impl_uart_poll_out_u16((const struct device *)dev, out_u16);
    a000f60c:	79402fe1 	ldrh	w1, [sp, #22]
    a000f610:	f9400fe0 	ldr	x0, [sp, #24]
    a000f614:	97fffdd7 	bl	a000ed70 <z_impl_uart_poll_out_u16>
}
    a000f618:	d503201f 	nop
    a000f61c:	a9407bfd 	ldp	x29, x30, [sp]
    a000f620:	910903ff 	add	sp, sp, #0x240
    a000f624:	d65f03c0 	ret

00000000a000f628 <z_mrsh_uart_poll_out_u16>:
#include <syscalls/uart.h>

extern void z_vrfy_uart_poll_out_u16(const struct device * dev, uint16_t out_u16);
uintptr_t z_mrsh_uart_poll_out_u16(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a000f628:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a000f62c:	910003fd 	mov	x29, sp
    a000f630:	f90027e0 	str	x0, [sp, #72]
    a000f634:	f90023e1 	str	x1, [sp, #64]
    a000f638:	f9001fe2 	str	x2, [sp, #56]
    a000f63c:	f9001be3 	str	x3, [sp, #48]
    a000f640:	f90017e4 	str	x4, [sp, #40]
    a000f644:	f90013e5 	str	x5, [sp, #32]
    a000f648:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a000f64c:	900001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000f650:	913f8000 	add	x0, x0, #0xfe0
    a000f654:	f9400800 	ldr	x0, [x0, #16]
    a000f658:	f9400fe1 	ldr	x1, [sp, #24]
    a000f65c:	f9008401 	str	x1, [x0, #264]
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_uart_poll_out_u16(*(const struct device **)&arg0, *(uint16_t*)&arg1)
    a000f660:	910123e0 	add	x0, sp, #0x48
    a000f664:	f9400002 	ldr	x2, [x0]
    a000f668:	910103e0 	add	x0, sp, #0x40
    a000f66c:	79400000 	ldrh	w0, [x0]
    a000f670:	2a0003e1 	mov	w1, w0
    a000f674:	aa0203e0 	mov	x0, x2
    a000f678:	97ffffc0 	bl	a000f578 <z_vrfy_uart_poll_out_u16>
;
	_current->syscall_frame = NULL;
    a000f67c:	900001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000f680:	913f8000 	add	x0, x0, #0xfe0
    a000f684:	f9400800 	ldr	x0, [x0, #16]
    a000f688:	f900841f 	str	xzr, [x0, #264]
	return 0;
    a000f68c:	d2800000 	mov	x0, #0x0                   	// #0
}
    a000f690:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a000f694:	d65f03c0 	ret

00000000a000f698 <z_vrfy_uart_config_get>:
#include <syscalls/uart_poll_out_u16_mrsh.c>

static inline int z_vrfy_uart_config_get(const struct device *dev,
					 struct uart_config *cfg)
{
    a000f698:	d10c03ff 	sub	sp, sp, #0x300
    a000f69c:	a9007bfd 	stp	x29, x30, [sp]
    a000f6a0:	910003fd 	mov	x29, sp
    a000f6a4:	f9000fe0 	str	x0, [sp, #24]
    a000f6a8:	f9000be1 	str	x1, [sp, #16]
	Z_OOPS(Z_SYSCALL_DRIVER_UART(dev, config_get));
    a000f6ac:	f9400fe0 	ldr	x0, [sp, #24]
    a000f6b0:	940034de 	bl	a001ca28 <z_object_find>
    a000f6b4:	52800003 	mov	w3, #0x0                   	// #0
    a000f6b8:	52800602 	mov	w2, #0x30                  	// #48
    a000f6bc:	f9400fe1 	ldr	x1, [sp, #24]
    a000f6c0:	97fffe64 	bl	a000f050 <z_obj_validation_check>
    a000f6c4:	7100001f 	cmp	w0, #0x0
    a000f6c8:	1a9f07e0 	cset	w0, ne  // ne = any
    a000f6cc:	390bbbe0 	strb	w0, [sp, #750]
    a000f6d0:	394bbbe0 	ldrb	w0, [sp, #750]
    a000f6d4:	7100001f 	cmp	w0, #0x0
    a000f6d8:	394bbbe0 	ldrb	w0, [sp, #750]
    a000f6dc:	7100001f 	cmp	w0, #0x0
    a000f6e0:	540001c1 	b.ne	a000f718 <z_vrfy_uart_config_get+0x80>  // b.any
    a000f6e4:	f9400fe0 	ldr	x0, [sp, #24]
    a000f6e8:	f9400800 	ldr	x0, [x0, #16]
    a000f6ec:	f9017be0 	str	x0, [sp, #752]
    a000f6f0:	f9417be0 	ldr	x0, [sp, #752]
    a000f6f4:	f9401000 	ldr	x0, [x0, #32]
    a000f6f8:	f100001f 	cmp	x0, #0x0
    a000f6fc:	1a9f17e0 	cset	w0, eq  // eq = none
    a000f700:	390bbfe0 	strb	w0, [sp, #751]
    a000f704:	394bbfe0 	ldrb	w0, [sp, #751]
    a000f708:	7100001f 	cmp	w0, #0x0
    a000f70c:	394bbfe0 	ldrb	w0, [sp, #751]
    a000f710:	7100001f 	cmp	w0, #0x0
    a000f714:	540000c0 	b.eq	a000f72c <z_vrfy_uart_config_get+0x94>  // b.none
    a000f718:	900001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000f71c:	913f8000 	add	x0, x0, #0xfe0
    a000f720:	f9400800 	ldr	x0, [x0, #16]
    a000f724:	f9408400 	ldr	x0, [x0, #264]
    a000f728:	97ffe68c 	bl	a0009158 <arch_syscall_oops>
	Z_OOPS(Z_SYSCALL_MEMORY_WRITE(cfg, sizeof(struct uart_config)));
    a000f72c:	52800022 	mov	w2, #0x1                   	// #1
    a000f730:	d2800101 	mov	x1, #0x8                   	// #8
    a000f734:	f9400be0 	ldr	x0, [sp, #16]
    a000f738:	97fff04d 	bl	a000b86c <arch_buffer_validate>
    a000f73c:	7100001f 	cmp	w0, #0x0
    a000f740:	1a9f07e0 	cset	w0, ne  // ne = any
    a000f744:	390bffe0 	strb	w0, [sp, #767]
    a000f748:	394bffe0 	ldrb	w0, [sp, #767]
    a000f74c:	7100001f 	cmp	w0, #0x0
    a000f750:	394bffe0 	ldrb	w0, [sp, #767]
    a000f754:	7100001f 	cmp	w0, #0x0
    a000f758:	540000c0 	b.eq	a000f770 <z_vrfy_uart_config_get+0xd8>  // b.none
    a000f75c:	900001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000f760:	913f8000 	add	x0, x0, #0xfe0
    a000f764:	f9400800 	ldr	x0, [x0, #16]
    a000f768:	f9408400 	ldr	x0, [x0, #264]
    a000f76c:	97ffe67b 	bl	a0009158 <arch_syscall_oops>

	return z_impl_uart_config_get(dev, cfg);
    a000f770:	f9400be1 	ldr	x1, [sp, #16]
    a000f774:	f9400fe0 	ldr	x0, [sp, #24]
    a000f778:	97fffd98 	bl	a000edd8 <z_impl_uart_config_get>
}
    a000f77c:	a9407bfd 	ldp	x29, x30, [sp]
    a000f780:	910c03ff 	add	sp, sp, #0x300
    a000f784:	d65f03c0 	ret

00000000a000f788 <z_mrsh_uart_config_get>:
#include <syscalls/uart.h>

extern int z_vrfy_uart_config_get(const struct device * dev, struct uart_config * cfg);
uintptr_t z_mrsh_uart_config_get(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a000f788:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a000f78c:	910003fd 	mov	x29, sp
    a000f790:	f90027e0 	str	x0, [sp, #72]
    a000f794:	f90023e1 	str	x1, [sp, #64]
    a000f798:	f9001fe2 	str	x2, [sp, #56]
    a000f79c:	f9001be3 	str	x3, [sp, #48]
    a000f7a0:	f90017e4 	str	x4, [sp, #40]
    a000f7a4:	f90013e5 	str	x5, [sp, #32]
    a000f7a8:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a000f7ac:	900001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000f7b0:	913f8000 	add	x0, x0, #0xfe0
    a000f7b4:	f9400800 	ldr	x0, [x0, #16]
    a000f7b8:	f9400fe1 	ldr	x1, [sp, #24]
    a000f7bc:	f9008401 	str	x1, [x0, #264]
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_uart_config_get(*(const struct device **)&arg0, *(struct uart_config **)&arg1)
    a000f7c0:	910123e0 	add	x0, sp, #0x48
    a000f7c4:	f9400002 	ldr	x2, [x0]
    a000f7c8:	910103e0 	add	x0, sp, #0x40
    a000f7cc:	f9400000 	ldr	x0, [x0]
    a000f7d0:	aa0003e1 	mov	x1, x0
    a000f7d4:	aa0203e0 	mov	x0, x2
    a000f7d8:	97ffffb0 	bl	a000f698 <z_vrfy_uart_config_get>
    a000f7dc:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a000f7e0:	900001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000f7e4:	913f8000 	add	x0, x0, #0xfe0
    a000f7e8:	f9400800 	ldr	x0, [x0, #16]
    a000f7ec:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a000f7f0:	b9805fe0 	ldrsw	x0, [sp, #92]
}
    a000f7f4:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a000f7f8:	d65f03c0 	ret

00000000a000f7fc <z_vrfy_uart_configure>:
#include <syscalls/uart_config_get_mrsh.c>

static inline int z_vrfy_uart_configure(const struct device *dev,
					const struct uart_config *cfg)
{
    a000f7fc:	d10c03ff 	sub	sp, sp, #0x300
    a000f800:	a9007bfd 	stp	x29, x30, [sp]
    a000f804:	910003fd 	mov	x29, sp
    a000f808:	f9000fe0 	str	x0, [sp, #24]
    a000f80c:	f9000be1 	str	x1, [sp, #16]
	Z_OOPS(Z_SYSCALL_DRIVER_UART(dev, config_get));
    a000f810:	f9400fe0 	ldr	x0, [sp, #24]
    a000f814:	94003485 	bl	a001ca28 <z_object_find>
    a000f818:	52800003 	mov	w3, #0x0                   	// #0
    a000f81c:	52800602 	mov	w2, #0x30                  	// #48
    a000f820:	f9400fe1 	ldr	x1, [sp, #24]
    a000f824:	97fffe0b 	bl	a000f050 <z_obj_validation_check>
    a000f828:	7100001f 	cmp	w0, #0x0
    a000f82c:	1a9f07e0 	cset	w0, ne  // ne = any
    a000f830:	390bbbe0 	strb	w0, [sp, #750]
    a000f834:	394bbbe0 	ldrb	w0, [sp, #750]
    a000f838:	7100001f 	cmp	w0, #0x0
    a000f83c:	394bbbe0 	ldrb	w0, [sp, #750]
    a000f840:	7100001f 	cmp	w0, #0x0
    a000f844:	540001c1 	b.ne	a000f87c <z_vrfy_uart_configure+0x80>  // b.any
    a000f848:	f9400fe0 	ldr	x0, [sp, #24]
    a000f84c:	f9400800 	ldr	x0, [x0, #16]
    a000f850:	f9017be0 	str	x0, [sp, #752]
    a000f854:	f9417be0 	ldr	x0, [sp, #752]
    a000f858:	f9401000 	ldr	x0, [x0, #32]
    a000f85c:	f100001f 	cmp	x0, #0x0
    a000f860:	1a9f17e0 	cset	w0, eq  // eq = none
    a000f864:	390bbfe0 	strb	w0, [sp, #751]
    a000f868:	394bbfe0 	ldrb	w0, [sp, #751]
    a000f86c:	7100001f 	cmp	w0, #0x0
    a000f870:	394bbfe0 	ldrb	w0, [sp, #751]
    a000f874:	7100001f 	cmp	w0, #0x0
    a000f878:	540000c0 	b.eq	a000f890 <z_vrfy_uart_configure+0x94>  // b.none
    a000f87c:	900001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000f880:	913f8000 	add	x0, x0, #0xfe0
    a000f884:	f9400800 	ldr	x0, [x0, #16]
    a000f888:	f9408400 	ldr	x0, [x0, #264]
    a000f88c:	97ffe633 	bl	a0009158 <arch_syscall_oops>
	Z_OOPS(Z_SYSCALL_MEMORY_READ(cfg, sizeof(struct uart_config)));
    a000f890:	52800002 	mov	w2, #0x0                   	// #0
    a000f894:	d2800101 	mov	x1, #0x8                   	// #8
    a000f898:	f9400be0 	ldr	x0, [sp, #16]
    a000f89c:	97ffeff4 	bl	a000b86c <arch_buffer_validate>
    a000f8a0:	7100001f 	cmp	w0, #0x0
    a000f8a4:	1a9f07e0 	cset	w0, ne  // ne = any
    a000f8a8:	390bffe0 	strb	w0, [sp, #767]
    a000f8ac:	394bffe0 	ldrb	w0, [sp, #767]
    a000f8b0:	7100001f 	cmp	w0, #0x0
    a000f8b4:	394bffe0 	ldrb	w0, [sp, #767]
    a000f8b8:	7100001f 	cmp	w0, #0x0
    a000f8bc:	540000c0 	b.eq	a000f8d4 <z_vrfy_uart_configure+0xd8>  // b.none
    a000f8c0:	900001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000f8c4:	913f8000 	add	x0, x0, #0xfe0
    a000f8c8:	f9400800 	ldr	x0, [x0, #16]
    a000f8cc:	f9408400 	ldr	x0, [x0, #264]
    a000f8d0:	97ffe622 	bl	a0009158 <arch_syscall_oops>

	return z_impl_uart_configure(dev, cfg);
    a000f8d4:	f9400be1 	ldr	x1, [sp, #16]
    a000f8d8:	f9400fe0 	ldr	x0, [sp, #24]
    a000f8dc:	97fffd2b 	bl	a000ed88 <z_impl_uart_configure>
}
    a000f8e0:	a9407bfd 	ldp	x29, x30, [sp]
    a000f8e4:	910c03ff 	add	sp, sp, #0x300
    a000f8e8:	d65f03c0 	ret

00000000a000f8ec <z_mrsh_uart_configure>:
#include <syscalls/uart.h>

extern int z_vrfy_uart_configure(const struct device * dev, const struct uart_config * cfg);
uintptr_t z_mrsh_uart_configure(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a000f8ec:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a000f8f0:	910003fd 	mov	x29, sp
    a000f8f4:	f90027e0 	str	x0, [sp, #72]
    a000f8f8:	f90023e1 	str	x1, [sp, #64]
    a000f8fc:	f9001fe2 	str	x2, [sp, #56]
    a000f900:	f9001be3 	str	x3, [sp, #48]
    a000f904:	f90017e4 	str	x4, [sp, #40]
    a000f908:	f90013e5 	str	x5, [sp, #32]
    a000f90c:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a000f910:	900001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000f914:	913f8000 	add	x0, x0, #0xfe0
    a000f918:	f9400800 	ldr	x0, [x0, #16]
    a000f91c:	f9400fe1 	ldr	x1, [sp, #24]
    a000f920:	f9008401 	str	x1, [x0, #264]
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_uart_configure(*(const struct device **)&arg0, *(const struct uart_config **)&arg1)
    a000f924:	910123e0 	add	x0, sp, #0x48
    a000f928:	f9400002 	ldr	x2, [x0]
    a000f92c:	910103e0 	add	x0, sp, #0x40
    a000f930:	f9400000 	ldr	x0, [x0]
    a000f934:	aa0003e1 	mov	x1, x0
    a000f938:	aa0203e0 	mov	x0, x2
    a000f93c:	97ffffb0 	bl	a000f7fc <z_vrfy_uart_configure>
    a000f940:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a000f944:	900001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000f948:	913f8000 	add	x0, x0, #0xfe0
    a000f94c:	f9400800 	ldr	x0, [x0, #16]
    a000f950:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a000f954:	b9805fe0 	ldrsw	x0, [sp, #92]
}
    a000f958:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a000f95c:	d65f03c0 	ret

00000000a000f960 <z_vrfy_uart_irq_tx_enable>:
UART_SIMPLE(rx_disable);
#include <syscalls/uart_rx_disable_mrsh.c>
#endif /* CONFIG_UART_ASYNC_API */

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
UART_SIMPLE_VOID(irq_tx_enable)
    a000f960:	d10903ff 	sub	sp, sp, #0x240
    a000f964:	a9007bfd 	stp	x29, x30, [sp]
    a000f968:	910003fd 	mov	x29, sp
    a000f96c:	f9000fe0 	str	x0, [sp, #24]
    a000f970:	f9400fe0 	ldr	x0, [sp, #24]
    a000f974:	9400342d 	bl	a001ca28 <z_object_find>
    a000f978:	52800003 	mov	w3, #0x0                   	// #0
    a000f97c:	52800602 	mov	w2, #0x30                  	// #48
    a000f980:	f9400fe1 	ldr	x1, [sp, #24]
    a000f984:	97fffdb3 	bl	a000f050 <z_obj_validation_check>
    a000f988:	7100001f 	cmp	w0, #0x0
    a000f98c:	1a9f07e0 	cset	w0, ne  // ne = any
    a000f990:	3908bfe0 	strb	w0, [sp, #559]
    a000f994:	3948bfe0 	ldrb	w0, [sp, #559]
    a000f998:	7100001f 	cmp	w0, #0x0
    a000f99c:	3948bfe0 	ldrb	w0, [sp, #559]
    a000f9a0:	7100001f 	cmp	w0, #0x0
    a000f9a4:	540001c1 	b.ne	a000f9dc <z_vrfy_uart_irq_tx_enable+0x7c>  // b.any
    a000f9a8:	f9400fe0 	ldr	x0, [sp, #24]
    a000f9ac:	f9400800 	ldr	x0, [x0, #16]
    a000f9b0:	f9011be0 	str	x0, [sp, #560]
    a000f9b4:	f9411be0 	ldr	x0, [sp, #560]
    a000f9b8:	f9401c00 	ldr	x0, [x0, #56]
    a000f9bc:	f100001f 	cmp	x0, #0x0
    a000f9c0:	1a9f17e0 	cset	w0, eq  // eq = none
    a000f9c4:	3908ffe0 	strb	w0, [sp, #575]
    a000f9c8:	3948ffe0 	ldrb	w0, [sp, #575]
    a000f9cc:	7100001f 	cmp	w0, #0x0
    a000f9d0:	3948ffe0 	ldrb	w0, [sp, #575]
    a000f9d4:	7100001f 	cmp	w0, #0x0
    a000f9d8:	540000c0 	b.eq	a000f9f0 <z_vrfy_uart_irq_tx_enable+0x90>  // b.none
    a000f9dc:	900001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000f9e0:	913f8000 	add	x0, x0, #0xfe0
    a000f9e4:	f9400800 	ldr	x0, [x0, #16]
    a000f9e8:	f9408400 	ldr	x0, [x0, #264]
    a000f9ec:	97ffe5db 	bl	a0009158 <arch_syscall_oops>
    a000f9f0:	f9400fe0 	ldr	x0, [sp, #24]
    a000f9f4:	97fffd0d 	bl	a000ee28 <z_impl_uart_irq_tx_enable>
    a000f9f8:	d503201f 	nop
    a000f9fc:	a9407bfd 	ldp	x29, x30, [sp]
    a000fa00:	910903ff 	add	sp, sp, #0x240
    a000fa04:	d65f03c0 	ret

00000000a000fa08 <z_vrfy_uart_irq_tx_disable>:
UART_SIMPLE_VOID(irq_tx_disable)
    a000fa08:	d10903ff 	sub	sp, sp, #0x240
    a000fa0c:	a9007bfd 	stp	x29, x30, [sp]
    a000fa10:	910003fd 	mov	x29, sp
    a000fa14:	f9000fe0 	str	x0, [sp, #24]
    a000fa18:	f9400fe0 	ldr	x0, [sp, #24]
    a000fa1c:	94003403 	bl	a001ca28 <z_object_find>
    a000fa20:	52800003 	mov	w3, #0x0                   	// #0
    a000fa24:	52800602 	mov	w2, #0x30                  	// #48
    a000fa28:	f9400fe1 	ldr	x1, [sp, #24]
    a000fa2c:	97fffd89 	bl	a000f050 <z_obj_validation_check>
    a000fa30:	7100001f 	cmp	w0, #0x0
    a000fa34:	1a9f07e0 	cset	w0, ne  // ne = any
    a000fa38:	3908bfe0 	strb	w0, [sp, #559]
    a000fa3c:	3948bfe0 	ldrb	w0, [sp, #559]
    a000fa40:	7100001f 	cmp	w0, #0x0
    a000fa44:	3948bfe0 	ldrb	w0, [sp, #559]
    a000fa48:	7100001f 	cmp	w0, #0x0
    a000fa4c:	540001c1 	b.ne	a000fa84 <z_vrfy_uart_irq_tx_disable+0x7c>  // b.any
    a000fa50:	f9400fe0 	ldr	x0, [sp, #24]
    a000fa54:	f9400800 	ldr	x0, [x0, #16]
    a000fa58:	f9011be0 	str	x0, [sp, #560]
    a000fa5c:	f9411be0 	ldr	x0, [sp, #560]
    a000fa60:	f9402000 	ldr	x0, [x0, #64]
    a000fa64:	f100001f 	cmp	x0, #0x0
    a000fa68:	1a9f17e0 	cset	w0, eq  // eq = none
    a000fa6c:	3908ffe0 	strb	w0, [sp, #575]
    a000fa70:	3948ffe0 	ldrb	w0, [sp, #575]
    a000fa74:	7100001f 	cmp	w0, #0x0
    a000fa78:	3948ffe0 	ldrb	w0, [sp, #575]
    a000fa7c:	7100001f 	cmp	w0, #0x0
    a000fa80:	540000c0 	b.eq	a000fa98 <z_vrfy_uart_irq_tx_disable+0x90>  // b.none
    a000fa84:	900001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000fa88:	913f8000 	add	x0, x0, #0xfe0
    a000fa8c:	f9400800 	ldr	x0, [x0, #16]
    a000fa90:	f9408400 	ldr	x0, [x0, #264]
    a000fa94:	97ffe5b1 	bl	a0009158 <arch_syscall_oops>
    a000fa98:	f9400fe0 	ldr	x0, [sp, #24]
    a000fa9c:	97fffcf4 	bl	a000ee6c <z_impl_uart_irq_tx_disable>
    a000faa0:	d503201f 	nop
    a000faa4:	a9407bfd 	ldp	x29, x30, [sp]
    a000faa8:	910903ff 	add	sp, sp, #0x240
    a000faac:	d65f03c0 	ret

00000000a000fab0 <z_vrfy_uart_irq_rx_enable>:
UART_SIMPLE_VOID(irq_rx_enable)
    a000fab0:	d10903ff 	sub	sp, sp, #0x240
    a000fab4:	a9007bfd 	stp	x29, x30, [sp]
    a000fab8:	910003fd 	mov	x29, sp
    a000fabc:	f9000fe0 	str	x0, [sp, #24]
    a000fac0:	f9400fe0 	ldr	x0, [sp, #24]
    a000fac4:	940033d9 	bl	a001ca28 <z_object_find>
    a000fac8:	52800003 	mov	w3, #0x0                   	// #0
    a000facc:	52800602 	mov	w2, #0x30                  	// #48
    a000fad0:	f9400fe1 	ldr	x1, [sp, #24]
    a000fad4:	97fffd5f 	bl	a000f050 <z_obj_validation_check>
    a000fad8:	7100001f 	cmp	w0, #0x0
    a000fadc:	1a9f07e0 	cset	w0, ne  // ne = any
    a000fae0:	3908bfe0 	strb	w0, [sp, #559]
    a000fae4:	3948bfe0 	ldrb	w0, [sp, #559]
    a000fae8:	7100001f 	cmp	w0, #0x0
    a000faec:	3948bfe0 	ldrb	w0, [sp, #559]
    a000faf0:	7100001f 	cmp	w0, #0x0
    a000faf4:	540001c1 	b.ne	a000fb2c <z_vrfy_uart_irq_rx_enable+0x7c>  // b.any
    a000faf8:	f9400fe0 	ldr	x0, [sp, #24]
    a000fafc:	f9400800 	ldr	x0, [x0, #16]
    a000fb00:	f9011be0 	str	x0, [sp, #560]
    a000fb04:	f9411be0 	ldr	x0, [sp, #560]
    a000fb08:	f9402800 	ldr	x0, [x0, #80]
    a000fb0c:	f100001f 	cmp	x0, #0x0
    a000fb10:	1a9f17e0 	cset	w0, eq  // eq = none
    a000fb14:	3908ffe0 	strb	w0, [sp, #575]
    a000fb18:	3948ffe0 	ldrb	w0, [sp, #575]
    a000fb1c:	7100001f 	cmp	w0, #0x0
    a000fb20:	3948ffe0 	ldrb	w0, [sp, #575]
    a000fb24:	7100001f 	cmp	w0, #0x0
    a000fb28:	540000c0 	b.eq	a000fb40 <z_vrfy_uart_irq_rx_enable+0x90>  // b.none
    a000fb2c:	900001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000fb30:	913f8000 	add	x0, x0, #0xfe0
    a000fb34:	f9400800 	ldr	x0, [x0, #16]
    a000fb38:	f9408400 	ldr	x0, [x0, #264]
    a000fb3c:	97ffe587 	bl	a0009158 <arch_syscall_oops>
    a000fb40:	f9400fe0 	ldr	x0, [sp, #24]
    a000fb44:	97fffcdb 	bl	a000eeb0 <z_impl_uart_irq_rx_enable>
    a000fb48:	d503201f 	nop
    a000fb4c:	a9407bfd 	ldp	x29, x30, [sp]
    a000fb50:	910903ff 	add	sp, sp, #0x240
    a000fb54:	d65f03c0 	ret

00000000a000fb58 <z_vrfy_uart_irq_rx_disable>:
UART_SIMPLE_VOID(irq_rx_disable)
    a000fb58:	d10903ff 	sub	sp, sp, #0x240
    a000fb5c:	a9007bfd 	stp	x29, x30, [sp]
    a000fb60:	910003fd 	mov	x29, sp
    a000fb64:	f9000fe0 	str	x0, [sp, #24]
    a000fb68:	f9400fe0 	ldr	x0, [sp, #24]
    a000fb6c:	940033af 	bl	a001ca28 <z_object_find>
    a000fb70:	52800003 	mov	w3, #0x0                   	// #0
    a000fb74:	52800602 	mov	w2, #0x30                  	// #48
    a000fb78:	f9400fe1 	ldr	x1, [sp, #24]
    a000fb7c:	97fffd35 	bl	a000f050 <z_obj_validation_check>
    a000fb80:	7100001f 	cmp	w0, #0x0
    a000fb84:	1a9f07e0 	cset	w0, ne  // ne = any
    a000fb88:	3908bfe0 	strb	w0, [sp, #559]
    a000fb8c:	3948bfe0 	ldrb	w0, [sp, #559]
    a000fb90:	7100001f 	cmp	w0, #0x0
    a000fb94:	3948bfe0 	ldrb	w0, [sp, #559]
    a000fb98:	7100001f 	cmp	w0, #0x0
    a000fb9c:	540001c1 	b.ne	a000fbd4 <z_vrfy_uart_irq_rx_disable+0x7c>  // b.any
    a000fba0:	f9400fe0 	ldr	x0, [sp, #24]
    a000fba4:	f9400800 	ldr	x0, [x0, #16]
    a000fba8:	f9011be0 	str	x0, [sp, #560]
    a000fbac:	f9411be0 	ldr	x0, [sp, #560]
    a000fbb0:	f9402c00 	ldr	x0, [x0, #88]
    a000fbb4:	f100001f 	cmp	x0, #0x0
    a000fbb8:	1a9f17e0 	cset	w0, eq  // eq = none
    a000fbbc:	3908ffe0 	strb	w0, [sp, #575]
    a000fbc0:	3948ffe0 	ldrb	w0, [sp, #575]
    a000fbc4:	7100001f 	cmp	w0, #0x0
    a000fbc8:	3948ffe0 	ldrb	w0, [sp, #575]
    a000fbcc:	7100001f 	cmp	w0, #0x0
    a000fbd0:	540000c0 	b.eq	a000fbe8 <z_vrfy_uart_irq_rx_disable+0x90>  // b.none
    a000fbd4:	900001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000fbd8:	913f8000 	add	x0, x0, #0xfe0
    a000fbdc:	f9400800 	ldr	x0, [x0, #16]
    a000fbe0:	f9408400 	ldr	x0, [x0, #264]
    a000fbe4:	97ffe55d 	bl	a0009158 <arch_syscall_oops>
    a000fbe8:	f9400fe0 	ldr	x0, [sp, #24]
    a000fbec:	97fffcc2 	bl	a000eef4 <z_impl_uart_irq_rx_disable>
    a000fbf0:	d503201f 	nop
    a000fbf4:	a9407bfd 	ldp	x29, x30, [sp]
    a000fbf8:	910903ff 	add	sp, sp, #0x240
    a000fbfc:	d65f03c0 	ret

00000000a000fc00 <z_vrfy_uart_irq_err_enable>:
UART_SIMPLE_VOID(irq_err_enable)
    a000fc00:	d10903ff 	sub	sp, sp, #0x240
    a000fc04:	a9007bfd 	stp	x29, x30, [sp]
    a000fc08:	910003fd 	mov	x29, sp
    a000fc0c:	f9000fe0 	str	x0, [sp, #24]
    a000fc10:	f9400fe0 	ldr	x0, [sp, #24]
    a000fc14:	94003385 	bl	a001ca28 <z_object_find>
    a000fc18:	52800003 	mov	w3, #0x0                   	// #0
    a000fc1c:	52800602 	mov	w2, #0x30                  	// #48
    a000fc20:	f9400fe1 	ldr	x1, [sp, #24]
    a000fc24:	97fffd0b 	bl	a000f050 <z_obj_validation_check>
    a000fc28:	7100001f 	cmp	w0, #0x0
    a000fc2c:	1a9f07e0 	cset	w0, ne  // ne = any
    a000fc30:	3908bfe0 	strb	w0, [sp, #559]
    a000fc34:	3948bfe0 	ldrb	w0, [sp, #559]
    a000fc38:	7100001f 	cmp	w0, #0x0
    a000fc3c:	3948bfe0 	ldrb	w0, [sp, #559]
    a000fc40:	7100001f 	cmp	w0, #0x0
    a000fc44:	540001c1 	b.ne	a000fc7c <z_vrfy_uart_irq_err_enable+0x7c>  // b.any
    a000fc48:	f9400fe0 	ldr	x0, [sp, #24]
    a000fc4c:	f9400800 	ldr	x0, [x0, #16]
    a000fc50:	f9011be0 	str	x0, [sp, #560]
    a000fc54:	f9411be0 	ldr	x0, [sp, #560]
    a000fc58:	f9403800 	ldr	x0, [x0, #112]
    a000fc5c:	f100001f 	cmp	x0, #0x0
    a000fc60:	1a9f17e0 	cset	w0, eq  // eq = none
    a000fc64:	3908ffe0 	strb	w0, [sp, #575]
    a000fc68:	3948ffe0 	ldrb	w0, [sp, #575]
    a000fc6c:	7100001f 	cmp	w0, #0x0
    a000fc70:	3948ffe0 	ldrb	w0, [sp, #575]
    a000fc74:	7100001f 	cmp	w0, #0x0
    a000fc78:	540000c0 	b.eq	a000fc90 <z_vrfy_uart_irq_err_enable+0x90>  // b.none
    a000fc7c:	900001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000fc80:	913f8000 	add	x0, x0, #0xfe0
    a000fc84:	f9400800 	ldr	x0, [x0, #16]
    a000fc88:	f9408400 	ldr	x0, [x0, #264]
    a000fc8c:	97ffe533 	bl	a0009158 <arch_syscall_oops>
    a000fc90:	f9400fe0 	ldr	x0, [sp, #24]
    a000fc94:	97fffca9 	bl	a000ef38 <z_impl_uart_irq_err_enable>
    a000fc98:	d503201f 	nop
    a000fc9c:	a9407bfd 	ldp	x29, x30, [sp]
    a000fca0:	910903ff 	add	sp, sp, #0x240
    a000fca4:	d65f03c0 	ret

00000000a000fca8 <z_vrfy_uart_irq_err_disable>:
UART_SIMPLE_VOID(irq_err_disable)
    a000fca8:	d10903ff 	sub	sp, sp, #0x240
    a000fcac:	a9007bfd 	stp	x29, x30, [sp]
    a000fcb0:	910003fd 	mov	x29, sp
    a000fcb4:	f9000fe0 	str	x0, [sp, #24]
    a000fcb8:	f9400fe0 	ldr	x0, [sp, #24]
    a000fcbc:	9400335b 	bl	a001ca28 <z_object_find>
    a000fcc0:	52800003 	mov	w3, #0x0                   	// #0
    a000fcc4:	52800602 	mov	w2, #0x30                  	// #48
    a000fcc8:	f9400fe1 	ldr	x1, [sp, #24]
    a000fccc:	97fffce1 	bl	a000f050 <z_obj_validation_check>
    a000fcd0:	7100001f 	cmp	w0, #0x0
    a000fcd4:	1a9f07e0 	cset	w0, ne  // ne = any
    a000fcd8:	3908bfe0 	strb	w0, [sp, #559]
    a000fcdc:	3948bfe0 	ldrb	w0, [sp, #559]
    a000fce0:	7100001f 	cmp	w0, #0x0
    a000fce4:	3948bfe0 	ldrb	w0, [sp, #559]
    a000fce8:	7100001f 	cmp	w0, #0x0
    a000fcec:	540001c1 	b.ne	a000fd24 <z_vrfy_uart_irq_err_disable+0x7c>  // b.any
    a000fcf0:	f9400fe0 	ldr	x0, [sp, #24]
    a000fcf4:	f9400800 	ldr	x0, [x0, #16]
    a000fcf8:	f9011be0 	str	x0, [sp, #560]
    a000fcfc:	f9411be0 	ldr	x0, [sp, #560]
    a000fd00:	f9403c00 	ldr	x0, [x0, #120]
    a000fd04:	f100001f 	cmp	x0, #0x0
    a000fd08:	1a9f17e0 	cset	w0, eq  // eq = none
    a000fd0c:	3908ffe0 	strb	w0, [sp, #575]
    a000fd10:	3948ffe0 	ldrb	w0, [sp, #575]
    a000fd14:	7100001f 	cmp	w0, #0x0
    a000fd18:	3948ffe0 	ldrb	w0, [sp, #575]
    a000fd1c:	7100001f 	cmp	w0, #0x0
    a000fd20:	540000c0 	b.eq	a000fd38 <z_vrfy_uart_irq_err_disable+0x90>  // b.none
    a000fd24:	900001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000fd28:	913f8000 	add	x0, x0, #0xfe0
    a000fd2c:	f9400800 	ldr	x0, [x0, #16]
    a000fd30:	f9408400 	ldr	x0, [x0, #264]
    a000fd34:	97ffe509 	bl	a0009158 <arch_syscall_oops>
    a000fd38:	f9400fe0 	ldr	x0, [sp, #24]
    a000fd3c:	97fffc90 	bl	a000ef7c <z_impl_uart_irq_err_disable>
    a000fd40:	d503201f 	nop
    a000fd44:	a9407bfd 	ldp	x29, x30, [sp]
    a000fd48:	910903ff 	add	sp, sp, #0x240
    a000fd4c:	d65f03c0 	ret

00000000a000fd50 <z_vrfy_uart_irq_is_pending>:
UART_SIMPLE(irq_is_pending)
    a000fd50:	d10903ff 	sub	sp, sp, #0x240
    a000fd54:	a9007bfd 	stp	x29, x30, [sp]
    a000fd58:	910003fd 	mov	x29, sp
    a000fd5c:	f9000fe0 	str	x0, [sp, #24]
    a000fd60:	f9400fe0 	ldr	x0, [sp, #24]
    a000fd64:	94003331 	bl	a001ca28 <z_object_find>
    a000fd68:	52800003 	mov	w3, #0x0                   	// #0
    a000fd6c:	52800602 	mov	w2, #0x30                  	// #48
    a000fd70:	f9400fe1 	ldr	x1, [sp, #24]
    a000fd74:	97fffcb7 	bl	a000f050 <z_obj_validation_check>
    a000fd78:	7100001f 	cmp	w0, #0x0
    a000fd7c:	1a9f07e0 	cset	w0, ne  // ne = any
    a000fd80:	3908bfe0 	strb	w0, [sp, #559]
    a000fd84:	3948bfe0 	ldrb	w0, [sp, #559]
    a000fd88:	7100001f 	cmp	w0, #0x0
    a000fd8c:	3948bfe0 	ldrb	w0, [sp, #559]
    a000fd90:	7100001f 	cmp	w0, #0x0
    a000fd94:	540001c1 	b.ne	a000fdcc <z_vrfy_uart_irq_is_pending+0x7c>  // b.any
    a000fd98:	f9400fe0 	ldr	x0, [sp, #24]
    a000fd9c:	f9400800 	ldr	x0, [x0, #16]
    a000fda0:	f9011be0 	str	x0, [sp, #560]
    a000fda4:	f9411be0 	ldr	x0, [sp, #560]
    a000fda8:	f9404000 	ldr	x0, [x0, #128]
    a000fdac:	f100001f 	cmp	x0, #0x0
    a000fdb0:	1a9f17e0 	cset	w0, eq  // eq = none
    a000fdb4:	3908ffe0 	strb	w0, [sp, #575]
    a000fdb8:	3948ffe0 	ldrb	w0, [sp, #575]
    a000fdbc:	7100001f 	cmp	w0, #0x0
    a000fdc0:	3948ffe0 	ldrb	w0, [sp, #575]
    a000fdc4:	7100001f 	cmp	w0, #0x0
    a000fdc8:	540000c0 	b.eq	a000fde0 <z_vrfy_uart_irq_is_pending+0x90>  // b.none
    a000fdcc:	900001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000fdd0:	913f8000 	add	x0, x0, #0xfe0
    a000fdd4:	f9400800 	ldr	x0, [x0, #16]
    a000fdd8:	f9408400 	ldr	x0, [x0, #264]
    a000fddc:	97ffe4df 	bl	a0009158 <arch_syscall_oops>
    a000fde0:	f9400fe0 	ldr	x0, [sp, #24]
    a000fde4:	97fffc77 	bl	a000efc0 <z_impl_uart_irq_is_pending>
    a000fde8:	a9407bfd 	ldp	x29, x30, [sp]
    a000fdec:	910903ff 	add	sp, sp, #0x240
    a000fdf0:	d65f03c0 	ret

00000000a000fdf4 <z_vrfy_uart_irq_update>:
UART_SIMPLE(irq_update)
    a000fdf4:	d10903ff 	sub	sp, sp, #0x240
    a000fdf8:	a9007bfd 	stp	x29, x30, [sp]
    a000fdfc:	910003fd 	mov	x29, sp
    a000fe00:	f9000fe0 	str	x0, [sp, #24]
    a000fe04:	f9400fe0 	ldr	x0, [sp, #24]
    a000fe08:	94003308 	bl	a001ca28 <z_object_find>
    a000fe0c:	52800003 	mov	w3, #0x0                   	// #0
    a000fe10:	52800602 	mov	w2, #0x30                  	// #48
    a000fe14:	f9400fe1 	ldr	x1, [sp, #24]
    a000fe18:	97fffc8e 	bl	a000f050 <z_obj_validation_check>
    a000fe1c:	7100001f 	cmp	w0, #0x0
    a000fe20:	1a9f07e0 	cset	w0, ne  // ne = any
    a000fe24:	3908bfe0 	strb	w0, [sp, #559]
    a000fe28:	3948bfe0 	ldrb	w0, [sp, #559]
    a000fe2c:	7100001f 	cmp	w0, #0x0
    a000fe30:	3948bfe0 	ldrb	w0, [sp, #559]
    a000fe34:	7100001f 	cmp	w0, #0x0
    a000fe38:	540001c1 	b.ne	a000fe70 <z_vrfy_uart_irq_update+0x7c>  // b.any
    a000fe3c:	f9400fe0 	ldr	x0, [sp, #24]
    a000fe40:	f9400800 	ldr	x0, [x0, #16]
    a000fe44:	f9011be0 	str	x0, [sp, #560]
    a000fe48:	f9411be0 	ldr	x0, [sp, #560]
    a000fe4c:	f9404400 	ldr	x0, [x0, #136]
    a000fe50:	f100001f 	cmp	x0, #0x0
    a000fe54:	1a9f17e0 	cset	w0, eq  // eq = none
    a000fe58:	3908ffe0 	strb	w0, [sp, #575]
    a000fe5c:	3948ffe0 	ldrb	w0, [sp, #575]
    a000fe60:	7100001f 	cmp	w0, #0x0
    a000fe64:	3948ffe0 	ldrb	w0, [sp, #575]
    a000fe68:	7100001f 	cmp	w0, #0x0
    a000fe6c:	540000c0 	b.eq	a000fe84 <z_vrfy_uart_irq_update+0x90>  // b.none
    a000fe70:	900001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000fe74:	913f8000 	add	x0, x0, #0xfe0
    a000fe78:	f9400800 	ldr	x0, [x0, #16]
    a000fe7c:	f9408400 	ldr	x0, [x0, #264]
    a000fe80:	97ffe4b6 	bl	a0009158 <arch_syscall_oops>
    a000fe84:	f9400fe0 	ldr	x0, [sp, #24]
    a000fe88:	97fffc60 	bl	a000f008 <z_impl_uart_irq_update>
    a000fe8c:	a9407bfd 	ldp	x29, x30, [sp]
    a000fe90:	910903ff 	add	sp, sp, #0x240
    a000fe94:	d65f03c0 	ret

00000000a000fe98 <z_mrsh_uart_irq_tx_enable>:
#include <syscalls/uart.h>

extern void z_vrfy_uart_irq_tx_enable(const struct device * dev);
uintptr_t z_mrsh_uart_irq_tx_enable(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a000fe98:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a000fe9c:	910003fd 	mov	x29, sp
    a000fea0:	f90027e0 	str	x0, [sp, #72]
    a000fea4:	f90023e1 	str	x1, [sp, #64]
    a000fea8:	f9001fe2 	str	x2, [sp, #56]
    a000feac:	f9001be3 	str	x3, [sp, #48]
    a000feb0:	f90017e4 	str	x4, [sp, #40]
    a000feb4:	f90013e5 	str	x5, [sp, #32]
    a000feb8:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a000febc:	900001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000fec0:	913f8000 	add	x0, x0, #0xfe0
    a000fec4:	f9400800 	ldr	x0, [x0, #16]
    a000fec8:	f9400fe1 	ldr	x1, [sp, #24]
    a000fecc:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_uart_irq_tx_enable(*(const struct device **)&arg0)
    a000fed0:	910123e0 	add	x0, sp, #0x48
    a000fed4:	f9400000 	ldr	x0, [x0]
    a000fed8:	97fffea2 	bl	a000f960 <z_vrfy_uart_irq_tx_enable>
;
	_current->syscall_frame = NULL;
    a000fedc:	900001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000fee0:	913f8000 	add	x0, x0, #0xfe0
    a000fee4:	f9400800 	ldr	x0, [x0, #16]
    a000fee8:	f900841f 	str	xzr, [x0, #264]
	return 0;
    a000feec:	d2800000 	mov	x0, #0x0                   	// #0
}
    a000fef0:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a000fef4:	d65f03c0 	ret

00000000a000fef8 <z_mrsh_uart_irq_tx_disable>:
#include <syscalls/uart.h>

extern void z_vrfy_uart_irq_tx_disable(const struct device * dev);
uintptr_t z_mrsh_uart_irq_tx_disable(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a000fef8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a000fefc:	910003fd 	mov	x29, sp
    a000ff00:	f90027e0 	str	x0, [sp, #72]
    a000ff04:	f90023e1 	str	x1, [sp, #64]
    a000ff08:	f9001fe2 	str	x2, [sp, #56]
    a000ff0c:	f9001be3 	str	x3, [sp, #48]
    a000ff10:	f90017e4 	str	x4, [sp, #40]
    a000ff14:	f90013e5 	str	x5, [sp, #32]
    a000ff18:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a000ff1c:	900001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000ff20:	913f8000 	add	x0, x0, #0xfe0
    a000ff24:	f9400800 	ldr	x0, [x0, #16]
    a000ff28:	f9400fe1 	ldr	x1, [sp, #24]
    a000ff2c:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_uart_irq_tx_disable(*(const struct device **)&arg0)
    a000ff30:	910123e0 	add	x0, sp, #0x48
    a000ff34:	f9400000 	ldr	x0, [x0]
    a000ff38:	97fffeb4 	bl	a000fa08 <z_vrfy_uart_irq_tx_disable>
;
	_current->syscall_frame = NULL;
    a000ff3c:	900001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000ff40:	913f8000 	add	x0, x0, #0xfe0
    a000ff44:	f9400800 	ldr	x0, [x0, #16]
    a000ff48:	f900841f 	str	xzr, [x0, #264]
	return 0;
    a000ff4c:	d2800000 	mov	x0, #0x0                   	// #0
}
    a000ff50:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a000ff54:	d65f03c0 	ret

00000000a000ff58 <z_mrsh_uart_irq_rx_enable>:
#include <syscalls/uart.h>

extern void z_vrfy_uart_irq_rx_enable(const struct device * dev);
uintptr_t z_mrsh_uart_irq_rx_enable(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a000ff58:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a000ff5c:	910003fd 	mov	x29, sp
    a000ff60:	f90027e0 	str	x0, [sp, #72]
    a000ff64:	f90023e1 	str	x1, [sp, #64]
    a000ff68:	f9001fe2 	str	x2, [sp, #56]
    a000ff6c:	f9001be3 	str	x3, [sp, #48]
    a000ff70:	f90017e4 	str	x4, [sp, #40]
    a000ff74:	f90013e5 	str	x5, [sp, #32]
    a000ff78:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a000ff7c:	900001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000ff80:	913f8000 	add	x0, x0, #0xfe0
    a000ff84:	f9400800 	ldr	x0, [x0, #16]
    a000ff88:	f9400fe1 	ldr	x1, [sp, #24]
    a000ff8c:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_uart_irq_rx_enable(*(const struct device **)&arg0)
    a000ff90:	910123e0 	add	x0, sp, #0x48
    a000ff94:	f9400000 	ldr	x0, [x0]
    a000ff98:	97fffec6 	bl	a000fab0 <z_vrfy_uart_irq_rx_enable>
;
	_current->syscall_frame = NULL;
    a000ff9c:	900001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000ffa0:	913f8000 	add	x0, x0, #0xfe0
    a000ffa4:	f9400800 	ldr	x0, [x0, #16]
    a000ffa8:	f900841f 	str	xzr, [x0, #264]
	return 0;
    a000ffac:	d2800000 	mov	x0, #0x0                   	// #0
}
    a000ffb0:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a000ffb4:	d65f03c0 	ret

00000000a000ffb8 <z_mrsh_uart_irq_rx_disable>:
#include <syscalls/uart.h>

extern void z_vrfy_uart_irq_rx_disable(const struct device * dev);
uintptr_t z_mrsh_uart_irq_rx_disable(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a000ffb8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a000ffbc:	910003fd 	mov	x29, sp
    a000ffc0:	f90027e0 	str	x0, [sp, #72]
    a000ffc4:	f90023e1 	str	x1, [sp, #64]
    a000ffc8:	f9001fe2 	str	x2, [sp, #56]
    a000ffcc:	f9001be3 	str	x3, [sp, #48]
    a000ffd0:	f90017e4 	str	x4, [sp, #40]
    a000ffd4:	f90013e5 	str	x5, [sp, #32]
    a000ffd8:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a000ffdc:	900001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a000ffe0:	913f8000 	add	x0, x0, #0xfe0
    a000ffe4:	f9400800 	ldr	x0, [x0, #16]
    a000ffe8:	f9400fe1 	ldr	x1, [sp, #24]
    a000ffec:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_uart_irq_rx_disable(*(const struct device **)&arg0)
    a000fff0:	910123e0 	add	x0, sp, #0x48
    a000fff4:	f9400000 	ldr	x0, [x0]
    a000fff8:	97fffed8 	bl	a000fb58 <z_vrfy_uart_irq_rx_disable>
;
	_current->syscall_frame = NULL;
    a000fffc:	900001c0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0010000:	913f8000 	add	x0, x0, #0xfe0
    a0010004:	f9400800 	ldr	x0, [x0, #16]
    a0010008:	f900841f 	str	xzr, [x0, #264]
	return 0;
    a001000c:	d2800000 	mov	x0, #0x0                   	// #0
}
    a0010010:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a0010014:	d65f03c0 	ret

00000000a0010018 <z_mrsh_uart_irq_err_enable>:
#include <syscalls/uart.h>

extern void z_vrfy_uart_irq_err_enable(const struct device * dev);
uintptr_t z_mrsh_uart_irq_err_enable(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a0010018:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a001001c:	910003fd 	mov	x29, sp
    a0010020:	f90027e0 	str	x0, [sp, #72]
    a0010024:	f90023e1 	str	x1, [sp, #64]
    a0010028:	f9001fe2 	str	x2, [sp, #56]
    a001002c:	f9001be3 	str	x3, [sp, #48]
    a0010030:	f90017e4 	str	x4, [sp, #40]
    a0010034:	f90013e5 	str	x5, [sp, #32]
    a0010038:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a001003c:	f00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0010040:	913f8000 	add	x0, x0, #0xfe0
    a0010044:	f9400800 	ldr	x0, [x0, #16]
    a0010048:	f9400fe1 	ldr	x1, [sp, #24]
    a001004c:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_uart_irq_err_enable(*(const struct device **)&arg0)
    a0010050:	910123e0 	add	x0, sp, #0x48
    a0010054:	f9400000 	ldr	x0, [x0]
    a0010058:	97fffeea 	bl	a000fc00 <z_vrfy_uart_irq_err_enable>
;
	_current->syscall_frame = NULL;
    a001005c:	f00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0010060:	913f8000 	add	x0, x0, #0xfe0
    a0010064:	f9400800 	ldr	x0, [x0, #16]
    a0010068:	f900841f 	str	xzr, [x0, #264]
	return 0;
    a001006c:	d2800000 	mov	x0, #0x0                   	// #0
}
    a0010070:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a0010074:	d65f03c0 	ret

00000000a0010078 <z_mrsh_uart_irq_err_disable>:
#include <syscalls/uart.h>

extern void z_vrfy_uart_irq_err_disable(const struct device * dev);
uintptr_t z_mrsh_uart_irq_err_disable(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a0010078:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a001007c:	910003fd 	mov	x29, sp
    a0010080:	f90027e0 	str	x0, [sp, #72]
    a0010084:	f90023e1 	str	x1, [sp, #64]
    a0010088:	f9001fe2 	str	x2, [sp, #56]
    a001008c:	f9001be3 	str	x3, [sp, #48]
    a0010090:	f90017e4 	str	x4, [sp, #40]
    a0010094:	f90013e5 	str	x5, [sp, #32]
    a0010098:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a001009c:	f00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00100a0:	913f8000 	add	x0, x0, #0xfe0
    a00100a4:	f9400800 	ldr	x0, [x0, #16]
    a00100a8:	f9400fe1 	ldr	x1, [sp, #24]
    a00100ac:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_uart_irq_err_disable(*(const struct device **)&arg0)
    a00100b0:	910123e0 	add	x0, sp, #0x48
    a00100b4:	f9400000 	ldr	x0, [x0]
    a00100b8:	97fffefc 	bl	a000fca8 <z_vrfy_uart_irq_err_disable>
;
	_current->syscall_frame = NULL;
    a00100bc:	f00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00100c0:	913f8000 	add	x0, x0, #0xfe0
    a00100c4:	f9400800 	ldr	x0, [x0, #16]
    a00100c8:	f900841f 	str	xzr, [x0, #264]
	return 0;
    a00100cc:	d2800000 	mov	x0, #0x0                   	// #0
}
    a00100d0:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a00100d4:	d65f03c0 	ret

00000000a00100d8 <z_mrsh_uart_irq_is_pending>:
#include <syscalls/uart.h>

extern int z_vrfy_uart_irq_is_pending(const struct device * dev);
uintptr_t z_mrsh_uart_irq_is_pending(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a00100d8:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a00100dc:	910003fd 	mov	x29, sp
    a00100e0:	f90027e0 	str	x0, [sp, #72]
    a00100e4:	f90023e1 	str	x1, [sp, #64]
    a00100e8:	f9001fe2 	str	x2, [sp, #56]
    a00100ec:	f9001be3 	str	x3, [sp, #48]
    a00100f0:	f90017e4 	str	x4, [sp, #40]
    a00100f4:	f90013e5 	str	x5, [sp, #32]
    a00100f8:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a00100fc:	f00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0010100:	913f8000 	add	x0, x0, #0xfe0
    a0010104:	f9400800 	ldr	x0, [x0, #16]
    a0010108:	f9400fe1 	ldr	x1, [sp, #24]
    a001010c:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_uart_irq_is_pending(*(const struct device **)&arg0)
    a0010110:	910123e0 	add	x0, sp, #0x48
    a0010114:	f9400000 	ldr	x0, [x0]
    a0010118:	97ffff0e 	bl	a000fd50 <z_vrfy_uart_irq_is_pending>
    a001011c:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a0010120:	f00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0010124:	913f8000 	add	x0, x0, #0xfe0
    a0010128:	f9400800 	ldr	x0, [x0, #16]
    a001012c:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a0010130:	b9805fe0 	ldrsw	x0, [sp, #92]
}
    a0010134:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a0010138:	d65f03c0 	ret

00000000a001013c <z_mrsh_uart_irq_update>:
#include <syscalls/uart.h>

extern int z_vrfy_uart_irq_update(const struct device * dev);
uintptr_t z_mrsh_uart_irq_update(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a001013c:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a0010140:	910003fd 	mov	x29, sp
    a0010144:	f90027e0 	str	x0, [sp, #72]
    a0010148:	f90023e1 	str	x1, [sp, #64]
    a001014c:	f9001fe2 	str	x2, [sp, #56]
    a0010150:	f9001be3 	str	x3, [sp, #48]
    a0010154:	f90017e4 	str	x4, [sp, #40]
    a0010158:	f90013e5 	str	x5, [sp, #32]
    a001015c:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a0010160:	f00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0010164:	913f8000 	add	x0, x0, #0xfe0
    a0010168:	f9400800 	ldr	x0, [x0, #16]
    a001016c:	f9400fe1 	ldr	x1, [sp, #24]
    a0010170:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_uart_irq_update(*(const struct device **)&arg0)
    a0010174:	910123e0 	add	x0, sp, #0x48
    a0010178:	f9400000 	ldr	x0, [x0]
    a001017c:	97ffff1e 	bl	a000fdf4 <z_vrfy_uart_irq_update>
    a0010180:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a0010184:	f00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0010188:	913f8000 	add	x0, x0, #0xfe0
    a001018c:	f9400800 	ldr	x0, [x0, #16]
    a0010190:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a0010194:	b9805fe0 	ldrsw	x0, [sp, #92]
}
    a0010198:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a001019c:	d65f03c0 	ret

00000000a00101a0 <sys_clock_hw_cycles_per_sec>:
	return CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC;
    a00101a0:	52959400 	mov	w0, #0xaca0                	// #44192
    a00101a4:	72a07720 	movk	w0, #0x3b9, lsl #16
}
    a00101a8:	d65f03c0 	ret

00000000a00101ac <arm_arch_timer_compare_isr>:

static struct k_spinlock lock;
static uint64_t last_cycle;

static void arm_arch_timer_compare_isr(const void *arg)
{
    a00101ac:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
    a00101b0:	910003fd 	mov	x29, sp
    a00101b4:	f9000bf3 	str	x19, [sp, #16]
    a00101b8:	f90017e0 	str	x0, [sp, #40]
    a00101bc:	f00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00101c0:	913f6000 	add	x0, x0, #0xfd8
    a00101c4:	f9004be0 	str	x0, [sp, #144]
MAKE_REG_HELPER(daif)
    a00101c8:	d53b4220 	mrs	x0, daif
    a00101cc:	f90047e0 	str	x0, [sp, #136]
    a00101d0:	f94047e0 	ldr	x0, [sp, #136]
    a00101d4:	d503201f 	nop
	key = read_daif();
    a00101d8:	b90087e0 	str	w0, [sp, #132]
	__asm__ volatile ("msr DAIFSet, %0"
    a00101dc:	d50342df 	msr	daifset, #0x2
}
    a00101e0:	d503201f 	nop
	return key;
    a00101e4:	b94087e0 	ldr	w0, [sp, #132]
	k.key = arch_irq_lock();
    a00101e8:	b90033e0 	str	w0, [sp, #48]
	return k;
    a00101ec:	b94033e0 	ldr	w0, [sp, #48]
    a00101f0:	b90043e0 	str	w0, [sp, #64]
MAKE_REG_HELPER(cntvct_el0);
    a00101f4:	d53be040 	mrs	x0, cntvct_el0
    a00101f8:	f9004fe0 	str	x0, [sp, #152]
    a00101fc:	f9404fe0 	ldr	x0, [sp, #152]
    a0010200:	d503201f 	nop
	write_cntv_ctl_el0(cntv_ctl);
}

static ALWAYS_INLINE uint64_t arm_arch_timer_count(void)
{
	return read_cntvct_el0();
    a0010204:	d503201f 	nop
		k_spin_unlock(&lock, key);
		return;
	}
#endif /* CONFIG_ARM_ARCH_TIMER_ERRATUM_740657 */

	uint64_t curr_cycle = arm_arch_timer_count();
    a0010208:	f90057e0 	str	x0, [sp, #168]
	uint32_t delta_ticks = (uint32_t)((curr_cycle - last_cycle) / CYC_PER_TICK);
    a001020c:	f00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0010210:	913f6000 	add	x0, x0, #0xfd8
    a0010214:	f9400000 	ldr	x0, [x0]
    a0010218:	f94057e1 	ldr	x1, [sp, #168]
    a001021c:	cb000033 	sub	x19, x1, x0
    a0010220:	97ffffe0 	bl	a00101a0 <sys_clock_hw_cycles_per_sec>
    a0010224:	93407c00 	sxtw	x0, w0
    a0010228:	d342fc01 	lsr	x1, x0, #2
    a001022c:	d29eb860 	mov	x0, #0xf5c3                	// #62915
    a0010230:	f2ab8500 	movk	x0, #0x5c28, lsl #16
    a0010234:	f2d851e0 	movk	x0, #0xc28f, lsl #32
    a0010238:	f2e51ea0 	movk	x0, #0x28f5, lsl #48
    a001023c:	9bc07c20 	umulh	x0, x1, x0
    a0010240:	d342fc00 	lsr	x0, x0, #2
    a0010244:	9ac00a60 	udiv	x0, x19, x0
    a0010248:	b900a7e0 	str	w0, [sp, #164]

	last_cycle += delta_ticks * CYC_PER_TICK;
    a001024c:	b940a7f3 	ldr	w19, [sp, #164]
    a0010250:	97ffffd4 	bl	a00101a0 <sys_clock_hw_cycles_per_sec>
    a0010254:	93407c00 	sxtw	x0, w0
    a0010258:	d342fc01 	lsr	x1, x0, #2
    a001025c:	d29eb860 	mov	x0, #0xf5c3                	// #62915
    a0010260:	f2ab8500 	movk	x0, #0x5c28, lsl #16
    a0010264:	f2d851e0 	movk	x0, #0xc28f, lsl #32
    a0010268:	f2e51ea0 	movk	x0, #0x28f5, lsl #48
    a001026c:	9bc07c20 	umulh	x0, x1, x0
    a0010270:	d342fc00 	lsr	x0, x0, #2
    a0010274:	9b007e61 	mul	x1, x19, x0
    a0010278:	f00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001027c:	913f6000 	add	x0, x0, #0xfd8
    a0010280:	f9400000 	ldr	x0, [x0]
    a0010284:	8b000021 	add	x1, x1, x0
    a0010288:	f00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001028c:	913f6000 	add	x0, x0, #0xfd8
    a0010290:	f9000001 	str	x1, [x0]
    a0010294:	52800020 	mov	w0, #0x1                   	// #1
    a0010298:	39019fe0 	strb	w0, [sp, #103]
MAKE_REG_HELPER(cntv_ctl_el0)
    a001029c:	d53be320 	mrs	x0, cntv_ctl_el0
    a00102a0:	f9002fe0 	str	x0, [sp, #88]
    a00102a4:	f9402fe0 	ldr	x0, [sp, #88]
    a00102a8:	d503201f 	nop
	cntv_ctl = read_cntv_ctl_el0();
    a00102ac:	f9002be0 	str	x0, [sp, #80]
	if (mask) {
    a00102b0:	39419fe0 	ldrb	w0, [sp, #103]
    a00102b4:	7100001f 	cmp	w0, #0x0
    a00102b8:	540000a0 	b.eq	a00102cc <arm_arch_timer_compare_isr+0x120>  // b.none
		cntv_ctl |= CNTV_CTL_IMASK_BIT;
    a00102bc:	f9402be0 	ldr	x0, [sp, #80]
    a00102c0:	b27f0000 	orr	x0, x0, #0x2
    a00102c4:	f9002be0 	str	x0, [sp, #80]
    a00102c8:	14000004 	b	a00102d8 <arm_arch_timer_compare_isr+0x12c>
		cntv_ctl &= ~CNTV_CTL_IMASK_BIT;
    a00102cc:	f9402be0 	ldr	x0, [sp, #80]
    a00102d0:	927ef800 	and	x0, x0, #0xfffffffffffffffd
    a00102d4:	f9002be0 	str	x0, [sp, #80]
    a00102d8:	f9402be0 	ldr	x0, [sp, #80]
    a00102dc:	f90027e0 	str	x0, [sp, #72]
    a00102e0:	f94027e0 	ldr	x0, [sp, #72]
    a00102e4:	d51be320 	msr	cntv_ctl_el0, x0
    a00102e8:	d503201f 	nop
}
    a00102ec:	d503201f 	nop
    a00102f0:	f00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00102f4:	913f6000 	add	x0, x0, #0xfd8
    a00102f8:	f9003fe0 	str	x0, [sp, #120]
    a00102fc:	b94043e0 	ldr	w0, [sp, #64]
    a0010300:	b9003be0 	str	w0, [sp, #56]
	arch_irq_unlock(key.key);
    a0010304:	b9403be0 	ldr	w0, [sp, #56]
    a0010308:	b90077e0 	str	w0, [sp, #116]
	write_daif(key);
    a001030c:	b94077e0 	ldr	w0, [sp, #116]
    a0010310:	f90037e0 	str	x0, [sp, #104]
MAKE_REG_HELPER(daif)
    a0010314:	f94037e0 	ldr	x0, [sp, #104]
    a0010318:	d51b4220 	msr	daif, x0
    a001031c:	d503201f 	nop
}
    a0010320:	d503201f 	nop
}
    a0010324:	d503201f 	nop
	}
#endif /* CONFIG_ARM_ARCH_TIMER_ERRATUM_740657 */

	k_spin_unlock(&lock, key);

	sys_clock_announce(delta_ticks);
    a0010328:	b940a7e0 	ldr	w0, [sp, #164]
    a001032c:	94002734 	bl	a0019ffc <sys_clock_announce>
}
    a0010330:	d503201f 	nop
    a0010334:	f9400bf3 	ldr	x19, [sp, #16]
    a0010338:	a8cb7bfd 	ldp	x29, x30, [sp], #176
    a001033c:	d65f03c0 	ret

00000000a0010340 <sys_clock_set_timeout>:

void sys_clock_set_timeout(int32_t ticks, bool idle)
{
    a0010340:	a9b47bfd 	stp	x29, x30, [sp, #-192]!
    a0010344:	910003fd 	mov	x29, sp
    a0010348:	f9000bf3 	str	x19, [sp, #16]
    a001034c:	b9002fe0 	str	w0, [sp, #44]
    a0010350:	3900afe1 	strb	w1, [sp, #43]
#if defined(CONFIG_TICKLESS_KERNEL)

	if (ticks == K_TICKS_FOREVER && idle) {
    a0010354:	b9402fe0 	ldr	w0, [sp, #44]
    a0010358:	3100041f 	cmn	w0, #0x1
    a001035c:	54000081 	b.ne	a001036c <sys_clock_set_timeout+0x2c>  // b.any
    a0010360:	3940afe0 	ldrb	w0, [sp, #43]
    a0010364:	7100001f 	cmp	w0, #0x0
    a0010368:	54001361 	b.ne	a00105d4 <sys_clock_set_timeout+0x294>  // b.any
		return;
	}

	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : \
    a001036c:	b9402fe0 	ldr	w0, [sp, #44]
    a0010370:	3100041f 	cmn	w0, #0x1
    a0010374:	54000100 	b.eq	a0010394 <sys_clock_set_timeout+0x54>  // b.none
		MIN(MAX_TICKS,  MAX(ticks - 1,  0));
    a0010378:	b9402fe2 	ldr	w2, [sp, #44]
    a001037c:	b9402fe1 	ldr	w1, [sp, #44]
    a0010380:	52800020 	mov	w0, #0x1                   	// #1
    a0010384:	7100005f 	cmp	w2, #0x0
    a0010388:	1a80c020 	csel	w0, w1, w0, gt
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : \
    a001038c:	51000400 	sub	w0, w0, #0x1
    a0010390:	14000002 	b	a0010398 <sys_clock_set_timeout+0x58>
    a0010394:	12b00000 	mov	w0, #0x7fffffff            	// #2147483647
    a0010398:	b9002fe0 	str	w0, [sp, #44]
    a001039c:	f00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00103a0:	913f6000 	add	x0, x0, #0xfd8
    a00103a4:	f90053e0 	str	x0, [sp, #160]
    a00103a8:	d53b4220 	mrs	x0, daif
    a00103ac:	f9004fe0 	str	x0, [sp, #152]
    a00103b0:	f9404fe0 	ldr	x0, [sp, #152]
    a00103b4:	d503201f 	nop
	key = read_daif();
    a00103b8:	b90097e0 	str	w0, [sp, #148]
	__asm__ volatile ("msr DAIFSet, %0"
    a00103bc:	d50342df 	msr	daifset, #0x2
}
    a00103c0:	d503201f 	nop
	return key;
    a00103c4:	b94097e0 	ldr	w0, [sp, #148]
	k.key = arch_irq_lock();
    a00103c8:	b90033e0 	str	w0, [sp, #48]
	return k;
    a00103cc:	b94033e0 	ldr	w0, [sp, #48]
    a00103d0:	b90043e0 	str	w0, [sp, #64]
MAKE_REG_HELPER(cntvct_el0);
    a00103d4:	d53be040 	mrs	x0, cntvct_el0
    a00103d8:	f90057e0 	str	x0, [sp, #168]
    a00103dc:	f94057e0 	ldr	x0, [sp, #168]
    a00103e0:	d503201f 	nop
	return read_cntvct_el0();
    a00103e4:	d503201f 	nop

	k_spinlock_key_t key = k_spin_lock(&lock);
	uint64_t curr_cycle = arm_arch_timer_count();
    a00103e8:	f9005be0 	str	x0, [sp, #176]
	uint64_t req_cycle = ticks * CYC_PER_TICK;
    a00103ec:	b9802ff3 	ldrsw	x19, [sp, #44]
    a00103f0:	97ffff6c 	bl	a00101a0 <sys_clock_hw_cycles_per_sec>
    a00103f4:	93407c00 	sxtw	x0, w0
    a00103f8:	d342fc01 	lsr	x1, x0, #2
    a00103fc:	d29eb860 	mov	x0, #0xf5c3                	// #62915
    a0010400:	f2ab8500 	movk	x0, #0x5c28, lsl #16
    a0010404:	f2d851e0 	movk	x0, #0xc28f, lsl #32
    a0010408:	f2e51ea0 	movk	x0, #0x28f5, lsl #48
    a001040c:	9bc07c20 	umulh	x0, x1, x0
    a0010410:	d342fc00 	lsr	x0, x0, #2
    a0010414:	9b007e60 	mul	x0, x19, x0
    a0010418:	f9005fe0 	str	x0, [sp, #184]

	/* Round up to next tick boundary */
	req_cycle += (curr_cycle - last_cycle) + (CYC_PER_TICK - 1);
    a001041c:	f00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0010420:	913f6000 	add	x0, x0, #0xfd8
    a0010424:	f9400000 	ldr	x0, [x0]
    a0010428:	f9405be1 	ldr	x1, [sp, #176]
    a001042c:	cb000033 	sub	x19, x1, x0
    a0010430:	97ffff5c 	bl	a00101a0 <sys_clock_hw_cycles_per_sec>
    a0010434:	93407c00 	sxtw	x0, w0
    a0010438:	d342fc01 	lsr	x1, x0, #2
    a001043c:	d29eb860 	mov	x0, #0xf5c3                	// #62915
    a0010440:	f2ab8500 	movk	x0, #0x5c28, lsl #16
    a0010444:	f2d851e0 	movk	x0, #0xc28f, lsl #32
    a0010448:	f2e51ea0 	movk	x0, #0x28f5, lsl #48
    a001044c:	9bc07c20 	umulh	x0, x1, x0
    a0010450:	d342fc00 	lsr	x0, x0, #2
    a0010454:	8b000260 	add	x0, x19, x0
    a0010458:	d1000400 	sub	x0, x0, #0x1
    a001045c:	f9405fe1 	ldr	x1, [sp, #184]
    a0010460:	8b000020 	add	x0, x1, x0
    a0010464:	f9005fe0 	str	x0, [sp, #184]

	req_cycle = (req_cycle / CYC_PER_TICK) * CYC_PER_TICK;
    a0010468:	97ffff4e 	bl	a00101a0 <sys_clock_hw_cycles_per_sec>
    a001046c:	93407c00 	sxtw	x0, w0
    a0010470:	d342fc01 	lsr	x1, x0, #2
    a0010474:	d29eb860 	mov	x0, #0xf5c3                	// #62915
    a0010478:	f2ab8500 	movk	x0, #0x5c28, lsl #16
    a001047c:	f2d851e0 	movk	x0, #0xc28f, lsl #32
    a0010480:	f2e51ea0 	movk	x0, #0x28f5, lsl #48
    a0010484:	9bc07c20 	umulh	x0, x1, x0
    a0010488:	d342fc00 	lsr	x0, x0, #2
    a001048c:	f9405fe1 	ldr	x1, [sp, #184]
    a0010490:	9ac00833 	udiv	x19, x1, x0
    a0010494:	97ffff43 	bl	a00101a0 <sys_clock_hw_cycles_per_sec>
    a0010498:	93407c00 	sxtw	x0, w0
    a001049c:	d342fc01 	lsr	x1, x0, #2
    a00104a0:	d29eb860 	mov	x0, #0xf5c3                	// #62915
    a00104a4:	f2ab8500 	movk	x0, #0x5c28, lsl #16
    a00104a8:	f2d851e0 	movk	x0, #0xc28f, lsl #32
    a00104ac:	f2e51ea0 	movk	x0, #0x28f5, lsl #48
    a00104b0:	9bc07c20 	umulh	x0, x1, x0
    a00104b4:	d342fc00 	lsr	x0, x0, #2
    a00104b8:	9b007e60 	mul	x0, x19, x0
    a00104bc:	f9005fe0 	str	x0, [sp, #184]

	if ((req_cycle + last_cycle - curr_cycle) < MIN_DELAY) {
    a00104c0:	f00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00104c4:	913f6000 	add	x0, x0, #0xfd8
    a00104c8:	f9400001 	ldr	x1, [x0]
    a00104cc:	f9405fe0 	ldr	x0, [sp, #184]
    a00104d0:	8b000021 	add	x1, x1, x0
    a00104d4:	f9405be0 	ldr	x0, [sp, #176]
    a00104d8:	cb000020 	sub	x0, x1, x0
    a00104dc:	f10f9c1f 	cmp	x0, #0x3e7
    a00104e0:	540001a8 	b.hi	a0010514 <sys_clock_set_timeout+0x1d4>  // b.pmore
		req_cycle += CYC_PER_TICK;
    a00104e4:	97ffff2f 	bl	a00101a0 <sys_clock_hw_cycles_per_sec>
    a00104e8:	93407c00 	sxtw	x0, w0
    a00104ec:	d342fc01 	lsr	x1, x0, #2
    a00104f0:	d29eb860 	mov	x0, #0xf5c3                	// #62915
    a00104f4:	f2ab8500 	movk	x0, #0x5c28, lsl #16
    a00104f8:	f2d851e0 	movk	x0, #0xc28f, lsl #32
    a00104fc:	f2e51ea0 	movk	x0, #0x28f5, lsl #48
    a0010500:	9bc07c20 	umulh	x0, x1, x0
    a0010504:	d342fc00 	lsr	x0, x0, #2
    a0010508:	f9405fe1 	ldr	x1, [sp, #184]
    a001050c:	8b000020 	add	x0, x1, x0
    a0010510:	f9005fe0 	str	x0, [sp, #184]
	}

	arm_arch_timer_set_compare(req_cycle + last_cycle);
    a0010514:	f00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0010518:	913f6000 	add	x0, x0, #0xfd8
    a001051c:	f9400001 	ldr	x1, [x0]
    a0010520:	f9405fe0 	ldr	x0, [sp, #184]
    a0010524:	8b000020 	add	x0, x1, x0
    a0010528:	f9002be0 	str	x0, [sp, #80]
    a001052c:	f9402be0 	ldr	x0, [sp, #80]
    a0010530:	f90027e0 	str	x0, [sp, #72]
MAKE_REG_HELPER(cntv_cval_el0)
    a0010534:	f94027e0 	ldr	x0, [sp, #72]
    a0010538:	d51be340 	msr	cntv_cval_el0, x0
    a001053c:	d503201f 	nop
}
    a0010540:	d503201f 	nop
    a0010544:	3901dfff 	strb	wzr, [sp, #119]
MAKE_REG_HELPER(cntv_ctl_el0)
    a0010548:	d53be320 	mrs	x0, cntv_ctl_el0
    a001054c:	f90037e0 	str	x0, [sp, #104]
    a0010550:	f94037e0 	ldr	x0, [sp, #104]
    a0010554:	d503201f 	nop
	cntv_ctl = read_cntv_ctl_el0();
    a0010558:	f90033e0 	str	x0, [sp, #96]
	if (mask) {
    a001055c:	3941dfe0 	ldrb	w0, [sp, #119]
    a0010560:	7100001f 	cmp	w0, #0x0
    a0010564:	540000a0 	b.eq	a0010578 <sys_clock_set_timeout+0x238>  // b.none
		cntv_ctl |= CNTV_CTL_IMASK_BIT;
    a0010568:	f94033e0 	ldr	x0, [sp, #96]
    a001056c:	b27f0000 	orr	x0, x0, #0x2
    a0010570:	f90033e0 	str	x0, [sp, #96]
    a0010574:	14000004 	b	a0010584 <sys_clock_set_timeout+0x244>
		cntv_ctl &= ~CNTV_CTL_IMASK_BIT;
    a0010578:	f94033e0 	ldr	x0, [sp, #96]
    a001057c:	927ef800 	and	x0, x0, #0xfffffffffffffffd
    a0010580:	f90033e0 	str	x0, [sp, #96]
    a0010584:	f94033e0 	ldr	x0, [sp, #96]
    a0010588:	f9002fe0 	str	x0, [sp, #88]
    a001058c:	f9402fe0 	ldr	x0, [sp, #88]
    a0010590:	d51be320 	msr	cntv_ctl_el0, x0
    a0010594:	d503201f 	nop
}
    a0010598:	d503201f 	nop
    a001059c:	f00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00105a0:	913f6000 	add	x0, x0, #0xfd8
    a00105a4:	f90047e0 	str	x0, [sp, #136]
    a00105a8:	b94043e0 	ldr	w0, [sp, #64]
    a00105ac:	b9003be0 	str	w0, [sp, #56]
	arch_irq_unlock(key.key);
    a00105b0:	b9403be0 	ldr	w0, [sp, #56]
    a00105b4:	b90087e0 	str	w0, [sp, #132]
	write_daif(key);
    a00105b8:	b94087e0 	ldr	w0, [sp, #132]
    a00105bc:	f9003fe0 	str	x0, [sp, #120]
MAKE_REG_HELPER(daif)
    a00105c0:	f9403fe0 	ldr	x0, [sp, #120]
    a00105c4:	d51b4220 	msr	daif, x0
    a00105c8:	d503201f 	nop
}
    a00105cc:	d503201f 	nop
}
    a00105d0:	14000002 	b	a00105d8 <sys_clock_set_timeout+0x298>
		return;
    a00105d4:	d503201f 	nop

#else  /* CONFIG_TICKLESS_KERNEL */
	ARG_UNUSED(ticks);
	ARG_UNUSED(idle);
#endif
}
    a00105d8:	f9400bf3 	ldr	x19, [sp, #16]
    a00105dc:	a8cc7bfd 	ldp	x29, x30, [sp], #192
    a00105e0:	d65f03c0 	ret

00000000a00105e4 <sys_clock_elapsed>:

uint32_t sys_clock_elapsed(void)
{
    a00105e4:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    a00105e8:	910003fd 	mov	x29, sp
    a00105ec:	f9000bf3 	str	x19, [sp, #16]
    a00105f0:	f00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00105f4:	913f6000 	add	x0, x0, #0xfd8
    a00105f8:	f90023e0 	str	x0, [sp, #64]
    a00105fc:	d53b4220 	mrs	x0, daif
    a0010600:	f9001fe0 	str	x0, [sp, #56]
    a0010604:	f9401fe0 	ldr	x0, [sp, #56]
    a0010608:	d503201f 	nop
	key = read_daif();
    a001060c:	b90037e0 	str	w0, [sp, #52]
	__asm__ volatile ("msr DAIFSet, %0"
    a0010610:	d50342df 	msr	daifset, #0x2
}
    a0010614:	d503201f 	nop
	return key;
    a0010618:	b94037e0 	ldr	w0, [sp, #52]
	k.key = arch_irq_lock();
    a001061c:	b9002be0 	str	w0, [sp, #40]
	return k;
    a0010620:	b9402be0 	ldr	w0, [sp, #40]
    a0010624:	b90033e0 	str	w0, [sp, #48]
MAKE_REG_HELPER(cntvct_el0);
    a0010628:	d53be040 	mrs	x0, cntvct_el0
    a001062c:	f90027e0 	str	x0, [sp, #72]
    a0010630:	f94027e1 	ldr	x1, [sp, #72]
    a0010634:	d503201f 	nop
	return read_cntvct_el0();
    a0010638:	d503201f 	nop
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return 0;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	uint32_t ret = (uint32_t)((arm_arch_timer_count() - last_cycle)
    a001063c:	f00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0010640:	913f6000 	add	x0, x0, #0xfd8
    a0010644:	f9400000 	ldr	x0, [x0]
    a0010648:	cb000033 	sub	x19, x1, x0
		    / CYC_PER_TICK);
    a001064c:	97fffed5 	bl	a00101a0 <sys_clock_hw_cycles_per_sec>
    a0010650:	93407c00 	sxtw	x0, w0
    a0010654:	d342fc01 	lsr	x1, x0, #2
    a0010658:	d29eb860 	mov	x0, #0xf5c3                	// #62915
    a001065c:	f2ab8500 	movk	x0, #0x5c28, lsl #16
    a0010660:	f2d851e0 	movk	x0, #0xc28f, lsl #32
    a0010664:	f2e51ea0 	movk	x0, #0x28f5, lsl #48
    a0010668:	9bc07c20 	umulh	x0, x1, x0
    a001066c:	d342fc00 	lsr	x0, x0, #2
    a0010670:	9ac00a60 	udiv	x0, x19, x0
	uint32_t ret = (uint32_t)((arm_arch_timer_count() - last_cycle)
    a0010674:	b9006fe0 	str	w0, [sp, #108]
    a0010678:	f00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001067c:	913f6000 	add	x0, x0, #0xfd8
    a0010680:	f90033e0 	str	x0, [sp, #96]
    a0010684:	b94033e0 	ldr	w0, [sp, #48]
    a0010688:	b90023e0 	str	w0, [sp, #32]
	arch_irq_unlock(key.key);
    a001068c:	b94023e0 	ldr	w0, [sp, #32]
    a0010690:	b9005fe0 	str	w0, [sp, #92]
	write_daif(key);
    a0010694:	b9405fe0 	ldr	w0, [sp, #92]
    a0010698:	f9002be0 	str	x0, [sp, #80]
MAKE_REG_HELPER(daif)
    a001069c:	f9402be0 	ldr	x0, [sp, #80]
    a00106a0:	d51b4220 	msr	daif, x0
    a00106a4:	d503201f 	nop
}
    a00106a8:	d503201f 	nop
}
    a00106ac:	d503201f 	nop

	k_spin_unlock(&lock, key);
	return ret;
    a00106b0:	b9406fe0 	ldr	w0, [sp, #108]
}
    a00106b4:	f9400bf3 	ldr	x19, [sp, #16]
    a00106b8:	a8c77bfd 	ldp	x29, x30, [sp], #112
    a00106bc:	d65f03c0 	ret

00000000a00106c0 <arch_busy_wait>:
	return arm_arch_timer_count();
}

#ifdef CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT
void arch_busy_wait(uint32_t usec_to_wait)
{
    a00106c0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a00106c4:	910003fd 	mov	x29, sp
    a00106c8:	b9001fe0 	str	w0, [sp, #28]
	if (usec_to_wait == 0) {
    a00106cc:	b9401fe0 	ldr	w0, [sp, #28]
    a00106d0:	7100001f 	cmp	w0, #0x0
    a00106d4:	540003e0 	b.eq	a0010750 <arch_busy_wait+0x90>  // b.none
MAKE_REG_HELPER(cntvct_el0);
    a00106d8:	d53be040 	mrs	x0, cntvct_el0
    a00106dc:	f9001be0 	str	x0, [sp, #48]
    a00106e0:	f9401be0 	ldr	x0, [sp, #48]
    a00106e4:	d503201f 	nop
    a00106e8:	d503201f 	nop
		return;
	}

	uint64_t start_cycles = arm_arch_timer_count();
    a00106ec:	f90027e0 	str	x0, [sp, #72]

	uint64_t cycles_to_wait = sys_clock_hw_cycles_per_sec() / USEC_PER_SEC * usec_to_wait;
    a00106f0:	97fffeac 	bl	a00101a0 <sys_clock_hw_cycles_per_sec>
    a00106f4:	2a0003e1 	mov	w1, w0
    a00106f8:	529bd060 	mov	w0, #0xde83                	// #56963
    a00106fc:	72a86360 	movk	w0, #0x431b, lsl #16
    a0010700:	9ba07c20 	umull	x0, w1, w0
    a0010704:	d360fc00 	lsr	x0, x0, #32
    a0010708:	53127c01 	lsr	w1, w0, #18
    a001070c:	b9401fe0 	ldr	w0, [sp, #28]
    a0010710:	1b007c20 	mul	w0, w1, w0
    a0010714:	2a0003e0 	mov	w0, w0
    a0010718:	f90023e0 	str	x0, [sp, #64]
    a001071c:	d53be040 	mrs	x0, cntvct_el0
    a0010720:	f90017e0 	str	x0, [sp, #40]
    a0010724:	f94017e0 	ldr	x0, [sp, #40]
    a0010728:	d503201f 	nop
    a001072c:	d503201f 	nop

	for (;;) {
		uint64_t current_cycles = arm_arch_timer_count();
    a0010730:	f9001fe0 	str	x0, [sp, #56]

		/* this handles the rollover on an unsigned 32-bit value */
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
    a0010734:	f9401fe1 	ldr	x1, [sp, #56]
    a0010738:	f94027e0 	ldr	x0, [sp, #72]
    a001073c:	cb000020 	sub	x0, x1, x0
    a0010740:	f94023e1 	ldr	x1, [sp, #64]
    a0010744:	eb00003f 	cmp	x1, x0
    a0010748:	54000089 	b.ls	a0010758 <arch_busy_wait+0x98>  // b.plast
	for (;;) {
    a001074c:	17fffff4 	b	a001071c <arch_busy_wait+0x5c>
		return;
    a0010750:	d503201f 	nop
    a0010754:	14000002 	b	a001075c <arch_busy_wait+0x9c>
			break;
    a0010758:	d503201f 	nop
		}
	}
}
    a001075c:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a0010760:	d65f03c0 	ret

00000000a0010764 <sys_clock_driver_init>:
	arm_arch_timer_set_irq_mask(false);
}
#endif

static int sys_clock_driver_init(const struct device *dev)
{
    a0010764:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
    a0010768:	910003fd 	mov	x29, sp
    a001076c:	f9000bf3 	str	x19, [sp, #16]
    a0010770:	f90017e0 	str	x0, [sp, #40]
	ARG_UNUSED(dev);

	IRQ_CONNECT(ARM_ARCH_TIMER_IRQ, ARM_ARCH_TIMER_PRIO,
    a0010774:	52800042 	mov	w2, #0x2                   	// #2
    a0010778:	52801401 	mov	w1, #0xa0                  	// #160
    a001077c:	52800360 	mov	w0, #0x1b                  	// #27
    a0010780:	97ffe286 	bl	a0009198 <z_arm64_irq_priority_set>
}
    a0010784:	d503201f 	nop
    a0010788:	d53be040 	mrs	x0, cntvct_el0
    a001078c:	f9001fe0 	str	x0, [sp, #56]
    a0010790:	f9401ff3 	ldr	x19, [sp, #56]
    a0010794:	d503201f 	nop
	return read_cntvct_el0();
    a0010798:	d503201f 	nop
		    arm_arch_timer_compare_isr, NULL, ARM_ARCH_TIMER_FLAGS);
	arm_arch_timer_init();
	arm_arch_timer_set_compare(arm_arch_timer_count() + CYC_PER_TICK);
    a001079c:	97fffe81 	bl	a00101a0 <sys_clock_hw_cycles_per_sec>
    a00107a0:	93407c00 	sxtw	x0, w0
    a00107a4:	d342fc01 	lsr	x1, x0, #2
    a00107a8:	d29eb860 	mov	x0, #0xf5c3                	// #62915
    a00107ac:	f2ab8500 	movk	x0, #0x5c28, lsl #16
    a00107b0:	f2d851e0 	movk	x0, #0xc28f, lsl #32
    a00107b4:	f2e51ea0 	movk	x0, #0x28f5, lsl #48
    a00107b8:	9bc07c20 	umulh	x0, x1, x0
    a00107bc:	d342fc00 	lsr	x0, x0, #2
    a00107c0:	8b000260 	add	x0, x19, x0
    a00107c4:	f90027e0 	str	x0, [sp, #72]
    a00107c8:	f94027e0 	ldr	x0, [sp, #72]
    a00107cc:	f90023e0 	str	x0, [sp, #64]
MAKE_REG_HELPER(cntv_cval_el0)
    a00107d0:	f94023e0 	ldr	x0, [sp, #64]
    a00107d4:	d51be340 	msr	cntv_cval_el0, x0
    a00107d8:	d503201f 	nop
}
    a00107dc:	d503201f 	nop
    a00107e0:	52800020 	mov	w0, #0x1                   	// #1
    a00107e4:	3901bfe0 	strb	w0, [sp, #111]
MAKE_REG_HELPER(cntv_ctl_el0)
    a00107e8:	d53be320 	mrs	x0, cntv_ctl_el0
    a00107ec:	f90033e0 	str	x0, [sp, #96]
    a00107f0:	f94033e0 	ldr	x0, [sp, #96]
    a00107f4:	d503201f 	nop
	cntv_ctl = read_cntv_ctl_el0();
    a00107f8:	f9002fe0 	str	x0, [sp, #88]
	if (enable) {
    a00107fc:	3941bfe0 	ldrb	w0, [sp, #111]
    a0010800:	7100001f 	cmp	w0, #0x0
    a0010804:	540000a0 	b.eq	a0010818 <sys_clock_driver_init+0xb4>  // b.none
		cntv_ctl |= CNTV_CTL_ENABLE_BIT;
    a0010808:	f9402fe0 	ldr	x0, [sp, #88]
    a001080c:	b2400000 	orr	x0, x0, #0x1
    a0010810:	f9002fe0 	str	x0, [sp, #88]
    a0010814:	14000004 	b	a0010824 <sys_clock_driver_init+0xc0>
		cntv_ctl &= ~CNTV_CTL_ENABLE_BIT;
    a0010818:	f9402fe0 	ldr	x0, [sp, #88]
    a001081c:	927ff800 	and	x0, x0, #0xfffffffffffffffe
    a0010820:	f9002fe0 	str	x0, [sp, #88]
    a0010824:	f9402fe0 	ldr	x0, [sp, #88]
    a0010828:	f9002be0 	str	x0, [sp, #80]
    a001082c:	f9402be0 	ldr	x0, [sp, #80]
    a0010830:	d51be320 	msr	cntv_ctl_el0, x0
    a0010834:	d503201f 	nop
}
    a0010838:	d503201f 	nop
	arm_arch_timer_enable(true);
	irq_enable(ARM_ARCH_TIMER_IRQ);
    a001083c:	52800360 	mov	w0, #0x1b                  	// #27
    a0010840:	97ffe24e 	bl	a0009178 <arch_irq_enable>
    a0010844:	39023fff 	strb	wzr, [sp, #143]
    a0010848:	d53be320 	mrs	x0, cntv_ctl_el0
    a001084c:	f90043e0 	str	x0, [sp, #128]
    a0010850:	f94043e0 	ldr	x0, [sp, #128]
    a0010854:	d503201f 	nop
	cntv_ctl = read_cntv_ctl_el0();
    a0010858:	f9003fe0 	str	x0, [sp, #120]
	if (mask) {
    a001085c:	39423fe0 	ldrb	w0, [sp, #143]
    a0010860:	7100001f 	cmp	w0, #0x0
    a0010864:	540000a0 	b.eq	a0010878 <sys_clock_driver_init+0x114>  // b.none
		cntv_ctl |= CNTV_CTL_IMASK_BIT;
    a0010868:	f9403fe0 	ldr	x0, [sp, #120]
    a001086c:	b27f0000 	orr	x0, x0, #0x2
    a0010870:	f9003fe0 	str	x0, [sp, #120]
    a0010874:	14000004 	b	a0010884 <sys_clock_driver_init+0x120>
		cntv_ctl &= ~CNTV_CTL_IMASK_BIT;
    a0010878:	f9403fe0 	ldr	x0, [sp, #120]
    a001087c:	927ef800 	and	x0, x0, #0xfffffffffffffffd
    a0010880:	f9003fe0 	str	x0, [sp, #120]
    a0010884:	f9403fe0 	ldr	x0, [sp, #120]
    a0010888:	f9003be0 	str	x0, [sp, #112]
    a001088c:	f9403be0 	ldr	x0, [sp, #112]
    a0010890:	d51be320 	msr	cntv_ctl_el0, x0
    a0010894:	d503201f 	nop
}
    a0010898:	d503201f 	nop
	arm_arch_timer_set_irq_mask(false);

	return 0;
    a001089c:	52800000 	mov	w0, #0x0                   	// #0
}
    a00108a0:	f9400bf3 	ldr	x19, [sp, #16]
    a00108a4:	a8c97bfd 	ldp	x29, x30, [sp], #144
    a00108a8:	d65f03c0 	ret

00000000a00108ac <z_impl_device_is_ready>:
{
    a00108ac:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a00108b0:	910003fd 	mov	x29, sp
    a00108b4:	f9000fe0 	str	x0, [sp, #24]
	return z_device_is_ready(dev);
    a00108b8:	f9400fe0 	ldr	x0, [sp, #24]
    a00108bc:	940000ff 	bl	a0010cb8 <z_device_is_ready>
    a00108c0:	12001c00 	and	w0, w0, #0xff
}
    a00108c4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a00108c8:	d65f03c0 	ret

00000000a00108cc <z_obj_validation_check>:
{
    a00108cc:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    a00108d0:	910003fd 	mov	x29, sp
    a00108d4:	f90017e0 	str	x0, [sp, #40]
    a00108d8:	f90013e1 	str	x1, [sp, #32]
    a00108dc:	b9001fe2 	str	w2, [sp, #28]
    a00108e0:	b9001be3 	str	w3, [sp, #24]
	ret = z_object_validate(ko, otype, init);
    a00108e4:	b9401be2 	ldr	w2, [sp, #24]
    a00108e8:	b9401fe1 	ldr	w1, [sp, #28]
    a00108ec:	f94017e0 	ldr	x0, [sp, #40]
    a00108f0:	94003275 	bl	a001d2c4 <z_object_validate>
    a00108f4:	b9003fe0 	str	w0, [sp, #60]
	return ret;
    a00108f8:	b9403fe0 	ldr	w0, [sp, #60]
}
    a00108fc:	a8c47bfd 	ldp	x29, x30, [sp], #64
    a0010900:	d65f03c0 	ret

00000000a0010904 <z_device_state_init>:
 *
 * The state object is always zero-initialized, but this may not be
 * sufficient.
 */
void z_device_state_init(void)
{
    a0010904:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0010908:	910003fd 	mov	x29, sp
	const struct device *dev = __device_start;
    a001090c:	f0000080 	adrp	x0, a0023000 <__rodata_region_start>
    a0010910:	91024000 	add	x0, x0, #0x90
    a0010914:	f9000fe0 	str	x0, [sp, #24]

	while (dev < __device_end) {
    a0010918:	14000006 	b	a0010930 <z_device_state_init+0x2c>
		z_object_init(dev);
    a001091c:	f9400fe0 	ldr	x0, [sp, #24]
    a0010920:	940032bc 	bl	a001d410 <z_object_init>
		++dev;
    a0010924:	f9400fe0 	ldr	x0, [sp, #24]
    a0010928:	9100c000 	add	x0, x0, #0x30
    a001092c:	f9000fe0 	str	x0, [sp, #24]
	while (dev < __device_end) {
    a0010930:	f9400fe1 	ldr	x1, [sp, #24]
    a0010934:	f0000080 	adrp	x0, a0023000 <__rodata_region_start>
    a0010938:	91030000 	add	x0, x0, #0xc0
    a001093c:	eb00003f 	cmp	x1, x0
    a0010940:	54fffee3 	b.cc	a001091c <z_device_state_init+0x18>  // b.lo, b.ul, b.last
	}
}
    a0010944:	d503201f 	nop
    a0010948:	d503201f 	nop
    a001094c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0010950:	d65f03c0 	ret

00000000a0010954 <z_sys_init_run_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void z_sys_init_run_level(int32_t level)
{
    a0010954:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    a0010958:	910003fd 	mov	x29, sp
    a001095c:	b9001fe0 	str	w0, [sp, #28]
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    a0010960:	f0000440 	adrp	x0, a009b000 <twom1000.10>
    a0010964:	91012000 	add	x0, x0, #0x48
    a0010968:	b9801fe1 	ldrsw	x1, [sp, #28]
    a001096c:	f8617800 	ldr	x0, [x0, x1, lsl #3]
    a0010970:	f9001fe0 	str	x0, [sp, #56]
    a0010974:	14000027 	b	a0010a10 <z_sys_init_run_level+0xbc>
		const struct device *dev = entry->dev;
    a0010978:	f9401fe0 	ldr	x0, [sp, #56]
    a001097c:	f9400400 	ldr	x0, [x0, #8]
    a0010980:	f90017e0 	str	x0, [sp, #40]
		int rc = entry->init(dev);
    a0010984:	f9401fe0 	ldr	x0, [sp, #56]
    a0010988:	f9400001 	ldr	x1, [x0]
    a001098c:	f94017e0 	ldr	x0, [sp, #40]
    a0010990:	d63f0020 	blr	x1
    a0010994:	b90037e0 	str	w0, [sp, #52]

		if (dev != NULL) {
    a0010998:	f94017e0 	ldr	x0, [sp, #40]
    a001099c:	f100001f 	cmp	x0, #0x0
    a00109a0:	54000320 	b.eq	a0010a04 <z_sys_init_run_level+0xb0>  // b.none
			/* Mark device initialized.  If initialization
			 * failed, record the error condition.
			 */
			if (rc != 0) {
    a00109a4:	b94037e0 	ldr	w0, [sp, #52]
    a00109a8:	7100001f 	cmp	w0, #0x0
    a00109ac:	54000220 	b.eq	a00109f0 <z_sys_init_run_level+0x9c>  // b.none
				if (rc < 0) {
    a00109b0:	b94037e0 	ldr	w0, [sp, #52]
    a00109b4:	7100001f 	cmp	w0, #0x0
    a00109b8:	5400008a 	b.ge	a00109c8 <z_sys_init_run_level+0x74>  // b.tcont
					rc = -rc;
    a00109bc:	b94037e0 	ldr	w0, [sp, #52]
    a00109c0:	4b0003e0 	neg	w0, w0
    a00109c4:	b90037e0 	str	w0, [sp, #52]
				}
				if (rc > UINT8_MAX) {
    a00109c8:	b94037e0 	ldr	w0, [sp, #52]
    a00109cc:	7103fc1f 	cmp	w0, #0xff
    a00109d0:	5400006d 	b.le	a00109dc <z_sys_init_run_level+0x88>
					rc = UINT8_MAX;
    a00109d4:	52801fe0 	mov	w0, #0xff                  	// #255
    a00109d8:	b90037e0 	str	w0, [sp, #52]
				}
				dev->state->init_res = rc;
    a00109dc:	f94017e0 	ldr	x0, [sp, #40]
    a00109e0:	f9400c00 	ldr	x0, [x0, #24]
    a00109e4:	b94037e1 	ldr	w1, [sp, #52]
    a00109e8:	12001c21 	and	w1, w1, #0xff
    a00109ec:	39000001 	strb	w1, [x0]
			}
			dev->state->initialized = true;
    a00109f0:	f94017e0 	ldr	x0, [sp, #40]
    a00109f4:	f9400c00 	ldr	x0, [x0, #24]
    a00109f8:	79400001 	ldrh	w1, [x0]
    a00109fc:	32180021 	orr	w1, w1, #0x100
    a0010a00:	79000001 	strh	w1, [x0]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    a0010a04:	f9401fe0 	ldr	x0, [sp, #56]
    a0010a08:	91004000 	add	x0, x0, #0x10
    a0010a0c:	f9001fe0 	str	x0, [sp, #56]
    a0010a10:	b9401fe0 	ldr	w0, [sp, #28]
    a0010a14:	11000401 	add	w1, w0, #0x1
    a0010a18:	f0000440 	adrp	x0, a009b000 <twom1000.10>
    a0010a1c:	91012000 	add	x0, x0, #0x48
    a0010a20:	93407c21 	sxtw	x1, w1
    a0010a24:	f8617800 	ldr	x0, [x0, x1, lsl #3]
    a0010a28:	f9401fe1 	ldr	x1, [sp, #56]
    a0010a2c:	eb00003f 	cmp	x1, x0
    a0010a30:	54fffa43 	b.cc	a0010978 <z_sys_init_run_level+0x24>  // b.lo, b.ul, b.last
		}
	}
}
    a0010a34:	d503201f 	nop
    a0010a38:	d503201f 	nop
    a0010a3c:	a8c47bfd 	ldp	x29, x30, [sp], #64
    a0010a40:	d65f03c0 	ret

00000000a0010a44 <z_impl_device_get_binding>:

const struct device *z_impl_device_get_binding(const char *name)
{
    a0010a44:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0010a48:	910003fd 	mov	x29, sp
    a0010a4c:	f9000fe0 	str	x0, [sp, #24]
	const struct device *dev;

	/* A null string identifies no device.  So does an empty
	 * string.
	 */
	if ((name == NULL) || (name[0] == '\0')) {
    a0010a50:	f9400fe0 	ldr	x0, [sp, #24]
    a0010a54:	f100001f 	cmp	x0, #0x0
    a0010a58:	540000a0 	b.eq	a0010a6c <z_impl_device_get_binding+0x28>  // b.none
    a0010a5c:	f9400fe0 	ldr	x0, [sp, #24]
    a0010a60:	39400000 	ldrb	w0, [x0]
    a0010a64:	7100001f 	cmp	w0, #0x0
    a0010a68:	54000061 	b.ne	a0010a74 <z_impl_device_get_binding+0x30>  // b.any
		return NULL;
    a0010a6c:	d2800000 	mov	x0, #0x0                   	// #0
    a0010a70:	14000034 	b	a0010b40 <z_impl_device_get_binding+0xfc>
	/* Split the search into two loops: in the common scenario, where
	 * device names are stored in ROM (and are referenced by the user
	 * with CONFIG_* macros), only cheap pointer comparisons will be
	 * performed. Reserve string comparisons for a fallback.
	 */
	for (dev = __device_start; dev != __device_end; dev++) {
    a0010a74:	f0000080 	adrp	x0, a0023000 <__rodata_region_start>
    a0010a78:	91024000 	add	x0, x0, #0x90
    a0010a7c:	f90017e0 	str	x0, [sp, #40]
    a0010a80:	14000010 	b	a0010ac0 <z_impl_device_get_binding+0x7c>
		if (z_device_is_ready(dev) && (dev->name == name)) {
    a0010a84:	f94017e0 	ldr	x0, [sp, #40]
    a0010a88:	9400008c 	bl	a0010cb8 <z_device_is_ready>
    a0010a8c:	12001c00 	and	w0, w0, #0xff
    a0010a90:	7100001f 	cmp	w0, #0x0
    a0010a94:	54000100 	b.eq	a0010ab4 <z_impl_device_get_binding+0x70>  // b.none
    a0010a98:	f94017e0 	ldr	x0, [sp, #40]
    a0010a9c:	f9400000 	ldr	x0, [x0]
    a0010aa0:	f9400fe1 	ldr	x1, [sp, #24]
    a0010aa4:	eb00003f 	cmp	x1, x0
    a0010aa8:	54000061 	b.ne	a0010ab4 <z_impl_device_get_binding+0x70>  // b.any
			return dev;
    a0010aac:	f94017e0 	ldr	x0, [sp, #40]
    a0010ab0:	14000024 	b	a0010b40 <z_impl_device_get_binding+0xfc>
	for (dev = __device_start; dev != __device_end; dev++) {
    a0010ab4:	f94017e0 	ldr	x0, [sp, #40]
    a0010ab8:	9100c000 	add	x0, x0, #0x30
    a0010abc:	f90017e0 	str	x0, [sp, #40]
    a0010ac0:	f94017e1 	ldr	x1, [sp, #40]
    a0010ac4:	f0000080 	adrp	x0, a0023000 <__rodata_region_start>
    a0010ac8:	91030000 	add	x0, x0, #0xc0
    a0010acc:	eb00003f 	cmp	x1, x0
    a0010ad0:	54fffda1 	b.ne	a0010a84 <z_impl_device_get_binding+0x40>  // b.any
		}
	}

	for (dev = __device_start; dev != __device_end; dev++) {
    a0010ad4:	f0000080 	adrp	x0, a0023000 <__rodata_region_start>
    a0010ad8:	91024000 	add	x0, x0, #0x90
    a0010adc:	f90017e0 	str	x0, [sp, #40]
    a0010ae0:	14000012 	b	a0010b28 <z_impl_device_get_binding+0xe4>
		if (z_device_is_ready(dev) && (strcmp(name, dev->name) == 0)) {
    a0010ae4:	f94017e0 	ldr	x0, [sp, #40]
    a0010ae8:	94000074 	bl	a0010cb8 <z_device_is_ready>
    a0010aec:	12001c00 	and	w0, w0, #0xff
    a0010af0:	7100001f 	cmp	w0, #0x0
    a0010af4:	54000140 	b.eq	a0010b1c <z_impl_device_get_binding+0xd8>  // b.none
    a0010af8:	f94017e0 	ldr	x0, [sp, #40]
    a0010afc:	f9400000 	ldr	x0, [x0]
    a0010b00:	aa0003e1 	mov	x1, x0
    a0010b04:	f9400fe0 	ldr	x0, [sp, #24]
    a0010b08:	97ffecc8 	bl	a000be28 <strcmp>
    a0010b0c:	7100001f 	cmp	w0, #0x0
    a0010b10:	54000061 	b.ne	a0010b1c <z_impl_device_get_binding+0xd8>  // b.any
			return dev;
    a0010b14:	f94017e0 	ldr	x0, [sp, #40]
    a0010b18:	1400000a 	b	a0010b40 <z_impl_device_get_binding+0xfc>
	for (dev = __device_start; dev != __device_end; dev++) {
    a0010b1c:	f94017e0 	ldr	x0, [sp, #40]
    a0010b20:	9100c000 	add	x0, x0, #0x30
    a0010b24:	f90017e0 	str	x0, [sp, #40]
    a0010b28:	f94017e1 	ldr	x1, [sp, #40]
    a0010b2c:	f0000080 	adrp	x0, a0023000 <__rodata_region_start>
    a0010b30:	91030000 	add	x0, x0, #0xc0
    a0010b34:	eb00003f 	cmp	x1, x0
    a0010b38:	54fffd61 	b.ne	a0010ae4 <z_impl_device_get_binding+0xa0>  // b.any
		}
	}

	return NULL;
    a0010b3c:	d2800000 	mov	x0, #0x0                   	// #0
}
    a0010b40:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0010b44:	d65f03c0 	ret

00000000a0010b48 <z_vrfy_device_get_binding>:

#ifdef CONFIG_USERSPACE
static inline const struct device *z_vrfy_device_get_binding(const char *name)
{
    a0010b48:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a0010b4c:	910003fd 	mov	x29, sp
    a0010b50:	f9000fe0 	str	x0, [sp, #24]
	char name_copy[Z_DEVICE_MAX_NAME_LEN];

	if (z_user_string_copy(name_copy, (char *)name, sizeof(name_copy))
    a0010b54:	910083e0 	add	x0, sp, #0x20
    a0010b58:	d2800602 	mov	x2, #0x30                  	// #48
    a0010b5c:	f9400fe1 	ldr	x1, [sp, #24]
    a0010b60:	94003298 	bl	a001d5c0 <z_user_string_copy>
    a0010b64:	7100001f 	cmp	w0, #0x0
    a0010b68:	54000060 	b.eq	a0010b74 <z_vrfy_device_get_binding+0x2c>  // b.none
	    != 0) {
		return NULL;
    a0010b6c:	d2800000 	mov	x0, #0x0                   	// #0
    a0010b70:	14000003 	b	a0010b7c <z_vrfy_device_get_binding+0x34>
	}

	return z_impl_device_get_binding(name_copy);
    a0010b74:	910083e0 	add	x0, sp, #0x20
    a0010b78:	97ffffb3 	bl	a0010a44 <z_impl_device_get_binding>
}
    a0010b7c:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a0010b80:	d65f03c0 	ret

00000000a0010b84 <z_mrsh_device_get_binding>:
#include <syscalls/device.h>

extern const struct device * z_vrfy_device_get_binding(const char * name);
uintptr_t z_mrsh_device_get_binding(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a0010b84:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a0010b88:	910003fd 	mov	x29, sp
    a0010b8c:	f90027e0 	str	x0, [sp, #72]
    a0010b90:	f90023e1 	str	x1, [sp, #64]
    a0010b94:	f9001fe2 	str	x2, [sp, #56]
    a0010b98:	f9001be3 	str	x3, [sp, #48]
    a0010b9c:	f90017e4 	str	x4, [sp, #40]
    a0010ba0:	f90013e5 	str	x5, [sp, #32]
    a0010ba4:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a0010ba8:	f00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0010bac:	913f8000 	add	x0, x0, #0xfe0
    a0010bb0:	f9400800 	ldr	x0, [x0, #16]
    a0010bb4:	f9400fe1 	ldr	x1, [sp, #24]
    a0010bb8:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	const struct device * ret = z_vrfy_device_get_binding(*(const char **)&arg0)
    a0010bbc:	910123e0 	add	x0, sp, #0x48
    a0010bc0:	f9400000 	ldr	x0, [x0]
    a0010bc4:	97ffffe1 	bl	a0010b48 <z_vrfy_device_get_binding>
    a0010bc8:	f9002fe0 	str	x0, [sp, #88]
;
	_current->syscall_frame = NULL;
    a0010bcc:	f00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0010bd0:	913f8000 	add	x0, x0, #0xfe0
    a0010bd4:	f9400800 	ldr	x0, [x0, #16]
    a0010bd8:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a0010bdc:	f9402fe0 	ldr	x0, [sp, #88]
}
    a0010be0:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a0010be4:	d65f03c0 	ret

00000000a0010be8 <z_vrfy_device_is_ready>:
#include <syscalls/device_get_binding_mrsh.c>

static inline bool z_vrfy_device_is_ready(const struct device *dev)
{
    a0010be8:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a0010bec:	910003fd 	mov	x29, sp
    a0010bf0:	f9000fe0 	str	x0, [sp, #24]
	Z_OOPS(Z_SYSCALL_OBJ_INIT(dev, K_OBJ_ANY));
    a0010bf4:	f9400fe0 	ldr	x0, [sp, #24]
    a0010bf8:	94002f8c 	bl	a001ca28 <z_object_find>
    a0010bfc:	52800023 	mov	w3, #0x1                   	// #1
    a0010c00:	52800002 	mov	w2, #0x0                   	// #0
    a0010c04:	f9400fe1 	ldr	x1, [sp, #24]
    a0010c08:	97ffff31 	bl	a00108cc <z_obj_validation_check>
    a0010c0c:	7100001f 	cmp	w0, #0x0
    a0010c10:	1a9f07e0 	cset	w0, ne  // ne = any
    a0010c14:	39063fe0 	strb	w0, [sp, #399]
    a0010c18:	39463fe0 	ldrb	w0, [sp, #399]
    a0010c1c:	7100001f 	cmp	w0, #0x0
    a0010c20:	39463fe0 	ldrb	w0, [sp, #399]
    a0010c24:	7100001f 	cmp	w0, #0x0
    a0010c28:	540000c0 	b.eq	a0010c40 <z_vrfy_device_is_ready+0x58>  // b.none
    a0010c2c:	f00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0010c30:	913f8000 	add	x0, x0, #0xfe0
    a0010c34:	f9400800 	ldr	x0, [x0, #16]
    a0010c38:	f9408400 	ldr	x0, [x0, #264]
    a0010c3c:	97ffe147 	bl	a0009158 <arch_syscall_oops>

	return z_impl_device_is_ready(dev);
    a0010c40:	f9400fe0 	ldr	x0, [sp, #24]
    a0010c44:	97ffff1a 	bl	a00108ac <z_impl_device_is_ready>
    a0010c48:	12001c00 	and	w0, w0, #0xff
}
    a0010c4c:	a8d97bfd 	ldp	x29, x30, [sp], #400
    a0010c50:	d65f03c0 	ret

00000000a0010c54 <z_mrsh_device_is_ready>:
#include <syscalls/device.h>

extern bool z_vrfy_device_is_ready(const struct device * dev);
uintptr_t z_mrsh_device_is_ready(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a0010c54:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a0010c58:	910003fd 	mov	x29, sp
    a0010c5c:	f90027e0 	str	x0, [sp, #72]
    a0010c60:	f90023e1 	str	x1, [sp, #64]
    a0010c64:	f9001fe2 	str	x2, [sp, #56]
    a0010c68:	f9001be3 	str	x3, [sp, #48]
    a0010c6c:	f90017e4 	str	x4, [sp, #40]
    a0010c70:	f90013e5 	str	x5, [sp, #32]
    a0010c74:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a0010c78:	f00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0010c7c:	913f8000 	add	x0, x0, #0xfe0
    a0010c80:	f9400800 	ldr	x0, [x0, #16]
    a0010c84:	f9400fe1 	ldr	x1, [sp, #24]
    a0010c88:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	bool ret = z_vrfy_device_is_ready(*(const struct device **)&arg0)
    a0010c8c:	910123e0 	add	x0, sp, #0x48
    a0010c90:	f9400000 	ldr	x0, [x0]
    a0010c94:	97ffffd5 	bl	a0010be8 <z_vrfy_device_is_ready>
    a0010c98:	39017fe0 	strb	w0, [sp, #95]
;
	_current->syscall_frame = NULL;
    a0010c9c:	f00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0010ca0:	913f8000 	add	x0, x0, #0xfe0
    a0010ca4:	f9400800 	ldr	x0, [x0, #16]
    a0010ca8:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a0010cac:	39417fe0 	ldrb	w0, [sp, #95]
}
    a0010cb0:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a0010cb4:	d65f03c0 	ret

00000000a0010cb8 <z_device_is_ready>:
	*devices = __device_start;
	return __device_end - __device_start;
}

bool z_device_is_ready(const struct device *dev)
{
    a0010cb8:	d10043ff 	sub	sp, sp, #0x10
    a0010cbc:	f90007e0 	str	x0, [sp, #8]
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
    a0010cc0:	f94007e0 	ldr	x0, [sp, #8]
    a0010cc4:	f100001f 	cmp	x0, #0x0
    a0010cc8:	54000061 	b.ne	a0010cd4 <z_device_is_ready+0x1c>  // b.any
		return false;
    a0010ccc:	52800000 	mov	w0, #0x0                   	// #0
    a0010cd0:	14000012 	b	a0010d18 <z_device_is_ready+0x60>
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
    a0010cd4:	f94007e0 	ldr	x0, [sp, #8]
    a0010cd8:	f9400c00 	ldr	x0, [x0, #24]
    a0010cdc:	79400000 	ldrh	w0, [x0]
    a0010ce0:	12180000 	and	w0, w0, #0x100
    a0010ce4:	12003c00 	and	w0, w0, #0xffff
    a0010ce8:	7100001f 	cmp	w0, #0x0
    a0010cec:	54000100 	b.eq	a0010d0c <z_device_is_ready+0x54>  // b.none
    a0010cf0:	f94007e0 	ldr	x0, [sp, #8]
    a0010cf4:	f9400c00 	ldr	x0, [x0, #24]
    a0010cf8:	39400000 	ldrb	w0, [x0]
    a0010cfc:	7100001f 	cmp	w0, #0x0
    a0010d00:	54000061 	b.ne	a0010d0c <z_device_is_ready+0x54>  // b.any
    a0010d04:	52800020 	mov	w0, #0x1                   	// #1
    a0010d08:	14000002 	b	a0010d10 <z_device_is_ready+0x58>
    a0010d0c:	52800000 	mov	w0, #0x0                   	// #0
    a0010d10:	12000000 	and	w0, w0, #0x1
    a0010d14:	12001c00 	and	w0, w0, #0xff
}
    a0010d18:	910043ff 	add	sp, sp, #0x10
    a0010d1c:	d65f03c0 	ret

00000000a0010d20 <z_impl_z_errno>:
int *z_impl_z_errno(void)
{
	/* Initialized to the lowest address in the stack so the thread can
	 * directly read/write it
	 */
	return &_current->userspace_local_data->errno_var;
    a0010d20:	f00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0010d24:	913f8000 	add	x0, x0, #0xfe0
    a0010d28:	f9400800 	ldr	x0, [x0, #16]
    a0010d2c:	f9406400 	ldr	x0, [x0, #200]
}
    a0010d30:	d65f03c0 	ret

00000000a0010d34 <z_vrfy_z_errno>:

static inline int *z_vrfy_z_errno(void)
{
    a0010d34:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    a0010d38:	910003fd 	mov	x29, sp
	return z_impl_z_errno();
    a0010d3c:	97fffff9 	bl	a0010d20 <z_impl_z_errno>
}
    a0010d40:	a8c17bfd 	ldp	x29, x30, [sp], #16
    a0010d44:	d65f03c0 	ret

00000000a0010d48 <z_mrsh_z_errno>:
#include <syscalls/errno_private.h>

extern int * z_vrfy_z_errno();
uintptr_t z_mrsh_z_errno(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a0010d48:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a0010d4c:	910003fd 	mov	x29, sp
    a0010d50:	f90027e0 	str	x0, [sp, #72]
    a0010d54:	f90023e1 	str	x1, [sp, #64]
    a0010d58:	f9001fe2 	str	x2, [sp, #56]
    a0010d5c:	f9001be3 	str	x3, [sp, #48]
    a0010d60:	f90017e4 	str	x4, [sp, #40]
    a0010d64:	f90013e5 	str	x5, [sp, #32]
    a0010d68:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a0010d6c:	f00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0010d70:	913f8000 	add	x0, x0, #0xfe0
    a0010d74:	f9400800 	ldr	x0, [x0, #16]
    a0010d78:	f9400fe1 	ldr	x1, [sp, #24]
    a0010d7c:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int * ret = z_vrfy_z_errno()
    a0010d80:	97ffffed 	bl	a0010d34 <z_vrfy_z_errno>
    a0010d84:	f9002fe0 	str	x0, [sp, #88]
;
	_current->syscall_frame = NULL;
    a0010d88:	f00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0010d8c:	913f8000 	add	x0, x0, #0xfe0
    a0010d90:	f9400800 	ldr	x0, [x0, #16]
    a0010d94:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a0010d98:	f9402fe0 	ldr	x0, [sp, #88]
}
    a0010d9c:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a0010da0:	d65f03c0 	ret

00000000a0010da4 <arch_syscall_invoke1>:
{
    a0010da4:	d10043ff 	sub	sp, sp, #0x10
    a0010da8:	f90007e0 	str	x0, [sp, #8]
    a0010dac:	f90003e1 	str	x1, [sp]
	register uint64_t ret __asm__("x0") = arg1;
    a0010db0:	f94007e0 	ldr	x0, [sp, #8]
	register uint64_t r8 __asm__("x8") = call_id;
    a0010db4:	f94003e8 	ldr	x8, [sp]
	__asm__ volatile("svc %[svid]\n"
    a0010db8:	d4000061 	svc	#0x3
}
    a0010dbc:	910043ff 	add	sp, sp, #0x10
    a0010dc0:	d65f03c0 	ret

00000000a0010dc4 <arch_syscall_invoke0>:
{
    a0010dc4:	d10043ff 	sub	sp, sp, #0x10
    a0010dc8:	f90007e0 	str	x0, [sp, #8]
	register uint64_t r8 __asm__("x8") = call_id;
    a0010dcc:	f94007e8 	ldr	x8, [sp, #8]
	__asm__ volatile("svc %[svid]\n"
    a0010dd0:	d4000061 	svc	#0x3
}
    a0010dd4:	910043ff 	add	sp, sp, #0x10
    a0010dd8:	d65f03c0 	ret

00000000a0010ddc <k_current_get>:
{
    a0010ddc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    a0010de0:	910003fd 	mov	x29, sp
	return z_current_get();
    a0010de4:	94000003 	bl	a0010df0 <z_current_get>
}
    a0010de8:	a8c17bfd 	ldp	x29, x30, [sp], #16
    a0010dec:	d65f03c0 	ret

00000000a0010df0 <z_current_get>:
{
    a0010df0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0010df4:	910003fd 	mov	x29, sp
	bool ret = false;
    a0010df8:	39007fff 	strb	wzr, [sp, #31]
	ret = false;
    a0010dfc:	39007fff 	strb	wzr, [sp, #31]
	return ret;
    a0010e00:	39407fe0 	ldrb	w0, [sp, #31]
	if (z_syscall_trap()) {
    a0010e04:	7100001f 	cmp	w0, #0x0
    a0010e08:	54000080 	b.eq	a0010e18 <z_current_get+0x28>  // b.none
		return (k_tid_t) arch_syscall_invoke0(K_SYSCALL_Z_CURRENT_GET);
    a0010e0c:	d2802b40 	mov	x0, #0x15a                 	// #346
    a0010e10:	97ffffed 	bl	a0010dc4 <arch_syscall_invoke0>
    a0010e14:	14000002 	b	a0010e1c <z_current_get+0x2c>
	return z_impl_z_current_get();
    a0010e18:	94001ffc 	bl	a0018e08 <z_impl_z_current_get>
}
    a0010e1c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0010e20:	d65f03c0 	ret

00000000a0010e24 <k_thread_abort>:
{
    a0010e24:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0010e28:	910003fd 	mov	x29, sp
    a0010e2c:	f9000fe0 	str	x0, [sp, #24]
	bool ret = false;
    a0010e30:	3900bfff 	strb	wzr, [sp, #47]
	ret = false;
    a0010e34:	3900bfff 	strb	wzr, [sp, #47]
	return ret;
    a0010e38:	3940bfe0 	ldrb	w0, [sp, #47]
	if (z_syscall_trap()) {
    a0010e3c:	7100001f 	cmp	w0, #0x0
    a0010e40:	540000c0 	b.eq	a0010e58 <k_thread_abort+0x34>  // b.none
		arch_syscall_invoke1(*(uintptr_t *)&thread, K_SYSCALL_K_THREAD_ABORT);
    a0010e44:	910063e0 	add	x0, sp, #0x18
    a0010e48:	f9400000 	ldr	x0, [x0]
    a0010e4c:	d2801801 	mov	x1, #0xc0                  	// #192
    a0010e50:	97ffffd5 	bl	a0010da4 <arch_syscall_invoke1>
		return;
    a0010e54:	14000003 	b	a0010e60 <k_thread_abort+0x3c>
	z_impl_k_thread_abort(thread);
    a0010e58:	f9400fe0 	ldr	x0, [sp, #24]
    a0010e5c:	940020f8 	bl	a001923c <z_impl_k_thread_abort>
}
    a0010e60:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0010e64:	d65f03c0 	ret

00000000a0010e68 <coredump>:

#else

void coredump(unsigned int reason, const z_arch_esf_t *esf,
	      struct k_thread *thread)
{
    a0010e68:	d10083ff 	sub	sp, sp, #0x20
    a0010e6c:	b9001fe0 	str	w0, [sp, #28]
    a0010e70:	f9000be1 	str	x1, [sp, #16]
    a0010e74:	f90007e2 	str	x2, [sp, #8]
}
    a0010e78:	d503201f 	nop
    a0010e7c:	910083ff 	add	sp, sp, #0x20
    a0010e80:	d65f03c0 	ret

00000000a0010e84 <arch_system_halt>:

LOG_MODULE_DECLARE(os, CONFIG_KERNEL_LOG_LEVEL);

/* LCOV_EXCL_START */
FUNC_NORETURN __weak void arch_system_halt(unsigned int reason)
{
    a0010e84:	d10083ff 	sub	sp, sp, #0x20
    a0010e88:	b9000fe0 	str	w0, [sp, #12]
MAKE_REG_HELPER(daif)
    a0010e8c:	d53b4220 	mrs	x0, daif
    a0010e90:	f9000fe0 	str	x0, [sp, #24]
    a0010e94:	f9400fe0 	ldr	x0, [sp, #24]
    a0010e98:	d503201f 	nop
	key = read_daif();
    a0010e9c:	b90017e0 	str	w0, [sp, #20]
	__asm__ volatile ("msr DAIFSet, %0"
    a0010ea0:	d50342df 	msr	daifset, #0x2
}
    a0010ea4:	d503201f 	nop
	/* TODO: What's the best way to totally halt the system if SMP
	 * is enabled?
	 */

	(void)arch_irq_lock();
	for (;;) {
    a0010ea8:	14000000 	b	a0010ea8 <arch_system_halt+0x24>

00000000a0010eac <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
    a0010eac:	a9aa7bfd 	stp	x29, x30, [sp, #-352]!
    a0010eb0:	910003fd 	mov	x29, sp
    a0010eb4:	b9001fe0 	str	w0, [sp, #28]
    a0010eb8:	f9000be1 	str	x1, [sp, #16]
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
	arch_system_halt(reason);
    a0010ebc:	b9401fe0 	ldr	w0, [sp, #28]
    a0010ec0:	97fffff1 	bl	a0010e84 <arch_system_halt>

00000000a0010ec4 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
    a0010ec4:	d109c3ff 	sub	sp, sp, #0x270
    a0010ec8:	a9007bfd 	stp	x29, x30, [sp]
    a0010ecc:	910003fd 	mov	x29, sp
    a0010ed0:	b9001fe0 	str	w0, [sp, #28]
    a0010ed4:	f9000be1 	str	x1, [sp, #16]
MAKE_REG_HELPER(daif)
    a0010ed8:	d53b4220 	mrs	x0, daif
    a0010edc:	f9012be0 	str	x0, [sp, #592]
    a0010ee0:	f9412be0 	ldr	x0, [sp, #592]
    a0010ee4:	d503201f 	nop
    a0010ee8:	b9025fe0 	str	w0, [sp, #604]
	__asm__ volatile ("msr DAIFSet, %0"
    a0010eec:	d50342df 	msr	daifset, #0x2
}
    a0010ef0:	d503201f 	nop
	return key;
    a0010ef4:	b9425fe0 	ldr	w0, [sp, #604]
	/* We can't allow this code to be preempted, but don't need to
	 * synchronize between CPUs, so an arch-layer lock is
	 * appropriate.
	 */
	unsigned int key = arch_irq_lock();
    a0010ef8:	b9024fe0 	str	w0, [sp, #588]
	struct k_thread *thread = IS_ENABLED(CONFIG_MULTITHREADING) ?
			k_current_get() : NULL;
    a0010efc:	97ffffb8 	bl	a0010ddc <k_current_get>
    a0010f00:	f90123e0 	str	x0, [sp, #576]
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
		log_strdup(thread_name_get(thread)));

	coredump(reason, esf, thread);
    a0010f04:	f94123e2 	ldr	x2, [sp, #576]
    a0010f08:	f9400be1 	ldr	x1, [sp, #16]
    a0010f0c:	b9401fe0 	ldr	w0, [sp, #28]
    a0010f10:	97ffffd6 	bl	a0010e68 <coredump>

	k_sys_fatal_error_handler(reason, esf);
    a0010f14:	f9400be1 	ldr	x1, [sp, #16]
    a0010f18:	b9401fe0 	ldr	w0, [sp, #28]
    a0010f1c:	97ffffe4 	bl	a0010eac <k_sys_fatal_error_handler>
    a0010f20:	b9424fe0 	ldr	w0, [sp, #588]
    a0010f24:	b9026fe0 	str	w0, [sp, #620]
	write_daif(key);
    a0010f28:	b9426fe0 	ldr	w0, [sp, #620]
    a0010f2c:	f90133e0 	str	x0, [sp, #608]
MAKE_REG_HELPER(daif)
    a0010f30:	f94133e0 	ldr	x0, [sp, #608]
    a0010f34:	d51b4220 	msr	daif, x0
    a0010f38:	d503201f 	nop
}
    a0010f3c:	d503201f 	nop
	}

	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
    a0010f40:	f94123e0 	ldr	x0, [sp, #576]
    a0010f44:	97ffffb8 	bl	a0010e24 <k_thread_abort>
	}
}
    a0010f48:	d503201f 	nop
    a0010f4c:	a9407bfd 	ldp	x29, x30, [sp]
    a0010f50:	9109c3ff 	add	sp, sp, #0x270
    a0010f54:	d65f03c0 	ret

00000000a0010f58 <arch_cohere_stacks>:
 */
#ifndef CONFIG_KERNEL_COHERENCE
static inline void arch_cohere_stacks(struct k_thread *old_thread,
				      void *old_switch_handle,
				      struct k_thread *new_thread)
{
    a0010f58:	d10083ff 	sub	sp, sp, #0x20
    a0010f5c:	f9000fe0 	str	x0, [sp, #24]
    a0010f60:	f9000be1 	str	x1, [sp, #16]
    a0010f64:	f90007e2 	str	x2, [sp, #8]
	ARG_UNUSED(old_thread);
	ARG_UNUSED(old_switch_handle);
	ARG_UNUSED(new_thread);
}
    a0010f68:	d503201f 	nop
    a0010f6c:	910083ff 	add	sp, sp, #0x20
    a0010f70:	d65f03c0 	ret

00000000a0010f74 <Z_KERNEL_STACK_BUFFER>:
#define K_KERNEL_STACK_SIZEOF(sym) (sizeof(sym) - K_KERNEL_STACK_RESERVED)

/** @} */

static inline char *Z_KERNEL_STACK_BUFFER(k_thread_stack_t *sym)
{
    a0010f74:	d10043ff 	sub	sp, sp, #0x10
    a0010f78:	f90007e0 	str	x0, [sp, #8]
	return (char *)sym + K_KERNEL_STACK_RESERVED;
    a0010f7c:	f94007e0 	ldr	x0, [sp, #8]
}
    a0010f80:	910043ff 	add	sp, sp, #0x10
    a0010f84:	d65f03c0 	ret

00000000a0010f88 <arch_switch>:
static ALWAYS_INLINE void arch_kernel_init(void)
{
}

static inline void arch_switch(void *switch_to, void **switched_from)
{
    a0010f88:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0010f8c:	910003fd 	mov	x29, sp
    a0010f90:	f9000fe0 	str	x0, [sp, #24]
    a0010f94:	f9000be1 	str	x1, [sp, #16]
	z_arm64_call_svc(switch_to, switched_from);
    a0010f98:	f9400be1 	ldr	x1, [sp, #16]
    a0010f9c:	f9400fe0 	ldr	x0, [sp, #24]
    a0010fa0:	97ffe20e 	bl	a00097d8 <z_arm64_call_svc>

	return;
    a0010fa4:	d503201f 	nop
}
    a0010fa8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0010fac:	d65f03c0 	ret

00000000a0010fb0 <z_mark_thread_as_started>:

	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
    a0010fb0:	d10043ff 	sub	sp, sp, #0x10
    a0010fb4:	f90007e0 	str	x0, [sp, #8]
	thread->base.thread_state &= ~_THREAD_PRESTART;
    a0010fb8:	f94007e0 	ldr	x0, [sp, #8]
    a0010fbc:	39406400 	ldrb	w0, [x0, #25]
    a0010fc0:	121d7800 	and	w0, w0, #0xfffffffb
    a0010fc4:	12001c01 	and	w1, w0, #0xff
    a0010fc8:	f94007e0 	ldr	x0, [sp, #8]
    a0010fcc:	39006401 	strb	w1, [x0, #25]
}
    a0010fd0:	d503201f 	nop
    a0010fd4:	910043ff 	add	sp, sp, #0x10
    a0010fd8:	d65f03c0 	ret

00000000a0010fdc <z_sched_usage_switch>:
 */
void z_sched_thread_usage(struct k_thread *thread,
			  struct k_thread_runtime_stats *stats);

static inline void z_sched_usage_switch(struct k_thread *thread)
{
    a0010fdc:	d10043ff 	sub	sp, sp, #0x10
    a0010fe0:	f90007e0 	str	x0, [sp, #8]
	ARG_UNUSED(thread);
#ifdef CONFIG_SCHED_THREAD_USAGE
	z_sched_usage_stop();
	z_sched_usage_start(thread);
#endif
}
    a0010fe4:	d503201f 	nop
    a0010fe8:	910043ff 	add	sp, sp, #0x10
    a0010fec:	d65f03c0 	ret

00000000a0010ff0 <gcov_static_init>:
#ifdef CONFIG_COVERAGE_GCOV
void gcov_coverage_dump(void);
void gcov_static_init(void);
#else
static inline void gcov_coverage_dump(void) { }
static inline void gcov_static_init(void) { }
    a0010ff0:	d503201f 	nop
    a0010ff4:	d65f03c0 	ret

00000000a0010ff8 <wait_for_switch>:
 * Note: future SMP architectures may need a fence/barrier or cache
 * invalidation here.  Current ones don't, and sadly Zephyr doesn't
 * have a framework for that yet.
 */
static inline void wait_for_switch(struct k_thread *thread)
{
    a0010ff8:	d10043ff 	sub	sp, sp, #0x10
    a0010ffc:	f90007e0 	str	x0, [sp, #8]

	while (*shp == NULL) {
		k_busy_wait(1);
	}
#endif
}
    a0011000:	d503201f 	nop
    a0011004:	910043ff 	add	sp, sp, #0x10
    a0011008:	d65f03c0 	ret

00000000a001100c <z_swap_unlocked>:
{
	return do_swap(key.key, lock, 1);
}

static inline void z_swap_unlocked(void)
{
    a001100c:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
    a0011010:	910003fd 	mov	x29, sp
    a0011014:	d53b4220 	mrs	x0, daif
    a0011018:	f9000fe0 	str	x0, [sp, #24]
    a001101c:	f9400fe0 	ldr	x0, [sp, #24]
    a0011020:	d503201f 	nop
	key = read_daif();
    a0011024:	b90017e0 	str	w0, [sp, #20]
	__asm__ volatile ("msr DAIFSet, %0"
    a0011028:	d50342df 	msr	daifset, #0x2
}
    a001102c:	d503201f 	nop
	return key;
    a0011030:	b94017e0 	ldr	w0, [sp, #20]
    a0011034:	b9009fe0 	str	w0, [sp, #156]
    a0011038:	f9004bff 	str	xzr, [sp, #144]
    a001103c:	52800020 	mov	w0, #0x1                   	// #1
    a0011040:	b9008fe0 	str	w0, [sp, #140]
	old_thread = _current;
    a0011044:	d00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0011048:	913f8000 	add	x0, x0, #0xfe0
    a001104c:	f9400800 	ldr	x0, [x0, #16]
    a0011050:	f90043e0 	str	x0, [sp, #128]
	old_thread->swap_retval = -EAGAIN;
    a0011054:	f94043e0 	ldr	x0, [sp, #128]
    a0011058:	12800141 	mov	w1, #0xfffffff5            	// #-11
    a001105c:	b9011001 	str	w1, [x0, #272]
	if (is_spinlock && lock != NULL && lock != &sched_spinlock) {
    a0011060:	b9408fe0 	ldr	w0, [sp, #140]
    a0011064:	7100001f 	cmp	w0, #0x0
    a0011068:	54000180 	b.eq	a0011098 <z_swap_unlocked+0x8c>  // b.none
    a001106c:	f9404be0 	ldr	x0, [sp, #144]
    a0011070:	f100001f 	cmp	x0, #0x0
    a0011074:	54000120 	b.eq	a0011098 <z_swap_unlocked+0x8c>  // b.none
    a0011078:	f9404be1 	ldr	x1, [sp, #144]
    a001107c:	f00001a0 	adrp	x0, a0048000 <_kernel+0x20>
    a0011080:	910a4000 	add	x0, x0, #0x290
    a0011084:	eb00003f 	cmp	x1, x0
    a0011088:	54000080 	b.eq	a0011098 <z_swap_unlocked+0x8c>  // b.none
    a001108c:	f9404be0 	ldr	x0, [sp, #144]
    a0011090:	f9003fe0 	str	x0, [sp, #120]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
#endif
#ifdef CONFIG_SMP
	atomic_clear(&l->locked);
#endif
}
    a0011094:	d503201f 	nop
	if (!is_spinlock || lock != &sched_spinlock) {
    a0011098:	b9408fe0 	ldr	w0, [sp, #140]
    a001109c:	7100001f 	cmp	w0, #0x0
    a00110a0:	540000c0 	b.eq	a00110b8 <z_swap_unlocked+0xac>  // b.none
    a00110a4:	f9404be1 	ldr	x1, [sp, #144]
    a00110a8:	f00001a0 	adrp	x0, a0048000 <_kernel+0x20>
    a00110ac:	910a4000 	add	x0, x0, #0x290
    a00110b0:	eb00003f 	cmp	x1, x0
    a00110b4:	540001c0 	b.eq	a00110ec <z_swap_unlocked+0xe0>  // b.none
    a00110b8:	f00001a0 	adrp	x0, a0048000 <_kernel+0x20>
    a00110bc:	910a4000 	add	x0, x0, #0x290
    a00110c0:	f9003be0 	str	x0, [sp, #112]
MAKE_REG_HELPER(daif)
    a00110c4:	d53b4220 	mrs	x0, daif
    a00110c8:	f90037e0 	str	x0, [sp, #104]
    a00110cc:	f94037e0 	ldr	x0, [sp, #104]
    a00110d0:	d503201f 	nop
	key = read_daif();
    a00110d4:	b90067e0 	str	w0, [sp, #100]
	__asm__ volatile ("msr DAIFSet, %0"
    a00110d8:	d50342df 	msr	daifset, #0x2
}
    a00110dc:	d503201f 	nop
	return key;
    a00110e0:	b94067e0 	ldr	w0, [sp, #100]
	k.key = arch_irq_lock();
    a00110e4:	b90013e0 	str	w0, [sp, #16]
	return k;
    a00110e8:	d503201f 	nop
	new_thread = z_swap_next_thread();
    a00110ec:	94001c9f 	bl	a0018368 <z_swap_next_thread>
    a00110f0:	f9002fe0 	str	x0, [sp, #88]
	if (new_thread != old_thread) {
    a00110f4:	f94043e1 	ldr	x1, [sp, #128]
    a00110f8:	f9402fe0 	ldr	x0, [sp, #88]
    a00110fc:	eb00003f 	cmp	x1, x0
    a0011100:	54000360 	b.eq	a001116c <z_swap_unlocked+0x160>  // b.none
		z_reset_time_slice();
    a0011104:	94001686 	bl	a0016b1c <z_reset_time_slice>
		z_sched_usage_switch(new_thread);
    a0011108:	f9402fe0 	ldr	x0, [sp, #88]
    a001110c:	97ffffb4 	bl	a0010fdc <z_sched_usage_switch>
		wait_for_switch(new_thread);
    a0011110:	f9402fe0 	ldr	x0, [sp, #88]
    a0011114:	97ffffb9 	bl	a0010ff8 <wait_for_switch>
		_current_cpu->current = new_thread;
    a0011118:	d00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001111c:	913f8000 	add	x0, x0, #0xfe0
    a0011120:	f9402fe1 	ldr	x1, [sp, #88]
    a0011124:	f9000801 	str	x1, [x0, #16]
		arch_cohere_stacks(old_thread, NULL, new_thread);
    a0011128:	f9402fe2 	ldr	x2, [sp, #88]
    a001112c:	d2800001 	mov	x1, #0x0                   	// #0
    a0011130:	f94043e0 	ldr	x0, [sp, #128]
    a0011134:	97ffff89 	bl	a0010f58 <arch_cohere_stacks>
		void *newsh = new_thread->switch_handle;
    a0011138:	f9402fe0 	ldr	x0, [sp, #88]
    a001113c:	f9408c00 	ldr	x0, [x0, #280]
    a0011140:	f9002be0 	str	x0, [sp, #80]
    a0011144:	f00001a0 	adrp	x0, a0048000 <_kernel+0x20>
    a0011148:	910a4000 	add	x0, x0, #0x290
    a001114c:	f90027e0 	str	x0, [sp, #72]
}
    a0011150:	d503201f 	nop
		arch_switch(newsh, &old_thread->switch_handle);
    a0011154:	f94043e0 	ldr	x0, [sp, #128]
    a0011158:	91046000 	add	x0, x0, #0x118
    a001115c:	aa0003e1 	mov	x1, x0
    a0011160:	f9402be0 	ldr	x0, [sp, #80]
    a0011164:	97ffff89 	bl	a0010f88 <arch_switch>
    a0011168:	14000005 	b	a001117c <z_swap_unlocked+0x170>
    a001116c:	f00001a0 	adrp	x0, a0048000 <_kernel+0x20>
    a0011170:	910a4000 	add	x0, x0, #0x290
    a0011174:	f90023e0 	str	x0, [sp, #64]
    a0011178:	d503201f 	nop
	if (is_spinlock) {
    a001117c:	b9408fe0 	ldr	w0, [sp, #140]
    a0011180:	7100001f 	cmp	w0, #0x0
    a0011184:	54000120 	b.eq	a00111a8 <z_swap_unlocked+0x19c>  // b.none
    a0011188:	b9409fe0 	ldr	w0, [sp, #156]
    a001118c:	b9003fe0 	str	w0, [sp, #60]
	write_daif(key);
    a0011190:	b9403fe0 	ldr	w0, [sp, #60]
    a0011194:	f9001be0 	str	x0, [sp, #48]
MAKE_REG_HELPER(daif)
    a0011198:	f9401be0 	ldr	x0, [sp, #48]
    a001119c:	d51b4220 	msr	daif, x0
    a00111a0:	d503201f 	nop
}
    a00111a4:	14000009 	b	a00111c8 <z_swap_unlocked+0x1bc>
    a00111a8:	b9409fe0 	ldr	w0, [sp, #156]
    a00111ac:	b9002fe0 	str	w0, [sp, #44]
	write_daif(key);
    a00111b0:	b9402fe0 	ldr	w0, [sp, #44]
    a00111b4:	f90013e0 	str	x0, [sp, #32]
    a00111b8:	f94013e0 	ldr	x0, [sp, #32]
    a00111bc:	d51b4220 	msr	daif, x0
    a00111c0:	d503201f 	nop
}
    a00111c4:	d503201f 	nop
	(void) do_swap(arch_irq_lock(), NULL, 1);
}
    a00111c8:	d503201f 	nop
    a00111cc:	a8ca7bfd 	ldp	x29, x30, [sp], #160
    a00111d0:	d65f03c0 	ret

00000000a00111d4 <z_dummy_thread_init>:
 * use it to properly store state, which will just be discarded.
 *
 * The memory of the dummy thread can be completely uninitialized.
 */
static inline void z_dummy_thread_init(struct k_thread *dummy_thread)
{
    a00111d4:	d10043ff 	sub	sp, sp, #0x10
    a00111d8:	f90007e0 	str	x0, [sp, #8]
	dummy_thread->base.thread_state = _THREAD_DUMMY;
    a00111dc:	f94007e0 	ldr	x0, [sp, #8]
    a00111e0:	52800021 	mov	w1, #0x1                   	// #1
    a00111e4:	39006401 	strb	w1, [x0, #25]
#ifdef CONFIG_SCHED_CPU_MASK
	dummy_thread->base.cpu_mask = -1;
#endif
	dummy_thread->base.user_options = K_ESSENTIAL;
    a00111e8:	f94007e0 	ldr	x0, [sp, #8]
    a00111ec:	52800021 	mov	w1, #0x1                   	// #1
    a00111f0:	39006001 	strb	w1, [x0, #24]
#ifdef CONFIG_THREAD_STACK_INFO
	dummy_thread->stack_info.start = 0U;
    a00111f4:	f94007e0 	ldr	x0, [sp, #8]
    a00111f8:	f900681f 	str	xzr, [x0, #208]
	dummy_thread->stack_info.size = 0U;
    a00111fc:	f94007e0 	ldr	x0, [sp, #8]
    a0011200:	f9006c1f 	str	xzr, [x0, #216]
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
    a0011204:	f94007e0 	ldr	x0, [sp, #8]
    a0011208:	f00003e1 	adrp	x1, a0090000 <z_page_frames+0x47d68>
    a001120c:	910ac021 	add	x1, x1, #0x2b0
    a0011210:	f9007c01 	str	x1, [x0, #248]
#endif
#if (CONFIG_HEAP_MEM_POOL_SIZE > 0)
	k_thread_system_pool_assign(dummy_thread);
#else
	dummy_thread->resource_pool = NULL;
    a0011214:	f94007e0 	ldr	x0, [sp, #8]
    a0011218:	f900901f 	str	xzr, [x0, #288]
#endif

	_current_cpu->current = dummy_thread;
    a001121c:	d00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0011220:	913f8000 	add	x0, x0, #0xfe0
    a0011224:	f94007e1 	ldr	x1, [sp, #8]
    a0011228:	f9000801 	str	x1, [x0, #16]
}
    a001122c:	d503201f 	nop
    a0011230:	910043ff 	add	sp, sp, #0x10
    a0011234:	d65f03c0 	ret

00000000a0011238 <bg_thread_main>:
 * This routine completes kernel initialization by invoking the remaining
 * init functions, then invokes application's main() routine.
 */
__boot_func
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
    a0011238:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a001123c:	910003fd 	mov	x29, sp
    a0011240:	f90017e0 	str	x0, [sp, #40]
    a0011244:	f90013e1 	str	x1, [sp, #32]
    a0011248:	f9000fe2 	str	x2, [sp, #24]
	/* Invoked here such that backing store or eviction algorithms may
	 * initialize kernel objects, and that all POST_KERNEL and later tasks
	 * may perform memory management tasks (except for z_phys_map() which
	 * is allowed at any time)
	 */
	z_mem_manage_init();
    a001124c:	94002881 	bl	a001b450 <z_mem_manage_init>
#endif /* CONFIG_MMU */
	z_sys_post_kernel = true;
    a0011250:	f00003e0 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a0011254:	9111c000 	add	x0, x0, #0x470
    a0011258:	52800021 	mov	w1, #0x1                   	// #1
    a001125c:	39000001 	strb	w1, [x0]

	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
    a0011260:	52800040 	mov	w0, #0x2                   	// #2
    a0011264:	97fffdbc 	bl	a0010954 <z_sys_init_run_level>
#if CONFIG_STACK_POINTER_RANDOM
	z_stack_adjust_initialized = 1;
#endif
	boot_banner();
    a0011268:	94003154 	bl	a001d7b8 <boot_banner>
	void z_cpp_init_static(void);
	z_cpp_init_static();
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
    a001126c:	52800060 	mov	w0, #0x3                   	// #3
    a0011270:	97fffdb9 	bl	a0010954 <z_sys_init_run_level>

	z_init_static_threads();
    a0011274:	94000524 	bl	a0012704 <z_init_static_threads>
	z_smp_init();
	z_sys_init_run_level(_SYS_INIT_LEVEL_SMP);
#endif

#ifdef CONFIG_MMU
	z_mem_manage_boot_finish();
    a0011278:	940028c7 	bl	a001b594 <z_mem_manage_boot_finish>
#endif /* CONFIG_MMU */

	extern void main(void);

	main();
    a001127c:	97ffc02e 	bl	a0001334 <main>

	/* Mark nonessenrial since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
    a0011280:	f00001a0 	adrp	x0, a0048000 <_kernel+0x20>
    a0011284:	91008000 	add	x0, x0, #0x20
    a0011288:	39406000 	ldrb	w0, [x0, #24]
    a001128c:	121f7800 	and	w0, w0, #0xfffffffe
    a0011290:	12001c01 	and	w1, w0, #0xff
    a0011294:	f00001a0 	adrp	x0, a0048000 <_kernel+0x20>
    a0011298:	91008000 	add	x0, x0, #0x20
    a001129c:	39006001 	strb	w1, [x0, #24]

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
    a00112a0:	d503201f 	nop
    a00112a4:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a00112a8:	d65f03c0 	ret

00000000a00112ac <init_idle_thread>:

#if defined(CONFIG_MULTITHREADING)
__boot_func
static void init_idle_thread(int i)
{
    a00112ac:	d10143ff 	sub	sp, sp, #0x50
    a00112b0:	a9017bfd 	stp	x29, x30, [sp, #16]
    a00112b4:	910043fd 	add	x29, sp, #0x10
    a00112b8:	b9002fe0 	str	w0, [sp, #44]
	struct k_thread *thread = &z_idle_threads[i];
    a00112bc:	b9802fe1 	ldrsw	x1, [sp, #44]
    a00112c0:	d2802700 	mov	x0, #0x138                 	// #312
    a00112c4:	9b007c21 	mul	x1, x1, x0
    a00112c8:	f00001a0 	adrp	x0, a0048000 <_kernel+0x20>
    a00112cc:	91056000 	add	x0, x0, #0x158
    a00112d0:	8b000020 	add	x0, x1, x0
    a00112d4:	f90027e0 	str	x0, [sp, #72]
	k_thread_stack_t *stack = z_idle_stacks[i];
    a00112d8:	b9802fe0 	ldrsw	x0, [sp, #44]
    a00112dc:	d374cc01 	lsl	x1, x0, #12
    a00112e0:	90000400 	adrp	x0, a0091000 <z_idle_stacks>
    a00112e4:	91000000 	add	x0, x0, #0x0
    a00112e8:	8b000020 	add	x0, x1, x0
    a00112ec:	f90023e0 	str	x0, [sp, #64]
#ifdef CONFIG_THREAD_NAME
	char tname[8];

	snprintk(tname, 8, "idle %02d", i);
#else
	char *tname = NULL;
    a00112f0:	f9001fff 	str	xzr, [sp, #56]
#endif /* CONFIG_THREAD_NAME */

	z_setup_new_thread(thread, stack,
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
    a00112f4:	b9802fe1 	ldrsw	x1, [sp, #44]
    a00112f8:	d2800500 	mov	x0, #0x28                  	// #40
    a00112fc:	9b007c21 	mul	x1, x1, x0
    a0011300:	d00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0011304:	913f8000 	add	x0, x0, #0xfe0
    a0011308:	8b000021 	add	x1, x1, x0
	z_setup_new_thread(thread, stack,
    a001130c:	f9401fe0 	ldr	x0, [sp, #56]
    a0011310:	f90007e0 	str	x0, [sp, #8]
    a0011314:	52800020 	mov	w0, #0x1                   	// #1
    a0011318:	b90003e0 	str	w0, [sp]
    a001131c:	528001e7 	mov	w7, #0xf                   	// #15
    a0011320:	d2800006 	mov	x6, #0x0                   	// #0
    a0011324:	d2800005 	mov	x5, #0x0                   	// #0
    a0011328:	aa0103e4 	mov	x4, x1
    a001132c:	b0000000 	adrp	x0, a0012000 <setup_thread_stack+0x14>
    a0011330:	9134b003 	add	x3, x0, #0xd2c
    a0011334:	d2820002 	mov	x2, #0x1000                	// #4096
    a0011338:	f94023e1 	ldr	x1, [sp, #64]
    a001133c:	f94027e0 	ldr	x0, [sp, #72]
    a0011340:	94000376 	bl	a0012118 <z_setup_new_thread>
			  NULL, NULL, K_IDLE_PRIO, K_ESSENTIAL,
			  tname);
	z_mark_thread_as_started(thread);
    a0011344:	f94027e0 	ldr	x0, [sp, #72]
    a0011348:	97ffff1a 	bl	a0010fb0 <z_mark_thread_as_started>

#ifdef CONFIG_SMP
	thread->base.is_idle = 1U;
#endif
}
    a001134c:	d503201f 	nop
    a0011350:	a9417bfd 	ldp	x29, x30, [sp, #16]
    a0011354:	910143ff 	add	sp, sp, #0x50
    a0011358:	d65f03c0 	ret

00000000a001135c <prepare_multithreading>:
 *
 * @return initial stack pointer for the main thread
 */
__boot_func
static char *prepare_multithreading(void)
{
    a001135c:	d100c3ff 	sub	sp, sp, #0x30
    a0011360:	a9017bfd 	stp	x29, x30, [sp, #16]
    a0011364:	910043fd 	add	x29, sp, #0x10
	char *stack_ptr;

	/* _kernel.ready_q is all zeroes */
	z_sched_init();
    a0011368:	94001c58 	bl	a00184c8 <z_sched_init>
	 * - the main thread will be the one to run first
	 * - no other thread is initialized yet and thus their priority fields
	 *   contain garbage, which would prevent the cache loading algorithm
	 *   to work as intended
	 */
	_kernel.ready_q.cache = &z_main_thread;
    a001136c:	d00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0011370:	913f8000 	add	x0, x0, #0xfe0
    a0011374:	f00001a1 	adrp	x1, a0048000 <_kernel+0x20>
    a0011378:	91008021 	add	x1, x1, #0x20
    a001137c:	f9001401 	str	x1, [x0, #40]
#endif
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    a0011380:	f0000080 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a0011384:	91116000 	add	x0, x0, #0x458
    a0011388:	f90007e0 	str	x0, [sp, #8]
    a001138c:	52800020 	mov	w0, #0x1                   	// #1
    a0011390:	b90003e0 	str	w0, [sp]
    a0011394:	52800007 	mov	w7, #0x0                   	// #0
    a0011398:	d2800006 	mov	x6, #0x0                   	// #0
    a001139c:	d2800005 	mov	x5, #0x0                   	// #0
    a00113a0:	d2800004 	mov	x4, #0x0                   	// #0
    a00113a4:	90000000 	adrp	x0, a0011000 <wait_for_switch+0x8>
    a00113a8:	9108e003 	add	x3, x0, #0x238
    a00113ac:	d2820002 	mov	x2, #0x1000                	// #4096
    a00113b0:	90000440 	adrp	x0, a0099000 <z_main_stack>
    a00113b4:	91000001 	add	x1, x0, #0x0
    a00113b8:	f00001a0 	adrp	x0, a0048000 <_kernel+0x20>
    a00113bc:	91008000 	add	x0, x0, #0x20
    a00113c0:	94000356 	bl	a0012118 <z_setup_new_thread>
    a00113c4:	f90013e0 	str	x0, [sp, #32]
				       CONFIG_MAIN_STACK_SIZE, bg_thread_main,
				       NULL, NULL, NULL,
				       CONFIG_MAIN_THREAD_PRIORITY,
				       K_ESSENTIAL, "main");
	z_mark_thread_as_started(&z_main_thread);
    a00113c8:	f00001a0 	adrp	x0, a0048000 <_kernel+0x20>
    a00113cc:	91008000 	add	x0, x0, #0x20
    a00113d0:	97fffef8 	bl	a0010fb0 <z_mark_thread_as_started>
	z_ready_thread(&z_main_thread);
    a00113d4:	f00001a0 	adrp	x0, a0048000 <_kernel+0x20>
    a00113d8:	91008000 	add	x0, x0, #0x20
    a00113dc:	94001745 	bl	a00170f0 <z_ready_thread>

	for (int i = 0; i < CONFIG_MP_NUM_CPUS; i++) {
    a00113e0:	b9002fff 	str	wzr, [sp, #44]
    a00113e4:	1400002b 	b	a0011490 <prepare_multithreading+0x134>
		init_idle_thread(i);
    a00113e8:	b9402fe0 	ldr	w0, [sp, #44]
    a00113ec:	97ffffb0 	bl	a00112ac <init_idle_thread>
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
    a00113f0:	b9802fe1 	ldrsw	x1, [sp, #44]
    a00113f4:	d2802700 	mov	x0, #0x138                 	// #312
    a00113f8:	9b007c21 	mul	x1, x1, x0
    a00113fc:	f00001a0 	adrp	x0, a0048000 <_kernel+0x20>
    a0011400:	91056000 	add	x0, x0, #0x158
    a0011404:	8b000021 	add	x1, x1, x0
    a0011408:	d00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001140c:	913f8002 	add	x2, x0, #0xfe0
    a0011410:	b9802fe3 	ldrsw	x3, [sp, #44]
    a0011414:	d2800500 	mov	x0, #0x28                  	// #40
    a0011418:	9b007c60 	mul	x0, x3, x0
    a001141c:	8b000040 	add	x0, x2, x0
    a0011420:	f9000c01 	str	x1, [x0, #24]
		_kernel.cpus[i].id = i;
    a0011424:	b9402fe0 	ldr	w0, [sp, #44]
    a0011428:	12001c03 	and	w3, w0, #0xff
    a001142c:	d00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0011430:	913f8001 	add	x1, x0, #0xfe0
    a0011434:	b9802fe2 	ldrsw	x2, [sp, #44]
    a0011438:	d2800500 	mov	x0, #0x28                  	// #40
    a001143c:	9b007c40 	mul	x0, x2, x0
    a0011440:	8b000020 	add	x0, x1, x0
    a0011444:	2a0303e1 	mov	w1, w3
    a0011448:	39009001 	strb	w1, [x0, #36]
		_kernel.cpus[i].irq_stack =
			(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[i]) +
    a001144c:	b9802fe0 	ldrsw	x0, [sp, #44]
    a0011450:	d374cc01 	lsl	x1, x0, #12
    a0011454:	b0000400 	adrp	x0, a0092000 <z_interrupt_stacks>
    a0011458:	91000000 	add	x0, x0, #0x0
    a001145c:	8b000020 	add	x0, x1, x0
    a0011460:	97fffec5 	bl	a0010f74 <Z_KERNEL_STACK_BUFFER>
    a0011464:	91400401 	add	x1, x0, #0x1, lsl #12
		_kernel.cpus[i].irq_stack =
    a0011468:	d00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001146c:	913f8002 	add	x2, x0, #0xfe0
    a0011470:	b9802fe3 	ldrsw	x3, [sp, #44]
    a0011474:	d2800500 	mov	x0, #0x28                  	// #40
    a0011478:	9b007c60 	mul	x0, x3, x0
    a001147c:	8b000040 	add	x0, x2, x0
    a0011480:	f9000401 	str	x1, [x0, #8]
	for (int i = 0; i < CONFIG_MP_NUM_CPUS; i++) {
    a0011484:	b9402fe0 	ldr	w0, [sp, #44]
    a0011488:	11000400 	add	w0, w0, #0x1
    a001148c:	b9002fe0 	str	w0, [sp, #44]
    a0011490:	b9402fe0 	ldr	w0, [sp, #44]
    a0011494:	7100001f 	cmp	w0, #0x0
    a0011498:	54fffa8d 	b.le	a00113e8 <prepare_multithreading+0x8c>
		_kernel.cpus[i].usage.track_usage =
			CONFIG_SCHED_THREAD_USAGE_AUTO_ENABLE;
#endif
	}

	return stack_ptr;
    a001149c:	f94013e0 	ldr	x0, [sp, #32]
}
    a00114a0:	a9417bfd 	ldp	x29, x30, [sp, #16]
    a00114a4:	9100c3ff 	add	sp, sp, #0x30
    a00114a8:	d65f03c0 	ret

00000000a00114ac <switch_to_main_thread>:

__boot_func
static FUNC_NORETURN void switch_to_main_thread(char *stack_ptr)
{
    a00114ac:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a00114b0:	910003fd 	mov	x29, sp
    a00114b4:	f9000fe0 	str	x0, [sp, #24]
	/*
	 * Context switch to main task (entry function is _main()): the
	 * current fake thread is not on a wait queue or ready queue, so it
	 * will never be rescheduled in.
	 */
	z_swap_unlocked();
    a00114b8:	97fffed5 	bl	a001100c <z_swap_unlocked>

00000000a00114bc <z_cstart>:
 *
 * @return Does not return
 */
__boot_func
FUNC_NORETURN void z_cstart(void)
{
    a00114bc:	a9ab7bfd 	stp	x29, x30, [sp, #-336]!
    a00114c0:	910003fd 	mov	x29, sp
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();
    a00114c4:	97fffecb 	bl	a0010ff0 <gcov_static_init>
}
    a00114c8:	d503201f 	nop
	/* Note: The z_ready_thread() call in prepare_multithreading() requires
	 * a dummy thread even if CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN=y
	 */
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
    a00114cc:	910063e0 	add	x0, sp, #0x18
    a00114d0:	97ffff41 	bl	a00111d4 <z_dummy_thread_init>
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
    a00114d4:	97fffd0c 	bl	a0010904 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
    a00114d8:	52800000 	mov	w0, #0x0                   	// #0
    a00114dc:	97fffd1e 	bl	a0010954 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
    a00114e0:	52800020 	mov	w0, #0x1                   	// #1
    a00114e4:	97fffd1c 	bl	a0010954 <z_sys_init_run_level>
	timing_init();
	timing_start();
#endif

#ifdef CONFIG_MULTITHREADING
	switch_to_main_thread(prepare_multithreading());
    a00114e8:	97ffff9d 	bl	a001135c <prepare_multithreading>
    a00114ec:	97fffff0 	bl	a00114ac <switch_to_main_thread>

00000000a00114f0 <create_free_list>:
 *
 * @retval 0 on success.
 * @retval -EINVAL if @p slab contains invalid configuration and/or values.
 */
static int create_free_list(struct k_mem_slab *slab)
{
    a00114f0:	d10083ff 	sub	sp, sp, #0x20
    a00114f4:	f90007e0 	str	x0, [sp, #8]
	uint32_t j;
	char *p;

	/* blocks must be word aligned */
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
    a00114f8:	f94007e0 	ldr	x0, [sp, #8]
    a00114fc:	f9400c00 	ldr	x0, [x0, #24]
    a0011500:	f94007e1 	ldr	x1, [sp, #8]
    a0011504:	f9401021 	ldr	x1, [x1, #32]
    a0011508:	aa010000 	orr	x0, x0, x1
    a001150c:	92400800 	and	x0, x0, #0x7
    a0011510:	f100001f 	cmp	x0, #0x0
    a0011514:	54000060 	b.eq	a0011520 <create_free_list+0x30>  // b.none
				(sizeof(void *) - 1)) != 0U) {
		return -EINVAL;
    a0011518:	128002a0 	mov	w0, #0xffffffea            	// #-22
    a001151c:	1400001d 	b	a0011590 <create_free_list+0xa0>
	}

	slab->free_list = NULL;
    a0011520:	f94007e0 	ldr	x0, [sp, #8]
    a0011524:	f900141f 	str	xzr, [x0, #40]
	p = slab->buffer;
    a0011528:	f94007e0 	ldr	x0, [sp, #8]
    a001152c:	f9401000 	ldr	x0, [x0, #32]
    a0011530:	f9000be0 	str	x0, [sp, #16]

	for (j = 0U; j < slab->num_blocks; j++) {
    a0011534:	b9001fff 	str	wzr, [sp, #28]
    a0011538:	14000010 	b	a0011578 <create_free_list+0x88>
		*(char **)p = slab->free_list;
    a001153c:	f94007e0 	ldr	x0, [sp, #8]
    a0011540:	f9401401 	ldr	x1, [x0, #40]
    a0011544:	f9400be0 	ldr	x0, [sp, #16]
    a0011548:	f9000001 	str	x1, [x0]
		slab->free_list = p;
    a001154c:	f94007e0 	ldr	x0, [sp, #8]
    a0011550:	f9400be1 	ldr	x1, [sp, #16]
    a0011554:	f9001401 	str	x1, [x0, #40]
		p += slab->block_size;
    a0011558:	f94007e0 	ldr	x0, [sp, #8]
    a001155c:	f9400c00 	ldr	x0, [x0, #24]
    a0011560:	f9400be1 	ldr	x1, [sp, #16]
    a0011564:	8b000020 	add	x0, x1, x0
    a0011568:	f9000be0 	str	x0, [sp, #16]
	for (j = 0U; j < slab->num_blocks; j++) {
    a001156c:	b9401fe0 	ldr	w0, [sp, #28]
    a0011570:	11000400 	add	w0, w0, #0x1
    a0011574:	b9001fe0 	str	w0, [sp, #28]
    a0011578:	f94007e0 	ldr	x0, [sp, #8]
    a001157c:	b9401000 	ldr	w0, [x0, #16]
    a0011580:	b9401fe1 	ldr	w1, [sp, #28]
    a0011584:	6b00003f 	cmp	w1, w0
    a0011588:	54fffda3 	b.cc	a001153c <create_free_list+0x4c>  // b.lo, b.ul, b.last
	}
	return 0;
    a001158c:	52800000 	mov	w0, #0x0                   	// #0
}
    a0011590:	910083ff 	add	sp, sp, #0x20
    a0011594:	d65f03c0 	ret

00000000a0011598 <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return 0 on success, fails otherwise.
 */
static int init_mem_slab_module(const struct device *dev)
{
    a0011598:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a001159c:	910003fd 	mov	x29, sp
    a00115a0:	f9000fe0 	str	x0, [sp, #24]
	int rc = 0;
    a00115a4:	b9002fff 	str	wzr, [sp, #44]
	ARG_UNUSED(dev);

	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
    a00115a8:	d0000440 	adrp	x0, a009b000 <twom1000.10>
    a00115ac:	9102d000 	add	x0, x0, #0xb4
    a00115b0:	f90013e0 	str	x0, [sp, #32]
    a00115b4:	1400000c 	b	a00115e4 <init_mem_slab_module+0x4c>
		rc = create_free_list(slab);
    a00115b8:	f94013e0 	ldr	x0, [sp, #32]
    a00115bc:	97ffffcd 	bl	a00114f0 <create_free_list>
    a00115c0:	b9002fe0 	str	w0, [sp, #44]
		if (rc < 0) {
    a00115c4:	b9402fe0 	ldr	w0, [sp, #44]
    a00115c8:	7100001f 	cmp	w0, #0x0
    a00115cc:	540001eb 	b.lt	a0011608 <init_mem_slab_module+0x70>  // b.tstop
			goto out;
		}
		z_object_init(slab);
    a00115d0:	f94013e0 	ldr	x0, [sp, #32]
    a00115d4:	94002f8f 	bl	a001d410 <z_object_init>
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
    a00115d8:	f94013e0 	ldr	x0, [sp, #32]
    a00115dc:	9100e000 	add	x0, x0, #0x38
    a00115e0:	f90013e0 	str	x0, [sp, #32]
    a00115e4:	f94013e1 	ldr	x1, [sp, #32]
    a00115e8:	d0000440 	adrp	x0, a009b000 <twom1000.10>
    a00115ec:	9102d000 	add	x0, x0, #0xb4
    a00115f0:	eb00003f 	cmp	x1, x0
    a00115f4:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
    a00115f8:	12001c00 	and	w0, w0, #0xff
    a00115fc:	7100001f 	cmp	w0, #0x0
    a0011600:	54fffdc1 	b.ne	a00115b8 <init_mem_slab_module+0x20>  // b.any
	}

out:
    a0011604:	14000002 	b	a001160c <init_mem_slab_module+0x74>
			goto out;
    a0011608:	d503201f 	nop
	return rc;
    a001160c:	b9402fe0 	ldr	w0, [sp, #44]
}
    a0011610:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0011614:	d65f03c0 	ret

00000000a0011618 <sys_dlist_init>:
 *
 * @param list the doubly-linked list
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
    a0011618:	d10043ff 	sub	sp, sp, #0x10
    a001161c:	f90007e0 	str	x0, [sp, #8]
	list->head = (sys_dnode_t *)list;
    a0011620:	f94007e0 	ldr	x0, [sp, #8]
    a0011624:	f94007e1 	ldr	x1, [sp, #8]
    a0011628:	f9000001 	str	x1, [x0]
	list->tail = (sys_dnode_t *)list;
    a001162c:	f94007e0 	ldr	x0, [sp, #8]
    a0011630:	f94007e1 	ldr	x1, [sp, #8]
    a0011634:	f9000401 	str	x1, [x0, #8]
}
    a0011638:	d503201f 	nop
    a001163c:	910043ff 	add	sp, sp, #0x10
    a0011640:	d65f03c0 	ret

00000000a0011644 <sys_dnode_init>:
 *
 * @param node the node
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
    a0011644:	d10043ff 	sub	sp, sp, #0x10
    a0011648:	f90007e0 	str	x0, [sp, #8]
	node->next = NULL;
    a001164c:	f94007e0 	ldr	x0, [sp, #8]
    a0011650:	f900001f 	str	xzr, [x0]
	node->prev = NULL;
    a0011654:	f94007e0 	ldr	x0, [sp, #8]
    a0011658:	f900041f 	str	xzr, [x0, #8]
}
    a001165c:	d503201f 	nop
    a0011660:	910043ff 	add	sp, sp, #0x10
    a0011664:	d65f03c0 	ret

00000000a0011668 <arch_syscall_invoke2>:
{
    a0011668:	d10083ff 	sub	sp, sp, #0x20
    a001166c:	f9000fe0 	str	x0, [sp, #24]
    a0011670:	f9000be1 	str	x1, [sp, #16]
    a0011674:	f90007e2 	str	x2, [sp, #8]
	register uint64_t ret __asm__("x0") = arg1;
    a0011678:	f9400fe0 	ldr	x0, [sp, #24]
	register uint64_t r1 __asm__("x1") = arg2;
    a001167c:	f9400be1 	ldr	x1, [sp, #16]
	register uint64_t r8 __asm__("x8") = call_id;
    a0011680:	f94007e8 	ldr	x8, [sp, #8]
	__asm__ volatile("svc %[svid]\n"
    a0011684:	d4000061 	svc	#0x3
}
    a0011688:	910083ff 	add	sp, sp, #0x20
    a001168c:	d65f03c0 	ret

00000000a0011690 <arch_syscall_invoke1>:
{
    a0011690:	d10043ff 	sub	sp, sp, #0x10
    a0011694:	f90007e0 	str	x0, [sp, #8]
    a0011698:	f90003e1 	str	x1, [sp]
	register uint64_t ret __asm__("x0") = arg1;
    a001169c:	f94007e0 	ldr	x0, [sp, #8]
	register uint64_t r8 __asm__("x8") = call_id;
    a00116a0:	f94003e8 	ldr	x8, [sp]
	__asm__ volatile("svc %[svid]\n"
    a00116a4:	d4000061 	svc	#0x3
}
    a00116a8:	910043ff 	add	sp, sp, #0x10
    a00116ac:	d65f03c0 	ret

00000000a00116b0 <k_ms_to_ticks_ceil64>:
{
    a00116b0:	d10103ff 	sub	sp, sp, #0x40
    a00116b4:	f90007e0 	str	x0, [sp, #8]
    a00116b8:	f94007e0 	ldr	x0, [sp, #8]
    a00116bc:	f9001fe0 	str	x0, [sp, #56]
    a00116c0:	52807d00 	mov	w0, #0x3e8                 	// #1000
    a00116c4:	b90037e0 	str	w0, [sp, #52]
    a00116c8:	52800c80 	mov	w0, #0x64                  	// #100
    a00116cc:	b90033e0 	str	w0, [sp, #48]
    a00116d0:	52800020 	mov	w0, #0x1                   	// #1
    a00116d4:	3900bfe0 	strb	w0, [sp, #47]
    a00116d8:	3900bbff 	strb	wzr, [sp, #46]
    a00116dc:	52800020 	mov	w0, #0x1                   	// #1
    a00116e0:	3900b7e0 	strb	w0, [sp, #45]
    a00116e4:	3900b3ff 	strb	wzr, [sp, #44]
		(to_hz > from_hz) && ((to_hz % from_hz) == 0U);
    a00116e8:	3940bfe0 	ldrb	w0, [sp, #47]
    a00116ec:	7100001f 	cmp	w0, #0x0
    a00116f0:	540001e0 	b.eq	a001172c <k_ms_to_ticks_ceil64+0x7c>  // b.none
	bool mul_ratio = const_hz &&
    a00116f4:	b94037e1 	ldr	w1, [sp, #52]
    a00116f8:	b94033e0 	ldr	w0, [sp, #48]
    a00116fc:	6b00003f 	cmp	w1, w0
    a0011700:	54000162 	b.cs	a001172c <k_ms_to_ticks_ceil64+0x7c>  // b.hs, b.nlast
		(to_hz > from_hz) && ((to_hz % from_hz) == 0U);
    a0011704:	b94033e0 	ldr	w0, [sp, #48]
    a0011708:	b94037e1 	ldr	w1, [sp, #52]
    a001170c:	1ac10802 	udiv	w2, w0, w1
    a0011710:	b94037e1 	ldr	w1, [sp, #52]
    a0011714:	1b017c41 	mul	w1, w2, w1
    a0011718:	4b010000 	sub	w0, w0, w1
    a001171c:	7100001f 	cmp	w0, #0x0
    a0011720:	54000061 	b.ne	a001172c <k_ms_to_ticks_ceil64+0x7c>  // b.any
    a0011724:	52800020 	mov	w0, #0x1                   	// #1
    a0011728:	14000002 	b	a0011730 <k_ms_to_ticks_ceil64+0x80>
    a001172c:	52800000 	mov	w0, #0x0                   	// #0
	bool mul_ratio = const_hz &&
    a0011730:	3900afe0 	strb	w0, [sp, #43]
    a0011734:	3940afe0 	ldrb	w0, [sp, #43]
    a0011738:	12000000 	and	w0, w0, #0x1
    a001173c:	3900afe0 	strb	w0, [sp, #43]
		(from_hz > to_hz) && ((from_hz % to_hz) == 0U);
    a0011740:	3940bfe0 	ldrb	w0, [sp, #47]
    a0011744:	7100001f 	cmp	w0, #0x0
    a0011748:	540001e0 	b.eq	a0011784 <k_ms_to_ticks_ceil64+0xd4>  // b.none
	bool div_ratio = const_hz &&
    a001174c:	b94037e1 	ldr	w1, [sp, #52]
    a0011750:	b94033e0 	ldr	w0, [sp, #48]
    a0011754:	6b00003f 	cmp	w1, w0
    a0011758:	54000169 	b.ls	a0011784 <k_ms_to_ticks_ceil64+0xd4>  // b.plast
		(from_hz > to_hz) && ((from_hz % to_hz) == 0U);
    a001175c:	b94037e0 	ldr	w0, [sp, #52]
    a0011760:	b94033e1 	ldr	w1, [sp, #48]
    a0011764:	1ac10802 	udiv	w2, w0, w1
    a0011768:	b94033e1 	ldr	w1, [sp, #48]
    a001176c:	1b017c41 	mul	w1, w2, w1
    a0011770:	4b010000 	sub	w0, w0, w1
    a0011774:	7100001f 	cmp	w0, #0x0
    a0011778:	54000061 	b.ne	a0011784 <k_ms_to_ticks_ceil64+0xd4>  // b.any
    a001177c:	52800020 	mov	w0, #0x1                   	// #1
    a0011780:	14000002 	b	a0011788 <k_ms_to_ticks_ceil64+0xd8>
    a0011784:	52800000 	mov	w0, #0x0                   	// #0
	bool div_ratio = const_hz &&
    a0011788:	3900abe0 	strb	w0, [sp, #42]
    a001178c:	3940abe0 	ldrb	w0, [sp, #42]
    a0011790:	12000000 	and	w0, w0, #0x1
    a0011794:	3900abe0 	strb	w0, [sp, #42]
	if (from_hz == to_hz) {
    a0011798:	b94037e1 	ldr	w1, [sp, #52]
    a001179c:	b94033e0 	ldr	w0, [sp, #48]
    a00117a0:	6b00003f 	cmp	w1, w0
    a00117a4:	54000121 	b.ne	a00117c8 <k_ms_to_ticks_ceil64+0x118>  // b.any
		return result32 ? ((uint32_t)t) : t;
    a00117a8:	3940bbe0 	ldrb	w0, [sp, #46]
    a00117ac:	7100001f 	cmp	w0, #0x0
    a00117b0:	54000080 	b.eq	a00117c0 <k_ms_to_ticks_ceil64+0x110>  // b.none
    a00117b4:	f9401fe0 	ldr	x0, [sp, #56]
    a00117b8:	2a0003e0 	mov	w0, w0
    a00117bc:	14000089 	b	a00119e0 <k_ms_to_ticks_ceil64+0x330>
    a00117c0:	f9401fe0 	ldr	x0, [sp, #56]
    a00117c4:	14000087 	b	a00119e0 <k_ms_to_ticks_ceil64+0x330>
	uint64_t off = 0;
    a00117c8:	f90013ff 	str	xzr, [sp, #32]
	if (!mul_ratio) {
    a00117cc:	3940afe0 	ldrb	w0, [sp, #43]
    a00117d0:	52000000 	eor	w0, w0, #0x1
    a00117d4:	12001c00 	and	w0, w0, #0xff
    a00117d8:	7100001f 	cmp	w0, #0x0
    a00117dc:	54000300 	b.eq	a001183c <k_ms_to_ticks_ceil64+0x18c>  // b.none
		uint32_t rdivisor = div_ratio ? (from_hz / to_hz) : from_hz;
    a00117e0:	3940abe0 	ldrb	w0, [sp, #42]
    a00117e4:	7100001f 	cmp	w0, #0x0
    a00117e8:	540000a0 	b.eq	a00117fc <k_ms_to_ticks_ceil64+0x14c>  // b.none
    a00117ec:	b94037e1 	ldr	w1, [sp, #52]
    a00117f0:	b94033e0 	ldr	w0, [sp, #48]
    a00117f4:	1ac00820 	udiv	w0, w1, w0
    a00117f8:	14000002 	b	a0011800 <k_ms_to_ticks_ceil64+0x150>
    a00117fc:	b94037e0 	ldr	w0, [sp, #52]
    a0011800:	b9001fe0 	str	w0, [sp, #28]
		if (round_up) {
    a0011804:	3940b7e0 	ldrb	w0, [sp, #45]
    a0011808:	7100001f 	cmp	w0, #0x0
    a001180c:	540000a0 	b.eq	a0011820 <k_ms_to_ticks_ceil64+0x170>  // b.none
			off = rdivisor - 1U;
    a0011810:	b9401fe0 	ldr	w0, [sp, #28]
    a0011814:	51000400 	sub	w0, w0, #0x1
    a0011818:	2a0003e0 	mov	w0, w0
    a001181c:	f90013e0 	str	x0, [sp, #32]
		if (round_off) {
    a0011820:	3940b3e0 	ldrb	w0, [sp, #44]
    a0011824:	7100001f 	cmp	w0, #0x0
    a0011828:	540000a0 	b.eq	a001183c <k_ms_to_ticks_ceil64+0x18c>  // b.none
			off = rdivisor / 2U;
    a001182c:	b9401fe0 	ldr	w0, [sp, #28]
    a0011830:	53017c00 	lsr	w0, w0, #1
    a0011834:	2a0003e0 	mov	w0, w0
    a0011838:	f90013e0 	str	x0, [sp, #32]
	if (div_ratio) {
    a001183c:	3940abe0 	ldrb	w0, [sp, #42]
    a0011840:	7100001f 	cmp	w0, #0x0
    a0011844:	54000360 	b.eq	a00118b0 <k_ms_to_ticks_ceil64+0x200>  // b.none
		t += off;
    a0011848:	f9401fe1 	ldr	x1, [sp, #56]
    a001184c:	f94013e0 	ldr	x0, [sp, #32]
    a0011850:	8b000020 	add	x0, x1, x0
    a0011854:	f9001fe0 	str	x0, [sp, #56]
		if (result32 && (t < BIT64(32))) {
    a0011858:	3940bbe0 	ldrb	w0, [sp, #46]
    a001185c:	7100001f 	cmp	w0, #0x0
    a0011860:	540001a0 	b.eq	a0011894 <k_ms_to_ticks_ceil64+0x1e4>  // b.none
    a0011864:	f9401fe1 	ldr	x1, [sp, #56]
    a0011868:	b2407fe0 	mov	x0, #0xffffffff            	// #4294967295
    a001186c:	eb00003f 	cmp	x1, x0
    a0011870:	54000128 	b.hi	a0011894 <k_ms_to_ticks_ceil64+0x1e4>  // b.pmore
			return ((uint32_t)t) / (from_hz / to_hz);
    a0011874:	f9401fe0 	ldr	x0, [sp, #56]
    a0011878:	2a0003e2 	mov	w2, w0
    a001187c:	b94037e1 	ldr	w1, [sp, #52]
    a0011880:	b94033e0 	ldr	w0, [sp, #48]
    a0011884:	1ac00820 	udiv	w0, w1, w0
    a0011888:	1ac00840 	udiv	w0, w2, w0
    a001188c:	2a0003e0 	mov	w0, w0
    a0011890:	14000054 	b	a00119e0 <k_ms_to_ticks_ceil64+0x330>
			return t / ((uint64_t)from_hz / to_hz);
    a0011894:	b94037e1 	ldr	w1, [sp, #52]
    a0011898:	b94033e0 	ldr	w0, [sp, #48]
    a001189c:	1ac00820 	udiv	w0, w1, w0
    a00118a0:	2a0003e0 	mov	w0, w0
    a00118a4:	f9401fe1 	ldr	x1, [sp, #56]
    a00118a8:	9ac00820 	udiv	x0, x1, x0
    a00118ac:	1400004d 	b	a00119e0 <k_ms_to_ticks_ceil64+0x330>
	} else if (mul_ratio) {
    a00118b0:	3940afe0 	ldrb	w0, [sp, #43]
    a00118b4:	7100001f 	cmp	w0, #0x0
    a00118b8:	54000260 	b.eq	a0011904 <k_ms_to_ticks_ceil64+0x254>  // b.none
		if (result32) {
    a00118bc:	3940bbe0 	ldrb	w0, [sp, #46]
    a00118c0:	7100001f 	cmp	w0, #0x0
    a00118c4:	54000120 	b.eq	a00118e8 <k_ms_to_ticks_ceil64+0x238>  // b.none
			return ((uint32_t)t) * (to_hz / from_hz);
    a00118c8:	f9401fe0 	ldr	x0, [sp, #56]
    a00118cc:	2a0003e2 	mov	w2, w0
    a00118d0:	b94033e1 	ldr	w1, [sp, #48]
    a00118d4:	b94037e0 	ldr	w0, [sp, #52]
    a00118d8:	1ac00820 	udiv	w0, w1, w0
    a00118dc:	1b007c40 	mul	w0, w2, w0
    a00118e0:	2a0003e0 	mov	w0, w0
    a00118e4:	1400003f 	b	a00119e0 <k_ms_to_ticks_ceil64+0x330>
			return t * ((uint64_t)to_hz / from_hz);
    a00118e8:	b94033e1 	ldr	w1, [sp, #48]
    a00118ec:	b94037e0 	ldr	w0, [sp, #52]
    a00118f0:	1ac00820 	udiv	w0, w1, w0
    a00118f4:	2a0003e1 	mov	w1, w0
    a00118f8:	f9401fe0 	ldr	x0, [sp, #56]
    a00118fc:	9b007c20 	mul	x0, x1, x0
    a0011900:	14000038 	b	a00119e0 <k_ms_to_ticks_ceil64+0x330>
		if (result32) {
    a0011904:	3940bbe0 	ldrb	w0, [sp, #46]
    a0011908:	7100001f 	cmp	w0, #0x0
    a001190c:	54000140 	b.eq	a0011934 <k_ms_to_ticks_ceil64+0x284>  // b.none
			return (uint32_t)((t * to_hz + off) / from_hz);
    a0011910:	b94033e1 	ldr	w1, [sp, #48]
    a0011914:	f9401fe0 	ldr	x0, [sp, #56]
    a0011918:	9b007c21 	mul	x1, x1, x0
    a001191c:	f94013e0 	ldr	x0, [sp, #32]
    a0011920:	8b000021 	add	x1, x1, x0
    a0011924:	b94037e0 	ldr	w0, [sp, #52]
    a0011928:	9ac00820 	udiv	x0, x1, x0
    a001192c:	2a0003e0 	mov	w0, w0
    a0011930:	1400002c 	b	a00119e0 <k_ms_to_ticks_ceil64+0x330>
		} else if (const_hz && Z_TMCVT_USE_FAST_ALGO(from_hz, to_hz)) {
    a0011934:	3940bfe0 	ldrb	w0, [sp, #47]
    a0011938:	7100001f 	cmp	w0, #0x0
    a001193c:	54000300 	b.eq	a001199c <k_ms_to_ticks_ceil64+0x2ec>  // b.none
    a0011940:	b94037e1 	ldr	w1, [sp, #52]
    a0011944:	d2867000 	mov	x0, #0x3380                	// #13184
    a0011948:	f2a03c20 	movk	x0, #0x1e1, lsl #16
    a001194c:	9b007c21 	mul	x1, x1, x0
    a0011950:	b27f7be0 	mov	x0, #0xfffffffe            	// #4294967294
    a0011954:	8b000021 	add	x1, x1, x0
    a0011958:	320107e0 	mov	w0, #0x80000001            	// #-2147483647
    a001195c:	f2f00000 	movk	x0, #0x8000, lsl #48
    a0011960:	9bc07c20 	umulh	x0, x1, x0
    a0011964:	d35ffc01 	lsr	x1, x0, #31
    a0011968:	b94033e0 	ldr	w0, [sp, #48]
    a001196c:	9b007c21 	mul	x1, x1, x0
    a0011970:	b2407fe0 	mov	x0, #0xffffffff            	// #4294967295
    a0011974:	eb00003f 	cmp	x1, x0
    a0011978:	54000128 	b.hi	a001199c <k_ms_to_ticks_ceil64+0x2ec>  // b.pmore
			return ((t * to_hz + off) / from_hz);
    a001197c:	b94033e1 	ldr	w1, [sp, #48]
    a0011980:	f9401fe0 	ldr	x0, [sp, #56]
    a0011984:	9b007c21 	mul	x1, x1, x0
    a0011988:	f94013e0 	ldr	x0, [sp, #32]
    a001198c:	8b000021 	add	x1, x1, x0
    a0011990:	b94037e0 	ldr	w0, [sp, #52]
    a0011994:	9ac00820 	udiv	x0, x1, x0
    a0011998:	14000012 	b	a00119e0 <k_ms_to_ticks_ceil64+0x330>
			return (t / from_hz) * to_hz + ((t % from_hz) * to_hz + off) / from_hz;
    a001199c:	b94037e0 	ldr	w0, [sp, #52]
    a00119a0:	f9401fe1 	ldr	x1, [sp, #56]
    a00119a4:	9ac00821 	udiv	x1, x1, x0
    a00119a8:	b94033e0 	ldr	w0, [sp, #48]
    a00119ac:	9b007c22 	mul	x2, x1, x0
    a00119b0:	b94037e1 	ldr	w1, [sp, #52]
    a00119b4:	f9401fe0 	ldr	x0, [sp, #56]
    a00119b8:	9ac10803 	udiv	x3, x0, x1
    a00119bc:	9b017c61 	mul	x1, x3, x1
    a00119c0:	cb010001 	sub	x1, x0, x1
    a00119c4:	b94033e0 	ldr	w0, [sp, #48]
    a00119c8:	9b007c21 	mul	x1, x1, x0
    a00119cc:	f94013e0 	ldr	x0, [sp, #32]
    a00119d0:	8b000021 	add	x1, x1, x0
    a00119d4:	b94037e0 	ldr	w0, [sp, #52]
    a00119d8:	9ac00820 	udiv	x0, x1, x0
    a00119dc:	8b000040 	add	x0, x2, x0
}
    a00119e0:	910103ff 	add	sp, sp, #0x40
    a00119e4:	d65f03c0 	ret

00000000a00119e8 <Z_KERNEL_STACK_BUFFER>:
{
    a00119e8:	d10043ff 	sub	sp, sp, #0x10
    a00119ec:	f90007e0 	str	x0, [sp, #8]
	return (char *)sym + K_KERNEL_STACK_RESERVED;
    a00119f0:	f94007e0 	ldr	x0, [sp, #8]
}
    a00119f4:	910043ff 	add	sp, sp, #0x10
    a00119f8:	d65f03c0 	ret

00000000a00119fc <Z_THREAD_STACK_BUFFER>:
 *
 * @param sym Declared stack symbol name
 * @return The buffer itself, a char *
 */
static inline char *Z_THREAD_STACK_BUFFER(k_thread_stack_t *sym)
{
    a00119fc:	d10043ff 	sub	sp, sp, #0x10
    a0011a00:	f90007e0 	str	x0, [sp, #8]
	return (char *)sym + K_THREAD_STACK_RESERVED;
    a0011a04:	f94007e0 	ldr	x0, [sp, #8]
    a0011a08:	91400400 	add	x0, x0, #0x1, lsl #12
}
    a0011a0c:	910043ff 	add	sp, sp, #0x10
    a0011a10:	d65f03c0 	ret

00000000a0011a14 <k_object_access_grant>:

extern void z_impl_k_object_access_grant(const void * object, struct k_thread * thread);

__pinned_func
static inline void k_object_access_grant(const void * object, struct k_thread * thread)
{
    a0011a14:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0011a18:	910003fd 	mov	x29, sp
    a0011a1c:	f9000fe0 	str	x0, [sp, #24]
    a0011a20:	f9000be1 	str	x1, [sp, #16]
	bool ret = false;
    a0011a24:	3900bfff 	strb	wzr, [sp, #47]
	ret = false;
    a0011a28:	3900bfff 	strb	wzr, [sp, #47]
	return ret;
    a0011a2c:	3940bfe0 	ldrb	w0, [sp, #47]
#ifdef CONFIG_USERSPACE
	if (z_syscall_trap()) {
    a0011a30:	7100001f 	cmp	w0, #0x0
    a0011a34:	54000140 	b.eq	a0011a5c <k_object_access_grant+0x48>  // b.none
		/* coverity[OVERRUN] */
		arch_syscall_invoke2(*(uintptr_t *)&object, *(uintptr_t *)&thread, K_SYSCALL_K_OBJECT_ACCESS_GRANT);
    a0011a38:	910063e0 	add	x0, sp, #0x18
    a0011a3c:	f9400003 	ldr	x3, [x0]
    a0011a40:	910043e0 	add	x0, sp, #0x10
    a0011a44:	f9400000 	ldr	x0, [x0]
    a0011a48:	d28013e2 	mov	x2, #0x9f                  	// #159
    a0011a4c:	aa0003e1 	mov	x1, x0
    a0011a50:	aa0303e0 	mov	x0, x3
    a0011a54:	97ffff05 	bl	a0011668 <arch_syscall_invoke2>
		return;
    a0011a58:	14000004 	b	a0011a68 <k_object_access_grant+0x54>
	}
#endif
	compiler_barrier();
	z_impl_k_object_access_grant(object, thread);
    a0011a5c:	f9400fe0 	ldr	x0, [sp, #24]
    a0011a60:	f9400be1 	ldr	x1, [sp, #16]
    a0011a64:	94002e08 	bl	a001d284 <z_impl_k_object_access_grant>
}
    a0011a68:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0011a6c:	d65f03c0 	ret

00000000a0011a70 <z_impl_k_thread_timeout_expires_ticks>:
 */
__syscall k_ticks_t k_thread_timeout_expires_ticks(const struct k_thread *t);

static inline k_ticks_t z_impl_k_thread_timeout_expires_ticks(
						const struct k_thread *t)
{
    a0011a70:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0011a74:	910003fd 	mov	x29, sp
    a0011a78:	f9000fe0 	str	x0, [sp, #24]
	return z_timeout_expires(&t->base.timeout);
    a0011a7c:	f9400fe0 	ldr	x0, [sp, #24]
    a0011a80:	9100a000 	add	x0, x0, #0x28
    a0011a84:	940020de 	bl	a0019dfc <z_timeout_expires>
}
    a0011a88:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0011a8c:	d65f03c0 	ret

00000000a0011a90 <z_impl_k_thread_timeout_remaining_ticks>:
 */
__syscall k_ticks_t k_thread_timeout_remaining_ticks(const struct k_thread *t);

static inline k_ticks_t z_impl_k_thread_timeout_remaining_ticks(
						const struct k_thread *t)
{
    a0011a90:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0011a94:	910003fd 	mov	x29, sp
    a0011a98:	f9000fe0 	str	x0, [sp, #24]
	return z_timeout_remaining(&t->base.timeout);
    a0011a9c:	f9400fe0 	ldr	x0, [sp, #24]
    a0011aa0:	9100a000 	add	x0, x0, #0x28
    a0011aa4:	940020a9 	bl	a0019d48 <z_timeout_remaining>
}
    a0011aa8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0011aac:	d65f03c0 	ret

00000000a0011ab0 <k_thread_start>:
{
    a0011ab0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0011ab4:	910003fd 	mov	x29, sp
    a0011ab8:	f9000fe0 	str	x0, [sp, #24]
	bool ret = false;
    a0011abc:	3900bfff 	strb	wzr, [sp, #47]
	ret = false;
    a0011ac0:	3900bfff 	strb	wzr, [sp, #47]
	return ret;
    a0011ac4:	3940bfe0 	ldrb	w0, [sp, #47]
	if (z_syscall_trap()) {
    a0011ac8:	7100001f 	cmp	w0, #0x0
    a0011acc:	540000c0 	b.eq	a0011ae4 <k_thread_start+0x34>  // b.none
		arch_syscall_invoke1(*(uintptr_t *)&thread, K_SYSCALL_K_THREAD_START);
    a0011ad0:	910063e0 	add	x0, sp, #0x18
    a0011ad4:	f9400000 	ldr	x0, [x0]
    a0011ad8:	d2801981 	mov	x1, #0xcc                  	// #204
    a0011adc:	97fffeed 	bl	a0011690 <arch_syscall_invoke1>
		return;
    a0011ae0:	14000003 	b	a0011aec <k_thread_start+0x3c>
	z_impl_k_thread_start(thread);
    a0011ae4:	f9400fe0 	ldr	x0, [sp, #24]
    a0011ae8:	940000f6 	bl	a0011ec0 <z_impl_k_thread_start>
}
    a0011aec:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0011af0:	d65f03c0 	ret

00000000a0011af4 <size_add_overflow>:
{
    a0011af4:	d10083ff 	sub	sp, sp, #0x20
    a0011af8:	f9000fe0 	str	x0, [sp, #24]
    a0011afc:	f9000be1 	str	x1, [sp, #16]
    a0011b00:	f90007e2 	str	x2, [sp, #8]
	return __builtin_add_overflow(a, b, result);
    a0011b04:	d2800002 	mov	x2, #0x0                   	// #0
    a0011b08:	f9400fe0 	ldr	x0, [sp, #24]
    a0011b0c:	f9400be1 	ldr	x1, [sp, #16]
    a0011b10:	ab010000 	adds	x0, x0, x1
    a0011b14:	54000043 	b.cc	a0011b1c <size_add_overflow+0x28>  // b.lo, b.ul, b.last
    a0011b18:	d2800022 	mov	x2, #0x1                   	// #1
    a0011b1c:	aa0003e1 	mov	x1, x0
    a0011b20:	f94007e0 	ldr	x0, [sp, #8]
    a0011b24:	f9000001 	str	x1, [x0]
    a0011b28:	aa0203e0 	mov	x0, x2
    a0011b2c:	12000000 	and	w0, w0, #0x1
    a0011b30:	12001c00 	and	w0, w0, #0xff
}
    a0011b34:	910083ff 	add	sp, sp, #0x20
    a0011b38:	d65f03c0 	ret

00000000a0011b3c <z_init_timeout>:
#endif

#ifdef CONFIG_SYS_CLOCK_EXISTS

static inline void z_init_timeout(struct _timeout *to)
{
    a0011b3c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0011b40:	910003fd 	mov	x29, sp
    a0011b44:	f9000fe0 	str	x0, [sp, #24]
	sys_dnode_init(&to->node);
    a0011b48:	f9400fe0 	ldr	x0, [sp, #24]
    a0011b4c:	97fffebe 	bl	a0011644 <sys_dnode_init>
}
    a0011b50:	d503201f 	nop
    a0011b54:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0011b58:	d65f03c0 	ret

00000000a0011b5c <z_init_thread_timeout>:
{
	return !sys_dnode_is_linked(&to->node);
}

static inline void z_init_thread_timeout(struct _thread_base *thread_base)
{
    a0011b5c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0011b60:	910003fd 	mov	x29, sp
    a0011b64:	f9000fe0 	str	x0, [sp, #24]
	z_init_timeout(&thread_base->timeout);
    a0011b68:	f9400fe0 	ldr	x0, [sp, #24]
    a0011b6c:	9100a000 	add	x0, x0, #0x28
    a0011b70:	97fffff3 	bl	a0011b3c <z_init_timeout>
}
    a0011b74:	d503201f 	nop
    a0011b78:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0011b7c:	d65f03c0 	ret

00000000a0011b80 <z_add_thread_timeout>:

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
    a0011b80:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0011b84:	910003fd 	mov	x29, sp
    a0011b88:	f9000fe0 	str	x0, [sp, #24]
    a0011b8c:	f9000be1 	str	x1, [sp, #16]
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
    a0011b90:	f9400fe0 	ldr	x0, [sp, #24]
    a0011b94:	9100a003 	add	x3, x0, #0x28
    a0011b98:	f9400be2 	ldr	x2, [sp, #16]
    a0011b9c:	d0000020 	adrp	x0, a0017000 <ready_thread+0x70>
    a0011ba0:	91276001 	add	x1, x0, #0x9d8
    a0011ba4:	aa0303e0 	mov	x0, x3
    a0011ba8:	94001f82 	bl	a00199b0 <z_add_timeout>
}
    a0011bac:	d503201f 	nop
    a0011bb0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0011bb4:	d65f03c0 	ret

00000000a0011bb8 <z_is_idle_thread_entry>:
{
    a0011bb8:	d10043ff 	sub	sp, sp, #0x10
    a0011bbc:	f90007e0 	str	x0, [sp, #8]
	return entry_point == idle;
    a0011bc0:	f94007e1 	ldr	x1, [sp, #8]
    a0011bc4:	b0000000 	adrp	x0, a0012000 <setup_thread_stack+0x14>
    a0011bc8:	9134b000 	add	x0, x0, #0xd2c
    a0011bcc:	eb00003f 	cmp	x1, x0
    a0011bd0:	1a9f17e0 	cset	w0, eq  // eq = none
    a0011bd4:	12001c00 	and	w0, w0, #0xff
}
    a0011bd8:	910043ff 	add	sp, sp, #0x10
    a0011bdc:	d65f03c0 	ret

00000000a0011be0 <z_is_prio1_higher_than_or_equal_to_prio2>:
{
    a0011be0:	d10043ff 	sub	sp, sp, #0x10
    a0011be4:	b9000fe0 	str	w0, [sp, #12]
    a0011be8:	b9000be1 	str	w1, [sp, #8]
	return prio1 <= prio2;
    a0011bec:	b9400fe1 	ldr	w1, [sp, #12]
    a0011bf0:	b9400be0 	ldr	w0, [sp, #8]
    a0011bf4:	6b00003f 	cmp	w1, w0
    a0011bf8:	1a9fc7e0 	cset	w0, le
    a0011bfc:	12001c00 	and	w0, w0, #0xff
}
    a0011c00:	910043ff 	add	sp, sp, #0x10
    a0011c04:	d65f03c0 	ret

00000000a0011c08 <z_is_prio_higher_or_equal>:
{
    a0011c08:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0011c0c:	910003fd 	mov	x29, sp
    a0011c10:	b9001fe0 	str	w0, [sp, #28]
    a0011c14:	b9001be1 	str	w1, [sp, #24]
	return z_is_prio1_higher_than_or_equal_to_prio2(prio1, prio2);
    a0011c18:	b9401be1 	ldr	w1, [sp, #24]
    a0011c1c:	b9401fe0 	ldr	w0, [sp, #28]
    a0011c20:	97fffff0 	bl	a0011be0 <z_is_prio1_higher_than_or_equal_to_prio2>
    a0011c24:	12001c00 	and	w0, w0, #0xff
}
    a0011c28:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0011c2c:	d65f03c0 	ret

00000000a0011c30 <z_is_prio1_lower_than_or_equal_to_prio2>:
{
    a0011c30:	d10043ff 	sub	sp, sp, #0x10
    a0011c34:	b9000fe0 	str	w0, [sp, #12]
    a0011c38:	b9000be1 	str	w1, [sp, #8]
	return prio1 >= prio2;
    a0011c3c:	b9400fe1 	ldr	w1, [sp, #12]
    a0011c40:	b9400be0 	ldr	w0, [sp, #8]
    a0011c44:	6b00003f 	cmp	w1, w0
    a0011c48:	1a9fb7e0 	cset	w0, ge  // ge = tcont
    a0011c4c:	12001c00 	and	w0, w0, #0xff
}
    a0011c50:	910043ff 	add	sp, sp, #0x10
    a0011c54:	d65f03c0 	ret

00000000a0011c58 <z_is_prio_lower_or_equal>:
{
    a0011c58:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0011c5c:	910003fd 	mov	x29, sp
    a0011c60:	b9001fe0 	str	w0, [sp, #28]
    a0011c64:	b9001be1 	str	w1, [sp, #24]
	return z_is_prio1_lower_than_or_equal_to_prio2(prio1, prio2);
    a0011c68:	b9401be1 	ldr	w1, [sp, #24]
    a0011c6c:	b9401fe0 	ldr	w0, [sp, #28]
    a0011c70:	97fffff0 	bl	a0011c30 <z_is_prio1_lower_than_or_equal_to_prio2>
    a0011c74:	12001c00 	and	w0, w0, #0xff
}
    a0011c78:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0011c7c:	d65f03c0 	ret

00000000a0011c80 <_is_valid_prio>:
{
    a0011c80:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0011c84:	910003fd 	mov	x29, sp
    a0011c88:	b9001fe0 	str	w0, [sp, #28]
    a0011c8c:	f9000be1 	str	x1, [sp, #16]
	if (prio == K_IDLE_PRIO && z_is_idle_thread_entry(entry_point)) {
    a0011c90:	b9401fe0 	ldr	w0, [sp, #28]
    a0011c94:	71003c1f 	cmp	w0, #0xf
    a0011c98:	54000101 	b.ne	a0011cb8 <_is_valid_prio+0x38>  // b.any
    a0011c9c:	f9400be0 	ldr	x0, [sp, #16]
    a0011ca0:	97ffffc6 	bl	a0011bb8 <z_is_idle_thread_entry>
    a0011ca4:	12001c00 	and	w0, w0, #0xff
    a0011ca8:	7100001f 	cmp	w0, #0x0
    a0011cac:	54000060 	b.eq	a0011cb8 <_is_valid_prio+0x38>  // b.none
		return true;
    a0011cb0:	52800020 	mov	w0, #0x1                   	// #1
    a0011cb4:	14000016 	b	a0011d0c <_is_valid_prio+0x8c>
	if (!z_is_prio_higher_or_equal(prio,
    a0011cb8:	528001c1 	mov	w1, #0xe                   	// #14
    a0011cbc:	b9401fe0 	ldr	w0, [sp, #28]
    a0011cc0:	97ffffd2 	bl	a0011c08 <z_is_prio_higher_or_equal>
    a0011cc4:	12001c00 	and	w0, w0, #0xff
    a0011cc8:	52000000 	eor	w0, w0, #0x1
    a0011ccc:	12001c00 	and	w0, w0, #0xff
    a0011cd0:	7100001f 	cmp	w0, #0x0
    a0011cd4:	54000060 	b.eq	a0011ce0 <_is_valid_prio+0x60>  // b.none
		return false;
    a0011cd8:	52800000 	mov	w0, #0x0                   	// #0
    a0011cdc:	1400000c 	b	a0011d0c <_is_valid_prio+0x8c>
	if (!z_is_prio_lower_or_equal(prio,
    a0011ce0:	128001e1 	mov	w1, #0xfffffff0            	// #-16
    a0011ce4:	b9401fe0 	ldr	w0, [sp, #28]
    a0011ce8:	97ffffdc 	bl	a0011c58 <z_is_prio_lower_or_equal>
    a0011cec:	12001c00 	and	w0, w0, #0xff
    a0011cf0:	52000000 	eor	w0, w0, #0x1
    a0011cf4:	12001c00 	and	w0, w0, #0xff
    a0011cf8:	7100001f 	cmp	w0, #0x0
    a0011cfc:	54000060 	b.eq	a0011d08 <_is_valid_prio+0x88>  // b.none
		return false;
    a0011d00:	52800000 	mov	w0, #0x0                   	// #0
    a0011d04:	14000002 	b	a0011d0c <_is_valid_prio+0x8c>
	return true;
    a0011d08:	52800020 	mov	w0, #0x1                   	// #1
}
    a0011d0c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0011d10:	d65f03c0 	ret

00000000a0011d14 <z_waitq_init>:
#define _WAIT_Q_FOR_EACH(wq, thread_ptr) \
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
    a0011d14:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0011d18:	910003fd 	mov	x29, sp
    a0011d1c:	f9000fe0 	str	x0, [sp, #24]
	sys_dlist_init(&w->waitq);
    a0011d20:	f9400fe0 	ldr	x0, [sp, #24]
    a0011d24:	97fffe3d 	bl	a0011618 <sys_dlist_init>
}
    a0011d28:	d503201f 	nop
    a0011d2c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0011d30:	d65f03c0 	ret

00000000a0011d34 <z_obj_validation_check>:
{
    a0011d34:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    a0011d38:	910003fd 	mov	x29, sp
    a0011d3c:	f90017e0 	str	x0, [sp, #40]
    a0011d40:	f90013e1 	str	x1, [sp, #32]
    a0011d44:	b9001fe2 	str	w2, [sp, #28]
    a0011d48:	b9001be3 	str	w3, [sp, #24]
	ret = z_object_validate(ko, otype, init);
    a0011d4c:	b9401be2 	ldr	w2, [sp, #24]
    a0011d50:	b9401fe1 	ldr	w1, [sp, #28]
    a0011d54:	f94017e0 	ldr	x0, [sp, #40]
    a0011d58:	94002d5b 	bl	a001d2c4 <z_object_validate>
    a0011d5c:	b9003fe0 	str	w0, [sp, #60]
	return ret;
    a0011d60:	b9403fe0 	ldr	w0, [sp, #60]
}
    a0011d64:	a8c47bfd 	ldp	x29, x30, [sp], #64
    a0011d68:	d65f03c0 	ret

00000000a0011d6c <k_is_in_isr>:
	k_spin_unlock(&z_thread_monitor_lock, key);
#endif
}

bool k_is_in_isr(void)
{
    a0011d6c:	d10043ff 	sub	sp, sp, #0x10
MAKE_REG_HELPER(tpidrro_el0);
    a0011d70:	d53bd060 	mrs	x0, tpidrro_el0
    a0011d74:	f90007e0 	str	x0, [sp, #8]
    a0011d78:	f94007e0 	ldr	x0, [sp, #8]
    a0011d7c:	d503201f 	nop
    a0011d80:	927db000 	and	x0, x0, #0xfffffffffff8
extern void z_arm64_offload(void);
#endif

static ALWAYS_INLINE bool arch_is_in_isr(void)
{
	return arch_curr_cpu()->nested != 0U;
    a0011d84:	b9400000 	ldr	w0, [x0]
    a0011d88:	7100001f 	cmp	w0, #0x0
    a0011d8c:	1a9f07e0 	cset	w0, ne  // ne = any
    a0011d90:	12001c00 	and	w0, w0, #0xff
	return arch_is_in_isr();
}
    a0011d94:	910043ff 	add	sp, sp, #0x10
    a0011d98:	d65f03c0 	ret

00000000a0011d9c <z_vrfy_k_thread_name_set>:
#endif /* CONFIG_THREAD_NAME */
}

#ifdef CONFIG_USERSPACE
static inline int z_vrfy_k_thread_name_set(struct k_thread *thread, const char *str)
{
    a0011d9c:	d10043ff 	sub	sp, sp, #0x10
    a0011da0:	f90007e0 	str	x0, [sp, #8]
    a0011da4:	f90003e1 	str	x1, [sp]
		return -EFAULT;
	}

	return z_impl_k_thread_name_set(thread, name);
#else
	return -ENOSYS;
    a0011da8:	12800ae0 	mov	w0, #0xffffffa8            	// #-88
#endif /* CONFIG_THREAD_NAME */
}
    a0011dac:	910043ff 	add	sp, sp, #0x10
    a0011db0:	d65f03c0 	ret

00000000a0011db4 <z_mrsh_k_thread_name_set>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_thread_name_set(k_tid_t thread, const char * str);
uintptr_t z_mrsh_k_thread_name_set(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a0011db4:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a0011db8:	910003fd 	mov	x29, sp
    a0011dbc:	f90027e0 	str	x0, [sp, #72]
    a0011dc0:	f90023e1 	str	x1, [sp, #64]
    a0011dc4:	f9001fe2 	str	x2, [sp, #56]
    a0011dc8:	f9001be3 	str	x3, [sp, #48]
    a0011dcc:	f90017e4 	str	x4, [sp, #40]
    a0011dd0:	f90013e5 	str	x5, [sp, #32]
    a0011dd4:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a0011dd8:	d00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0011ddc:	913f8000 	add	x0, x0, #0xfe0
    a0011de0:	f9400800 	ldr	x0, [x0, #16]
    a0011de4:	f9400fe1 	ldr	x1, [sp, #24]
    a0011de8:	f9008401 	str	x1, [x0, #264]
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_thread_name_set(*(k_tid_t*)&arg0, *(const char **)&arg1)
    a0011dec:	910123e0 	add	x0, sp, #0x48
    a0011df0:	f9400002 	ldr	x2, [x0]
    a0011df4:	910103e0 	add	x0, sp, #0x40
    a0011df8:	f9400000 	ldr	x0, [x0]
    a0011dfc:	aa0003e1 	mov	x1, x0
    a0011e00:	aa0203e0 	mov	x0, x2
    a0011e04:	97ffffe6 	bl	a0011d9c <z_vrfy_k_thread_name_set>
    a0011e08:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a0011e0c:	d00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0011e10:	913f8000 	add	x0, x0, #0xfe0
    a0011e14:	f9400800 	ldr	x0, [x0, #16]
    a0011e18:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a0011e1c:	b9805fe0 	ldrsw	x0, [sp, #92]
}
    a0011e20:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a0011e24:	d65f03c0 	ret

00000000a0011e28 <z_vrfy_k_thread_name_copy>:
}

#ifdef CONFIG_USERSPACE
static inline int z_vrfy_k_thread_name_copy(k_tid_t thread,
					    char *buf, size_t size)
{
    a0011e28:	d10083ff 	sub	sp, sp, #0x20
    a0011e2c:	f9000fe0 	str	x0, [sp, #24]
    a0011e30:	f9000be1 	str	x1, [sp, #16]
    a0011e34:	f90007e2 	str	x2, [sp, #8]
	return z_user_to_copy((void *)buf, thread->name, len + 1);
#else
	ARG_UNUSED(thread);
	ARG_UNUSED(buf);
	ARG_UNUSED(size);
	return -ENOSYS;
    a0011e38:	12800ae0 	mov	w0, #0xffffffa8            	// #-88
#endif /* CONFIG_THREAD_NAME */
}
    a0011e3c:	910083ff 	add	sp, sp, #0x20
    a0011e40:	d65f03c0 	ret

00000000a0011e44 <z_mrsh_k_thread_name_copy>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_thread_name_copy(k_tid_t thread, char * buf, size_t size);
uintptr_t z_mrsh_k_thread_name_copy(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a0011e44:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a0011e48:	910003fd 	mov	x29, sp
    a0011e4c:	f90027e0 	str	x0, [sp, #72]
    a0011e50:	f90023e1 	str	x1, [sp, #64]
    a0011e54:	f9001fe2 	str	x2, [sp, #56]
    a0011e58:	f9001be3 	str	x3, [sp, #48]
    a0011e5c:	f90017e4 	str	x4, [sp, #40]
    a0011e60:	f90013e5 	str	x5, [sp, #32]
    a0011e64:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a0011e68:	d00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0011e6c:	913f8000 	add	x0, x0, #0xfe0
    a0011e70:	f9400800 	ldr	x0, [x0, #16]
    a0011e74:	f9400fe1 	ldr	x1, [sp, #24]
    a0011e78:	f9008401 	str	x1, [x0, #264]
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_thread_name_copy(*(k_tid_t*)&arg0, *(char **)&arg1, *(size_t*)&arg2)
    a0011e7c:	910123e0 	add	x0, sp, #0x48
    a0011e80:	f9400003 	ldr	x3, [x0]
    a0011e84:	910103e0 	add	x0, sp, #0x40
    a0011e88:	f9400001 	ldr	x1, [x0]
    a0011e8c:	9100e3e0 	add	x0, sp, #0x38
    a0011e90:	f9400000 	ldr	x0, [x0]
    a0011e94:	aa0003e2 	mov	x2, x0
    a0011e98:	aa0303e0 	mov	x0, x3
    a0011e9c:	97ffffe3 	bl	a0011e28 <z_vrfy_k_thread_name_copy>
    a0011ea0:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a0011ea4:	d00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0011ea8:	913f8000 	add	x0, x0, #0xfe0
    a0011eac:	f9400800 	ldr	x0, [x0, #16]
    a0011eb0:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a0011eb4:	b9805fe0 	ldrsw	x0, [sp, #92]
}
    a0011eb8:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a0011ebc:	d65f03c0 	ret

00000000a0011ec0 <z_impl_k_thread_start>:
	}
}
#endif /* CONFIG_STACK_SENTINEL */

void z_impl_k_thread_start(struct k_thread *thread)
{
    a0011ec0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0011ec4:	910003fd 	mov	x29, sp
    a0011ec8:	f9000fe0 	str	x0, [sp, #24]
	SYS_PORT_TRACING_OBJ_FUNC(k_thread, start, thread);

	z_sched_start(thread);
    a0011ecc:	f9400fe0 	ldr	x0, [sp, #24]
    a0011ed0:	940014bb 	bl	a00171bc <z_sched_start>
}
    a0011ed4:	d503201f 	nop
    a0011ed8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0011edc:	d65f03c0 	ret

00000000a0011ee0 <z_vrfy_k_thread_start>:

#ifdef CONFIG_USERSPACE
static inline void z_vrfy_k_thread_start(struct k_thread *thread)
{
    a0011ee0:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a0011ee4:	910003fd 	mov	x29, sp
    a0011ee8:	f9000fe0 	str	x0, [sp, #24]
	Z_OOPS(Z_SYSCALL_OBJ(thread, K_OBJ_THREAD));
    a0011eec:	f9400fe0 	ldr	x0, [sp, #24]
    a0011ef0:	94002ace 	bl	a001ca28 <z_object_find>
    a0011ef4:	52800003 	mov	w3, #0x0                   	// #0
    a0011ef8:	52800122 	mov	w2, #0x9                   	// #9
    a0011efc:	f9400fe1 	ldr	x1, [sp, #24]
    a0011f00:	97ffff8d 	bl	a0011d34 <z_obj_validation_check>
    a0011f04:	7100001f 	cmp	w0, #0x0
    a0011f08:	1a9f07e0 	cset	w0, ne  // ne = any
    a0011f0c:	39063fe0 	strb	w0, [sp, #399]
    a0011f10:	39463fe0 	ldrb	w0, [sp, #399]
    a0011f14:	7100001f 	cmp	w0, #0x0
    a0011f18:	39463fe0 	ldrb	w0, [sp, #399]
    a0011f1c:	7100001f 	cmp	w0, #0x0
    a0011f20:	540000c0 	b.eq	a0011f38 <z_vrfy_k_thread_start+0x58>  // b.none
    a0011f24:	d00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0011f28:	913f8000 	add	x0, x0, #0xfe0
    a0011f2c:	f9400800 	ldr	x0, [x0, #16]
    a0011f30:	f9408400 	ldr	x0, [x0, #264]
    a0011f34:	97ffdc89 	bl	a0009158 <arch_syscall_oops>
	return z_impl_k_thread_start(thread);
    a0011f38:	f9400fe0 	ldr	x0, [sp, #24]
    a0011f3c:	97ffffe1 	bl	a0011ec0 <z_impl_k_thread_start>
}
    a0011f40:	a8d97bfd 	ldp	x29, x30, [sp], #400
    a0011f44:	d65f03c0 	ret

00000000a0011f48 <z_mrsh_k_thread_start>:
#include <syscalls/kernel.h>

extern void z_vrfy_k_thread_start(k_tid_t thread);
uintptr_t z_mrsh_k_thread_start(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a0011f48:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a0011f4c:	910003fd 	mov	x29, sp
    a0011f50:	f90027e0 	str	x0, [sp, #72]
    a0011f54:	f90023e1 	str	x1, [sp, #64]
    a0011f58:	f9001fe2 	str	x2, [sp, #56]
    a0011f5c:	f9001be3 	str	x3, [sp, #48]
    a0011f60:	f90017e4 	str	x4, [sp, #40]
    a0011f64:	f90013e5 	str	x5, [sp, #32]
    a0011f68:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a0011f6c:	d00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0011f70:	913f8000 	add	x0, x0, #0xfe0
    a0011f74:	f9400800 	ldr	x0, [x0, #16]
    a0011f78:	f9400fe1 	ldr	x1, [sp, #24]
    a0011f7c:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_thread_start(*(k_tid_t*)&arg0)
    a0011f80:	910123e0 	add	x0, sp, #0x48
    a0011f84:	f9400000 	ldr	x0, [x0]
    a0011f88:	97ffffd6 	bl	a0011ee0 <z_vrfy_k_thread_start>
;
	_current->syscall_frame = NULL;
    a0011f8c:	d00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0011f90:	913f8000 	add	x0, x0, #0xfe0
    a0011f94:	f9400800 	ldr	x0, [x0, #16]
    a0011f98:	f900841f 	str	xzr, [x0, #264]
	return 0;
    a0011f9c:	d2800000 	mov	x0, #0x0                   	// #0
}
    a0011fa0:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a0011fa4:	d65f03c0 	ret

00000000a0011fa8 <schedule_new_thread>:
#endif
#endif

#ifdef CONFIG_MULTITHREADING
static void schedule_new_thread(struct k_thread *thread, k_timeout_t delay)
{
    a0011fa8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0011fac:	910003fd 	mov	x29, sp
    a0011fb0:	f9000fe0 	str	x0, [sp, #24]
    a0011fb4:	f9000be1 	str	x1, [sp, #16]
#ifdef CONFIG_SYS_CLOCK_EXISTS
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
    a0011fb8:	f9400be0 	ldr	x0, [sp, #16]
    a0011fbc:	d2800001 	mov	x1, #0x0                   	// #0
    a0011fc0:	eb01001f 	cmp	x0, x1
    a0011fc4:	54000081 	b.ne	a0011fd4 <schedule_new_thread+0x2c>  // b.any
		k_thread_start(thread);
    a0011fc8:	f9400fe0 	ldr	x0, [sp, #24]
    a0011fcc:	97fffeb9 	bl	a0011ab0 <k_thread_start>
	}
#else
	ARG_UNUSED(delay);
	k_thread_start(thread);
#endif
}
    a0011fd0:	14000004 	b	a0011fe0 <schedule_new_thread+0x38>
		z_add_thread_timeout(thread, delay);
    a0011fd4:	f9400be1 	ldr	x1, [sp, #16]
    a0011fd8:	f9400fe0 	ldr	x0, [sp, #24]
    a0011fdc:	97fffee9 	bl	a0011b80 <z_add_thread_timeout>
}
    a0011fe0:	d503201f 	nop
    a0011fe4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0011fe8:	d65f03c0 	ret

00000000a0011fec <setup_thread_stack>:
#endif /* CONFIG_STACK_GROWS_UP */
#endif /* CONFIG_STACK_POINTER_RANDOM */

static char *setup_thread_stack(struct k_thread *new_thread,
				k_thread_stack_t *stack, size_t stack_size)
{
    a0011fec:	d10983ff 	sub	sp, sp, #0x260
    a0011ff0:	a9007bfd 	stp	x29, x30, [sp]
    a0011ff4:	910003fd 	mov	x29, sp
    a0011ff8:	f90017e0 	str	x0, [sp, #40]
    a0011ffc:	f90013e1 	str	x1, [sp, #32]
    a0012000:	f9000fe2 	str	x2, [sp, #24]
	size_t stack_obj_size, stack_buf_size;
	char *stack_ptr, *stack_buf_start;
	size_t delta = 0;
    a0012004:	f9012bff 	str	xzr, [sp, #592]

#ifdef CONFIG_USERSPACE
	if (z_stack_is_user_capable(stack)) {
    a0012008:	f94013e0 	ldr	x0, [sp, #32]
    a001200c:	94000084 	bl	a001221c <z_stack_is_user_capable>
    a0012010:	12001c00 	and	w0, w0, #0xff
    a0012014:	7100001f 	cmp	w0, #0x0
    a0012018:	540001a0 	b.eq	a001204c <setup_thread_stack+0x60>  // b.none
		stack_obj_size = Z_THREAD_STACK_SIZE_ADJUST(stack_size);
    a001201c:	f9400fe0 	ldr	x0, [sp, #24]
    a0012020:	913ffc00 	add	x0, x0, #0xfff
    a0012024:	9274cc00 	and	x0, x0, #0xfffffffffffff000
    a0012028:	91400400 	add	x0, x0, #0x1, lsl #12
    a001202c:	f9011fe0 	str	x0, [sp, #568]
		stack_buf_start = Z_THREAD_STACK_BUFFER(stack);
    a0012030:	f94013e0 	ldr	x0, [sp, #32]
    a0012034:	97fffe72 	bl	a00119fc <Z_THREAD_STACK_BUFFER>
    a0012038:	f9011be0 	str	x0, [sp, #560]
		stack_buf_size = stack_obj_size - K_THREAD_STACK_RESERVED;
    a001203c:	f9411fe0 	ldr	x0, [sp, #568]
    a0012040:	d1400400 	sub	x0, x0, #0x1, lsl #12
    a0012044:	f90123e0 	str	x0, [sp, #576]
    a0012048:	1400000a 	b	a0012070 <setup_thread_stack+0x84>
	} else
#endif
	{
		/* Object cannot host a user mode thread */
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
    a001204c:	f9400fe0 	ldr	x0, [sp, #24]
    a0012050:	91003c00 	add	x0, x0, #0xf
    a0012054:	927cec00 	and	x0, x0, #0xfffffffffffffff0
    a0012058:	f9011fe0 	str	x0, [sp, #568]
		stack_buf_start = Z_KERNEL_STACK_BUFFER(stack);
    a001205c:	f94013e0 	ldr	x0, [sp, #32]
    a0012060:	97fffe62 	bl	a00119e8 <Z_KERNEL_STACK_BUFFER>
    a0012064:	f9011be0 	str	x0, [sp, #560]
		stack_buf_size = stack_obj_size - K_KERNEL_STACK_RESERVED;
    a0012068:	f9411fe0 	ldr	x0, [sp, #568]
    a001206c:	f90123e0 	str	x0, [sp, #576]
	}

	/* Initial stack pointer at the high end of the stack object, may
	 * be reduced later in this function by TLS or random offset
	 */
	stack_ptr = (char *)stack + stack_obj_size;
    a0012070:	f94013e1 	ldr	x1, [sp, #32]
    a0012074:	f9411fe0 	ldr	x0, [sp, #568]
    a0012078:	8b000020 	add	x0, x1, x0
    a001207c:	f9012fe0 	str	x0, [sp, #600]
		" buf_size %zu stack_ptr=%p",
		stack, new_thread, stack_obj_size, stack_buf_start,
		stack_buf_size, stack_ptr);

#ifdef CONFIG_INIT_STACKS
	memset(stack_buf_start, 0xaa, stack_buf_size);
    a0012080:	f94123e2 	ldr	x2, [sp, #576]
    a0012084:	52801541 	mov	w1, #0xaa                  	// #170
    a0012088:	f9411be0 	ldr	x0, [sp, #560]
    a001208c:	97ffe79d 	bl	a000bf00 <memset>
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	/* TLS is always last within the stack buffer */
	delta += arch_tls_stack_setup(new_thread, stack_ptr);
#endif /* CONFIG_THREAD_LOCAL_STORAGE */
#ifdef CONFIG_THREAD_USERSPACE_LOCAL_DATA
	size_t tls_size = sizeof(struct _thread_userspace_local_data);
    a0012090:	d2800080 	mov	x0, #0x4                   	// #4
    a0012094:	f90127e0 	str	x0, [sp, #584]

	/* reserve space on highest memory of stack buffer for local data */
	delta += tls_size;
    a0012098:	f9412be1 	ldr	x1, [sp, #592]
    a001209c:	f94127e0 	ldr	x0, [sp, #584]
    a00120a0:	8b000020 	add	x0, x1, x0
    a00120a4:	f9012be0 	str	x0, [sp, #592]
	new_thread->userspace_local_data =
		(struct _thread_userspace_local_data *)(stack_ptr - delta);
    a00120a8:	f9412be0 	ldr	x0, [sp, #592]
    a00120ac:	cb0003e0 	neg	x0, x0
    a00120b0:	f9412fe1 	ldr	x1, [sp, #600]
    a00120b4:	8b000021 	add	x1, x1, x0
	new_thread->userspace_local_data =
    a00120b8:	f94017e0 	ldr	x0, [sp, #40]
    a00120bc:	f9006401 	str	x1, [x0, #200]
#endif
#if CONFIG_STACK_POINTER_RANDOM
	delta += random_offset(stack_buf_size);
#endif
	delta = ROUND_UP(delta, ARCH_STACK_PTR_ALIGN);
    a00120c0:	f9412be0 	ldr	x0, [sp, #592]
    a00120c4:	91003c00 	add	x0, x0, #0xf
    a00120c8:	927cec00 	and	x0, x0, #0xfffffffffffffff0
    a00120cc:	f9012be0 	str	x0, [sp, #592]
	 * will need to appropriately update this.
	 *
	 * The bounds tracked here correspond to the area of the stack object
	 * that the thread can access, which includes TLS.
	 */
	new_thread->stack_info.start = (uintptr_t)stack_buf_start;
    a00120d0:	f9411be1 	ldr	x1, [sp, #560]
    a00120d4:	f94017e0 	ldr	x0, [sp, #40]
    a00120d8:	f9006801 	str	x1, [x0, #208]
	new_thread->stack_info.size = stack_buf_size;
    a00120dc:	f94017e0 	ldr	x0, [sp, #40]
    a00120e0:	f94123e1 	ldr	x1, [sp, #576]
    a00120e4:	f9006c01 	str	x1, [x0, #216]
	new_thread->stack_info.delta = delta;
    a00120e8:	f94017e0 	ldr	x0, [sp, #40]
    a00120ec:	f9412be1 	ldr	x1, [sp, #592]
    a00120f0:	f9007001 	str	x1, [x0, #224]
#endif
	stack_ptr -= delta;
    a00120f4:	f9412be0 	ldr	x0, [sp, #592]
    a00120f8:	cb0003e0 	neg	x0, x0
    a00120fc:	f9412fe1 	ldr	x1, [sp, #600]
    a0012100:	8b000020 	add	x0, x1, x0
    a0012104:	f9012fe0 	str	x0, [sp, #600]

	return stack_ptr;
    a0012108:	f9412fe0 	ldr	x0, [sp, #600]
}
    a001210c:	a9407bfd 	ldp	x29, x30, [sp]
    a0012110:	910983ff 	add	sp, sp, #0x260
    a0012114:	d65f03c0 	ret

00000000a0012118 <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
    a0012118:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a001211c:	910003fd 	mov	x29, sp
    a0012120:	f90027e0 	str	x0, [sp, #72]
    a0012124:	f90023e1 	str	x1, [sp, #64]
    a0012128:	f9001fe2 	str	x2, [sp, #56]
    a001212c:	f9001be3 	str	x3, [sp, #48]
    a0012130:	f90017e4 	str	x4, [sp, #40]
    a0012134:	f90013e5 	str	x5, [sp, #32]
    a0012138:	f9000fe6 	str	x6, [sp, #24]
    a001213c:	b90017e7 	str	w7, [sp, #20]

#ifdef CONFIG_USERSPACE
	__ASSERT((options & K_USER) == 0U || z_stack_is_user_capable(stack),
		 "user thread %p with kernel-only stack %p",
		 new_thread, stack);
	z_object_init(new_thread);
    a0012140:	f94027e0 	ldr	x0, [sp, #72]
    a0012144:	94002cb3 	bl	a001d410 <z_object_init>
	z_object_init(stack);
    a0012148:	f94023e0 	ldr	x0, [sp, #64]
    a001214c:	94002cb1 	bl	a001d410 <z_object_init>
	new_thread->stack_obj = stack;
    a0012150:	f94027e0 	ldr	x0, [sp, #72]
    a0012154:	f94023e1 	ldr	x1, [sp, #64]
    a0012158:	f9008001 	str	x1, [x0, #256]
	new_thread->syscall_frame = NULL;
    a001215c:	f94027e0 	ldr	x0, [sp, #72]
    a0012160:	f900841f 	str	xzr, [x0, #264]

	/* Any given thread has access to itself */
	k_object_access_grant(new_thread, new_thread);
    a0012164:	f94027e1 	ldr	x1, [sp, #72]
    a0012168:	f94027e0 	ldr	x0, [sp, #72]
    a001216c:	97fffe2a 	bl	a0011a14 <k_object_access_grant>
#endif
	z_waitq_init(&new_thread->join_queue);
    a0012170:	f94027e0 	ldr	x0, [sp, #72]
    a0012174:	9102e000 	add	x0, x0, #0xb8
    a0012178:	97fffee7 	bl	a0011d14 <z_waitq_init>

	/* Initialize various struct k_thread members */
	z_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);
    a001217c:	f94027e0 	ldr	x0, [sp, #72]
    a0012180:	b94063e3 	ldr	w3, [sp, #96]
    a0012184:	52800082 	mov	w2, #0x4                   	// #4
    a0012188:	b94017e1 	ldr	w1, [sp, #20]
    a001218c:	940001b6 	bl	a0012864 <z_init_thread_base>
	stack_ptr = setup_thread_stack(new_thread, stack, stack_size);
    a0012190:	f9401fe2 	ldr	x2, [sp, #56]
    a0012194:	f94023e1 	ldr	x1, [sp, #64]
    a0012198:	f94027e0 	ldr	x0, [sp, #72]
    a001219c:	97ffff94 	bl	a0011fec <setup_thread_stack>
    a00121a0:	f9002fe0 	str	x0, [sp, #88]
	 */
	__ASSERT_NO_MSG(arch_mem_coherent(new_thread));
	__ASSERT_NO_MSG(!arch_mem_coherent(stack));
#endif

	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    a00121a4:	f9400fe6 	ldr	x6, [sp, #24]
    a00121a8:	f94013e5 	ldr	x5, [sp, #32]
    a00121ac:	f94017e4 	ldr	x4, [sp, #40]
    a00121b0:	f9401be3 	ldr	x3, [sp, #48]
    a00121b4:	f9402fe2 	ldr	x2, [sp, #88]
    a00121b8:	f94023e1 	ldr	x1, [sp, #64]
    a00121bc:	f94027e0 	ldr	x0, [sp, #72]
    a00121c0:	97ffdd99 	bl	a0009824 <arch_new_thread>

	/* static threads overwrite it afterwards with real value */
	new_thread->init_data = NULL;
    a00121c4:	f94027e0 	ldr	x0, [sp, #72]
    a00121c8:	f900581f 	str	xzr, [x0, #176]
		new_thread->resource_pool = NULL;
		return stack_ptr;
	}
#endif
#ifdef CONFIG_USERSPACE
	z_mem_domain_init_thread(new_thread);
    a00121cc:	f94027e0 	ldr	x0, [sp, #72]
    a00121d0:	9400278a 	bl	a001bff8 <z_mem_domain_init_thread>

	if ((options & K_INHERIT_PERMS) != 0U) {
    a00121d4:	b94063e0 	ldr	w0, [sp, #96]
    a00121d8:	927d0000 	and	x0, x0, #0x8
    a00121dc:	f100001f 	cmp	x0, #0x0
    a00121e0:	540000c0 	b.eq	a00121f8 <z_setup_new_thread+0xe0>  // b.none
		z_thread_perms_inherit(_current, new_thread);
    a00121e4:	b00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00121e8:	913f8000 	add	x0, x0, #0xfe0
    a00121ec:	f9400800 	ldr	x0, [x0, #16]
    a00121f0:	f94027e1 	ldr	x1, [sp, #72]
    a00121f4:	94002b62 	bl	a001cf7c <z_thread_perms_inherit>
	}
#endif
#ifdef CONFIG_SCHED_DEADLINE
	new_thread->base.prio_deadline = 0;
#endif
	new_thread->resource_pool = _current->resource_pool;
    a00121f8:	b00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00121fc:	913f8000 	add	x0, x0, #0xfe0
    a0012200:	f9400800 	ldr	x0, [x0, #16]
    a0012204:	f9409001 	ldr	x1, [x0, #288]
    a0012208:	f94027e0 	ldr	x0, [sp, #72]
    a001220c:	f9009001 	str	x1, [x0, #288]
		CONFIG_SCHED_THREAD_USAGE_AUTO_ENABLE;
#endif

	SYS_PORT_TRACING_OBJ_FUNC(k_thread, create, new_thread);

	return stack_ptr;
    a0012210:	f9402fe0 	ldr	x0, [sp, #88]
}
    a0012214:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a0012218:	d65f03c0 	ret

00000000a001221c <z_stack_is_user_capable>:
}


#ifdef CONFIG_USERSPACE
bool z_stack_is_user_capable(k_thread_stack_t *stack)
{
    a001221c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0012220:	910003fd 	mov	x29, sp
    a0012224:	f9000fe0 	str	x0, [sp, #24]
	return z_object_find(stack) != NULL;
    a0012228:	f9400fe0 	ldr	x0, [sp, #24]
    a001222c:	940029ff 	bl	a001ca28 <z_object_find>
    a0012230:	f100001f 	cmp	x0, #0x0
    a0012234:	1a9f07e0 	cset	w0, ne  // ne = any
    a0012238:	12001c00 	and	w0, w0, #0xff
}
    a001223c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0012240:	d65f03c0 	ret

00000000a0012244 <z_vrfy_k_thread_create>:
k_tid_t z_vrfy_k_thread_create(struct k_thread *new_thread,
			       k_thread_stack_t *stack,
			       size_t stack_size, k_thread_entry_t entry,
			       void *p1, void *p2, void *p3,
			       int prio, uint32_t options, k_timeout_t delay)
{
    a0012244:	d11443ff 	sub	sp, sp, #0x510
    a0012248:	a9017bfd 	stp	x29, x30, [sp, #16]
    a001224c:	910043fd 	add	x29, sp, #0x10
    a0012250:	f9002fe0 	str	x0, [sp, #88]
    a0012254:	f9002be1 	str	x1, [sp, #80]
    a0012258:	f90027e2 	str	x2, [sp, #72]
    a001225c:	f90023e3 	str	x3, [sp, #64]
    a0012260:	f9001fe4 	str	x4, [sp, #56]
    a0012264:	f9001be5 	str	x5, [sp, #48]
    a0012268:	f90017e6 	str	x6, [sp, #40]
    a001226c:	b90027e7 	str	w7, [sp, #36]
	size_t total_size, stack_obj_size;
	struct z_object *stack_object;

	/* The thread and stack objects *must* be in an uninitialized state */
	Z_OOPS(Z_SYSCALL_OBJ_NEVER_INIT(new_thread, K_OBJ_THREAD));
    a0012270:	f9402fe0 	ldr	x0, [sp, #88]
    a0012274:	940029ed 	bl	a001ca28 <z_object_find>
    a0012278:	12800003 	mov	w3, #0xffffffff            	// #-1
    a001227c:	52800122 	mov	w2, #0x9                   	// #9
    a0012280:	f9402fe1 	ldr	x1, [sp, #88]
    a0012284:	97fffeac 	bl	a0011d34 <z_obj_validation_check>
    a0012288:	7100001f 	cmp	w0, #0x0
    a001228c:	1a9f07e0 	cset	w0, ne  // ne = any
    a0012290:	3913bfe0 	strb	w0, [sp, #1263]
    a0012294:	3953bfe0 	ldrb	w0, [sp, #1263]
    a0012298:	7100001f 	cmp	w0, #0x0
    a001229c:	3953bfe0 	ldrb	w0, [sp, #1263]
    a00122a0:	7100001f 	cmp	w0, #0x0
    a00122a4:	540000c0 	b.eq	a00122bc <z_vrfy_k_thread_create+0x78>  // b.none
    a00122a8:	b00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00122ac:	913f8000 	add	x0, x0, #0xfe0
    a00122b0:	f9400800 	ldr	x0, [x0, #16]
    a00122b4:	f9408400 	ldr	x0, [x0, #264]
    a00122b8:	97ffdba8 	bl	a0009158 <arch_syscall_oops>

	/* No need to check z_stack_is_user_capable(), it won't be in the
	 * object table if it isn't
	 */
	stack_object = z_object_find(stack);
    a00122bc:	f9402be0 	ldr	x0, [sp, #80]
    a00122c0:	940029da 	bl	a001ca28 <z_object_find>
    a00122c4:	f9027be0 	str	x0, [sp, #1264]
	Z_OOPS(Z_SYSCALL_VERIFY_MSG(z_obj_validation_check(stack_object, stack,
    a00122c8:	12800003 	mov	w3, #0xffffffff            	// #-1
    a00122cc:	52800162 	mov	w2, #0xb                   	// #11
    a00122d0:	f9402be1 	ldr	x1, [sp, #80]
    a00122d4:	f9427be0 	ldr	x0, [sp, #1264]
    a00122d8:	97fffe97 	bl	a0011d34 <z_obj_validation_check>
    a00122dc:	7100001f 	cmp	w0, #0x0
    a00122e0:	1a9f07e0 	cset	w0, ne  // ne = any
    a00122e4:	3913ffe0 	strb	w0, [sp, #1279]
    a00122e8:	3953ffe0 	ldrb	w0, [sp, #1279]
    a00122ec:	7100001f 	cmp	w0, #0x0
    a00122f0:	3953ffe0 	ldrb	w0, [sp, #1279]
    a00122f4:	7100001f 	cmp	w0, #0x0
    a00122f8:	540000c0 	b.eq	a0012310 <z_vrfy_k_thread_create+0xcc>  // b.none
    a00122fc:	b00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0012300:	913f8000 	add	x0, x0, #0xfe0
    a0012304:	f9400800 	ldr	x0, [x0, #16]
    a0012308:	f9408400 	ldr	x0, [x0, #264]
    a001230c:	97ffdb93 	bl	a0009158 <arch_syscall_oops>
				    "bad stack object"));

	/* Verify that the stack size passed in is OK by computing the total
	 * size and comparing it with the size value in the object metadata
	 */
	Z_OOPS(Z_SYSCALL_VERIFY_MSG(!size_add_overflow(K_THREAD_STACK_RESERVED,
    a0012310:	911383e0 	add	x0, sp, #0x4e0
    a0012314:	aa0003e2 	mov	x2, x0
    a0012318:	f94027e1 	ldr	x1, [sp, #72]
    a001231c:	d2820000 	mov	x0, #0x1000                	// #4096
    a0012320:	97fffdf5 	bl	a0011af4 <size_add_overflow>
    a0012324:	12001c00 	and	w0, w0, #0xff
    a0012328:	39142be0 	strb	w0, [sp, #1290]
    a001232c:	39542be0 	ldrb	w0, [sp, #1290]
    a0012330:	7100001f 	cmp	w0, #0x0
    a0012334:	39542be0 	ldrb	w0, [sp, #1290]
    a0012338:	7100001f 	cmp	w0, #0x0
    a001233c:	540000c0 	b.eq	a0012354 <z_vrfy_k_thread_create+0x110>  // b.none
    a0012340:	b00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0012344:	913f8000 	add	x0, x0, #0xfe0
    a0012348:	f9400800 	ldr	x0, [x0, #16]
    a001234c:	f9408400 	ldr	x0, [x0, #264]
    a0012350:	97ffdb82 	bl	a0009158 <arch_syscall_oops>
	 * allocated for alignment constraints
	 */
#ifdef CONFIG_GEN_PRIV_STACKS
	stack_obj_size = stack_object->data.stack_data->size;
#else
	stack_obj_size = stack_object->data.stack_size;
    a0012354:	f9427be0 	ldr	x0, [sp, #1264]
    a0012358:	f840c000 	ldur	x0, [x0, #12]
    a001235c:	f90283e0 	str	x0, [sp, #1280]
#endif
	Z_OOPS(Z_SYSCALL_VERIFY_MSG(total_size <= stack_obj_size,
    a0012360:	f94273e0 	ldr	x0, [sp, #1248]
    a0012364:	f94283e1 	ldr	x1, [sp, #1280]
    a0012368:	eb00003f 	cmp	x1, x0
    a001236c:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
    a0012370:	39142fe0 	strb	w0, [sp, #1291]
    a0012374:	39542fe0 	ldrb	w0, [sp, #1291]
    a0012378:	7100001f 	cmp	w0, #0x0
    a001237c:	39542fe0 	ldrb	w0, [sp, #1291]
    a0012380:	7100001f 	cmp	w0, #0x0
    a0012384:	540000c0 	b.eq	a001239c <z_vrfy_k_thread_create+0x158>  // b.none
    a0012388:	b00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001238c:	913f8000 	add	x0, x0, #0xfe0
    a0012390:	f9400800 	ldr	x0, [x0, #16]
    a0012394:	f9408400 	ldr	x0, [x0, #264]
    a0012398:	97ffdb70 	bl	a0009158 <arch_syscall_oops>
				    total_size, stack_obj_size));

	/* User threads may only create other user threads and they can't
	 * be marked as essential
	 */
	Z_OOPS(Z_SYSCALL_VERIFY(options & K_USER));
    a001239c:	b94513e0 	ldr	w0, [sp, #1296]
    a00123a0:	927e0000 	and	x0, x0, #0x4
    a00123a4:	f100001f 	cmp	x0, #0x0
    a00123a8:	1a9f17e0 	cset	w0, eq  // eq = none
    a00123ac:	391433e0 	strb	w0, [sp, #1292]
    a00123b0:	395433e0 	ldrb	w0, [sp, #1292]
    a00123b4:	7100001f 	cmp	w0, #0x0
    a00123b8:	395433e0 	ldrb	w0, [sp, #1292]
    a00123bc:	7100001f 	cmp	w0, #0x0
    a00123c0:	540000c0 	b.eq	a00123d8 <z_vrfy_k_thread_create+0x194>  // b.none
    a00123c4:	b00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00123c8:	913f8000 	add	x0, x0, #0xfe0
    a00123cc:	f9400800 	ldr	x0, [x0, #16]
    a00123d0:	f9408400 	ldr	x0, [x0, #264]
    a00123d4:	97ffdb61 	bl	a0009158 <arch_syscall_oops>
	Z_OOPS(Z_SYSCALL_VERIFY(!(options & K_ESSENTIAL)));
    a00123d8:	b94513e0 	ldr	w0, [sp, #1296]
    a00123dc:	92400000 	and	x0, x0, #0x1
    a00123e0:	f100001f 	cmp	x0, #0x0
    a00123e4:	1a9f07e0 	cset	w0, ne  // ne = any
    a00123e8:	391437e0 	strb	w0, [sp, #1293]
    a00123ec:	395437e0 	ldrb	w0, [sp, #1293]
    a00123f0:	7100001f 	cmp	w0, #0x0
    a00123f4:	395437e0 	ldrb	w0, [sp, #1293]
    a00123f8:	7100001f 	cmp	w0, #0x0
    a00123fc:	540000c0 	b.eq	a0012414 <z_vrfy_k_thread_create+0x1d0>  // b.none
    a0012400:	b00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0012404:	913f8000 	add	x0, x0, #0xfe0
    a0012408:	f9400800 	ldr	x0, [x0, #16]
    a001240c:	f9408400 	ldr	x0, [x0, #264]
    a0012410:	97ffdb52 	bl	a0009158 <arch_syscall_oops>

	/* Check validity of prio argument; must be the same or worse priority
	 * than the caller
	 */
	Z_OOPS(Z_SYSCALL_VERIFY(_is_valid_prio(prio, NULL)));
    a0012414:	d2800001 	mov	x1, #0x0                   	// #0
    a0012418:	b94027e0 	ldr	w0, [sp, #36]
    a001241c:	97fffe19 	bl	a0011c80 <_is_valid_prio>
    a0012420:	12001c00 	and	w0, w0, #0xff
    a0012424:	7100001f 	cmp	w0, #0x0
    a0012428:	1a9f07e0 	cset	w0, ne  // ne = any
    a001242c:	12001c00 	and	w0, w0, #0xff
    a0012430:	52000000 	eor	w0, w0, #0x1
    a0012434:	12001c00 	and	w0, w0, #0xff
    a0012438:	39143be0 	strb	w0, [sp, #1294]
    a001243c:	39543be0 	ldrb	w0, [sp, #1294]
    a0012440:	12000000 	and	w0, w0, #0x1
    a0012444:	39143be0 	strb	w0, [sp, #1294]
    a0012448:	39543be0 	ldrb	w0, [sp, #1294]
    a001244c:	7100001f 	cmp	w0, #0x0
    a0012450:	39543be0 	ldrb	w0, [sp, #1294]
    a0012454:	7100001f 	cmp	w0, #0x0
    a0012458:	540000c0 	b.eq	a0012470 <z_vrfy_k_thread_create+0x22c>  // b.none
    a001245c:	b00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0012460:	913f8000 	add	x0, x0, #0xfe0
    a0012464:	f9400800 	ldr	x0, [x0, #16]
    a0012468:	f9408400 	ldr	x0, [x0, #264]
    a001246c:	97ffdb3b 	bl	a0009158 <arch_syscall_oops>
	Z_OOPS(Z_SYSCALL_VERIFY(z_is_prio_lower_or_equal(prio,
    a0012470:	b00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0012474:	913f8000 	add	x0, x0, #0xfe0
    a0012478:	f9400800 	ldr	x0, [x0, #16]
    a001247c:	39c06800 	ldrsb	w0, [x0, #26]
    a0012480:	2a0003e1 	mov	w1, w0
    a0012484:	b94027e0 	ldr	w0, [sp, #36]
    a0012488:	97fffdf4 	bl	a0011c58 <z_is_prio_lower_or_equal>
    a001248c:	12001c00 	and	w0, w0, #0xff
    a0012490:	7100001f 	cmp	w0, #0x0
    a0012494:	1a9f07e0 	cset	w0, ne  // ne = any
    a0012498:	12001c00 	and	w0, w0, #0xff
    a001249c:	52000000 	eor	w0, w0, #0x1
    a00124a0:	12001c00 	and	w0, w0, #0xff
    a00124a4:	39143fe0 	strb	w0, [sp, #1295]
    a00124a8:	39543fe0 	ldrb	w0, [sp, #1295]
    a00124ac:	12000000 	and	w0, w0, #0x1
    a00124b0:	39143fe0 	strb	w0, [sp, #1295]
    a00124b4:	39543fe0 	ldrb	w0, [sp, #1295]
    a00124b8:	7100001f 	cmp	w0, #0x0
    a00124bc:	39543fe0 	ldrb	w0, [sp, #1295]
    a00124c0:	7100001f 	cmp	w0, #0x0
    a00124c4:	540000c0 	b.eq	a00124dc <z_vrfy_k_thread_create+0x298>  // b.none
    a00124c8:	b00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00124cc:	913f8000 	add	x0, x0, #0xfe0
    a00124d0:	f9400800 	ldr	x0, [x0, #16]
    a00124d4:	f9408400 	ldr	x0, [x0, #264]
    a00124d8:	97ffdb20 	bl	a0009158 <arch_syscall_oops>
							_current->base.prio)));

	z_setup_new_thread(new_thread, stack, stack_size,
    a00124dc:	f90007ff 	str	xzr, [sp, #8]
    a00124e0:	b94513e0 	ldr	w0, [sp, #1296]
    a00124e4:	b90003e0 	str	w0, [sp]
    a00124e8:	b94027e7 	ldr	w7, [sp, #36]
    a00124ec:	f94017e6 	ldr	x6, [sp, #40]
    a00124f0:	f9401be5 	ldr	x5, [sp, #48]
    a00124f4:	f9401fe4 	ldr	x4, [sp, #56]
    a00124f8:	f94023e3 	ldr	x3, [sp, #64]
    a00124fc:	f94027e2 	ldr	x2, [sp, #72]
    a0012500:	f9402be1 	ldr	x1, [sp, #80]
    a0012504:	f9402fe0 	ldr	x0, [sp, #88]
    a0012508:	97ffff04 	bl	a0012118 <z_setup_new_thread>
			   entry, p1, p2, p3, prio, options, NULL);

	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
    a001250c:	f9428fe0 	ldr	x0, [sp, #1304]
    a0012510:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
    a0012514:	eb01001f 	cmp	x0, x1
    a0012518:	54000080 	b.eq	a0012528 <z_vrfy_k_thread_create+0x2e4>  // b.none
		schedule_new_thread(new_thread, delay);
    a001251c:	f9428fe1 	ldr	x1, [sp, #1304]
    a0012520:	f9402fe0 	ldr	x0, [sp, #88]
    a0012524:	97fffea1 	bl	a0011fa8 <schedule_new_thread>
	}

	return new_thread;
    a0012528:	f9402fe0 	ldr	x0, [sp, #88]
}
    a001252c:	a9417bfd 	ldp	x29, x30, [sp, #16]
    a0012530:	911443ff 	add	sp, sp, #0x510
    a0012534:	d65f03c0 	ret

00000000a0012538 <z_mrsh_k_thread_create>:
#include <syscalls/kernel.h>

extern k_tid_t z_vrfy_k_thread_create(struct k_thread * new_thread, k_thread_stack_t * stack, size_t stack_size, k_thread_entry_t entry, void * p1, void * p2, void * p3, int prio, uint32_t options, k_timeout_t delay);
uintptr_t z_mrsh_k_thread_create(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, void *more, void *ssf)
{
    a0012538:	d108c3ff 	sub	sp, sp, #0x230
    a001253c:	a9017bfd 	stp	x29, x30, [sp, #16]
    a0012540:	910043fd 	add	x29, sp, #0x10
    a0012544:	f9002fe0 	str	x0, [sp, #88]
    a0012548:	f9002be1 	str	x1, [sp, #80]
    a001254c:	f90027e2 	str	x2, [sp, #72]
    a0012550:	f90023e3 	str	x3, [sp, #64]
    a0012554:	f9001fe4 	str	x4, [sp, #56]
    a0012558:	f9001be5 	str	x5, [sp, #48]
    a001255c:	f90017e6 	str	x6, [sp, #40]
	_current->syscall_frame = ssf;
    a0012560:	b00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0012564:	913f8000 	add	x0, x0, #0xfe0
    a0012568:	f9400800 	ldr	x0, [x0, #16]
    a001256c:	f94017e1 	ldr	x1, [sp, #40]
    a0012570:	f9008401 	str	x1, [x0, #264]
	Z_OOPS(Z_SYSCALL_MEMORY_READ(more, 4 * sizeof(uintptr_t)));
    a0012574:	52800002 	mov	w2, #0x0                   	// #0
    a0012578:	d2800401 	mov	x1, #0x20                  	// #32
    a001257c:	f9401be0 	ldr	x0, [sp, #48]
    a0012580:	97ffe4bb 	bl	a000b86c <arch_buffer_validate>
    a0012584:	7100001f 	cmp	w0, #0x0
    a0012588:	1a9f07e0 	cset	w0, ne  // ne = any
    a001258c:	39089fe0 	strb	w0, [sp, #551]
    a0012590:	39489fe0 	ldrb	w0, [sp, #551]
    a0012594:	7100001f 	cmp	w0, #0x0
    a0012598:	39489fe0 	ldrb	w0, [sp, #551]
    a001259c:	7100001f 	cmp	w0, #0x0
    a00125a0:	540000c0 	b.eq	a00125b8 <z_mrsh_k_thread_create+0x80>  // b.none
    a00125a4:	b00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00125a8:	913f8000 	add	x0, x0, #0xfe0
    a00125ac:	f9400800 	ldr	x0, [x0, #16]
    a00125b0:	f9408400 	ldr	x0, [x0, #264]
    a00125b4:	97ffdae9 	bl	a0009158 <arch_syscall_oops>
	k_tid_t ret = z_vrfy_k_thread_create(*(struct k_thread **)&arg0, *(k_thread_stack_t **)&arg1, *(size_t*)&arg2, *(k_thread_entry_t*)&arg3, *(void **)&arg4, *(void **)&(((uintptr_t *)more)[0]), *(void **)&(((uintptr_t *)more)[1]), *(int*)&(((uintptr_t *)more)[2]), *(uint32_t*)&(((uintptr_t *)more)[3]), *(k_timeout_t*)&(((uintptr_t *)more)[4]))
    a00125b8:	910163e0 	add	x0, sp, #0x58
    a00125bc:	f9400008 	ldr	x8, [x0]
    a00125c0:	910143e0 	add	x0, sp, #0x50
    a00125c4:	f9400009 	ldr	x9, [x0]
    a00125c8:	910123e0 	add	x0, sp, #0x48
    a00125cc:	f9400002 	ldr	x2, [x0]
    a00125d0:	910103e0 	add	x0, sp, #0x40
    a00125d4:	f9400003 	ldr	x3, [x0]
    a00125d8:	9100e3e0 	add	x0, sp, #0x38
    a00125dc:	f9400004 	ldr	x4, [x0]
    a00125e0:	f9401be0 	ldr	x0, [sp, #48]
    a00125e4:	f9400005 	ldr	x5, [x0]
    a00125e8:	f9401be0 	ldr	x0, [sp, #48]
    a00125ec:	91002000 	add	x0, x0, #0x8
    a00125f0:	f9400006 	ldr	x6, [x0]
    a00125f4:	f9401be0 	ldr	x0, [sp, #48]
    a00125f8:	91004000 	add	x0, x0, #0x10
    a00125fc:	b9400007 	ldr	w7, [x0]
    a0012600:	f9401be0 	ldr	x0, [sp, #48]
    a0012604:	91006000 	add	x0, x0, #0x18
    a0012608:	b9400000 	ldr	w0, [x0]
    a001260c:	f9401be1 	ldr	x1, [sp, #48]
    a0012610:	91008021 	add	x1, x1, #0x20
    a0012614:	f9400021 	ldr	x1, [x1]
    a0012618:	f90007e1 	str	x1, [sp, #8]
    a001261c:	b90003e0 	str	w0, [sp]
    a0012620:	aa0903e1 	mov	x1, x9
    a0012624:	aa0803e0 	mov	x0, x8
    a0012628:	97ffff07 	bl	a0012244 <z_vrfy_k_thread_create>
    a001262c:	f90117e0 	str	x0, [sp, #552]
;
	_current->syscall_frame = NULL;
    a0012630:	b00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0012634:	913f8000 	add	x0, x0, #0xfe0
    a0012638:	f9400800 	ldr	x0, [x0, #16]
    a001263c:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a0012640:	f94117e0 	ldr	x0, [sp, #552]
}
    a0012644:	a9417bfd 	ldp	x29, x30, [sp, #16]
    a0012648:	9108c3ff 	add	sp, sp, #0x230
    a001264c:	d65f03c0 	ret

00000000a0012650 <grant_static_access>:

#ifdef CONFIG_MULTITHREADING
#ifdef CONFIG_USERSPACE

static void grant_static_access(void)
{
    a0012650:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0012654:	910003fd 	mov	x29, sp
	STRUCT_SECTION_FOREACH(z_object_assignment, pos) {
    a0012658:	b0000080 	adrp	x0, a0023000 <__rodata_region_start>
    a001265c:	913a0000 	add	x0, x0, #0xe80
    a0012660:	f9000fe0 	str	x0, [sp, #24]
    a0012664:	1400001c 	b	a00126d4 <grant_static_access+0x84>
		for (int i = 0; pos->objects[i] != NULL; i++) {
    a0012668:	b90017ff 	str	wzr, [sp, #20]
    a001266c:	1400000f 	b	a00126a8 <grant_static_access+0x58>
			k_object_access_grant(pos->objects[i],
    a0012670:	f9400fe0 	ldr	x0, [sp, #24]
    a0012674:	f9400401 	ldr	x1, [x0, #8]
    a0012678:	b98017e0 	ldrsw	x0, [sp, #20]
    a001267c:	d37df000 	lsl	x0, x0, #3
    a0012680:	8b000020 	add	x0, x1, x0
    a0012684:	f9400002 	ldr	x2, [x0]
    a0012688:	f9400fe0 	ldr	x0, [sp, #24]
    a001268c:	f9400000 	ldr	x0, [x0]
    a0012690:	aa0003e1 	mov	x1, x0
    a0012694:	aa0203e0 	mov	x0, x2
    a0012698:	97fffcdf 	bl	a0011a14 <k_object_access_grant>
		for (int i = 0; pos->objects[i] != NULL; i++) {
    a001269c:	b94017e0 	ldr	w0, [sp, #20]
    a00126a0:	11000400 	add	w0, w0, #0x1
    a00126a4:	b90017e0 	str	w0, [sp, #20]
    a00126a8:	f9400fe0 	ldr	x0, [sp, #24]
    a00126ac:	f9400401 	ldr	x1, [x0, #8]
    a00126b0:	b98017e0 	ldrsw	x0, [sp, #20]
    a00126b4:	d37df000 	lsl	x0, x0, #3
    a00126b8:	8b000020 	add	x0, x1, x0
    a00126bc:	f9400000 	ldr	x0, [x0]
    a00126c0:	f100001f 	cmp	x0, #0x0
    a00126c4:	54fffd61 	b.ne	a0012670 <grant_static_access+0x20>  // b.any
	STRUCT_SECTION_FOREACH(z_object_assignment, pos) {
    a00126c8:	f9400fe0 	ldr	x0, [sp, #24]
    a00126cc:	91004000 	add	x0, x0, #0x10
    a00126d0:	f9000fe0 	str	x0, [sp, #24]
    a00126d4:	f9400fe1 	ldr	x1, [sp, #24]
    a00126d8:	b0000080 	adrp	x0, a0023000 <__rodata_region_start>
    a00126dc:	913a0000 	add	x0, x0, #0xe80
    a00126e0:	eb00003f 	cmp	x1, x0
    a00126e4:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
    a00126e8:	12001c00 	and	w0, w0, #0xff
    a00126ec:	7100001f 	cmp	w0, #0x0
    a00126f0:	54fffbc1 	b.ne	a0012668 <grant_static_access+0x18>  // b.any
					      pos->thread);
		}
	}
}
    a00126f4:	d503201f 	nop
    a00126f8:	d503201f 	nop
    a00126fc:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0012700:	d65f03c0 	ret

00000000a0012704 <z_init_static_threads>:
#endif /* CONFIG_USERSPACE */

void z_init_static_threads(void)
{
    a0012704:	d10103ff 	sub	sp, sp, #0x40
    a0012708:	a9017bfd 	stp	x29, x30, [sp, #16]
    a001270c:	910043fd 	add	x29, sp, #0x10
    a0012710:	f90013f3 	str	x19, [sp, #32]
	_FOREACH_STATIC_THREAD(thread_data) {
    a0012714:	b0000440 	adrp	x0, a009b000 <twom1000.10>
    a0012718:	9102d000 	add	x0, x0, #0xb4
    a001271c:	f9001fe0 	str	x0, [sp, #56]
    a0012720:	14000022 	b	a00127a8 <z_init_static_threads+0xa4>
		z_setup_new_thread(
    a0012724:	f9401fe0 	ldr	x0, [sp, #56]
    a0012728:	f9400008 	ldr	x8, [x0]
    a001272c:	f9401fe0 	ldr	x0, [sp, #56]
    a0012730:	f9400409 	ldr	x9, [x0, #8]
			thread_data->init_thread,
			thread_data->init_stack,
			thread_data->init_stack_size,
    a0012734:	f9401fe0 	ldr	x0, [sp, #56]
    a0012738:	b9401000 	ldr	w0, [x0, #16]
		z_setup_new_thread(
    a001273c:	2a0003e2 	mov	w2, w0
    a0012740:	f9401fe0 	ldr	x0, [sp, #56]
    a0012744:	f9400c03 	ldr	x3, [x0, #24]
    a0012748:	f9401fe0 	ldr	x0, [sp, #56]
    a001274c:	f9401004 	ldr	x4, [x0, #32]
    a0012750:	f9401fe0 	ldr	x0, [sp, #56]
    a0012754:	f9401405 	ldr	x5, [x0, #40]
    a0012758:	f9401fe0 	ldr	x0, [sp, #56]
    a001275c:	f9401806 	ldr	x6, [x0, #48]
    a0012760:	f9401fe0 	ldr	x0, [sp, #56]
    a0012764:	b9403807 	ldr	w7, [x0, #56]
    a0012768:	f9401fe0 	ldr	x0, [sp, #56]
    a001276c:	b9403c00 	ldr	w0, [x0, #60]
    a0012770:	f9401fe1 	ldr	x1, [sp, #56]
    a0012774:	f9402821 	ldr	x1, [x1, #80]
    a0012778:	f90007e1 	str	x1, [sp, #8]
    a001277c:	b90003e0 	str	w0, [sp]
    a0012780:	aa0903e1 	mov	x1, x9
    a0012784:	aa0803e0 	mov	x0, x8
    a0012788:	97fffe64 	bl	a0012118 <z_setup_new_thread>
			thread_data->init_p3,
			thread_data->init_prio,
			thread_data->init_options,
			thread_data->init_name);

		thread_data->init_thread->init_data = thread_data;
    a001278c:	f9401fe0 	ldr	x0, [sp, #56]
    a0012790:	f9400000 	ldr	x0, [x0]
    a0012794:	f9401fe1 	ldr	x1, [sp, #56]
    a0012798:	f9005801 	str	x1, [x0, #176]
	_FOREACH_STATIC_THREAD(thread_data) {
    a001279c:	f9401fe0 	ldr	x0, [sp, #56]
    a00127a0:	91016000 	add	x0, x0, #0x58
    a00127a4:	f9001fe0 	str	x0, [sp, #56]
    a00127a8:	f9401fe1 	ldr	x1, [sp, #56]
    a00127ac:	b0000440 	adrp	x0, a009b000 <twom1000.10>
    a00127b0:	9102d000 	add	x0, x0, #0xb4
    a00127b4:	eb00003f 	cmp	x1, x0
    a00127b8:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
    a00127bc:	12001c00 	and	w0, w0, #0xff
    a00127c0:	7100001f 	cmp	w0, #0x0
    a00127c4:	54fffb01 	b.ne	a0012724 <z_init_static_threads+0x20>  // b.any
	}

#ifdef CONFIG_USERSPACE
	grant_static_access();
    a00127c8:	97ffffa2 	bl	a0012650 <grant_static_access>
	 * until they are all started.
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	k_sched_lock();
    a00127cc:	9400168b 	bl	a00181f8 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
    a00127d0:	b0000440 	adrp	x0, a009b000 <twom1000.10>
    a00127d4:	9102d000 	add	x0, x0, #0xb4
    a00127d8:	f9001be0 	str	x0, [sp, #48]
    a00127dc:	14000014 	b	a001282c <z_init_static_threads+0x128>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
    a00127e0:	f9401be0 	ldr	x0, [sp, #48]
    a00127e4:	b9404000 	ldr	w0, [x0, #64]
    a00127e8:	3100041f 	cmn	w0, #0x1
    a00127ec:	540001a0 	b.eq	a0012820 <z_init_static_threads+0x11c>  // b.none
			schedule_new_thread(thread_data->init_thread,
    a00127f0:	f9401be0 	ldr	x0, [sp, #48]
    a00127f4:	f9400013 	ldr	x19, [x0]
					    K_MSEC(thread_data->init_delay));
    a00127f8:	f9401be0 	ldr	x0, [sp, #48]
    a00127fc:	b9404000 	ldr	w0, [x0, #64]
    a0012800:	52800001 	mov	w1, #0x0                   	// #0
    a0012804:	7100001f 	cmp	w0, #0x0
    a0012808:	1a81a000 	csel	w0, w0, w1, ge  // ge = tcont
    a001280c:	93407c00 	sxtw	x0, w0
    a0012810:	97fffba8 	bl	a00116b0 <k_ms_to_ticks_ceil64>
			schedule_new_thread(thread_data->init_thread,
    a0012814:	aa0003e1 	mov	x1, x0
    a0012818:	aa1303e0 	mov	x0, x19
    a001281c:	97fffde3 	bl	a0011fa8 <schedule_new_thread>
	_FOREACH_STATIC_THREAD(thread_data) {
    a0012820:	f9401be0 	ldr	x0, [sp, #48]
    a0012824:	91016000 	add	x0, x0, #0x58
    a0012828:	f9001be0 	str	x0, [sp, #48]
    a001282c:	f9401be1 	ldr	x1, [sp, #48]
    a0012830:	b0000440 	adrp	x0, a009b000 <twom1000.10>
    a0012834:	9102d000 	add	x0, x0, #0xb4
    a0012838:	eb00003f 	cmp	x1, x0
    a001283c:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
    a0012840:	12001c00 	and	w0, w0, #0xff
    a0012844:	7100001f 	cmp	w0, #0x0
    a0012848:	54fffcc1 	b.ne	a00127e0 <z_init_static_threads+0xdc>  // b.any
		}
	}
	k_sched_unlock();
    a001284c:	94001695 	bl	a00182a0 <k_sched_unlock>
}
    a0012850:	d503201f 	nop
    a0012854:	f94013f3 	ldr	x19, [sp, #32]
    a0012858:	a9417bfd 	ldp	x29, x30, [sp, #16]
    a001285c:	910103ff 	add	sp, sp, #0x40
    a0012860:	d65f03c0 	ret

00000000a0012864 <z_init_thread_base>:
#endif

void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
    a0012864:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0012868:	910003fd 	mov	x29, sp
    a001286c:	f90017e0 	str	x0, [sp, #40]
    a0012870:	b90027e1 	str	w1, [sp, #36]
    a0012874:	b90023e2 	str	w2, [sp, #32]
    a0012878:	b9001fe3 	str	w3, [sp, #28]
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
    a001287c:	f94017e0 	ldr	x0, [sp, #40]
    a0012880:	f900081f 	str	xzr, [x0, #16]
	thread_base->user_options = (uint8_t)options;
    a0012884:	b9401fe0 	ldr	w0, [sp, #28]
    a0012888:	12001c01 	and	w1, w0, #0xff
    a001288c:	f94017e0 	ldr	x0, [sp, #40]
    a0012890:	39006001 	strb	w1, [x0, #24]
	thread_base->thread_state = (uint8_t)initial_state;
    a0012894:	b94023e0 	ldr	w0, [sp, #32]
    a0012898:	12001c01 	and	w1, w0, #0xff
    a001289c:	f94017e0 	ldr	x0, [sp, #40]
    a00128a0:	39006401 	strb	w1, [x0, #25]

	thread_base->prio = priority;
    a00128a4:	b94027e0 	ldr	w0, [sp, #36]
    a00128a8:	13001c01 	sxtb	w1, w0
    a00128ac:	f94017e0 	ldr	x0, [sp, #40]
    a00128b0:	39006801 	strb	w1, [x0, #26]

	thread_base->sched_locked = 0U;
    a00128b4:	f94017e0 	ldr	x0, [sp, #40]
    a00128b8:	39006c1f 	strb	wzr, [x0, #27]
	thread_base->is_idle = 0;
#endif

	/* swap_data does not need to be initialized */

	z_init_thread_timeout(thread_base);
    a00128bc:	f94017e0 	ldr	x0, [sp, #40]
    a00128c0:	97fffca7 	bl	a0011b5c <z_init_thread_timeout>
}
    a00128c4:	d503201f 	nop
    a00128c8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a00128cc:	d65f03c0 	ret

00000000a00128d0 <z_impl_k_float_disable>:
#endif /* CONFIG_KERNEL_COHERENCE */

#endif /* CONFIG_SPIN_VALIDATE */

int z_impl_k_float_disable(struct k_thread *thread)
{
    a00128d0:	d10043ff 	sub	sp, sp, #0x10
    a00128d4:	f90007e0 	str	x0, [sp, #8]
#if defined(CONFIG_FPU) && defined(CONFIG_FPU_SHARING)
	return arch_float_disable(thread);
#else
	return -ENOTSUP;
    a00128d8:	128010a0 	mov	w0, #0xffffff7a            	// #-134
#endif /* CONFIG_FPU && CONFIG_FPU_SHARING */
}
    a00128dc:	910043ff 	add	sp, sp, #0x10
    a00128e0:	d65f03c0 	ret

00000000a00128e4 <z_vrfy_k_float_disable>:
#endif /* CONFIG_FPU && CONFIG_FPU_SHARING */
}

#ifdef CONFIG_USERSPACE
static inline int z_vrfy_k_float_disable(struct k_thread *thread)
{
    a00128e4:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a00128e8:	910003fd 	mov	x29, sp
    a00128ec:	f9000fe0 	str	x0, [sp, #24]
	Z_OOPS(Z_SYSCALL_OBJ(thread, K_OBJ_THREAD));
    a00128f0:	f9400fe0 	ldr	x0, [sp, #24]
    a00128f4:	9400284d 	bl	a001ca28 <z_object_find>
    a00128f8:	52800003 	mov	w3, #0x0                   	// #0
    a00128fc:	52800122 	mov	w2, #0x9                   	// #9
    a0012900:	f9400fe1 	ldr	x1, [sp, #24]
    a0012904:	97fffd0c 	bl	a0011d34 <z_obj_validation_check>
    a0012908:	7100001f 	cmp	w0, #0x0
    a001290c:	1a9f07e0 	cset	w0, ne  // ne = any
    a0012910:	39063fe0 	strb	w0, [sp, #399]
    a0012914:	39463fe0 	ldrb	w0, [sp, #399]
    a0012918:	7100001f 	cmp	w0, #0x0
    a001291c:	39463fe0 	ldrb	w0, [sp, #399]
    a0012920:	7100001f 	cmp	w0, #0x0
    a0012924:	540000c0 	b.eq	a001293c <z_vrfy_k_float_disable+0x58>  // b.none
    a0012928:	b00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001292c:	913f8000 	add	x0, x0, #0xfe0
    a0012930:	f9400800 	ldr	x0, [x0, #16]
    a0012934:	f9408400 	ldr	x0, [x0, #264]
    a0012938:	97ffda08 	bl	a0009158 <arch_syscall_oops>
	return z_impl_k_float_disable(thread);
    a001293c:	f9400fe0 	ldr	x0, [sp, #24]
    a0012940:	97ffffe4 	bl	a00128d0 <z_impl_k_float_disable>
}
    a0012944:	a8d97bfd 	ldp	x29, x30, [sp], #400
    a0012948:	d65f03c0 	ret

00000000a001294c <z_mrsh_k_float_disable>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_float_disable(struct k_thread * thread);
uintptr_t z_mrsh_k_float_disable(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a001294c:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a0012950:	910003fd 	mov	x29, sp
    a0012954:	f90027e0 	str	x0, [sp, #72]
    a0012958:	f90023e1 	str	x1, [sp, #64]
    a001295c:	f9001fe2 	str	x2, [sp, #56]
    a0012960:	f9001be3 	str	x3, [sp, #48]
    a0012964:	f90017e4 	str	x4, [sp, #40]
    a0012968:	f90013e5 	str	x5, [sp, #32]
    a001296c:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a0012970:	b00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0012974:	913f8000 	add	x0, x0, #0xfe0
    a0012978:	f9400800 	ldr	x0, [x0, #16]
    a001297c:	f9400fe1 	ldr	x1, [sp, #24]
    a0012980:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_float_disable(*(struct k_thread **)&arg0)
    a0012984:	910123e0 	add	x0, sp, #0x48
    a0012988:	f9400000 	ldr	x0, [x0]
    a001298c:	97ffffd6 	bl	a00128e4 <z_vrfy_k_float_disable>
    a0012990:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a0012994:	b00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0012998:	913f8000 	add	x0, x0, #0xfe0
    a001299c:	f9400800 	ldr	x0, [x0, #16]
    a00129a0:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a00129a4:	b9805fe0 	ldrsw	x0, [sp, #92]
}
    a00129a8:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a00129ac:	d65f03c0 	ret

00000000a00129b0 <z_impl_k_thread_stack_space_get>:
#error "Unsupported configuration for stack analysis"
#endif

int z_impl_k_thread_stack_space_get(const struct k_thread *thread,
				    size_t *unused_ptr)
{
    a00129b0:	d10103ff 	sub	sp, sp, #0x40
    a00129b4:	f90007e0 	str	x0, [sp, #8]
    a00129b8:	f90003e1 	str	x1, [sp]
	const uint8_t *start = (uint8_t *)thread->stack_info.start;
    a00129bc:	f94007e0 	ldr	x0, [sp, #8]
    a00129c0:	f9406800 	ldr	x0, [x0, #208]
    a00129c4:	f9000be0 	str	x0, [sp, #16]
	size_t size = thread->stack_info.size;
    a00129c8:	f94007e0 	ldr	x0, [sp, #8]
    a00129cc:	f9406c00 	ldr	x0, [x0, #216]
    a00129d0:	f90017e0 	str	x0, [sp, #40]
	size_t unused = 0;
    a00129d4:	f9001fff 	str	xzr, [sp, #56]
	const uint8_t *checked_stack = start;
    a00129d8:	f9400be0 	ldr	x0, [sp, #16]
    a00129dc:	f90013e0 	str	x0, [sp, #32]
	/* Take the address of any local variable as a shallow bound for the
	 * stack pointer.  Addresses above it are guaranteed to be
	 * accessible.
	 */
	const uint8_t *stack_pointer = (const uint8_t *)&start;
    a00129e0:	910043e0 	add	x0, sp, #0x10
    a00129e4:	f9000fe0 	str	x0, [sp, #24]
		 */
		checked_stack += 4;
		size -= 4;
	}

	for (size_t i = 0; i < size; i++) {
    a00129e8:	f9001bff 	str	xzr, [sp, #48]
    a00129ec:	1400000d 	b	a0012a20 <z_impl_k_thread_stack_space_get+0x70>
		if ((checked_stack[i]) == 0xaaU) {
    a00129f0:	f94013e1 	ldr	x1, [sp, #32]
    a00129f4:	f9401be0 	ldr	x0, [sp, #48]
    a00129f8:	8b000020 	add	x0, x1, x0
    a00129fc:	39400000 	ldrb	w0, [x0]
    a0012a00:	7102a81f 	cmp	w0, #0xaa
    a0012a04:	54000181 	b.ne	a0012a34 <z_impl_k_thread_stack_space_get+0x84>  // b.any
			unused++;
    a0012a08:	f9401fe0 	ldr	x0, [sp, #56]
    a0012a0c:	91000400 	add	x0, x0, #0x1
    a0012a10:	f9001fe0 	str	x0, [sp, #56]
	for (size_t i = 0; i < size; i++) {
    a0012a14:	f9401be0 	ldr	x0, [sp, #48]
    a0012a18:	91000400 	add	x0, x0, #0x1
    a0012a1c:	f9001be0 	str	x0, [sp, #48]
    a0012a20:	f9401be1 	ldr	x1, [sp, #48]
    a0012a24:	f94017e0 	ldr	x0, [sp, #40]
    a0012a28:	eb00003f 	cmp	x1, x0
    a0012a2c:	54fffe23 	b.cc	a00129f0 <z_impl_k_thread_stack_space_get+0x40>  // b.lo, b.ul, b.last
    a0012a30:	14000002 	b	a0012a38 <z_impl_k_thread_stack_space_get+0x88>
		} else {
			break;
    a0012a34:	d503201f 	nop
		}
	}

	*unused_ptr = unused;
    a0012a38:	f94003e0 	ldr	x0, [sp]
    a0012a3c:	f9401fe1 	ldr	x1, [sp, #56]
    a0012a40:	f9000001 	str	x1, [x0]

	return 0;
    a0012a44:	52800000 	mov	w0, #0x0                   	// #0
}
    a0012a48:	910103ff 	add	sp, sp, #0x40
    a0012a4c:	d65f03c0 	ret

00000000a0012a50 <z_vrfy_k_thread_stack_space_get>:

#ifdef CONFIG_USERSPACE
int z_vrfy_k_thread_stack_space_get(const struct k_thread *thread,
				    size_t *unused_ptr)
{
    a0012a50:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a0012a54:	910003fd 	mov	x29, sp
    a0012a58:	f9000fe0 	str	x0, [sp, #24]
    a0012a5c:	f9000be1 	str	x1, [sp, #16]
	size_t unused;
	int ret;

	ret = Z_SYSCALL_OBJ(thread, K_OBJ_THREAD);
    a0012a60:	f9400fe0 	ldr	x0, [sp, #24]
    a0012a64:	940027f1 	bl	a001ca28 <z_object_find>
    a0012a68:	52800003 	mov	w3, #0x0                   	// #0
    a0012a6c:	52800122 	mov	w2, #0x9                   	// #9
    a0012a70:	f9400fe1 	ldr	x1, [sp, #24]
    a0012a74:	97fffcb0 	bl	a0011d34 <z_obj_validation_check>
    a0012a78:	7100001f 	cmp	w0, #0x0
    a0012a7c:	1a9f07e0 	cset	w0, ne  // ne = any
    a0012a80:	39062fe0 	strb	w0, [sp, #395]
    a0012a84:	39462fe0 	ldrb	w0, [sp, #395]
    a0012a88:	7100001f 	cmp	w0, #0x0
    a0012a8c:	39462fe0 	ldrb	w0, [sp, #395]
    a0012a90:	b9018fe0 	str	w0, [sp, #396]
	CHECKIF(ret != 0) {
    a0012a94:	b9418fe0 	ldr	w0, [sp, #396]
    a0012a98:	7100001f 	cmp	w0, #0x0
    a0012a9c:	54000060 	b.eq	a0012aa8 <z_vrfy_k_thread_stack_space_get+0x58>  // b.none
		return ret;
    a0012aa0:	b9418fe0 	ldr	w0, [sp, #396]
    a0012aa4:	14000017 	b	a0012b00 <z_vrfy_k_thread_stack_space_get+0xb0>
	}

	ret = z_impl_k_thread_stack_space_get(thread, &unused);
    a0012aa8:	910603e0 	add	x0, sp, #0x180
    a0012aac:	aa0003e1 	mov	x1, x0
    a0012ab0:	f9400fe0 	ldr	x0, [sp, #24]
    a0012ab4:	97ffffbf 	bl	a00129b0 <z_impl_k_thread_stack_space_get>
    a0012ab8:	b9018fe0 	str	w0, [sp, #396]
	CHECKIF(ret != 0) {
    a0012abc:	b9418fe0 	ldr	w0, [sp, #396]
    a0012ac0:	7100001f 	cmp	w0, #0x0
    a0012ac4:	54000060 	b.eq	a0012ad0 <z_vrfy_k_thread_stack_space_get+0x80>  // b.none
		return ret;
    a0012ac8:	b9418fe0 	ldr	w0, [sp, #396]
    a0012acc:	1400000d 	b	a0012b00 <z_vrfy_k_thread_stack_space_get+0xb0>
	}

	ret = z_user_to_copy(unused_ptr, &unused, sizeof(size_t));
    a0012ad0:	910603e0 	add	x0, sp, #0x180
    a0012ad4:	d2800102 	mov	x2, #0x8                   	// #8
    a0012ad8:	aa0003e1 	mov	x1, x0
    a0012adc:	f9400be0 	ldr	x0, [sp, #16]
    a0012ae0:	94002aac 	bl	a001d590 <z_user_to_copy>
    a0012ae4:	b9018fe0 	str	w0, [sp, #396]
	CHECKIF(ret != 0) {
    a0012ae8:	b9418fe0 	ldr	w0, [sp, #396]
    a0012aec:	7100001f 	cmp	w0, #0x0
    a0012af0:	54000060 	b.eq	a0012afc <z_vrfy_k_thread_stack_space_get+0xac>  // b.none
		return ret;
    a0012af4:	b9418fe0 	ldr	w0, [sp, #396]
    a0012af8:	14000002 	b	a0012b00 <z_vrfy_k_thread_stack_space_get+0xb0>
	}

	return 0;
    a0012afc:	52800000 	mov	w0, #0x0                   	// #0
}
    a0012b00:	a8d97bfd 	ldp	x29, x30, [sp], #400
    a0012b04:	d65f03c0 	ret

00000000a0012b08 <z_mrsh_k_thread_stack_space_get>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_thread_stack_space_get(const struct k_thread * thread, size_t * unused_ptr);
uintptr_t z_mrsh_k_thread_stack_space_get(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a0012b08:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a0012b0c:	910003fd 	mov	x29, sp
    a0012b10:	f90027e0 	str	x0, [sp, #72]
    a0012b14:	f90023e1 	str	x1, [sp, #64]
    a0012b18:	f9001fe2 	str	x2, [sp, #56]
    a0012b1c:	f9001be3 	str	x3, [sp, #48]
    a0012b20:	f90017e4 	str	x4, [sp, #40]
    a0012b24:	f90013e5 	str	x5, [sp, #32]
    a0012b28:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a0012b2c:	b00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0012b30:	913f8000 	add	x0, x0, #0xfe0
    a0012b34:	f9400800 	ldr	x0, [x0, #16]
    a0012b38:	f9400fe1 	ldr	x1, [sp, #24]
    a0012b3c:	f9008401 	str	x1, [x0, #264]
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_thread_stack_space_get(*(const struct k_thread **)&arg0, *(size_t **)&arg1)
    a0012b40:	910123e0 	add	x0, sp, #0x48
    a0012b44:	f9400002 	ldr	x2, [x0]
    a0012b48:	910103e0 	add	x0, sp, #0x40
    a0012b4c:	f9400000 	ldr	x0, [x0]
    a0012b50:	aa0003e1 	mov	x1, x0
    a0012b54:	aa0203e0 	mov	x0, x2
    a0012b58:	97ffffbe 	bl	a0012a50 <z_vrfy_k_thread_stack_space_get>
    a0012b5c:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a0012b60:	b00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0012b64:	913f8000 	add	x0, x0, #0xfe0
    a0012b68:	f9400800 	ldr	x0, [x0, #16]
    a0012b6c:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a0012b70:	b9805fe0 	ldrsw	x0, [sp, #92]
}
    a0012b74:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a0012b78:	d65f03c0 	ret

00000000a0012b7c <z_vrfy_k_thread_timeout_remaining_ticks>:
#endif /* CONFIG_INIT_STACKS && CONFIG_THREAD_STACK_INFO */

#ifdef CONFIG_USERSPACE
static inline k_ticks_t z_vrfy_k_thread_timeout_remaining_ticks(
						    const struct k_thread *t)
{
    a0012b7c:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a0012b80:	910003fd 	mov	x29, sp
    a0012b84:	f9000fe0 	str	x0, [sp, #24]
	Z_OOPS(Z_SYSCALL_OBJ(t, K_OBJ_THREAD));
    a0012b88:	f9400fe0 	ldr	x0, [sp, #24]
    a0012b8c:	940027a7 	bl	a001ca28 <z_object_find>
    a0012b90:	52800003 	mov	w3, #0x0                   	// #0
    a0012b94:	52800122 	mov	w2, #0x9                   	// #9
    a0012b98:	f9400fe1 	ldr	x1, [sp, #24]
    a0012b9c:	97fffc66 	bl	a0011d34 <z_obj_validation_check>
    a0012ba0:	7100001f 	cmp	w0, #0x0
    a0012ba4:	1a9f07e0 	cset	w0, ne  // ne = any
    a0012ba8:	39063fe0 	strb	w0, [sp, #399]
    a0012bac:	39463fe0 	ldrb	w0, [sp, #399]
    a0012bb0:	7100001f 	cmp	w0, #0x0
    a0012bb4:	39463fe0 	ldrb	w0, [sp, #399]
    a0012bb8:	7100001f 	cmp	w0, #0x0
    a0012bbc:	540000c0 	b.eq	a0012bd4 <z_vrfy_k_thread_timeout_remaining_ticks+0x58>  // b.none
    a0012bc0:	b00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0012bc4:	913f8000 	add	x0, x0, #0xfe0
    a0012bc8:	f9400800 	ldr	x0, [x0, #16]
    a0012bcc:	f9408400 	ldr	x0, [x0, #264]
    a0012bd0:	97ffd962 	bl	a0009158 <arch_syscall_oops>
	return z_impl_k_thread_timeout_remaining_ticks(t);
    a0012bd4:	f9400fe0 	ldr	x0, [sp, #24]
    a0012bd8:	97fffbae 	bl	a0011a90 <z_impl_k_thread_timeout_remaining_ticks>
}
    a0012bdc:	a8d97bfd 	ldp	x29, x30, [sp], #400
    a0012be0:	d65f03c0 	ret

00000000a0012be4 <z_mrsh_k_thread_timeout_remaining_ticks>:
#include <syscalls/kernel.h>

extern k_ticks_t z_vrfy_k_thread_timeout_remaining_ticks(const struct k_thread * t);
uintptr_t z_mrsh_k_thread_timeout_remaining_ticks(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a0012be4:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a0012be8:	910003fd 	mov	x29, sp
    a0012bec:	f90027e0 	str	x0, [sp, #72]
    a0012bf0:	f90023e1 	str	x1, [sp, #64]
    a0012bf4:	f9001fe2 	str	x2, [sp, #56]
    a0012bf8:	f9001be3 	str	x3, [sp, #48]
    a0012bfc:	f90017e4 	str	x4, [sp, #40]
    a0012c00:	f90013e5 	str	x5, [sp, #32]
    a0012c04:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a0012c08:	b00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0012c0c:	913f8000 	add	x0, x0, #0xfe0
    a0012c10:	f9400800 	ldr	x0, [x0, #16]
    a0012c14:	f9400fe1 	ldr	x1, [sp, #24]
    a0012c18:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	k_ticks_t ret = z_vrfy_k_thread_timeout_remaining_ticks(*(const struct k_thread **)&arg0)
    a0012c1c:	910123e0 	add	x0, sp, #0x48
    a0012c20:	f9400000 	ldr	x0, [x0]
    a0012c24:	97ffffd6 	bl	a0012b7c <z_vrfy_k_thread_timeout_remaining_ticks>
    a0012c28:	f9002fe0 	str	x0, [sp, #88]
;
	_current->syscall_frame = NULL;
    a0012c2c:	b00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0012c30:	913f8000 	add	x0, x0, #0xfe0
    a0012c34:	f9400800 	ldr	x0, [x0, #16]
    a0012c38:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a0012c3c:	f9402fe0 	ldr	x0, [sp, #88]
}
    a0012c40:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a0012c44:	d65f03c0 	ret

00000000a0012c48 <z_vrfy_k_thread_timeout_expires_ticks>:
#include <syscalls/k_thread_timeout_remaining_ticks_mrsh.c>

static inline k_ticks_t z_vrfy_k_thread_timeout_expires_ticks(
						  const struct k_thread *t)
{
    a0012c48:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a0012c4c:	910003fd 	mov	x29, sp
    a0012c50:	f9000fe0 	str	x0, [sp, #24]
	Z_OOPS(Z_SYSCALL_OBJ(t, K_OBJ_THREAD));
    a0012c54:	f9400fe0 	ldr	x0, [sp, #24]
    a0012c58:	94002774 	bl	a001ca28 <z_object_find>
    a0012c5c:	52800003 	mov	w3, #0x0                   	// #0
    a0012c60:	52800122 	mov	w2, #0x9                   	// #9
    a0012c64:	f9400fe1 	ldr	x1, [sp, #24]
    a0012c68:	97fffc33 	bl	a0011d34 <z_obj_validation_check>
    a0012c6c:	7100001f 	cmp	w0, #0x0
    a0012c70:	1a9f07e0 	cset	w0, ne  // ne = any
    a0012c74:	39063fe0 	strb	w0, [sp, #399]
    a0012c78:	39463fe0 	ldrb	w0, [sp, #399]
    a0012c7c:	7100001f 	cmp	w0, #0x0
    a0012c80:	39463fe0 	ldrb	w0, [sp, #399]
    a0012c84:	7100001f 	cmp	w0, #0x0
    a0012c88:	540000c0 	b.eq	a0012ca0 <z_vrfy_k_thread_timeout_expires_ticks+0x58>  // b.none
    a0012c8c:	b00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0012c90:	913f8000 	add	x0, x0, #0xfe0
    a0012c94:	f9400800 	ldr	x0, [x0, #16]
    a0012c98:	f9408400 	ldr	x0, [x0, #264]
    a0012c9c:	97ffd92f 	bl	a0009158 <arch_syscall_oops>
	return z_impl_k_thread_timeout_expires_ticks(t);
    a0012ca0:	f9400fe0 	ldr	x0, [sp, #24]
    a0012ca4:	97fffb73 	bl	a0011a70 <z_impl_k_thread_timeout_expires_ticks>
}
    a0012ca8:	a8d97bfd 	ldp	x29, x30, [sp], #400
    a0012cac:	d65f03c0 	ret

00000000a0012cb0 <z_mrsh_k_thread_timeout_expires_ticks>:
#include <syscalls/kernel.h>

extern k_ticks_t z_vrfy_k_thread_timeout_expires_ticks(const struct k_thread * t);
uintptr_t z_mrsh_k_thread_timeout_expires_ticks(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a0012cb0:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a0012cb4:	910003fd 	mov	x29, sp
    a0012cb8:	f90027e0 	str	x0, [sp, #72]
    a0012cbc:	f90023e1 	str	x1, [sp, #64]
    a0012cc0:	f9001fe2 	str	x2, [sp, #56]
    a0012cc4:	f9001be3 	str	x3, [sp, #48]
    a0012cc8:	f90017e4 	str	x4, [sp, #40]
    a0012ccc:	f90013e5 	str	x5, [sp, #32]
    a0012cd0:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a0012cd4:	b00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0012cd8:	913f8000 	add	x0, x0, #0xfe0
    a0012cdc:	f9400800 	ldr	x0, [x0, #16]
    a0012ce0:	f9400fe1 	ldr	x1, [sp, #24]
    a0012ce4:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	k_ticks_t ret = z_vrfy_k_thread_timeout_expires_ticks(*(const struct k_thread **)&arg0)
    a0012ce8:	910123e0 	add	x0, sp, #0x48
    a0012cec:	f9400000 	ldr	x0, [x0]
    a0012cf0:	97ffffd6 	bl	a0012c48 <z_vrfy_k_thread_timeout_expires_ticks>
    a0012cf4:	f9002fe0 	str	x0, [sp, #88]
;
	_current->syscall_frame = NULL;
    a0012cf8:	b00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0012cfc:	913f8000 	add	x0, x0, #0xfe0
    a0012d00:	f9400800 	ldr	x0, [x0, #16]
    a0012d04:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a0012d08:	f9402fe0 	ldr	x0, [sp, #88]
}
    a0012d0c:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a0012d10:	d65f03c0 	ret

00000000a0012d14 <k_cpu_idle>:
 *
 * @note In some architectures, before returning, the function unmasks interrupts
 * unconditionally.
 */
static inline void k_cpu_idle(void)
{
    a0012d14:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    a0012d18:	910003fd 	mov	x29, sp
	arch_cpu_idle();
    a0012d1c:	97ffd872 	bl	a0008ee4 <arch_cpu_idle>
}
    a0012d20:	d503201f 	nop
    a0012d24:	a8c17bfd 	ldp	x29, x30, [sp], #16
    a0012d28:	d65f03c0 	ret

00000000a0012d2c <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
    a0012d2c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    a0012d30:	910003fd 	mov	x29, sp
    a0012d34:	f90017e0 	str	x0, [sp, #40]
    a0012d38:	f90013e1 	str	x1, [sp, #32]
    a0012d3c:	f9000fe2 	str	x2, [sp, #24]
MAKE_REG_HELPER(daif)
    a0012d40:	d53b4220 	mrs	x0, daif
    a0012d44:	f9001fe0 	str	x0, [sp, #56]
    a0012d48:	f9401fe0 	ldr	x0, [sp, #56]
    a0012d4c:	d503201f 	nop
	key = read_daif();
    a0012d50:	b90037e0 	str	w0, [sp, #52]
	__asm__ volatile ("msr DAIFSet, %0"
    a0012d54:	d50342df 	msr	daifset, #0x2
}
    a0012d58:	d503201f 	nop
	return key;
    a0012d5c:	d503201f 	nop
		 */
		if (k_is_pre_kernel() || !pm_system_suspend(_kernel.idle)) {
			k_cpu_idle();
		}
#else
		k_cpu_idle();
    a0012d60:	97ffffed 	bl	a0012d14 <k_cpu_idle>
		if (IS_ENABLED(CONFIG_SMP) &&
    a0012d64:	17fffff7 	b	a0012d40 <idle+0x14>

00000000a0012d68 <sys_dlist_init>:
{
    a0012d68:	d10043ff 	sub	sp, sp, #0x10
    a0012d6c:	f90007e0 	str	x0, [sp, #8]
	list->head = (sys_dnode_t *)list;
    a0012d70:	f94007e0 	ldr	x0, [sp, #8]
    a0012d74:	f94007e1 	ldr	x1, [sp, #8]
    a0012d78:	f9000001 	str	x1, [x0]
	list->tail = (sys_dnode_t *)list;
    a0012d7c:	f94007e0 	ldr	x0, [sp, #8]
    a0012d80:	f94007e1 	ldr	x1, [sp, #8]
    a0012d84:	f9000401 	str	x1, [x0, #8]
}
    a0012d88:	d503201f 	nop
    a0012d8c:	910043ff 	add	sp, sp, #0x10
    a0012d90:	d65f03c0 	ret

00000000a0012d94 <sys_dlist_is_empty>:
 *
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
    a0012d94:	d10043ff 	sub	sp, sp, #0x10
    a0012d98:	f90007e0 	str	x0, [sp, #8]
	return list->head == list;
    a0012d9c:	f94007e0 	ldr	x0, [sp, #8]
    a0012da0:	f9400000 	ldr	x0, [x0]
    a0012da4:	f94007e1 	ldr	x1, [sp, #8]
    a0012da8:	eb00003f 	cmp	x1, x0
    a0012dac:	1a9f17e0 	cset	w0, eq  // eq = none
    a0012db0:	12001c00 	and	w0, w0, #0xff
}
    a0012db4:	910043ff 	add	sp, sp, #0x10
    a0012db8:	d65f03c0 	ret

00000000a0012dbc <sys_dlist_peek_head>:
 *
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
    a0012dbc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0012dc0:	910003fd 	mov	x29, sp
    a0012dc4:	f9000fe0 	str	x0, [sp, #24]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    a0012dc8:	f9400fe0 	ldr	x0, [sp, #24]
    a0012dcc:	97fffff2 	bl	a0012d94 <sys_dlist_is_empty>
    a0012dd0:	12001c00 	and	w0, w0, #0xff
    a0012dd4:	7100001f 	cmp	w0, #0x0
    a0012dd8:	54000081 	b.ne	a0012de8 <sys_dlist_peek_head+0x2c>  // b.any
    a0012ddc:	f9400fe0 	ldr	x0, [sp, #24]
    a0012de0:	f9400000 	ldr	x0, [x0]
    a0012de4:	14000002 	b	a0012dec <sys_dlist_peek_head+0x30>
    a0012de8:	d2800000 	mov	x0, #0x0                   	// #0
}
    a0012dec:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0012df0:	d65f03c0 	ret

00000000a0012df4 <z_is_under_prio_ceiling>:
{
    a0012df4:	d10043ff 	sub	sp, sp, #0x10
    a0012df8:	b9000fe0 	str	w0, [sp, #12]
	return prio >= CONFIG_PRIORITY_CEILING;
    a0012dfc:	b9400fe0 	ldr	w0, [sp, #12]
    a0012e00:	3101fc1f 	cmn	w0, #0x7f
    a0012e04:	1a9fb7e0 	cset	w0, ge  // ge = tcont
    a0012e08:	12001c00 	and	w0, w0, #0xff
}
    a0012e0c:	910043ff 	add	sp, sp, #0x10
    a0012e10:	d65f03c0 	ret

00000000a0012e14 <z_get_new_prio_with_ceiling>:
{
    a0012e14:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0012e18:	910003fd 	mov	x29, sp
    a0012e1c:	b9001fe0 	str	w0, [sp, #28]
	return z_is_under_prio_ceiling(prio) ? prio : CONFIG_PRIORITY_CEILING;
    a0012e20:	b9401fe0 	ldr	w0, [sp, #28]
    a0012e24:	97fffff4 	bl	a0012df4 <z_is_under_prio_ceiling>
    a0012e28:	12001c00 	and	w0, w0, #0xff
    a0012e2c:	7100001f 	cmp	w0, #0x0
    a0012e30:	54000060 	b.eq	a0012e3c <z_get_new_prio_with_ceiling+0x28>  // b.none
    a0012e34:	b9401fe0 	ldr	w0, [sp, #28]
    a0012e38:	14000002 	b	a0012e40 <z_get_new_prio_with_ceiling+0x2c>
    a0012e3c:	12800fc0 	mov	w0, #0xffffff81            	// #-127
}
    a0012e40:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0012e44:	d65f03c0 	ret

00000000a0012e48 <z_is_prio1_higher_than_prio2>:
{
    a0012e48:	d10043ff 	sub	sp, sp, #0x10
    a0012e4c:	b9000fe0 	str	w0, [sp, #12]
    a0012e50:	b9000be1 	str	w1, [sp, #8]
	return prio1 < prio2;
    a0012e54:	b9400fe1 	ldr	w1, [sp, #12]
    a0012e58:	b9400be0 	ldr	w0, [sp, #8]
    a0012e5c:	6b00003f 	cmp	w1, w0
    a0012e60:	1a9fa7e0 	cset	w0, lt  // lt = tstop
    a0012e64:	12001c00 	and	w0, w0, #0xff
}
    a0012e68:	910043ff 	add	sp, sp, #0x10
    a0012e6c:	d65f03c0 	ret

00000000a0012e70 <z_is_prio_higher>:
{
    a0012e70:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0012e74:	910003fd 	mov	x29, sp
    a0012e78:	b9001fe0 	str	w0, [sp, #28]
    a0012e7c:	b9001be1 	str	w1, [sp, #24]
	return z_is_prio1_higher_than_prio2(prio, test_prio);
    a0012e80:	b9401be1 	ldr	w1, [sp, #24]
    a0012e84:	b9401fe0 	ldr	w0, [sp, #28]
    a0012e88:	97fffff0 	bl	a0012e48 <z_is_prio1_higher_than_prio2>
    a0012e8c:	12001c00 	and	w0, w0, #0xff
}
    a0012e90:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0012e94:	d65f03c0 	ret

00000000a0012e98 <z_sched_lock>:
	--_current->base.sched_locked;
    a0012e98:	b00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0012e9c:	913f8000 	add	x0, x0, #0xfe0
    a0012ea0:	f9400800 	ldr	x0, [x0, #16]
    a0012ea4:	39406c01 	ldrb	w1, [x0, #27]
    a0012ea8:	51000421 	sub	w1, w1, #0x1
    a0012eac:	12001c21 	and	w1, w1, #0xff
    a0012eb0:	39006c01 	strb	w1, [x0, #27]
}
    a0012eb4:	d503201f 	nop
    a0012eb8:	d65f03c0 	ret

00000000a0012ebc <z_waitq_init>:
{
    a0012ebc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0012ec0:	910003fd 	mov	x29, sp
    a0012ec4:	f9000fe0 	str	x0, [sp, #24]
	sys_dlist_init(&w->waitq);
    a0012ec8:	f9400fe0 	ldr	x0, [sp, #24]
    a0012ecc:	97ffffa7 	bl	a0012d68 <sys_dlist_init>
}
    a0012ed0:	d503201f 	nop
    a0012ed4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0012ed8:	d65f03c0 	ret

00000000a0012edc <z_waitq_head>:

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
    a0012edc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0012ee0:	910003fd 	mov	x29, sp
    a0012ee4:	f9000fe0 	str	x0, [sp, #24]
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
    a0012ee8:	f9400fe0 	ldr	x0, [sp, #24]
    a0012eec:	97ffffb4 	bl	a0012dbc <sys_dlist_peek_head>
}
    a0012ef0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0012ef4:	d65f03c0 	ret

00000000a0012ef8 <z_obj_validation_check>:
{
    a0012ef8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    a0012efc:	910003fd 	mov	x29, sp
    a0012f00:	f90017e0 	str	x0, [sp, #40]
    a0012f04:	f90013e1 	str	x1, [sp, #32]
    a0012f08:	b9001fe2 	str	w2, [sp, #28]
    a0012f0c:	b9001be3 	str	w3, [sp, #24]
	ret = z_object_validate(ko, otype, init);
    a0012f10:	b9401be2 	ldr	w2, [sp, #24]
    a0012f14:	b9401fe1 	ldr	w1, [sp, #28]
    a0012f18:	f94017e0 	ldr	x0, [sp, #40]
    a0012f1c:	940028ea 	bl	a001d2c4 <z_object_validate>
    a0012f20:	b9003fe0 	str	w0, [sp, #60]
	return ret;
    a0012f24:	b9403fe0 	ldr	w0, [sp, #60]
}
    a0012f28:	a8c47bfd 	ldp	x29, x30, [sp], #64
    a0012f2c:	d65f03c0 	ret

00000000a0012f30 <z_impl_k_mutex_init>:
 * under the scheduler lock so we can break this up.
 */
static struct k_spinlock lock;

int z_impl_k_mutex_init(struct k_mutex *mutex)
{
    a0012f30:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0012f34:	910003fd 	mov	x29, sp
    a0012f38:	f9000fe0 	str	x0, [sp, #24]
	mutex->owner = NULL;
    a0012f3c:	f9400fe0 	ldr	x0, [sp, #24]
    a0012f40:	f900081f 	str	xzr, [x0, #16]
	mutex->lock_count = 0U;
    a0012f44:	f9400fe0 	ldr	x0, [sp, #24]
    a0012f48:	b900181f 	str	wzr, [x0, #24]

	z_waitq_init(&mutex->wait_q);
    a0012f4c:	f9400fe0 	ldr	x0, [sp, #24]
    a0012f50:	97ffffdb 	bl	a0012ebc <z_waitq_init>

	z_object_init(mutex);
    a0012f54:	f9400fe0 	ldr	x0, [sp, #24]
    a0012f58:	9400292e 	bl	a001d410 <z_object_init>

	SYS_PORT_TRACING_OBJ_INIT(k_mutex, mutex, 0);

	return 0;
    a0012f5c:	52800000 	mov	w0, #0x0                   	// #0
}
    a0012f60:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0012f64:	d65f03c0 	ret

00000000a0012f68 <z_vrfy_k_mutex_init>:

#ifdef CONFIG_USERSPACE
static inline int z_vrfy_k_mutex_init(struct k_mutex *mutex)
{
    a0012f68:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a0012f6c:	910003fd 	mov	x29, sp
    a0012f70:	f9000fe0 	str	x0, [sp, #24]
	Z_OOPS(Z_SYSCALL_OBJ_INIT(mutex, K_OBJ_MUTEX));
    a0012f74:	f9400fe0 	ldr	x0, [sp, #24]
    a0012f78:	940026ac 	bl	a001ca28 <z_object_find>
    a0012f7c:	52800023 	mov	w3, #0x1                   	// #1
    a0012f80:	52800062 	mov	w2, #0x3                   	// #3
    a0012f84:	f9400fe1 	ldr	x1, [sp, #24]
    a0012f88:	97ffffdc 	bl	a0012ef8 <z_obj_validation_check>
    a0012f8c:	7100001f 	cmp	w0, #0x0
    a0012f90:	1a9f07e0 	cset	w0, ne  // ne = any
    a0012f94:	39063fe0 	strb	w0, [sp, #399]
    a0012f98:	39463fe0 	ldrb	w0, [sp, #399]
    a0012f9c:	7100001f 	cmp	w0, #0x0
    a0012fa0:	39463fe0 	ldrb	w0, [sp, #399]
    a0012fa4:	7100001f 	cmp	w0, #0x0
    a0012fa8:	540000c0 	b.eq	a0012fc0 <z_vrfy_k_mutex_init+0x58>  // b.none
    a0012fac:	b00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0012fb0:	913f8000 	add	x0, x0, #0xfe0
    a0012fb4:	f9400800 	ldr	x0, [x0, #16]
    a0012fb8:	f9408400 	ldr	x0, [x0, #264]
    a0012fbc:	97ffd867 	bl	a0009158 <arch_syscall_oops>
	return z_impl_k_mutex_init(mutex);
    a0012fc0:	f9400fe0 	ldr	x0, [sp, #24]
    a0012fc4:	97ffffdb 	bl	a0012f30 <z_impl_k_mutex_init>
}
    a0012fc8:	a8d97bfd 	ldp	x29, x30, [sp], #400
    a0012fcc:	d65f03c0 	ret

00000000a0012fd0 <z_mrsh_k_mutex_init>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_mutex_init(struct k_mutex * mutex);
uintptr_t z_mrsh_k_mutex_init(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a0012fd0:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a0012fd4:	910003fd 	mov	x29, sp
    a0012fd8:	f90027e0 	str	x0, [sp, #72]
    a0012fdc:	f90023e1 	str	x1, [sp, #64]
    a0012fe0:	f9001fe2 	str	x2, [sp, #56]
    a0012fe4:	f9001be3 	str	x3, [sp, #48]
    a0012fe8:	f90017e4 	str	x4, [sp, #40]
    a0012fec:	f90013e5 	str	x5, [sp, #32]
    a0012ff0:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a0012ff4:	b00001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0012ff8:	913f8000 	add	x0, x0, #0xfe0
    a0012ffc:	f9400800 	ldr	x0, [x0, #16]
    a0013000:	f9400fe1 	ldr	x1, [sp, #24]
    a0013004:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_mutex_init(*(struct k_mutex **)&arg0)
    a0013008:	910123e0 	add	x0, sp, #0x48
    a001300c:	f9400000 	ldr	x0, [x0]
    a0013010:	97ffffd6 	bl	a0012f68 <z_vrfy_k_mutex_init>
    a0013014:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a0013018:	900001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001301c:	913f8000 	add	x0, x0, #0xfe0
    a0013020:	f9400800 	ldr	x0, [x0, #16]
    a0013024:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a0013028:	b9805fe0 	ldrsw	x0, [sp, #92]
}
    a001302c:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a0013030:	d65f03c0 	ret

00000000a0013034 <new_prio_for_inheritance>:
#include <syscalls/k_mutex_init_mrsh.c>
#endif

static int32_t new_prio_for_inheritance(int32_t target, int32_t limit)
{
    a0013034:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0013038:	910003fd 	mov	x29, sp
    a001303c:	b9001fe0 	str	w0, [sp, #28]
    a0013040:	b9001be1 	str	w1, [sp, #24]
	int new_prio = z_is_prio_higher(target, limit) ? target : limit;
    a0013044:	b9401be1 	ldr	w1, [sp, #24]
    a0013048:	b9401fe0 	ldr	w0, [sp, #28]
    a001304c:	97ffff89 	bl	a0012e70 <z_is_prio_higher>
    a0013050:	12001c00 	and	w0, w0, #0xff
    a0013054:	7100001f 	cmp	w0, #0x0
    a0013058:	54000060 	b.eq	a0013064 <new_prio_for_inheritance+0x30>  // b.none
    a001305c:	b9401fe0 	ldr	w0, [sp, #28]
    a0013060:	14000002 	b	a0013068 <new_prio_for_inheritance+0x34>
    a0013064:	b9401be0 	ldr	w0, [sp, #24]
    a0013068:	b9002fe0 	str	w0, [sp, #44]

	new_prio = z_get_new_prio_with_ceiling(new_prio);
    a001306c:	b9402fe0 	ldr	w0, [sp, #44]
    a0013070:	97ffff69 	bl	a0012e14 <z_get_new_prio_with_ceiling>
    a0013074:	b9002fe0 	str	w0, [sp, #44]

	return new_prio;
    a0013078:	b9402fe0 	ldr	w0, [sp, #44]
}
    a001307c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0013080:	d65f03c0 	ret

00000000a0013084 <adjust_owner_prio>:

static bool adjust_owner_prio(struct k_mutex *mutex, int32_t new_prio)
{
    a0013084:	a9a27bfd 	stp	x29, x30, [sp, #-480]!
    a0013088:	910003fd 	mov	x29, sp
    a001308c:	f9000fe0 	str	x0, [sp, #24]
    a0013090:	b90017e1 	str	w1, [sp, #20]
	if (mutex->owner->base.prio != new_prio) {
    a0013094:	f9400fe0 	ldr	x0, [sp, #24]
    a0013098:	f9400800 	ldr	x0, [x0, #16]
    a001309c:	39c06800 	ldrsb	w0, [x0, #26]
    a00130a0:	2a0003e1 	mov	w1, w0
    a00130a4:	b94017e0 	ldr	w0, [sp, #20]
    a00130a8:	6b01001f 	cmp	w0, w1
    a00130ac:	540000e0 	b.eq	a00130c8 <adjust_owner_prio+0x44>  // b.none
		LOG_DBG("%p (ready (y/n): %c) prio changed to %d (was %d)",
			mutex->owner, z_is_thread_ready(mutex->owner) ?
			'y' : 'n',
			new_prio, mutex->owner->base.prio);

		return z_set_prio(mutex->owner, new_prio);
    a00130b0:	f9400fe0 	ldr	x0, [sp, #24]
    a00130b4:	f9400800 	ldr	x0, [x0, #16]
    a00130b8:	b94017e1 	ldr	w1, [sp, #20]
    a00130bc:	9400133f 	bl	a0017db8 <z_set_prio>
    a00130c0:	12001c00 	and	w0, w0, #0xff
    a00130c4:	14000002 	b	a00130cc <adjust_owner_prio+0x48>
	}
	return false;
    a00130c8:	52800000 	mov	w0, #0x0                   	// #0
}
    a00130cc:	a8de7bfd 	ldp	x29, x30, [sp], #480
    a00130d0:	d65f03c0 	ret

00000000a00130d4 <z_impl_k_mutex_lock>:

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
    a00130d4:	d11403ff 	sub	sp, sp, #0x500
    a00130d8:	a9007bfd 	stp	x29, x30, [sp]
    a00130dc:	910003fd 	mov	x29, sp
    a00130e0:	f9000fe0 	str	x0, [sp, #24]
    a00130e4:	f9000be1 	str	x1, [sp, #16]
	int new_prio;
	k_spinlock_key_t key;
	bool resched = false;
    a00130e8:	39121fff 	strb	wzr, [sp, #1159]
    a00130ec:	b00001a0 	adrp	x0, a0048000 <_kernel+0x20>
    a00130f0:	910a4000 	add	x0, x0, #0x290
    a00130f4:	f90247e0 	str	x0, [sp, #1160]
MAKE_REG_HELPER(daif)
    a00130f8:	d53b4220 	mrs	x0, daif
    a00130fc:	f9024be0 	str	x0, [sp, #1168]
    a0013100:	f9424be0 	ldr	x0, [sp, #1168]
    a0013104:	d503201f 	nop
	key = read_daif();
    a0013108:	b9049fe0 	str	w0, [sp, #1180]
	__asm__ volatile ("msr DAIFSet, %0"
    a001310c:	d50342df 	msr	daifset, #0x2
}
    a0013110:	d503201f 	nop
	return key;
    a0013114:	b9449fe0 	ldr	w0, [sp, #1180]
	k.key = arch_irq_lock();
    a0013118:	b90453e0 	str	w0, [sp, #1104]
	return k;
    a001311c:	b94453e0 	ldr	w0, [sp, #1104]
    a0013120:	b90473e0 	str	w0, [sp, #1136]

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, lock, mutex, timeout);

	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
    a0013124:	f9400fe0 	ldr	x0, [sp, #24]
    a0013128:	b9401800 	ldr	w0, [x0, #24]
    a001312c:	7100001f 	cmp	w0, #0x0
    a0013130:	1a9f17e0 	cset	w0, eq  // eq = none
    a0013134:	12001c00 	and	w0, w0, #0xff
    a0013138:	92401c00 	and	x0, x0, #0xff
    a001313c:	f100001f 	cmp	x0, #0x0
    a0013140:	54000181 	b.ne	a0013170 <z_impl_k_mutex_lock+0x9c>  // b.any
    a0013144:	f9400fe0 	ldr	x0, [sp, #24]
    a0013148:	f9400801 	ldr	x1, [x0, #16]
    a001314c:	900001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0013150:	913f8000 	add	x0, x0, #0xfe0
    a0013154:	f9400800 	ldr	x0, [x0, #16]
    a0013158:	eb00003f 	cmp	x1, x0
    a001315c:	1a9f17e0 	cset	w0, eq  // eq = none
    a0013160:	12001c00 	and	w0, w0, #0xff
    a0013164:	92401c00 	and	x0, x0, #0xff
    a0013168:	f100001f 	cmp	x0, #0x0
    a001316c:	54000500 	b.eq	a001320c <z_impl_k_mutex_lock+0x138>  // b.none

		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
    a0013170:	f9400fe0 	ldr	x0, [sp, #24]
    a0013174:	b9401800 	ldr	w0, [x0, #24]
					_current->base.prio :
    a0013178:	7100001f 	cmp	w0, #0x0
    a001317c:	540000c1 	b.ne	a0013194 <z_impl_k_mutex_lock+0xc0>  // b.any
    a0013180:	900001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0013184:	913f8000 	add	x0, x0, #0xfe0
    a0013188:	f9400800 	ldr	x0, [x0, #16]
    a001318c:	39c06800 	ldrsb	w0, [x0, #26]
    a0013190:	14000003 	b	a001319c <z_impl_k_mutex_lock+0xc8>
    a0013194:	f9400fe0 	ldr	x0, [sp, #24]
    a0013198:	b9401c00 	ldr	w0, [x0, #28]
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
    a001319c:	f9400fe1 	ldr	x1, [sp, #24]
    a00131a0:	b9001c20 	str	w0, [x1, #28]
					mutex->owner_orig_prio;

		mutex->lock_count++;
    a00131a4:	f9400fe0 	ldr	x0, [sp, #24]
    a00131a8:	b9401800 	ldr	w0, [x0, #24]
    a00131ac:	11000401 	add	w1, w0, #0x1
    a00131b0:	f9400fe0 	ldr	x0, [sp, #24]
    a00131b4:	b9001801 	str	w1, [x0, #24]
		mutex->owner = _current;
    a00131b8:	900001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00131bc:	913f8000 	add	x0, x0, #0xfe0
    a00131c0:	f9400801 	ldr	x1, [x0, #16]
    a00131c4:	f9400fe0 	ldr	x0, [sp, #24]
    a00131c8:	f9000801 	str	x1, [x0, #16]
    a00131cc:	b00001a0 	adrp	x0, a0048000 <_kernel+0x20>
    a00131d0:	910a4000 	add	x0, x0, #0x290
    a00131d4:	f90253e0 	str	x0, [sp, #1184]
    a00131d8:	b94473e0 	ldr	w0, [sp, #1136]
    a00131dc:	b9045be0 	str	w0, [sp, #1112]
	arch_irq_unlock(key.key);
    a00131e0:	b9445be0 	ldr	w0, [sp, #1112]
    a00131e4:	b904afe0 	str	w0, [sp, #1196]
	write_daif(key);
    a00131e8:	b944afe0 	ldr	w0, [sp, #1196]
    a00131ec:	f9025fe0 	str	x0, [sp, #1208]
MAKE_REG_HELPER(daif)
    a00131f0:	f9425fe0 	ldr	x0, [sp, #1208]
    a00131f4:	d51b4220 	msr	daif, x0
    a00131f8:	d503201f 	nop
}
    a00131fc:	d503201f 	nop
}
    a0013200:	d503201f 	nop

		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);

		return 0;
    a0013204:	52800000 	mov	w0, #0x0                   	// #0
    a0013208:	14000086 	b	a0013420 <z_impl_k_mutex_lock+0x34c>
	}

	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
    a001320c:	f9400be0 	ldr	x0, [sp, #16]
    a0013210:	d2800001 	mov	x1, #0x0                   	// #0
    a0013214:	eb01001f 	cmp	x0, x1
    a0013218:	1a9f17e0 	cset	w0, eq  // eq = none
    a001321c:	12001c00 	and	w0, w0, #0xff
    a0013220:	92401c00 	and	x0, x0, #0xff
    a0013224:	f100001f 	cmp	x0, #0x0
    a0013228:	54000220 	b.eq	a001326c <z_impl_k_mutex_lock+0x198>  // b.none
    a001322c:	b00001a0 	adrp	x0, a0048000 <_kernel+0x20>
    a0013230:	910a4000 	add	x0, x0, #0x290
    a0013234:	f9025be0 	str	x0, [sp, #1200]
    a0013238:	b94473e0 	ldr	w0, [sp, #1136]
    a001323c:	b9038be0 	str	w0, [sp, #904]
	arch_irq_unlock(key.key);
    a0013240:	b9438be0 	ldr	w0, [sp, #904]
    a0013244:	b904c7e0 	str	w0, [sp, #1220]
	write_daif(key);
    a0013248:	b944c7e0 	ldr	w0, [sp, #1220]
    a001324c:	f9026be0 	str	x0, [sp, #1232]
    a0013250:	f9426be0 	ldr	x0, [sp, #1232]
    a0013254:	d51b4220 	msr	daif, x0
    a0013258:	d503201f 	nop
}
    a001325c:	d503201f 	nop
}
    a0013260:	d503201f 	nop
		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EBUSY);

		return -EBUSY;
    a0013264:	128001e0 	mov	w0, #0xfffffff0            	// #-16
    a0013268:	1400006e 	b	a0013420 <z_impl_k_mutex_lock+0x34c>
	}

	SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_mutex, lock, mutex, timeout);

	new_prio = new_prio_for_inheritance(_current->base.prio,
    a001326c:	900001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0013270:	913f8000 	add	x0, x0, #0xfe0
    a0013274:	f9400800 	ldr	x0, [x0, #16]
    a0013278:	39c06800 	ldrsb	w0, [x0, #26]
    a001327c:	2a0003e2 	mov	w2, w0
					    mutex->owner->base.prio);
    a0013280:	f9400fe0 	ldr	x0, [sp, #24]
    a0013284:	f9400800 	ldr	x0, [x0, #16]
    a0013288:	39c06800 	ldrsb	w0, [x0, #26]
	new_prio = new_prio_for_inheritance(_current->base.prio,
    a001328c:	2a0003e1 	mov	w1, w0
    a0013290:	2a0203e0 	mov	w0, w2
    a0013294:	97ffff68 	bl	a0013034 <new_prio_for_inheritance>
    a0013298:	b90483e0 	str	w0, [sp, #1152]

	LOG_DBG("adjusting prio up on mutex %p", mutex);

	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
    a001329c:	f9400fe0 	ldr	x0, [sp, #24]
    a00132a0:	f9400800 	ldr	x0, [x0, #16]
    a00132a4:	39c06800 	ldrsb	w0, [x0, #26]
    a00132a8:	2a0003e1 	mov	w1, w0
    a00132ac:	b94483e0 	ldr	w0, [sp, #1152]
    a00132b0:	97fffef0 	bl	a0012e70 <z_is_prio_higher>
    a00132b4:	12001c00 	and	w0, w0, #0xff
    a00132b8:	7100001f 	cmp	w0, #0x0
    a00132bc:	540000a0 	b.eq	a00132d0 <z_impl_k_mutex_lock+0x1fc>  // b.none
		resched = adjust_owner_prio(mutex, new_prio);
    a00132c0:	b94483e1 	ldr	w1, [sp, #1152]
    a00132c4:	f9400fe0 	ldr	x0, [sp, #24]
    a00132c8:	97ffff6f 	bl	a0013084 <adjust_owner_prio>
    a00132cc:	39121fe0 	strb	w0, [sp, #1159]
	}

	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
    a00132d0:	f9400fe0 	ldr	x0, [sp, #24]
    a00132d4:	f9400be3 	ldr	x3, [sp, #16]
    a00132d8:	aa0003e2 	mov	x2, x0
    a00132dc:	b94473e1 	ldr	w1, [sp, #1136]
    a00132e0:	b00001a0 	adrp	x0, a0048000 <_kernel+0x20>
    a00132e4:	910a4000 	add	x0, x0, #0x290
    a00132e8:	9400120d 	bl	a0017b1c <z_pend_curr>
    a00132ec:	b90477e0 	str	w0, [sp, #1140]
	LOG_DBG("on mutex %p got_mutex value: %d", mutex, got_mutex);

	LOG_DBG("%p got mutex %p (y/n): %c", _current, mutex,
		got_mutex ? 'y' : 'n');

	if (got_mutex == 0) {
    a00132f0:	b94477e0 	ldr	w0, [sp, #1140]
    a00132f4:	7100001f 	cmp	w0, #0x0
    a00132f8:	54000061 	b.ne	a0013304 <z_impl_k_mutex_lock+0x230>  // b.any
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);
		return 0;
    a00132fc:	52800000 	mov	w0, #0x0                   	// #0
    a0013300:	14000048 	b	a0013420 <z_impl_k_mutex_lock+0x34c>
    a0013304:	b00001a0 	adrp	x0, a0048000 <_kernel+0x20>
    a0013308:	910a4000 	add	x0, x0, #0x290
    a001330c:	f90267e0 	str	x0, [sp, #1224]
    a0013310:	d53b4220 	mrs	x0, daif
    a0013314:	f9026fe0 	str	x0, [sp, #1240]
    a0013318:	f9426fe0 	ldr	x0, [sp, #1240]
    a001331c:	d503201f 	nop
	key = read_daif();
    a0013320:	b904e7e0 	str	w0, [sp, #1252]
	__asm__ volatile ("msr DAIFSet, %0"
    a0013324:	d50342df 	msr	daifset, #0x2
}
    a0013328:	d503201f 	nop
	return key;
    a001332c:	b944e7e0 	ldr	w0, [sp, #1252]
	k.key = arch_irq_lock();
    a0013330:	b90463e0 	str	w0, [sp, #1120]
	return k;
    a0013334:	b94463e0 	ldr	w0, [sp, #1120]
    a0013338:	b90473e0 	str	w0, [sp, #1136]

	LOG_DBG("%p timeout on mutex %p", _current, mutex);

	key = k_spin_lock(&lock);

	struct k_thread *waiter = z_waitq_head(&mutex->wait_q);
    a001333c:	f9400fe0 	ldr	x0, [sp, #24]
    a0013340:	97fffee7 	bl	a0012edc <z_waitq_head>
    a0013344:	f9023fe0 	str	x0, [sp, #1144]

	new_prio = (waiter != NULL) ?
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
    a0013348:	f9423fe0 	ldr	x0, [sp, #1144]
    a001334c:	f100001f 	cmp	x0, #0x0
    a0013350:	54000140 	b.eq	a0013378 <z_impl_k_mutex_lock+0x2a4>  // b.none
    a0013354:	f9423fe0 	ldr	x0, [sp, #1144]
    a0013358:	39c06800 	ldrsb	w0, [x0, #26]
    a001335c:	2a0003e2 	mov	w2, w0
    a0013360:	f9400fe0 	ldr	x0, [sp, #24]
    a0013364:	b9401c00 	ldr	w0, [x0, #28]
    a0013368:	2a0003e1 	mov	w1, w0
    a001336c:	2a0203e0 	mov	w0, w2
    a0013370:	97ffff31 	bl	a0013034 <new_prio_for_inheritance>
    a0013374:	14000003 	b	a0013380 <z_impl_k_mutex_lock+0x2ac>
    a0013378:	f9400fe0 	ldr	x0, [sp, #24]
    a001337c:	b9401c00 	ldr	w0, [x0, #28]
	new_prio = (waiter != NULL) ?
    a0013380:	b90483e0 	str	w0, [sp, #1152]
		mutex->owner_orig_prio;

	LOG_DBG("adjusting prio down on mutex %p", mutex);

	resched = adjust_owner_prio(mutex, new_prio) || resched;
    a0013384:	b94483e1 	ldr	w1, [sp, #1152]
    a0013388:	f9400fe0 	ldr	x0, [sp, #24]
    a001338c:	97ffff3e 	bl	a0013084 <adjust_owner_prio>
    a0013390:	12001c00 	and	w0, w0, #0xff
    a0013394:	7100001f 	cmp	w0, #0x0
    a0013398:	54000081 	b.ne	a00133a8 <z_impl_k_mutex_lock+0x2d4>  // b.any
    a001339c:	39521fe0 	ldrb	w0, [sp, #1159]
    a00133a0:	7100001f 	cmp	w0, #0x0
    a00133a4:	54000060 	b.eq	a00133b0 <z_impl_k_mutex_lock+0x2dc>  // b.none
    a00133a8:	52800020 	mov	w0, #0x1                   	// #1
    a00133ac:	14000002 	b	a00133b4 <z_impl_k_mutex_lock+0x2e0>
    a00133b0:	52800000 	mov	w0, #0x0                   	// #0
    a00133b4:	39121fe0 	strb	w0, [sp, #1159]
    a00133b8:	39521fe0 	ldrb	w0, [sp, #1159]
    a00133bc:	12000000 	and	w0, w0, #0x1
    a00133c0:	39121fe0 	strb	w0, [sp, #1159]

	if (resched) {
    a00133c4:	39521fe0 	ldrb	w0, [sp, #1159]
    a00133c8:	7100001f 	cmp	w0, #0x0
    a00133cc:	540000c0 	b.eq	a00133e4 <z_impl_k_mutex_lock+0x310>  // b.none
		z_reschedule(&lock, key);
    a00133d0:	b94473e1 	ldr	w1, [sp, #1136]
    a00133d4:	b00001a0 	adrp	x0, a0048000 <_kernel+0x20>
    a00133d8:	910a4000 	add	x0, x0, #0x290
    a00133dc:	94001350 	bl	a001811c <z_reschedule>
    a00133e0:	1400000f 	b	a001341c <z_impl_k_mutex_lock+0x348>
    a00133e4:	b00001a0 	adrp	x0, a0048000 <_kernel+0x20>
    a00133e8:	910a4000 	add	x0, x0, #0x290
    a00133ec:	f90277e0 	str	x0, [sp, #1256]
    a00133f0:	b94473e0 	ldr	w0, [sp, #1136]
    a00133f4:	b9046be0 	str	w0, [sp, #1128]
	arch_irq_unlock(key.key);
    a00133f8:	b9446be0 	ldr	w0, [sp, #1128]
    a00133fc:	b904f7e0 	str	w0, [sp, #1268]
	write_daif(key);
    a0013400:	b944f7e0 	ldr	w0, [sp, #1268]
    a0013404:	f9027fe0 	str	x0, [sp, #1272]
MAKE_REG_HELPER(daif)
    a0013408:	f9427fe0 	ldr	x0, [sp, #1272]
    a001340c:	d51b4220 	msr	daif, x0
    a0013410:	d503201f 	nop
}
    a0013414:	d503201f 	nop
}
    a0013418:	d503201f 	nop
		k_spin_unlock(&lock, key);
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EAGAIN);

	return -EAGAIN;
    a001341c:	12800140 	mov	w0, #0xfffffff5            	// #-11
}
    a0013420:	a9407bfd 	ldp	x29, x30, [sp]
    a0013424:	911403ff 	add	sp, sp, #0x500
    a0013428:	d65f03c0 	ret

00000000a001342c <z_vrfy_k_mutex_lock>:

#ifdef CONFIG_USERSPACE
static inline int z_vrfy_k_mutex_lock(struct k_mutex *mutex,
				      k_timeout_t timeout)
{
    a001342c:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a0013430:	910003fd 	mov	x29, sp
    a0013434:	f9000fe0 	str	x0, [sp, #24]
    a0013438:	f9000be1 	str	x1, [sp, #16]
	Z_OOPS(Z_SYSCALL_OBJ(mutex, K_OBJ_MUTEX));
    a001343c:	f9400fe0 	ldr	x0, [sp, #24]
    a0013440:	9400257a 	bl	a001ca28 <z_object_find>
    a0013444:	52800003 	mov	w3, #0x0                   	// #0
    a0013448:	52800062 	mov	w2, #0x3                   	// #3
    a001344c:	f9400fe1 	ldr	x1, [sp, #24]
    a0013450:	97fffeaa 	bl	a0012ef8 <z_obj_validation_check>
    a0013454:	7100001f 	cmp	w0, #0x0
    a0013458:	1a9f07e0 	cset	w0, ne  // ne = any
    a001345c:	39063fe0 	strb	w0, [sp, #399]
    a0013460:	39463fe0 	ldrb	w0, [sp, #399]
    a0013464:	7100001f 	cmp	w0, #0x0
    a0013468:	39463fe0 	ldrb	w0, [sp, #399]
    a001346c:	7100001f 	cmp	w0, #0x0
    a0013470:	540000c0 	b.eq	a0013488 <z_vrfy_k_mutex_lock+0x5c>  // b.none
    a0013474:	900001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0013478:	913f8000 	add	x0, x0, #0xfe0
    a001347c:	f9400800 	ldr	x0, [x0, #16]
    a0013480:	f9408400 	ldr	x0, [x0, #264]
    a0013484:	97ffd735 	bl	a0009158 <arch_syscall_oops>
	return z_impl_k_mutex_lock(mutex, timeout);
    a0013488:	f9400be1 	ldr	x1, [sp, #16]
    a001348c:	f9400fe0 	ldr	x0, [sp, #24]
    a0013490:	97ffff11 	bl	a00130d4 <z_impl_k_mutex_lock>
}
    a0013494:	a8d97bfd 	ldp	x29, x30, [sp], #400
    a0013498:	d65f03c0 	ret

00000000a001349c <z_mrsh_k_mutex_lock>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_mutex_lock(struct k_mutex * mutex, k_timeout_t timeout);
uintptr_t z_mrsh_k_mutex_lock(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a001349c:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a00134a0:	910003fd 	mov	x29, sp
    a00134a4:	f90027e0 	str	x0, [sp, #72]
    a00134a8:	f90023e1 	str	x1, [sp, #64]
    a00134ac:	f9001fe2 	str	x2, [sp, #56]
    a00134b0:	f9001be3 	str	x3, [sp, #48]
    a00134b4:	f90017e4 	str	x4, [sp, #40]
    a00134b8:	f90013e5 	str	x5, [sp, #32]
    a00134bc:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a00134c0:	900001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00134c4:	913f8000 	add	x0, x0, #0xfe0
    a00134c8:	f9400800 	ldr	x0, [x0, #16]
    a00134cc:	f9400fe1 	ldr	x1, [sp, #24]
    a00134d0:	f9008401 	str	x1, [x0, #264]
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_mutex_lock(*(struct k_mutex **)&arg0, *(k_timeout_t*)&arg1)
    a00134d4:	910123e0 	add	x0, sp, #0x48
    a00134d8:	f9400002 	ldr	x2, [x0]
    a00134dc:	910103e0 	add	x0, sp, #0x40
    a00134e0:	f9400001 	ldr	x1, [x0]
    a00134e4:	aa0203e0 	mov	x0, x2
    a00134e8:	97ffffd1 	bl	a001342c <z_vrfy_k_mutex_lock>
    a00134ec:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a00134f0:	900001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00134f4:	913f8000 	add	x0, x0, #0xfe0
    a00134f8:	f9400800 	ldr	x0, [x0, #16]
    a00134fc:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a0013500:	b9805fe0 	ldrsw	x0, [sp, #92]
}
    a0013504:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a0013508:	d65f03c0 	ret

00000000a001350c <z_impl_k_mutex_unlock>:
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
    a001350c:	d10a83ff 	sub	sp, sp, #0x2a0
    a0013510:	a9007bfd 	stp	x29, x30, [sp]
    a0013514:	910003fd 	mov	x29, sp
    a0013518:	f9000fe0 	str	x0, [sp, #24]

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, unlock, mutex);

	CHECKIF(mutex->owner == NULL) {
    a001351c:	f9400fe0 	ldr	x0, [sp, #24]
    a0013520:	f9400800 	ldr	x0, [x0, #16]
    a0013524:	f100001f 	cmp	x0, #0x0
    a0013528:	54000061 	b.ne	a0013534 <z_impl_k_mutex_unlock+0x28>  // b.any
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, -EINVAL);

		return -EINVAL;
    a001352c:	128002a0 	mov	w0, #0xffffffea            	// #-22
    a0013530:	14000056 	b	a0013688 <z_impl_k_mutex_unlock+0x17c>
	}
	/*
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
    a0013534:	f9400fe0 	ldr	x0, [sp, #24]
    a0013538:	f9400801 	ldr	x1, [x0, #16]
    a001353c:	900001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0013540:	913f8000 	add	x0, x0, #0xfe0
    a0013544:	f9400800 	ldr	x0, [x0, #16]
    a0013548:	eb00003f 	cmp	x1, x0
    a001354c:	54000060 	b.eq	a0013558 <z_impl_k_mutex_unlock+0x4c>  // b.none
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, -EPERM);

		return -EPERM;
    a0013550:	12800000 	mov	w0, #0xffffffff            	// #-1
    a0013554:	1400004d 	b	a0013688 <z_impl_k_mutex_unlock+0x17c>
	 * therefore no underflow check is required. Use assert to catch
	 * undefined behavior.
	 */
	__ASSERT_NO_MSG(mutex->lock_count > 0U);

	z_sched_lock();
    a0013558:	97fffe50 	bl	a0012e98 <z_sched_lock>

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count > 1U) {
    a001355c:	f9400fe0 	ldr	x0, [sp, #24]
    a0013560:	b9401800 	ldr	w0, [x0, #24]
    a0013564:	7100041f 	cmp	w0, #0x1
    a0013568:	540000e9 	b.ls	a0013584 <z_impl_k_mutex_unlock+0x78>  // b.plast
		mutex->lock_count--;
    a001356c:	f9400fe0 	ldr	x0, [sp, #24]
    a0013570:	b9401800 	ldr	w0, [x0, #24]
    a0013574:	51000401 	sub	w1, w0, #0x1
    a0013578:	f9400fe0 	ldr	x0, [sp, #24]
    a001357c:	b9001801 	str	w1, [x0, #24]
		goto k_mutex_unlock_return;
    a0013580:	14000040 	b	a0013680 <z_impl_k_mutex_unlock+0x174>
    a0013584:	b00001a0 	adrp	x0, a0048000 <_kernel+0x20>
    a0013588:	910a4000 	add	x0, x0, #0x290
    a001358c:	f90133e0 	str	x0, [sp, #608]
    a0013590:	d53b4220 	mrs	x0, daif
    a0013594:	f90137e0 	str	x0, [sp, #616]
    a0013598:	f94137e0 	ldr	x0, [sp, #616]
    a001359c:	d503201f 	nop
	key = read_daif();
    a00135a0:	b90277e0 	str	w0, [sp, #628]
	__asm__ volatile ("msr DAIFSet, %0"
    a00135a4:	d50342df 	msr	daifset, #0x2
}
    a00135a8:	d503201f 	nop
	return key;
    a00135ac:	b94277e0 	ldr	w0, [sp, #628]
	k.key = arch_irq_lock();
    a00135b0:	b90243e0 	str	w0, [sp, #576]
	return k;
    a00135b4:	b94243e0 	ldr	w0, [sp, #576]
    a00135b8:	b90253e0 	str	w0, [sp, #592]
	}

	k_spinlock_key_t key = k_spin_lock(&lock);

	adjust_owner_prio(mutex, mutex->owner_orig_prio);
    a00135bc:	f9400fe0 	ldr	x0, [sp, #24]
    a00135c0:	b9401c00 	ldr	w0, [x0, #28]
    a00135c4:	2a0003e1 	mov	w1, w0
    a00135c8:	f9400fe0 	ldr	x0, [sp, #24]
    a00135cc:	97fffeae 	bl	a0013084 <adjust_owner_prio>

	/* Get the new owner, if any */
	new_owner = z_unpend_first_thread(&mutex->wait_q);
    a00135d0:	f9400fe0 	ldr	x0, [sp, #24]
    a00135d4:	94001195 	bl	a0017c28 <z_unpend_first_thread>
    a00135d8:	f9012fe0 	str	x0, [sp, #600]

	mutex->owner = new_owner;
    a00135dc:	f9400fe0 	ldr	x0, [sp, #24]
    a00135e0:	f9412fe1 	ldr	x1, [sp, #600]
    a00135e4:	f9000801 	str	x1, [x0, #16]

	LOG_DBG("new owner of mutex %p: %p (prio: %d)",
		mutex, new_owner, new_owner ? new_owner->base.prio : -1000);

	if (new_owner != NULL) {
    a00135e8:	f9412fe0 	ldr	x0, [sp, #600]
    a00135ec:	f100001f 	cmp	x0, #0x0
    a00135f0:	54000280 	b.eq	a0013640 <z_impl_k_mutex_unlock+0x134>  // b.none
		/*
		 * new owner is already of higher or equal prio than first
		 * waiter since the wait queue is priority-based: no need to
		 * ajust its priority
		 */
		mutex->owner_orig_prio = new_owner->base.prio;
    a00135f4:	f9412fe0 	ldr	x0, [sp, #600]
    a00135f8:	39c06800 	ldrsb	w0, [x0, #26]
    a00135fc:	2a0003e1 	mov	w1, w0
    a0013600:	f9400fe0 	ldr	x0, [sp, #24]
    a0013604:	b9001c01 	str	w1, [x0, #28]
    a0013608:	f9412fe0 	ldr	x0, [sp, #600]
    a001360c:	f9013fe0 	str	x0, [sp, #632]
    a0013610:	b90287ff 	str	wzr, [sp, #644]
 * z_swap() is in use it's a simple inline provided by the kernel.
 */
static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->swap_retval = value;
    a0013614:	b94287e1 	ldr	w1, [sp, #644]
    a0013618:	f9413fe0 	ldr	x0, [sp, #632]
    a001361c:	b9011001 	str	w1, [x0, #272]
}
    a0013620:	d503201f 	nop
		arch_thread_return_value_set(new_owner, 0);
		z_ready_thread(new_owner);
    a0013624:	f9412fe0 	ldr	x0, [sp, #600]
    a0013628:	94000eb2 	bl	a00170f0 <z_ready_thread>
		z_reschedule(&lock, key);
    a001362c:	b94253e1 	ldr	w1, [sp, #592]
    a0013630:	b00001a0 	adrp	x0, a0048000 <_kernel+0x20>
    a0013634:	910a4000 	add	x0, x0, #0x290
    a0013638:	940012b9 	bl	a001811c <z_reschedule>
    a001363c:	14000011 	b	a0013680 <z_impl_k_mutex_unlock+0x174>
	} else {
		mutex->lock_count = 0U;
    a0013640:	f9400fe0 	ldr	x0, [sp, #24]
    a0013644:	b900181f 	str	wzr, [x0, #24]
    a0013648:	b00001a0 	adrp	x0, a0048000 <_kernel+0x20>
    a001364c:	910a4000 	add	x0, x0, #0x290
    a0013650:	f90147e0 	str	x0, [sp, #648]
    a0013654:	b94253e0 	ldr	w0, [sp, #592]
    a0013658:	b9024be0 	str	w0, [sp, #584]
	arch_irq_unlock(key.key);
    a001365c:	b9424be0 	ldr	w0, [sp, #584]
    a0013660:	b90297e0 	str	w0, [sp, #660]
	write_daif(key);
    a0013664:	b94297e0 	ldr	w0, [sp, #660]
    a0013668:	f9014fe0 	str	x0, [sp, #664]
MAKE_REG_HELPER(daif)
    a001366c:	f9414fe0 	ldr	x0, [sp, #664]
    a0013670:	d51b4220 	msr	daif, x0
    a0013674:	d503201f 	nop
}
    a0013678:	d503201f 	nop
}
    a001367c:	d503201f 	nop


k_mutex_unlock_return:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, 0);

	k_sched_unlock();
    a0013680:	94001308 	bl	a00182a0 <k_sched_unlock>

	return 0;
    a0013684:	52800000 	mov	w0, #0x0                   	// #0
}
    a0013688:	a9407bfd 	ldp	x29, x30, [sp]
    a001368c:	910a83ff 	add	sp, sp, #0x2a0
    a0013690:	d65f03c0 	ret

00000000a0013694 <z_vrfy_k_mutex_unlock>:

#ifdef CONFIG_USERSPACE
static inline int z_vrfy_k_mutex_unlock(struct k_mutex *mutex)
{
    a0013694:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a0013698:	910003fd 	mov	x29, sp
    a001369c:	f9000fe0 	str	x0, [sp, #24]
	Z_OOPS(Z_SYSCALL_OBJ(mutex, K_OBJ_MUTEX));
    a00136a0:	f9400fe0 	ldr	x0, [sp, #24]
    a00136a4:	940024e1 	bl	a001ca28 <z_object_find>
    a00136a8:	52800003 	mov	w3, #0x0                   	// #0
    a00136ac:	52800062 	mov	w2, #0x3                   	// #3
    a00136b0:	f9400fe1 	ldr	x1, [sp, #24]
    a00136b4:	97fffe11 	bl	a0012ef8 <z_obj_validation_check>
    a00136b8:	7100001f 	cmp	w0, #0x0
    a00136bc:	1a9f07e0 	cset	w0, ne  // ne = any
    a00136c0:	39063fe0 	strb	w0, [sp, #399]
    a00136c4:	39463fe0 	ldrb	w0, [sp, #399]
    a00136c8:	7100001f 	cmp	w0, #0x0
    a00136cc:	39463fe0 	ldrb	w0, [sp, #399]
    a00136d0:	7100001f 	cmp	w0, #0x0
    a00136d4:	540000c0 	b.eq	a00136ec <z_vrfy_k_mutex_unlock+0x58>  // b.none
    a00136d8:	900001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00136dc:	913f8000 	add	x0, x0, #0xfe0
    a00136e0:	f9400800 	ldr	x0, [x0, #16]
    a00136e4:	f9408400 	ldr	x0, [x0, #264]
    a00136e8:	97ffd69c 	bl	a0009158 <arch_syscall_oops>
	return z_impl_k_mutex_unlock(mutex);
    a00136ec:	f9400fe0 	ldr	x0, [sp, #24]
    a00136f0:	97ffff87 	bl	a001350c <z_impl_k_mutex_unlock>
}
    a00136f4:	a8d97bfd 	ldp	x29, x30, [sp], #400
    a00136f8:	d65f03c0 	ret

00000000a00136fc <z_mrsh_k_mutex_unlock>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_mutex_unlock(struct k_mutex * mutex);
uintptr_t z_mrsh_k_mutex_unlock(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a00136fc:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a0013700:	910003fd 	mov	x29, sp
    a0013704:	f90027e0 	str	x0, [sp, #72]
    a0013708:	f90023e1 	str	x1, [sp, #64]
    a001370c:	f9001fe2 	str	x2, [sp, #56]
    a0013710:	f9001be3 	str	x3, [sp, #48]
    a0013714:	f90017e4 	str	x4, [sp, #40]
    a0013718:	f90013e5 	str	x5, [sp, #32]
    a001371c:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a0013720:	900001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0013724:	913f8000 	add	x0, x0, #0xfe0
    a0013728:	f9400800 	ldr	x0, [x0, #16]
    a001372c:	f9400fe1 	ldr	x1, [sp, #24]
    a0013730:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_mutex_unlock(*(struct k_mutex **)&arg0)
    a0013734:	910123e0 	add	x0, sp, #0x48
    a0013738:	f9400000 	ldr	x0, [x0]
    a001373c:	97ffffd6 	bl	a0013694 <z_vrfy_k_mutex_unlock>
    a0013740:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a0013744:	900001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0013748:	913f8000 	add	x0, x0, #0xfe0
    a001374c:	f9400800 	ldr	x0, [x0, #16]
    a0013750:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a0013754:	b9805fe0 	ldrsw	x0, [sp, #92]
}
    a0013758:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a001375c:	d65f03c0 	ret

00000000a0013760 <sys_dlist_init>:
{
    a0013760:	d10043ff 	sub	sp, sp, #0x10
    a0013764:	f90007e0 	str	x0, [sp, #8]
	list->head = (sys_dnode_t *)list;
    a0013768:	f94007e0 	ldr	x0, [sp, #8]
    a001376c:	f94007e1 	ldr	x1, [sp, #8]
    a0013770:	f9000001 	str	x1, [x0]
	list->tail = (sys_dnode_t *)list;
    a0013774:	f94007e0 	ldr	x0, [sp, #8]
    a0013778:	f94007e1 	ldr	x1, [sp, #8]
    a001377c:	f9000401 	str	x1, [x0, #8]
}
    a0013780:	d503201f 	nop
    a0013784:	910043ff 	add	sp, sp, #0x10
    a0013788:	d65f03c0 	ret

00000000a001378c <sys_sflist_init>:
 * @brief Initialize a list
 *
 * @param list A pointer on the list to initialize
 */
static inline void sys_sflist_init(sys_sflist_t *list)
{
    a001378c:	d10043ff 	sub	sp, sp, #0x10
    a0013790:	f90007e0 	str	x0, [sp, #8]
	list->head = NULL;
    a0013794:	f94007e0 	ldr	x0, [sp, #8]
    a0013798:	f900001f 	str	xzr, [x0]
	list->tail = NULL;
    a001379c:	f94007e0 	ldr	x0, [sp, #8]
    a00137a0:	f900041f 	str	xzr, [x0, #8]
}
    a00137a4:	d503201f 	nop
    a00137a8:	910043ff 	add	sp, sp, #0x10
    a00137ac:	d65f03c0 	ret

00000000a00137b0 <z_sfnode_next_peek>:

#define SYS_SFLIST_STATIC_INIT(ptr_to_list) {NULL, NULL}
#define SYS_SFLIST_FLAGS_MASK	0x3UL

static inline sys_sfnode_t *z_sfnode_next_peek(sys_sfnode_t *node)
{
    a00137b0:	d10043ff 	sub	sp, sp, #0x10
    a00137b4:	f90007e0 	str	x0, [sp, #8]
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
    a00137b8:	f94007e0 	ldr	x0, [sp, #8]
    a00137bc:	f9400000 	ldr	x0, [x0]
    a00137c0:	927ef400 	and	x0, x0, #0xfffffffffffffffc
}
    a00137c4:	910043ff 	add	sp, sp, #0x10
    a00137c8:	d65f03c0 	ret

00000000a00137cc <z_sfnode_next_set>:

static inline uint8_t sys_sfnode_flags_get(sys_sfnode_t *node);

static inline void z_sfnode_next_set(sys_sfnode_t *parent,
				       sys_sfnode_t *child)
{
    a00137cc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a00137d0:	910003fd 	mov	x29, sp
    a00137d4:	f9000fe0 	str	x0, [sp, #24]
    a00137d8:	f9000be1 	str	x1, [sp, #16]
	uint8_t cur_flags = sys_sfnode_flags_get(parent);
    a00137dc:	f9400fe0 	ldr	x0, [sp, #24]
    a00137e0:	94000028 	bl	a0013880 <sys_sfnode_flags_get>
    a00137e4:	3900bfe0 	strb	w0, [sp, #47]

	parent->next_and_flags = cur_flags | (unative_t)child;
    a00137e8:	3940bfe1 	ldrb	w1, [sp, #47]
    a00137ec:	f9400be0 	ldr	x0, [sp, #16]
    a00137f0:	aa000021 	orr	x1, x1, x0
    a00137f4:	f9400fe0 	ldr	x0, [sp, #24]
    a00137f8:	f9000001 	str	x1, [x0]
}
    a00137fc:	d503201f 	nop
    a0013800:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0013804:	d65f03c0 	ret

00000000a0013808 <z_sflist_head_set>:

static inline void z_sflist_head_set(sys_sflist_t *list, sys_sfnode_t *node)
{
    a0013808:	d10043ff 	sub	sp, sp, #0x10
    a001380c:	f90007e0 	str	x0, [sp, #8]
    a0013810:	f90003e1 	str	x1, [sp]
	list->head = node;
    a0013814:	f94007e0 	ldr	x0, [sp, #8]
    a0013818:	f94003e1 	ldr	x1, [sp]
    a001381c:	f9000001 	str	x1, [x0]
}
    a0013820:	d503201f 	nop
    a0013824:	910043ff 	add	sp, sp, #0x10
    a0013828:	d65f03c0 	ret

00000000a001382c <z_sflist_tail_set>:

static inline void z_sflist_tail_set(sys_sflist_t *list, sys_sfnode_t *node)
{
    a001382c:	d10043ff 	sub	sp, sp, #0x10
    a0013830:	f90007e0 	str	x0, [sp, #8]
    a0013834:	f90003e1 	str	x1, [sp]
	list->tail = node;
    a0013838:	f94007e0 	ldr	x0, [sp, #8]
    a001383c:	f94003e1 	ldr	x1, [sp]
    a0013840:	f9000401 	str	x1, [x0, #8]
}
    a0013844:	d503201f 	nop
    a0013848:	910043ff 	add	sp, sp, #0x10
    a001384c:	d65f03c0 	ret

00000000a0013850 <sys_sflist_peek_head>:
 * @param list A point on the list to peek the first node from
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_sfnode_t *sys_sflist_peek_head(sys_sflist_t *list)
{
    a0013850:	d10043ff 	sub	sp, sp, #0x10
    a0013854:	f90007e0 	str	x0, [sp, #8]
	return list->head;
    a0013858:	f94007e0 	ldr	x0, [sp, #8]
    a001385c:	f9400000 	ldr	x0, [x0]
}
    a0013860:	910043ff 	add	sp, sp, #0x10
    a0013864:	d65f03c0 	ret

00000000a0013868 <sys_sflist_peek_tail>:
 * @param list A point on the list to peek the last node from
 *
 * @return A pointer on the last node of the list (or NULL if none)
 */
static inline sys_sfnode_t *sys_sflist_peek_tail(sys_sflist_t *list)
{
    a0013868:	d10043ff 	sub	sp, sp, #0x10
    a001386c:	f90007e0 	str	x0, [sp, #8]
	return list->tail;
    a0013870:	f94007e0 	ldr	x0, [sp, #8]
    a0013874:	f9400400 	ldr	x0, [x0, #8]
}
    a0013878:	910043ff 	add	sp, sp, #0x10
    a001387c:	d65f03c0 	ret

00000000a0013880 <sys_sfnode_flags_get>:
 *
 * @param node A pointer to the node to fetch flags from
 * @return The value of flags, which will be between 0 and 3
 */
static inline uint8_t sys_sfnode_flags_get(sys_sfnode_t *node)
{
    a0013880:	d10043ff 	sub	sp, sp, #0x10
    a0013884:	f90007e0 	str	x0, [sp, #8]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
    a0013888:	f94007e0 	ldr	x0, [sp, #8]
    a001388c:	f9400000 	ldr	x0, [x0]
    a0013890:	12001c00 	and	w0, w0, #0xff
    a0013894:	12000400 	and	w0, w0, #0x3
    a0013898:	12001c00 	and	w0, w0, #0xff
}
    a001389c:	910043ff 	add	sp, sp, #0x10
    a00138a0:	d65f03c0 	ret

00000000a00138a4 <sys_sfnode_init>:
 *
 * @param node A pointer to the node to set the flags on
 * @param flags A value between 0 and 3 to set the flags value
 */
static inline void sys_sfnode_init(sys_sfnode_t *node, uint8_t flags)
{
    a00138a4:	d10043ff 	sub	sp, sp, #0x10
    a00138a8:	f90007e0 	str	x0, [sp, #8]
    a00138ac:	39001fe1 	strb	w1, [sp, #7]
	__ASSERT((flags & ~SYS_SFLIST_FLAGS_MASK) == 0UL, "flags too large");
	node->next_and_flags = flags;
    a00138b0:	39401fe1 	ldrb	w1, [sp, #7]
    a00138b4:	f94007e0 	ldr	x0, [sp, #8]
    a00138b8:	f9000001 	str	x1, [x0]
}
    a00138bc:	d503201f 	nop
    a00138c0:	910043ff 	add	sp, sp, #0x10
    a00138c4:	d65f03c0 	ret

00000000a00138c8 <sys_sflist_is_empty>:
 *
 * @return a boolean, true if it's empty, false otherwise
 */
static inline bool sys_sflist_is_empty(sys_sflist_t *list);

Z_GENLIST_IS_EMPTY(sflist)
    a00138c8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a00138cc:	910003fd 	mov	x29, sp
    a00138d0:	f9000fe0 	str	x0, [sp, #24]
    a00138d4:	f9400fe0 	ldr	x0, [sp, #24]
    a00138d8:	97ffffde 	bl	a0013850 <sys_sflist_peek_head>
    a00138dc:	f100001f 	cmp	x0, #0x0
    a00138e0:	1a9f17e0 	cset	w0, eq  // eq = none
    a00138e4:	12001c00 	and	w0, w0, #0xff
    a00138e8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a00138ec:	d65f03c0 	ret

00000000a00138f0 <sys_sflist_prepend>:
 * @param node A pointer on the node to prepend
 */
static inline void sys_sflist_prepend(sys_sflist_t *list,
				      sys_sfnode_t *node);

Z_GENLIST_PREPEND(sflist, sfnode)
    a00138f0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a00138f4:	910003fd 	mov	x29, sp
    a00138f8:	f9000fe0 	str	x0, [sp, #24]
    a00138fc:	f9000be1 	str	x1, [sp, #16]
    a0013900:	f9400fe0 	ldr	x0, [sp, #24]
    a0013904:	97ffffd3 	bl	a0013850 <sys_sflist_peek_head>
    a0013908:	aa0003e1 	mov	x1, x0
    a001390c:	f9400be0 	ldr	x0, [sp, #16]
    a0013910:	97ffffaf 	bl	a00137cc <z_sfnode_next_set>
    a0013914:	f9400be1 	ldr	x1, [sp, #16]
    a0013918:	f9400fe0 	ldr	x0, [sp, #24]
    a001391c:	97ffffbb 	bl	a0013808 <z_sflist_head_set>
    a0013920:	f9400fe0 	ldr	x0, [sp, #24]
    a0013924:	97ffffd1 	bl	a0013868 <sys_sflist_peek_tail>
    a0013928:	f100001f 	cmp	x0, #0x0
    a001392c:	540000c1 	b.ne	a0013944 <sys_sflist_prepend+0x54>  // b.any
    a0013930:	f9400fe0 	ldr	x0, [sp, #24]
    a0013934:	97ffffc7 	bl	a0013850 <sys_sflist_peek_head>
    a0013938:	aa0003e1 	mov	x1, x0
    a001393c:	f9400fe0 	ldr	x0, [sp, #24]
    a0013940:	97ffffbb 	bl	a001382c <z_sflist_tail_set>
    a0013944:	d503201f 	nop
    a0013948:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a001394c:	d65f03c0 	ret

00000000a0013950 <sys_sflist_append>:
 * @param node A pointer on the node to append
 */
static inline void sys_sflist_append(sys_sflist_t *list,
				     sys_sfnode_t *node);

Z_GENLIST_APPEND(sflist, sfnode)
    a0013950:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0013954:	910003fd 	mov	x29, sp
    a0013958:	f9000fe0 	str	x0, [sp, #24]
    a001395c:	f9000be1 	str	x1, [sp, #16]
    a0013960:	d2800001 	mov	x1, #0x0                   	// #0
    a0013964:	f9400be0 	ldr	x0, [sp, #16]
    a0013968:	97ffff99 	bl	a00137cc <z_sfnode_next_set>
    a001396c:	f9400fe0 	ldr	x0, [sp, #24]
    a0013970:	97ffffbe 	bl	a0013868 <sys_sflist_peek_tail>
    a0013974:	f100001f 	cmp	x0, #0x0
    a0013978:	54000101 	b.ne	a0013998 <sys_sflist_append+0x48>  // b.any
    a001397c:	f9400be1 	ldr	x1, [sp, #16]
    a0013980:	f9400fe0 	ldr	x0, [sp, #24]
    a0013984:	97ffffaa 	bl	a001382c <z_sflist_tail_set>
    a0013988:	f9400be1 	ldr	x1, [sp, #16]
    a001398c:	f9400fe0 	ldr	x0, [sp, #24]
    a0013990:	97ffff9e 	bl	a0013808 <z_sflist_head_set>
    a0013994:	14000008 	b	a00139b4 <sys_sflist_append+0x64>
    a0013998:	f9400fe0 	ldr	x0, [sp, #24]
    a001399c:	97ffffb3 	bl	a0013868 <sys_sflist_peek_tail>
    a00139a0:	f9400be1 	ldr	x1, [sp, #16]
    a00139a4:	97ffff8a 	bl	a00137cc <z_sfnode_next_set>
    a00139a8:	f9400be1 	ldr	x1, [sp, #16]
    a00139ac:	f9400fe0 	ldr	x0, [sp, #24]
    a00139b0:	97ffff9f 	bl	a001382c <z_sflist_tail_set>
    a00139b4:	d503201f 	nop
    a00139b8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a00139bc:	d65f03c0 	ret

00000000a00139c0 <sys_sflist_insert>:
 */
static inline void sys_sflist_insert(sys_sflist_t *list,
				     sys_sfnode_t *prev,
				     sys_sfnode_t *node);

Z_GENLIST_INSERT(sflist, sfnode)
    a00139c0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a00139c4:	910003fd 	mov	x29, sp
    a00139c8:	f90017e0 	str	x0, [sp, #40]
    a00139cc:	f90013e1 	str	x1, [sp, #32]
    a00139d0:	f9000fe2 	str	x2, [sp, #24]
    a00139d4:	f94013e0 	ldr	x0, [sp, #32]
    a00139d8:	f100001f 	cmp	x0, #0x0
    a00139dc:	540000a1 	b.ne	a00139f0 <sys_sflist_insert+0x30>  // b.any
    a00139e0:	f9400fe1 	ldr	x1, [sp, #24]
    a00139e4:	f94017e0 	ldr	x0, [sp, #40]
    a00139e8:	97ffffc2 	bl	a00138f0 <sys_sflist_prepend>
    a00139ec:	14000011 	b	a0013a30 <sys_sflist_insert+0x70>
    a00139f0:	f94013e0 	ldr	x0, [sp, #32]
    a00139f4:	97ffff6f 	bl	a00137b0 <z_sfnode_next_peek>
    a00139f8:	f100001f 	cmp	x0, #0x0
    a00139fc:	540000a1 	b.ne	a0013a10 <sys_sflist_insert+0x50>  // b.any
    a0013a00:	f9400fe1 	ldr	x1, [sp, #24]
    a0013a04:	f94017e0 	ldr	x0, [sp, #40]
    a0013a08:	97ffffd2 	bl	a0013950 <sys_sflist_append>
    a0013a0c:	14000009 	b	a0013a30 <sys_sflist_insert+0x70>
    a0013a10:	f94013e0 	ldr	x0, [sp, #32]
    a0013a14:	97ffff67 	bl	a00137b0 <z_sfnode_next_peek>
    a0013a18:	aa0003e1 	mov	x1, x0
    a0013a1c:	f9400fe0 	ldr	x0, [sp, #24]
    a0013a20:	97ffff6b 	bl	a00137cc <z_sfnode_next_set>
    a0013a24:	f9400fe1 	ldr	x1, [sp, #24]
    a0013a28:	f94013e0 	ldr	x0, [sp, #32]
    a0013a2c:	97ffff68 	bl	a00137cc <z_sfnode_next_set>
    a0013a30:	d503201f 	nop
    a0013a34:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0013a38:	d65f03c0 	ret

00000000a0013a3c <sys_sflist_get_not_empty>:
 *
 * @return A pointer to the first node of the list
 */
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);

Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
    a0013a3c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0013a40:	910003fd 	mov	x29, sp
    a0013a44:	f9000fe0 	str	x0, [sp, #24]
    a0013a48:	f9400fe0 	ldr	x0, [sp, #24]
    a0013a4c:	97ffff81 	bl	a0013850 <sys_sflist_peek_head>
    a0013a50:	f90017e0 	str	x0, [sp, #40]
    a0013a54:	f94017e0 	ldr	x0, [sp, #40]
    a0013a58:	97ffff56 	bl	a00137b0 <z_sfnode_next_peek>
    a0013a5c:	aa0003e1 	mov	x1, x0
    a0013a60:	f9400fe0 	ldr	x0, [sp, #24]
    a0013a64:	97ffff69 	bl	a0013808 <z_sflist_head_set>
    a0013a68:	f9400fe0 	ldr	x0, [sp, #24]
    a0013a6c:	97ffff7f 	bl	a0013868 <sys_sflist_peek_tail>
    a0013a70:	aa0003e1 	mov	x1, x0
    a0013a74:	f94017e0 	ldr	x0, [sp, #40]
    a0013a78:	eb01001f 	cmp	x0, x1
    a0013a7c:	540000c1 	b.ne	a0013a94 <sys_sflist_get_not_empty+0x58>  // b.any
    a0013a80:	f9400fe0 	ldr	x0, [sp, #24]
    a0013a84:	97ffff73 	bl	a0013850 <sys_sflist_peek_head>
    a0013a88:	aa0003e1 	mov	x1, x0
    a0013a8c:	f9400fe0 	ldr	x0, [sp, #24]
    a0013a90:	97ffff67 	bl	a001382c <z_sflist_tail_set>
    a0013a94:	f94017e0 	ldr	x0, [sp, #40]
    a0013a98:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0013a9c:	d65f03c0 	ret

00000000a0013aa0 <z_impl_k_queue_is_empty>:
{
    a0013aa0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0013aa4:	910003fd 	mov	x29, sp
    a0013aa8:	f9000fe0 	str	x0, [sp, #24]
	return (int)sys_sflist_is_empty(&queue->data_q);
    a0013aac:	f9400fe0 	ldr	x0, [sp, #24]
    a0013ab0:	97ffff86 	bl	a00138c8 <sys_sflist_is_empty>
    a0013ab4:	12001c00 	and	w0, w0, #0xff
}
    a0013ab8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0013abc:	d65f03c0 	ret

00000000a0013ac0 <z_waitq_init>:
{
    a0013ac0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0013ac4:	910003fd 	mov	x29, sp
    a0013ac8:	f9000fe0 	str	x0, [sp, #24]
	sys_dlist_init(&w->waitq);
    a0013acc:	f9400fe0 	ldr	x0, [sp, #24]
    a0013ad0:	97ffff24 	bl	a0013760 <sys_dlist_init>
}
    a0013ad4:	d503201f 	nop
    a0013ad8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0013adc:	d65f03c0 	ret

00000000a0013ae0 <z_thread_malloc>:
{
    a0013ae0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0013ae4:	910003fd 	mov	x29, sp
    a0013ae8:	f9000fe0 	str	x0, [sp, #24]
	return z_thread_aligned_alloc(0, size);
    a0013aec:	f9400fe1 	ldr	x1, [sp, #24]
    a0013af0:	d2800000 	mov	x0, #0x0                   	// #0
    a0013af4:	94001efc 	bl	a001b6e4 <z_thread_aligned_alloc>
}
    a0013af8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0013afc:	d65f03c0 	ret

00000000a0013b00 <z_obj_validation_check>:
{
    a0013b00:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    a0013b04:	910003fd 	mov	x29, sp
    a0013b08:	f90017e0 	str	x0, [sp, #40]
    a0013b0c:	f90013e1 	str	x1, [sp, #32]
    a0013b10:	b9001fe2 	str	w2, [sp, #28]
    a0013b14:	b9001be3 	str	w3, [sp, #24]
	ret = z_object_validate(ko, otype, init);
    a0013b18:	b9401be2 	ldr	w2, [sp, #24]
    a0013b1c:	b9401fe1 	ldr	w1, [sp, #28]
    a0013b20:	f94017e0 	ldr	x0, [sp, #40]
    a0013b24:	940025e8 	bl	a001d2c4 <z_object_validate>
    a0013b28:	b9003fe0 	str	w0, [sp, #60]
	return ret;
    a0013b2c:	b9403fe0 	ldr	w0, [sp, #60]
}
    a0013b30:	a8c47bfd 	ldp	x29, x30, [sp], #64
    a0013b34:	d65f03c0 	ret

00000000a0013b38 <z_queue_node_peek>:
	sys_sfnode_t node;
	void *data;
};

void *z_queue_node_peek(sys_sfnode_t *node, bool needs_free)
{
    a0013b38:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0013b3c:	910003fd 	mov	x29, sp
    a0013b40:	f9000fe0 	str	x0, [sp, #24]
    a0013b44:	39005fe1 	strb	w1, [sp, #23]
	void *ret;

	if ((node != NULL) && (sys_sfnode_flags_get(node) != (uint8_t)0)) {
    a0013b48:	f9400fe0 	ldr	x0, [sp, #24]
    a0013b4c:	f100001f 	cmp	x0, #0x0
    a0013b50:	54000220 	b.eq	a0013b94 <z_queue_node_peek+0x5c>  // b.none
    a0013b54:	f9400fe0 	ldr	x0, [sp, #24]
    a0013b58:	97ffff4a 	bl	a0013880 <sys_sfnode_flags_get>
    a0013b5c:	12001c00 	and	w0, w0, #0xff
    a0013b60:	7100001f 	cmp	w0, #0x0
    a0013b64:	54000180 	b.eq	a0013b94 <z_queue_node_peek+0x5c>  // b.none
		 * struct, which is what got put in the queue. Free it and pass
		 * back the data pointer.
		 */
		struct alloc_node *anode;

		anode = CONTAINER_OF(node, struct alloc_node, node);
    a0013b68:	f9400fe0 	ldr	x0, [sp, #24]
    a0013b6c:	f90013e0 	str	x0, [sp, #32]
		ret = anode->data;
    a0013b70:	f94013e0 	ldr	x0, [sp, #32]
    a0013b74:	f9400400 	ldr	x0, [x0, #8]
    a0013b78:	f90017e0 	str	x0, [sp, #40]
		if (needs_free) {
    a0013b7c:	39405fe0 	ldrb	w0, [sp, #23]
    a0013b80:	7100001f 	cmp	w0, #0x0
    a0013b84:	540000e0 	b.eq	a0013ba0 <z_queue_node_peek+0x68>  // b.none
			k_free(anode);
    a0013b88:	f94013e0 	ldr	x0, [sp, #32]
    a0013b8c:	94001ec2 	bl	a001b694 <k_free>
	if ((node != NULL) && (sys_sfnode_flags_get(node) != (uint8_t)0)) {
    a0013b90:	14000004 	b	a0013ba0 <z_queue_node_peek+0x68>
	} else {
		/* Data was directly placed in the queue, the first word
		 * reserved for the linked list. User mode isn't allowed to
		 * do this, although it can get data sent this way.
		 */
		ret = (void *)node;
    a0013b94:	f9400fe0 	ldr	x0, [sp, #24]
    a0013b98:	f90017e0 	str	x0, [sp, #40]
    a0013b9c:	14000002 	b	a0013ba4 <z_queue_node_peek+0x6c>
	if ((node != NULL) && (sys_sfnode_flags_get(node) != (uint8_t)0)) {
    a0013ba0:	d503201f 	nop
	}

	return ret;
    a0013ba4:	f94017e0 	ldr	x0, [sp, #40]
}
    a0013ba8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0013bac:	d65f03c0 	ret

00000000a0013bb0 <z_impl_k_queue_init>:

void z_impl_k_queue_init(struct k_queue *queue)
{
    a0013bb0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0013bb4:	910003fd 	mov	x29, sp
    a0013bb8:	f9000fe0 	str	x0, [sp, #24]
	sys_sflist_init(&queue->data_q);
    a0013bbc:	f9400fe0 	ldr	x0, [sp, #24]
    a0013bc0:	97fffef3 	bl	a001378c <sys_sflist_init>
	queue->lock = (struct k_spinlock) {};
	z_waitq_init(&queue->wait_q);
    a0013bc4:	f9400fe0 	ldr	x0, [sp, #24]
    a0013bc8:	91004000 	add	x0, x0, #0x10
    a0013bcc:	97ffffbd 	bl	a0013ac0 <z_waitq_init>
	sys_dlist_init(&queue->poll_events);
#endif

	SYS_PORT_TRACING_OBJ_INIT(k_queue, queue);

	z_object_init(queue);
    a0013bd0:	f9400fe0 	ldr	x0, [sp, #24]
    a0013bd4:	9400260f 	bl	a001d410 <z_object_init>
}
    a0013bd8:	d503201f 	nop
    a0013bdc:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0013be0:	d65f03c0 	ret

00000000a0013be4 <z_vrfy_k_queue_init>:

#ifdef CONFIG_USERSPACE
static inline void z_vrfy_k_queue_init(struct k_queue *queue)
{
    a0013be4:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a0013be8:	910003fd 	mov	x29, sp
    a0013bec:	f9000fe0 	str	x0, [sp, #24]
	Z_OOPS(Z_SYSCALL_OBJ_NEVER_INIT(queue, K_OBJ_QUEUE));
    a0013bf0:	f9400fe0 	ldr	x0, [sp, #24]
    a0013bf4:	9400238d 	bl	a001ca28 <z_object_find>
    a0013bf8:	12800003 	mov	w3, #0xffffffff            	// #-1
    a0013bfc:	528000a2 	mov	w2, #0x5                   	// #5
    a0013c00:	f9400fe1 	ldr	x1, [sp, #24]
    a0013c04:	97ffffbf 	bl	a0013b00 <z_obj_validation_check>
    a0013c08:	7100001f 	cmp	w0, #0x0
    a0013c0c:	1a9f07e0 	cset	w0, ne  // ne = any
    a0013c10:	39063fe0 	strb	w0, [sp, #399]
    a0013c14:	39463fe0 	ldrb	w0, [sp, #399]
    a0013c18:	7100001f 	cmp	w0, #0x0
    a0013c1c:	39463fe0 	ldrb	w0, [sp, #399]
    a0013c20:	7100001f 	cmp	w0, #0x0
    a0013c24:	540000c0 	b.eq	a0013c3c <z_vrfy_k_queue_init+0x58>  // b.none
    a0013c28:	900001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0013c2c:	913f8000 	add	x0, x0, #0xfe0
    a0013c30:	f9400800 	ldr	x0, [x0, #16]
    a0013c34:	f9408400 	ldr	x0, [x0, #264]
    a0013c38:	97ffd548 	bl	a0009158 <arch_syscall_oops>
	z_impl_k_queue_init(queue);
    a0013c3c:	f9400fe0 	ldr	x0, [sp, #24]
    a0013c40:	97ffffdc 	bl	a0013bb0 <z_impl_k_queue_init>
}
    a0013c44:	d503201f 	nop
    a0013c48:	a8d97bfd 	ldp	x29, x30, [sp], #400
    a0013c4c:	d65f03c0 	ret

00000000a0013c50 <z_mrsh_k_queue_init>:
#include <syscalls/kernel.h>

extern void z_vrfy_k_queue_init(struct k_queue * queue);
uintptr_t z_mrsh_k_queue_init(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a0013c50:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a0013c54:	910003fd 	mov	x29, sp
    a0013c58:	f90027e0 	str	x0, [sp, #72]
    a0013c5c:	f90023e1 	str	x1, [sp, #64]
    a0013c60:	f9001fe2 	str	x2, [sp, #56]
    a0013c64:	f9001be3 	str	x3, [sp, #48]
    a0013c68:	f90017e4 	str	x4, [sp, #40]
    a0013c6c:	f90013e5 	str	x5, [sp, #32]
    a0013c70:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a0013c74:	900001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0013c78:	913f8000 	add	x0, x0, #0xfe0
    a0013c7c:	f9400800 	ldr	x0, [x0, #16]
    a0013c80:	f9400fe1 	ldr	x1, [sp, #24]
    a0013c84:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_queue_init(*(struct k_queue **)&arg0)
    a0013c88:	910123e0 	add	x0, sp, #0x48
    a0013c8c:	f9400000 	ldr	x0, [x0]
    a0013c90:	97ffffd5 	bl	a0013be4 <z_vrfy_k_queue_init>
;
	_current->syscall_frame = NULL;
    a0013c94:	900001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0013c98:	913f8000 	add	x0, x0, #0xfe0
    a0013c9c:	f9400800 	ldr	x0, [x0, #16]
    a0013ca0:	f900841f 	str	xzr, [x0, #264]
	return 0;
    a0013ca4:	d2800000 	mov	x0, #0x0                   	// #0
}
    a0013ca8:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a0013cac:	d65f03c0 	ret

00000000a0013cb0 <prepare_thread_to_run>:
#include <syscalls/k_queue_init_mrsh.c>
#endif

static void prepare_thread_to_run(struct k_thread *thread, void *data)
{
    a0013cb0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a0013cb4:	910003fd 	mov	x29, sp
    a0013cb8:	f9000fe0 	str	x0, [sp, #24]
    a0013cbc:	f9000be1 	str	x1, [sp, #16]
    a0013cc0:	f9400fe0 	ldr	x0, [sp, #24]
    a0013cc4:	f90027e0 	str	x0, [sp, #72]
    a0013cc8:	b90047ff 	str	wzr, [sp, #68]
    a0013ccc:	f9400be0 	ldr	x0, [sp, #16]
    a0013cd0:	f9001fe0 	str	x0, [sp, #56]
    a0013cd4:	f94027e0 	ldr	x0, [sp, #72]
    a0013cd8:	f9001be0 	str	x0, [sp, #48]
    a0013cdc:	b94047e0 	ldr	w0, [sp, #68]
    a0013ce0:	b9002fe0 	str	w0, [sp, #44]
	thread->swap_retval = value;
    a0013ce4:	b9402fe1 	ldr	w1, [sp, #44]
    a0013ce8:	f9401be0 	ldr	x0, [sp, #48]
    a0013cec:	b9011001 	str	w1, [x0, #272]
}
    a0013cf0:	d503201f 	nop
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
    a0013cf4:	f94027e0 	ldr	x0, [sp, #72]
    a0013cf8:	f9401fe1 	ldr	x1, [sp, #56]
    a0013cfc:	f9001001 	str	x1, [x0, #32]
}
    a0013d00:	d503201f 	nop
	z_thread_return_value_set_with_data(thread, 0, data);
	z_ready_thread(thread);
    a0013d04:	f9400fe0 	ldr	x0, [sp, #24]
    a0013d08:	94000cfa 	bl	a00170f0 <z_ready_thread>
}
    a0013d0c:	d503201f 	nop
    a0013d10:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a0013d14:	d65f03c0 	ret

00000000a0013d18 <handle_poll_events>:

static inline void handle_poll_events(struct k_queue *queue, uint32_t state)
{
    a0013d18:	d10043ff 	sub	sp, sp, #0x10
    a0013d1c:	f90007e0 	str	x0, [sp, #8]
    a0013d20:	b90007e1 	str	w1, [sp, #4]
#ifdef CONFIG_POLL
	z_handle_obj_poll_events(&queue->poll_events, state);
#endif
}
    a0013d24:	d503201f 	nop
    a0013d28:	910043ff 	add	sp, sp, #0x10
    a0013d2c:	d65f03c0 	ret

00000000a0013d30 <z_impl_k_queue_cancel_wait>:

void z_impl_k_queue_cancel_wait(struct k_queue *queue)
{
    a0013d30:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a0013d34:	910003fd 	mov	x29, sp
    a0013d38:	f9000fe0 	str	x0, [sp, #24]
	SYS_PORT_TRACING_OBJ_FUNC(k_queue, cancel_wait, queue);

	k_spinlock_key_t key = k_spin_lock(&queue->lock);
    a0013d3c:	f9400fe0 	ldr	x0, [sp, #24]
    a0013d40:	91004000 	add	x0, x0, #0x10
    a0013d44:	f90023e0 	str	x0, [sp, #64]
    a0013d48:	d53b4220 	mrs	x0, daif
    a0013d4c:	f9001fe0 	str	x0, [sp, #56]
    a0013d50:	f9401fe0 	ldr	x0, [sp, #56]
    a0013d54:	d503201f 	nop
	key = read_daif();
    a0013d58:	b90037e0 	str	w0, [sp, #52]
	__asm__ volatile ("msr DAIFSet, %0"
    a0013d5c:	d50342df 	msr	daifset, #0x2
}
    a0013d60:	d503201f 	nop
	return key;
    a0013d64:	b94037e0 	ldr	w0, [sp, #52]
	k.key = arch_irq_lock();
    a0013d68:	b9002be0 	str	w0, [sp, #40]
	return k;
    a0013d6c:	b9402be0 	ldr	w0, [sp, #40]
    a0013d70:	b90033e0 	str	w0, [sp, #48]
	struct k_thread *first_pending_thread;

	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
    a0013d74:	f9400fe0 	ldr	x0, [sp, #24]
    a0013d78:	91004000 	add	x0, x0, #0x10
    a0013d7c:	94000fab 	bl	a0017c28 <z_unpend_first_thread>
    a0013d80:	f90027e0 	str	x0, [sp, #72]

	if (first_pending_thread != NULL) {
    a0013d84:	f94027e0 	ldr	x0, [sp, #72]
    a0013d88:	f100001f 	cmp	x0, #0x0
    a0013d8c:	54000080 	b.eq	a0013d9c <z_impl_k_queue_cancel_wait+0x6c>  // b.none
		prepare_thread_to_run(first_pending_thread, NULL);
    a0013d90:	d2800001 	mov	x1, #0x0                   	// #0
    a0013d94:	f94027e0 	ldr	x0, [sp, #72]
    a0013d98:	97ffffc6 	bl	a0013cb0 <prepare_thread_to_run>
	}

	handle_poll_events(queue, K_POLL_STATE_CANCELLED);
    a0013d9c:	52800101 	mov	w1, #0x8                   	// #8
    a0013da0:	f9400fe0 	ldr	x0, [sp, #24]
    a0013da4:	97ffffdd 	bl	a0013d18 <handle_poll_events>
	z_reschedule(&queue->lock, key);
    a0013da8:	f9400fe0 	ldr	x0, [sp, #24]
    a0013dac:	91004000 	add	x0, x0, #0x10
    a0013db0:	b94033e1 	ldr	w1, [sp, #48]
    a0013db4:	940010da 	bl	a001811c <z_reschedule>
}
    a0013db8:	d503201f 	nop
    a0013dbc:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a0013dc0:	d65f03c0 	ret

00000000a0013dc4 <z_vrfy_k_queue_cancel_wait>:

#ifdef CONFIG_USERSPACE
static inline void z_vrfy_k_queue_cancel_wait(struct k_queue *queue)
{
    a0013dc4:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a0013dc8:	910003fd 	mov	x29, sp
    a0013dcc:	f9000fe0 	str	x0, [sp, #24]
	Z_OOPS(Z_SYSCALL_OBJ(queue, K_OBJ_QUEUE));
    a0013dd0:	f9400fe0 	ldr	x0, [sp, #24]
    a0013dd4:	94002315 	bl	a001ca28 <z_object_find>
    a0013dd8:	52800003 	mov	w3, #0x0                   	// #0
    a0013ddc:	528000a2 	mov	w2, #0x5                   	// #5
    a0013de0:	f9400fe1 	ldr	x1, [sp, #24]
    a0013de4:	97ffff47 	bl	a0013b00 <z_obj_validation_check>
    a0013de8:	7100001f 	cmp	w0, #0x0
    a0013dec:	1a9f07e0 	cset	w0, ne  // ne = any
    a0013df0:	39063fe0 	strb	w0, [sp, #399]
    a0013df4:	39463fe0 	ldrb	w0, [sp, #399]
    a0013df8:	7100001f 	cmp	w0, #0x0
    a0013dfc:	39463fe0 	ldrb	w0, [sp, #399]
    a0013e00:	7100001f 	cmp	w0, #0x0
    a0013e04:	540000c0 	b.eq	a0013e1c <z_vrfy_k_queue_cancel_wait+0x58>  // b.none
    a0013e08:	900001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0013e0c:	913f8000 	add	x0, x0, #0xfe0
    a0013e10:	f9400800 	ldr	x0, [x0, #16]
    a0013e14:	f9408400 	ldr	x0, [x0, #264]
    a0013e18:	97ffd4d0 	bl	a0009158 <arch_syscall_oops>
	z_impl_k_queue_cancel_wait(queue);
    a0013e1c:	f9400fe0 	ldr	x0, [sp, #24]
    a0013e20:	97ffffc4 	bl	a0013d30 <z_impl_k_queue_cancel_wait>
}
    a0013e24:	d503201f 	nop
    a0013e28:	a8d97bfd 	ldp	x29, x30, [sp], #400
    a0013e2c:	d65f03c0 	ret

00000000a0013e30 <z_mrsh_k_queue_cancel_wait>:
#include <syscalls/kernel.h>

extern void z_vrfy_k_queue_cancel_wait(struct k_queue * queue);
uintptr_t z_mrsh_k_queue_cancel_wait(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a0013e30:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a0013e34:	910003fd 	mov	x29, sp
    a0013e38:	f90027e0 	str	x0, [sp, #72]
    a0013e3c:	f90023e1 	str	x1, [sp, #64]
    a0013e40:	f9001fe2 	str	x2, [sp, #56]
    a0013e44:	f9001be3 	str	x3, [sp, #48]
    a0013e48:	f90017e4 	str	x4, [sp, #40]
    a0013e4c:	f90013e5 	str	x5, [sp, #32]
    a0013e50:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a0013e54:	900001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0013e58:	913f8000 	add	x0, x0, #0xfe0
    a0013e5c:	f9400800 	ldr	x0, [x0, #16]
    a0013e60:	f9400fe1 	ldr	x1, [sp, #24]
    a0013e64:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_queue_cancel_wait(*(struct k_queue **)&arg0)
    a0013e68:	910123e0 	add	x0, sp, #0x48
    a0013e6c:	f9400000 	ldr	x0, [x0]
    a0013e70:	97ffffd5 	bl	a0013dc4 <z_vrfy_k_queue_cancel_wait>
;
	_current->syscall_frame = NULL;
    a0013e74:	900001a0 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0013e78:	913f8000 	add	x0, x0, #0xfe0
    a0013e7c:	f9400800 	ldr	x0, [x0, #16]
    a0013e80:	f900841f 	str	xzr, [x0, #264]
	return 0;
    a0013e84:	d2800000 	mov	x0, #0x0                   	// #0
}
    a0013e88:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a0013e8c:	d65f03c0 	ret

00000000a0013e90 <queue_insert>:
#include <syscalls/k_queue_cancel_wait_mrsh.c>
#endif

static int32_t queue_insert(struct k_queue *queue, void *prev, void *data,
			    bool alloc, bool is_append)
{
    a0013e90:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
    a0013e94:	910003fd 	mov	x29, sp
    a0013e98:	f90017e0 	str	x0, [sp, #40]
    a0013e9c:	f90013e1 	str	x1, [sp, #32]
    a0013ea0:	f9000fe2 	str	x2, [sp, #24]
    a0013ea4:	39005fe3 	strb	w3, [sp, #23]
    a0013ea8:	39005be4 	strb	w4, [sp, #22]
	struct k_thread *first_pending_thread;
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
    a0013eac:	f94017e0 	ldr	x0, [sp, #40]
    a0013eb0:	91004000 	add	x0, x0, #0x10
    a0013eb4:	f9003fe0 	str	x0, [sp, #120]
MAKE_REG_HELPER(daif)
    a0013eb8:	d53b4220 	mrs	x0, daif
    a0013ebc:	f9003be0 	str	x0, [sp, #112]
    a0013ec0:	f9403be0 	ldr	x0, [sp, #112]
    a0013ec4:	d503201f 	nop
	key = read_daif();
    a0013ec8:	b9006fe0 	str	w0, [sp, #108]
	__asm__ volatile ("msr DAIFSet, %0"
    a0013ecc:	d50342df 	msr	daifset, #0x2
}
    a0013ed0:	d503201f 	nop
	return key;
    a0013ed4:	b9406fe0 	ldr	w0, [sp, #108]
	k.key = arch_irq_lock();
    a0013ed8:	b90043e0 	str	w0, [sp, #64]
	return k;
    a0013edc:	b94043e0 	ldr	w0, [sp, #64]
    a0013ee0:	b9004be0 	str	w0, [sp, #72]

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, queue_insert, queue, alloc);

	if (is_append) {
    a0013ee4:	39405be0 	ldrb	w0, [sp, #22]
    a0013ee8:	7100001f 	cmp	w0, #0x0
    a0013eec:	54000080 	b.eq	a0013efc <queue_insert+0x6c>  // b.none
		prev = sys_sflist_peek_tail(&queue->data_q);
    a0013ef0:	f94017e0 	ldr	x0, [sp, #40]
    a0013ef4:	97fffe5d 	bl	a0013868 <sys_sflist_peek_tail>
    a0013ef8:	f90013e0 	str	x0, [sp, #32]
	}
	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
    a0013efc:	f94017e0 	ldr	x0, [sp, #40]
    a0013f00:	91004000 	add	x0, x0, #0x10
    a0013f04:	94000f49 	bl	a0017c28 <z_unpend_first_thread>
    a0013f08:	f90047e0 	str	x0, [sp, #136]

	if (first_pending_thread != NULL) {
    a0013f0c:	f94047e0 	ldr	x0, [sp, #136]
    a0013f10:	f100001f 	cmp	x0, #0x0
    a0013f14:	54000140 	b.eq	a0013f3c <queue_insert+0xac>  // b.none
		SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_queue, queue_insert, queue, alloc, K_FOREVER);

		prepare_thread_to_run(first_pending_thread, data);
    a0013f18:	f9400fe1 	ldr	x1, [sp, #24]
    a0013f1c:	f94047e0 	ldr	x0, [sp, #136]
    a0013f20:	97ffff64 	bl	a0013cb0 <prepare_thread_to_run>
		z_reschedule(&queue->lock, key);
    a0013f24:	f94017e0 	ldr	x0, [sp, #40]
    a0013f28:	91004000 	add	x0, x0, #0x10
    a0013f2c:	b9404be1 	ldr	w1, [sp, #72]
    a0013f30:	9400107b 	bl	a001811c <z_reschedule>

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, queue_insert, queue, alloc, 0);

		return 0;
    a0013f34:	52800000 	mov	w0, #0x0                   	// #0
    a0013f38:	14000032 	b	a0014000 <queue_insert+0x170>
	}

	/* Only need to actually allocate if no threads are pending */
	if (alloc) {
    a0013f3c:	39405fe0 	ldrb	w0, [sp, #23]
    a0013f40:	7100001f 	cmp	w0, #0x0
    a0013f44:	54000400 	b.eq	a0013fc4 <queue_insert+0x134>  // b.none
		struct alloc_node *anode;

		anode = z_thread_malloc(sizeof(*anode));
    a0013f48:	d2800200 	mov	x0, #0x10                  	// #16
    a0013f4c:	97fffee5 	bl	a0013ae0 <z_thread_malloc>
    a0013f50:	f90043e0 	str	x0, [sp, #128]
		if (anode == NULL) {
    a0013f54:	f94043e0 	ldr	x0, [sp, #128]
    a0013f58:	f100001f 	cmp	x0, #0x0
    a0013f5c:	54000221 	b.ne	a0013fa0 <queue_insert+0x110>  // b.any
			k_spin_unlock(&queue->lock, key);
    a0013f60:	f94017e0 	ldr	x0, [sp, #40]
    a0013f64:	91004000 	add	x0, x0, #0x10
    a0013f68:	f90033e0 	str	x0, [sp, #96]
    a0013f6c:	b9404be0 	ldr	w0, [sp, #72]
    a0013f70:	b9003be0 	str	w0, [sp, #56]
	arch_irq_unlock(key.key);
    a0013f74:	b9403be0 	ldr	w0, [sp, #56]
    a0013f78:	b9005fe0 	str	w0, [sp, #92]
	write_daif(key);
    a0013f7c:	b9405fe0 	ldr	w0, [sp, #92]
    a0013f80:	f9002be0 	str	x0, [sp, #80]
MAKE_REG_HELPER(daif)
    a0013f84:	f9402be0 	ldr	x0, [sp, #80]
    a0013f88:	d51b4220 	msr	daif, x0
    a0013f8c:	d503201f 	nop
}
    a0013f90:	d503201f 	nop
}
    a0013f94:	d503201f 	nop

			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, queue_insert, queue, alloc,
				-ENOMEM);

			return -ENOMEM;
    a0013f98:	12800160 	mov	w0, #0xfffffff4            	// #-12
    a0013f9c:	14000019 	b	a0014000 <queue_insert+0x170>
		}
		anode->data = data;
    a0013fa0:	f94043e0 	ldr	x0, [sp, #128]
    a0013fa4:	f9400fe1 	ldr	x1, [sp, #24]
    a0013fa8:	f9000401 	str	x1, [x0, #8]
		sys_sfnode_init(&anode->node, 0x1);
    a0013fac:	f94043e0 	ldr	x0, [sp, #128]
    a0013fb0:	52800021 	mov	w1, #0x1                   	// #1
    a0013fb4:	97fffe3c 	bl	a00138a4 <sys_sfnode_init>
		data = anode;
    a0013fb8:	f94043e0 	ldr	x0, [sp, #128]
    a0013fbc:	f9000fe0 	str	x0, [sp, #24]
    a0013fc0:	14000004 	b	a0013fd0 <queue_insert+0x140>
	} else {
		sys_sfnode_init(data, 0x0);
    a0013fc4:	52800001 	mov	w1, #0x0                   	// #0
    a0013fc8:	f9400fe0 	ldr	x0, [sp, #24]
    a0013fcc:	97fffe36 	bl	a00138a4 <sys_sfnode_init>
	}

	SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_queue, queue_insert, queue, alloc, K_FOREVER);

	sys_sflist_insert(&queue->data_q, prev, data);
    a0013fd0:	f94017e0 	ldr	x0, [sp, #40]
    a0013fd4:	f9400fe2 	ldr	x2, [sp, #24]
    a0013fd8:	f94013e1 	ldr	x1, [sp, #32]
    a0013fdc:	97fffe79 	bl	a00139c0 <sys_sflist_insert>
	handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE);
    a0013fe0:	52800081 	mov	w1, #0x4                   	// #4
    a0013fe4:	f94017e0 	ldr	x0, [sp, #40]
    a0013fe8:	97ffff4c 	bl	a0013d18 <handle_poll_events>
	z_reschedule(&queue->lock, key);
    a0013fec:	f94017e0 	ldr	x0, [sp, #40]
    a0013ff0:	91004000 	add	x0, x0, #0x10
    a0013ff4:	b9404be1 	ldr	w1, [sp, #72]
    a0013ff8:	94001049 	bl	a001811c <z_reschedule>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, queue_insert, queue, alloc, 0);

	return 0;
    a0013ffc:	52800000 	mov	w0, #0x0                   	// #0
}
    a0014000:	a8c97bfd 	ldp	x29, x30, [sp], #144
    a0014004:	d65f03c0 	ret

00000000a0014008 <z_impl_k_queue_alloc_append>:

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, prepend, queue);
}

int32_t z_impl_k_queue_alloc_append(struct k_queue *queue, void *data)
{
    a0014008:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a001400c:	910003fd 	mov	x29, sp
    a0014010:	f9000fe0 	str	x0, [sp, #24]
    a0014014:	f9000be1 	str	x1, [sp, #16]
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, alloc_append, queue);

	int32_t ret = queue_insert(queue, NULL, data, true, true);
    a0014018:	52800024 	mov	w4, #0x1                   	// #1
    a001401c:	52800023 	mov	w3, #0x1                   	// #1
    a0014020:	f9400be2 	ldr	x2, [sp, #16]
    a0014024:	d2800001 	mov	x1, #0x0                   	// #0
    a0014028:	f9400fe0 	ldr	x0, [sp, #24]
    a001402c:	97ffff99 	bl	a0013e90 <queue_insert>
    a0014030:	b9002fe0 	str	w0, [sp, #44]

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, alloc_append, queue, ret);

	return ret;
    a0014034:	b9402fe0 	ldr	w0, [sp, #44]
}
    a0014038:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a001403c:	d65f03c0 	ret

00000000a0014040 <z_vrfy_k_queue_alloc_append>:

#ifdef CONFIG_USERSPACE
static inline int32_t z_vrfy_k_queue_alloc_append(struct k_queue *queue,
						  void *data)
{
    a0014040:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a0014044:	910003fd 	mov	x29, sp
    a0014048:	f9000fe0 	str	x0, [sp, #24]
    a001404c:	f9000be1 	str	x1, [sp, #16]
	Z_OOPS(Z_SYSCALL_OBJ(queue, K_OBJ_QUEUE));
    a0014050:	f9400fe0 	ldr	x0, [sp, #24]
    a0014054:	94002275 	bl	a001ca28 <z_object_find>
    a0014058:	52800003 	mov	w3, #0x0                   	// #0
    a001405c:	528000a2 	mov	w2, #0x5                   	// #5
    a0014060:	f9400fe1 	ldr	x1, [sp, #24]
    a0014064:	97fffea7 	bl	a0013b00 <z_obj_validation_check>
    a0014068:	7100001f 	cmp	w0, #0x0
    a001406c:	1a9f07e0 	cset	w0, ne  // ne = any
    a0014070:	39063fe0 	strb	w0, [sp, #399]
    a0014074:	39463fe0 	ldrb	w0, [sp, #399]
    a0014078:	7100001f 	cmp	w0, #0x0
    a001407c:	39463fe0 	ldrb	w0, [sp, #399]
    a0014080:	7100001f 	cmp	w0, #0x0
    a0014084:	540000c0 	b.eq	a001409c <z_vrfy_k_queue_alloc_append+0x5c>  // b.none
    a0014088:	f0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001408c:	913f8000 	add	x0, x0, #0xfe0
    a0014090:	f9400800 	ldr	x0, [x0, #16]
    a0014094:	f9408400 	ldr	x0, [x0, #264]
    a0014098:	97ffd430 	bl	a0009158 <arch_syscall_oops>
	return z_impl_k_queue_alloc_append(queue, data);
    a001409c:	f9400be1 	ldr	x1, [sp, #16]
    a00140a0:	f9400fe0 	ldr	x0, [sp, #24]
    a00140a4:	97ffffd9 	bl	a0014008 <z_impl_k_queue_alloc_append>
}
    a00140a8:	a8d97bfd 	ldp	x29, x30, [sp], #400
    a00140ac:	d65f03c0 	ret

00000000a00140b0 <z_mrsh_k_queue_alloc_append>:
#include <syscalls/kernel.h>

extern int32_t z_vrfy_k_queue_alloc_append(struct k_queue * queue, void * data);
uintptr_t z_mrsh_k_queue_alloc_append(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a00140b0:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a00140b4:	910003fd 	mov	x29, sp
    a00140b8:	f90027e0 	str	x0, [sp, #72]
    a00140bc:	f90023e1 	str	x1, [sp, #64]
    a00140c0:	f9001fe2 	str	x2, [sp, #56]
    a00140c4:	f9001be3 	str	x3, [sp, #48]
    a00140c8:	f90017e4 	str	x4, [sp, #40]
    a00140cc:	f90013e5 	str	x5, [sp, #32]
    a00140d0:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a00140d4:	f0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00140d8:	913f8000 	add	x0, x0, #0xfe0
    a00140dc:	f9400800 	ldr	x0, [x0, #16]
    a00140e0:	f9400fe1 	ldr	x1, [sp, #24]
    a00140e4:	f9008401 	str	x1, [x0, #264]
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int32_t ret = z_vrfy_k_queue_alloc_append(*(struct k_queue **)&arg0, *(void **)&arg1)
    a00140e8:	910123e0 	add	x0, sp, #0x48
    a00140ec:	f9400002 	ldr	x2, [x0]
    a00140f0:	910103e0 	add	x0, sp, #0x40
    a00140f4:	f9400000 	ldr	x0, [x0]
    a00140f8:	aa0003e1 	mov	x1, x0
    a00140fc:	aa0203e0 	mov	x0, x2
    a0014100:	97ffffd0 	bl	a0014040 <z_vrfy_k_queue_alloc_append>
    a0014104:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a0014108:	f0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001410c:	913f8000 	add	x0, x0, #0xfe0
    a0014110:	f9400800 	ldr	x0, [x0, #16]
    a0014114:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a0014118:	b9805fe0 	ldrsw	x0, [sp, #92]
}
    a001411c:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a0014120:	d65f03c0 	ret

00000000a0014124 <z_impl_k_queue_alloc_prepend>:
#include <syscalls/k_queue_alloc_append_mrsh.c>
#endif

int32_t z_impl_k_queue_alloc_prepend(struct k_queue *queue, void *data)
{
    a0014124:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0014128:	910003fd 	mov	x29, sp
    a001412c:	f9000fe0 	str	x0, [sp, #24]
    a0014130:	f9000be1 	str	x1, [sp, #16]
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, alloc_prepend, queue);

	int32_t ret = queue_insert(queue, NULL, data, true, false);
    a0014134:	52800004 	mov	w4, #0x0                   	// #0
    a0014138:	52800023 	mov	w3, #0x1                   	// #1
    a001413c:	f9400be2 	ldr	x2, [sp, #16]
    a0014140:	d2800001 	mov	x1, #0x0                   	// #0
    a0014144:	f9400fe0 	ldr	x0, [sp, #24]
    a0014148:	97ffff52 	bl	a0013e90 <queue_insert>
    a001414c:	b9002fe0 	str	w0, [sp, #44]

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, alloc_prepend, queue, ret);

	return ret;
    a0014150:	b9402fe0 	ldr	w0, [sp, #44]
}
    a0014154:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0014158:	d65f03c0 	ret

00000000a001415c <z_vrfy_k_queue_alloc_prepend>:

#ifdef CONFIG_USERSPACE
static inline int32_t z_vrfy_k_queue_alloc_prepend(struct k_queue *queue,
						   void *data)
{
    a001415c:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a0014160:	910003fd 	mov	x29, sp
    a0014164:	f9000fe0 	str	x0, [sp, #24]
    a0014168:	f9000be1 	str	x1, [sp, #16]
	Z_OOPS(Z_SYSCALL_OBJ(queue, K_OBJ_QUEUE));
    a001416c:	f9400fe0 	ldr	x0, [sp, #24]
    a0014170:	9400222e 	bl	a001ca28 <z_object_find>
    a0014174:	52800003 	mov	w3, #0x0                   	// #0
    a0014178:	528000a2 	mov	w2, #0x5                   	// #5
    a001417c:	f9400fe1 	ldr	x1, [sp, #24]
    a0014180:	97fffe60 	bl	a0013b00 <z_obj_validation_check>
    a0014184:	7100001f 	cmp	w0, #0x0
    a0014188:	1a9f07e0 	cset	w0, ne  // ne = any
    a001418c:	39063fe0 	strb	w0, [sp, #399]
    a0014190:	39463fe0 	ldrb	w0, [sp, #399]
    a0014194:	7100001f 	cmp	w0, #0x0
    a0014198:	39463fe0 	ldrb	w0, [sp, #399]
    a001419c:	7100001f 	cmp	w0, #0x0
    a00141a0:	540000c0 	b.eq	a00141b8 <z_vrfy_k_queue_alloc_prepend+0x5c>  // b.none
    a00141a4:	f0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00141a8:	913f8000 	add	x0, x0, #0xfe0
    a00141ac:	f9400800 	ldr	x0, [x0, #16]
    a00141b0:	f9408400 	ldr	x0, [x0, #264]
    a00141b4:	97ffd3e9 	bl	a0009158 <arch_syscall_oops>
	return z_impl_k_queue_alloc_prepend(queue, data);
    a00141b8:	f9400be1 	ldr	x1, [sp, #16]
    a00141bc:	f9400fe0 	ldr	x0, [sp, #24]
    a00141c0:	97ffffd9 	bl	a0014124 <z_impl_k_queue_alloc_prepend>
}
    a00141c4:	a8d97bfd 	ldp	x29, x30, [sp], #400
    a00141c8:	d65f03c0 	ret

00000000a00141cc <z_mrsh_k_queue_alloc_prepend>:
#include <syscalls/kernel.h>

extern int32_t z_vrfy_k_queue_alloc_prepend(struct k_queue * queue, void * data);
uintptr_t z_mrsh_k_queue_alloc_prepend(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a00141cc:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a00141d0:	910003fd 	mov	x29, sp
    a00141d4:	f90027e0 	str	x0, [sp, #72]
    a00141d8:	f90023e1 	str	x1, [sp, #64]
    a00141dc:	f9001fe2 	str	x2, [sp, #56]
    a00141e0:	f9001be3 	str	x3, [sp, #48]
    a00141e4:	f90017e4 	str	x4, [sp, #40]
    a00141e8:	f90013e5 	str	x5, [sp, #32]
    a00141ec:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a00141f0:	f0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00141f4:	913f8000 	add	x0, x0, #0xfe0
    a00141f8:	f9400800 	ldr	x0, [x0, #16]
    a00141fc:	f9400fe1 	ldr	x1, [sp, #24]
    a0014200:	f9008401 	str	x1, [x0, #264]
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int32_t ret = z_vrfy_k_queue_alloc_prepend(*(struct k_queue **)&arg0, *(void **)&arg1)
    a0014204:	910123e0 	add	x0, sp, #0x48
    a0014208:	f9400002 	ldr	x2, [x0]
    a001420c:	910103e0 	add	x0, sp, #0x40
    a0014210:	f9400000 	ldr	x0, [x0]
    a0014214:	aa0003e1 	mov	x1, x0
    a0014218:	aa0203e0 	mov	x0, x2
    a001421c:	97ffffd0 	bl	a001415c <z_vrfy_k_queue_alloc_prepend>
    a0014220:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a0014224:	f0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0014228:	913f8000 	add	x0, x0, #0xfe0
    a001422c:	f9400800 	ldr	x0, [x0, #16]
    a0014230:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a0014234:	b9805fe0 	ldrsw	x0, [sp, #92]
}
    a0014238:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a001423c:	d65f03c0 	ret

00000000a0014240 <z_impl_k_queue_get>:

	return 0;
}

void *z_impl_k_queue_get(struct k_queue *queue, k_timeout_t timeout)
{
    a0014240:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
    a0014244:	910003fd 	mov	x29, sp
    a0014248:	f9000fe0 	str	x0, [sp, #24]
    a001424c:	f9000be1 	str	x1, [sp, #16]
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
    a0014250:	f9400fe0 	ldr	x0, [sp, #24]
    a0014254:	91004000 	add	x0, x0, #0x10
    a0014258:	f90043e0 	str	x0, [sp, #128]
    a001425c:	d53b4220 	mrs	x0, daif
    a0014260:	f9003fe0 	str	x0, [sp, #120]
    a0014264:	f9403fe0 	ldr	x0, [sp, #120]
    a0014268:	d503201f 	nop
	key = read_daif();
    a001426c:	b90077e0 	str	w0, [sp, #116]
	__asm__ volatile ("msr DAIFSet, %0"
    a0014270:	d50342df 	msr	daifset, #0x2
}
    a0014274:	d503201f 	nop
	return key;
    a0014278:	b94077e0 	ldr	w0, [sp, #116]
	k.key = arch_irq_lock();
    a001427c:	b90033e0 	str	w0, [sp, #48]
	return k;
    a0014280:	b94033e0 	ldr	w0, [sp, #48]
    a0014284:	b9003be0 	str	w0, [sp, #56]
	void *data;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, get, queue, timeout);

	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
    a0014288:	f9400fe0 	ldr	x0, [sp, #24]
    a001428c:	97fffd8f 	bl	a00138c8 <sys_sflist_is_empty>
    a0014290:	12001c00 	and	w0, w0, #0xff
    a0014294:	52000000 	eor	w0, w0, #0x1
    a0014298:	12001c00 	and	w0, w0, #0xff
    a001429c:	92401c00 	and	x0, x0, #0xff
    a00142a0:	f100001f 	cmp	x0, #0x0
    a00142a4:	54000300 	b.eq	a0014304 <z_impl_k_queue_get+0xc4>  // b.none
		sys_sfnode_t *node;

		node = sys_sflist_get_not_empty(&queue->data_q);
    a00142a8:	f9400fe0 	ldr	x0, [sp, #24]
    a00142ac:	97fffde4 	bl	a0013a3c <sys_sflist_get_not_empty>
    a00142b0:	f9004be0 	str	x0, [sp, #144]
		data = z_queue_node_peek(node, true);
    a00142b4:	52800021 	mov	w1, #0x1                   	// #1
    a00142b8:	f9404be0 	ldr	x0, [sp, #144]
    a00142bc:	97fffe1f 	bl	a0013b38 <z_queue_node_peek>
    a00142c0:	f90047e0 	str	x0, [sp, #136]
		k_spin_unlock(&queue->lock, key);
    a00142c4:	f9400fe0 	ldr	x0, [sp, #24]
    a00142c8:	91004000 	add	x0, x0, #0x10
    a00142cc:	f90037e0 	str	x0, [sp, #104]
    a00142d0:	b9403be0 	ldr	w0, [sp, #56]
    a00142d4:	b9002be0 	str	w0, [sp, #40]
	arch_irq_unlock(key.key);
    a00142d8:	b9402be0 	ldr	w0, [sp, #40]
    a00142dc:	b90067e0 	str	w0, [sp, #100]
	write_daif(key);
    a00142e0:	b94067e0 	ldr	w0, [sp, #100]
    a00142e4:	f9002fe0 	str	x0, [sp, #88]
MAKE_REG_HELPER(daif)
    a00142e8:	f9402fe0 	ldr	x0, [sp, #88]
    a00142ec:	d51b4220 	msr	daif, x0
    a00142f0:	d503201f 	nop
}
    a00142f4:	d503201f 	nop
}
    a00142f8:	d503201f 	nop

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, get, queue, timeout, data);

		return data;
    a00142fc:	f94047e0 	ldr	x0, [sp, #136]
    a0014300:	14000028 	b	a00143a0 <z_impl_k_queue_get+0x160>
	}

	SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_queue, get, queue, timeout);

	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    a0014304:	f9400be0 	ldr	x0, [sp, #16]
    a0014308:	d2800001 	mov	x1, #0x0                   	// #0
    a001430c:	eb01001f 	cmp	x0, x1
    a0014310:	54000221 	b.ne	a0014354 <z_impl_k_queue_get+0x114>  // b.any
		k_spin_unlock(&queue->lock, key);
    a0014314:	f9400fe0 	ldr	x0, [sp, #24]
    a0014318:	91004000 	add	x0, x0, #0x10
    a001431c:	f9002be0 	str	x0, [sp, #80]
    a0014320:	b9403be0 	ldr	w0, [sp, #56]
    a0014324:	b90023e0 	str	w0, [sp, #32]
	arch_irq_unlock(key.key);
    a0014328:	b94023e0 	ldr	w0, [sp, #32]
    a001432c:	b9004fe0 	str	w0, [sp, #76]
	write_daif(key);
    a0014330:	b9404fe0 	ldr	w0, [sp, #76]
    a0014334:	f90023e0 	str	x0, [sp, #64]
    a0014338:	f94023e0 	ldr	x0, [sp, #64]
    a001433c:	d51b4220 	msr	daif, x0
    a0014340:	d503201f 	nop
}
    a0014344:	d503201f 	nop
}
    a0014348:	d503201f 	nop

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, get, queue, timeout, NULL);

		return NULL;
    a001434c:	d2800000 	mov	x0, #0x0                   	// #0
    a0014350:	14000014 	b	a00143a0 <z_impl_k_queue_get+0x160>
	}

	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);
    a0014354:	f9400fe0 	ldr	x0, [sp, #24]
    a0014358:	91004004 	add	x4, x0, #0x10
    a001435c:	f9400fe0 	ldr	x0, [sp, #24]
    a0014360:	91004000 	add	x0, x0, #0x10
    a0014364:	f9400be3 	ldr	x3, [sp, #16]
    a0014368:	aa0003e2 	mov	x2, x0
    a001436c:	b9403be1 	ldr	w1, [sp, #56]
    a0014370:	aa0403e0 	mov	x0, x4
    a0014374:	94000dea 	bl	a0017b1c <z_pend_curr>
    a0014378:	b9009fe0 	str	w0, [sp, #156]

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, get, queue, timeout,
		(ret != 0) ? NULL : _current->base.swap_data);

	return (ret != 0) ? NULL : _current->base.swap_data;
    a001437c:	b9409fe0 	ldr	w0, [sp, #156]
    a0014380:	7100001f 	cmp	w0, #0x0
    a0014384:	540000c1 	b.ne	a001439c <z_impl_k_queue_get+0x15c>  // b.any
    a0014388:	f0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001438c:	913f8000 	add	x0, x0, #0xfe0
    a0014390:	f9400800 	ldr	x0, [x0, #16]
    a0014394:	f9401000 	ldr	x0, [x0, #32]
    a0014398:	14000002 	b	a00143a0 <z_impl_k_queue_get+0x160>
    a001439c:	d2800000 	mov	x0, #0x0                   	// #0
}
    a00143a0:	a8ca7bfd 	ldp	x29, x30, [sp], #160
    a00143a4:	d65f03c0 	ret

00000000a00143a8 <z_impl_k_queue_peek_head>:

	return true;
}

void *z_impl_k_queue_peek_head(struct k_queue *queue)
{
    a00143a8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a00143ac:	910003fd 	mov	x29, sp
    a00143b0:	f9000fe0 	str	x0, [sp, #24]
	void *ret = z_queue_node_peek(sys_sflist_peek_head(&queue->data_q), false);
    a00143b4:	f9400fe0 	ldr	x0, [sp, #24]
    a00143b8:	97fffd26 	bl	a0013850 <sys_sflist_peek_head>
    a00143bc:	52800001 	mov	w1, #0x0                   	// #0
    a00143c0:	97fffdde 	bl	a0013b38 <z_queue_node_peek>
    a00143c4:	f90017e0 	str	x0, [sp, #40]

	SYS_PORT_TRACING_OBJ_FUNC(k_queue, peek_head, queue, ret);

	return ret;
    a00143c8:	f94017e0 	ldr	x0, [sp, #40]
}
    a00143cc:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a00143d0:	d65f03c0 	ret

00000000a00143d4 <z_impl_k_queue_peek_tail>:

void *z_impl_k_queue_peek_tail(struct k_queue *queue)
{
    a00143d4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a00143d8:	910003fd 	mov	x29, sp
    a00143dc:	f9000fe0 	str	x0, [sp, #24]
	void *ret = z_queue_node_peek(sys_sflist_peek_tail(&queue->data_q), false);
    a00143e0:	f9400fe0 	ldr	x0, [sp, #24]
    a00143e4:	97fffd21 	bl	a0013868 <sys_sflist_peek_tail>
    a00143e8:	52800001 	mov	w1, #0x0                   	// #0
    a00143ec:	97fffdd3 	bl	a0013b38 <z_queue_node_peek>
    a00143f0:	f90017e0 	str	x0, [sp, #40]

	SYS_PORT_TRACING_OBJ_FUNC(k_queue, peek_tail, queue, ret);

	return ret;
    a00143f4:	f94017e0 	ldr	x0, [sp, #40]
}
    a00143f8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a00143fc:	d65f03c0 	ret

00000000a0014400 <z_vrfy_k_queue_get>:

#ifdef CONFIG_USERSPACE
static inline void *z_vrfy_k_queue_get(struct k_queue *queue,
				       k_timeout_t timeout)
{
    a0014400:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a0014404:	910003fd 	mov	x29, sp
    a0014408:	f9000fe0 	str	x0, [sp, #24]
    a001440c:	f9000be1 	str	x1, [sp, #16]
	Z_OOPS(Z_SYSCALL_OBJ(queue, K_OBJ_QUEUE));
    a0014410:	f9400fe0 	ldr	x0, [sp, #24]
    a0014414:	94002185 	bl	a001ca28 <z_object_find>
    a0014418:	52800003 	mov	w3, #0x0                   	// #0
    a001441c:	528000a2 	mov	w2, #0x5                   	// #5
    a0014420:	f9400fe1 	ldr	x1, [sp, #24]
    a0014424:	97fffdb7 	bl	a0013b00 <z_obj_validation_check>
    a0014428:	7100001f 	cmp	w0, #0x0
    a001442c:	1a9f07e0 	cset	w0, ne  // ne = any
    a0014430:	39063fe0 	strb	w0, [sp, #399]
    a0014434:	39463fe0 	ldrb	w0, [sp, #399]
    a0014438:	7100001f 	cmp	w0, #0x0
    a001443c:	39463fe0 	ldrb	w0, [sp, #399]
    a0014440:	7100001f 	cmp	w0, #0x0
    a0014444:	540000c0 	b.eq	a001445c <z_vrfy_k_queue_get+0x5c>  // b.none
    a0014448:	f0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001444c:	913f8000 	add	x0, x0, #0xfe0
    a0014450:	f9400800 	ldr	x0, [x0, #16]
    a0014454:	f9408400 	ldr	x0, [x0, #264]
    a0014458:	97ffd340 	bl	a0009158 <arch_syscall_oops>
	return z_impl_k_queue_get(queue, timeout);
    a001445c:	f9400be1 	ldr	x1, [sp, #16]
    a0014460:	f9400fe0 	ldr	x0, [sp, #24]
    a0014464:	97ffff77 	bl	a0014240 <z_impl_k_queue_get>
}
    a0014468:	a8d97bfd 	ldp	x29, x30, [sp], #400
    a001446c:	d65f03c0 	ret

00000000a0014470 <z_mrsh_k_queue_get>:
#include <syscalls/kernel.h>

extern void * z_vrfy_k_queue_get(struct k_queue * queue, k_timeout_t timeout);
uintptr_t z_mrsh_k_queue_get(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a0014470:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a0014474:	910003fd 	mov	x29, sp
    a0014478:	f90027e0 	str	x0, [sp, #72]
    a001447c:	f90023e1 	str	x1, [sp, #64]
    a0014480:	f9001fe2 	str	x2, [sp, #56]
    a0014484:	f9001be3 	str	x3, [sp, #48]
    a0014488:	f90017e4 	str	x4, [sp, #40]
    a001448c:	f90013e5 	str	x5, [sp, #32]
    a0014490:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a0014494:	f0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0014498:	913f8000 	add	x0, x0, #0xfe0
    a001449c:	f9400800 	ldr	x0, [x0, #16]
    a00144a0:	f9400fe1 	ldr	x1, [sp, #24]
    a00144a4:	f9008401 	str	x1, [x0, #264]
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	void * ret = z_vrfy_k_queue_get(*(struct k_queue **)&arg0, *(k_timeout_t*)&arg1)
    a00144a8:	910123e0 	add	x0, sp, #0x48
    a00144ac:	f9400002 	ldr	x2, [x0]
    a00144b0:	910103e0 	add	x0, sp, #0x40
    a00144b4:	f9400001 	ldr	x1, [x0]
    a00144b8:	aa0203e0 	mov	x0, x2
    a00144bc:	97ffffd1 	bl	a0014400 <z_vrfy_k_queue_get>
    a00144c0:	f9002fe0 	str	x0, [sp, #88]
;
	_current->syscall_frame = NULL;
    a00144c4:	f0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00144c8:	913f8000 	add	x0, x0, #0xfe0
    a00144cc:	f9400800 	ldr	x0, [x0, #16]
    a00144d0:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a00144d4:	f9402fe0 	ldr	x0, [sp, #88]
}
    a00144d8:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a00144dc:	d65f03c0 	ret

00000000a00144e0 <z_vrfy_k_queue_is_empty>:
#include <syscalls/k_queue_get_mrsh.c>

static inline int z_vrfy_k_queue_is_empty(struct k_queue *queue)
{
    a00144e0:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a00144e4:	910003fd 	mov	x29, sp
    a00144e8:	f9000fe0 	str	x0, [sp, #24]
	Z_OOPS(Z_SYSCALL_OBJ(queue, K_OBJ_QUEUE));
    a00144ec:	f9400fe0 	ldr	x0, [sp, #24]
    a00144f0:	9400214e 	bl	a001ca28 <z_object_find>
    a00144f4:	52800003 	mov	w3, #0x0                   	// #0
    a00144f8:	528000a2 	mov	w2, #0x5                   	// #5
    a00144fc:	f9400fe1 	ldr	x1, [sp, #24]
    a0014500:	97fffd80 	bl	a0013b00 <z_obj_validation_check>
    a0014504:	7100001f 	cmp	w0, #0x0
    a0014508:	1a9f07e0 	cset	w0, ne  // ne = any
    a001450c:	39063fe0 	strb	w0, [sp, #399]
    a0014510:	39463fe0 	ldrb	w0, [sp, #399]
    a0014514:	7100001f 	cmp	w0, #0x0
    a0014518:	39463fe0 	ldrb	w0, [sp, #399]
    a001451c:	7100001f 	cmp	w0, #0x0
    a0014520:	540000c0 	b.eq	a0014538 <z_vrfy_k_queue_is_empty+0x58>  // b.none
    a0014524:	f0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0014528:	913f8000 	add	x0, x0, #0xfe0
    a001452c:	f9400800 	ldr	x0, [x0, #16]
    a0014530:	f9408400 	ldr	x0, [x0, #264]
    a0014534:	97ffd309 	bl	a0009158 <arch_syscall_oops>
	return z_impl_k_queue_is_empty(queue);
    a0014538:	f9400fe0 	ldr	x0, [sp, #24]
    a001453c:	97fffd59 	bl	a0013aa0 <z_impl_k_queue_is_empty>
}
    a0014540:	a8d97bfd 	ldp	x29, x30, [sp], #400
    a0014544:	d65f03c0 	ret

00000000a0014548 <z_mrsh_k_queue_is_empty>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_queue_is_empty(struct k_queue * queue);
uintptr_t z_mrsh_k_queue_is_empty(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a0014548:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a001454c:	910003fd 	mov	x29, sp
    a0014550:	f90027e0 	str	x0, [sp, #72]
    a0014554:	f90023e1 	str	x1, [sp, #64]
    a0014558:	f9001fe2 	str	x2, [sp, #56]
    a001455c:	f9001be3 	str	x3, [sp, #48]
    a0014560:	f90017e4 	str	x4, [sp, #40]
    a0014564:	f90013e5 	str	x5, [sp, #32]
    a0014568:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a001456c:	f0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0014570:	913f8000 	add	x0, x0, #0xfe0
    a0014574:	f9400800 	ldr	x0, [x0, #16]
    a0014578:	f9400fe1 	ldr	x1, [sp, #24]
    a001457c:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_queue_is_empty(*(struct k_queue **)&arg0)
    a0014580:	910123e0 	add	x0, sp, #0x48
    a0014584:	f9400000 	ldr	x0, [x0]
    a0014588:	97ffffd6 	bl	a00144e0 <z_vrfy_k_queue_is_empty>
    a001458c:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a0014590:	f0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0014594:	913f8000 	add	x0, x0, #0xfe0
    a0014598:	f9400800 	ldr	x0, [x0, #16]
    a001459c:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a00145a0:	b9805fe0 	ldrsw	x0, [sp, #92]
}
    a00145a4:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a00145a8:	d65f03c0 	ret

00000000a00145ac <z_vrfy_k_queue_peek_head>:
#include <syscalls/k_queue_is_empty_mrsh.c>

static inline void *z_vrfy_k_queue_peek_head(struct k_queue *queue)
{
    a00145ac:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a00145b0:	910003fd 	mov	x29, sp
    a00145b4:	f9000fe0 	str	x0, [sp, #24]
	Z_OOPS(Z_SYSCALL_OBJ(queue, K_OBJ_QUEUE));
    a00145b8:	f9400fe0 	ldr	x0, [sp, #24]
    a00145bc:	9400211b 	bl	a001ca28 <z_object_find>
    a00145c0:	52800003 	mov	w3, #0x0                   	// #0
    a00145c4:	528000a2 	mov	w2, #0x5                   	// #5
    a00145c8:	f9400fe1 	ldr	x1, [sp, #24]
    a00145cc:	97fffd4d 	bl	a0013b00 <z_obj_validation_check>
    a00145d0:	7100001f 	cmp	w0, #0x0
    a00145d4:	1a9f07e0 	cset	w0, ne  // ne = any
    a00145d8:	39063fe0 	strb	w0, [sp, #399]
    a00145dc:	39463fe0 	ldrb	w0, [sp, #399]
    a00145e0:	7100001f 	cmp	w0, #0x0
    a00145e4:	39463fe0 	ldrb	w0, [sp, #399]
    a00145e8:	7100001f 	cmp	w0, #0x0
    a00145ec:	540000c0 	b.eq	a0014604 <z_vrfy_k_queue_peek_head+0x58>  // b.none
    a00145f0:	f0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00145f4:	913f8000 	add	x0, x0, #0xfe0
    a00145f8:	f9400800 	ldr	x0, [x0, #16]
    a00145fc:	f9408400 	ldr	x0, [x0, #264]
    a0014600:	97ffd2d6 	bl	a0009158 <arch_syscall_oops>
	return z_impl_k_queue_peek_head(queue);
    a0014604:	f9400fe0 	ldr	x0, [sp, #24]
    a0014608:	97ffff68 	bl	a00143a8 <z_impl_k_queue_peek_head>
}
    a001460c:	a8d97bfd 	ldp	x29, x30, [sp], #400
    a0014610:	d65f03c0 	ret

00000000a0014614 <z_mrsh_k_queue_peek_head>:
#include <syscalls/kernel.h>

extern void * z_vrfy_k_queue_peek_head(struct k_queue * queue);
uintptr_t z_mrsh_k_queue_peek_head(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a0014614:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a0014618:	910003fd 	mov	x29, sp
    a001461c:	f90027e0 	str	x0, [sp, #72]
    a0014620:	f90023e1 	str	x1, [sp, #64]
    a0014624:	f9001fe2 	str	x2, [sp, #56]
    a0014628:	f9001be3 	str	x3, [sp, #48]
    a001462c:	f90017e4 	str	x4, [sp, #40]
    a0014630:	f90013e5 	str	x5, [sp, #32]
    a0014634:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a0014638:	f0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001463c:	913f8000 	add	x0, x0, #0xfe0
    a0014640:	f9400800 	ldr	x0, [x0, #16]
    a0014644:	f9400fe1 	ldr	x1, [sp, #24]
    a0014648:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	void * ret = z_vrfy_k_queue_peek_head(*(struct k_queue **)&arg0)
    a001464c:	910123e0 	add	x0, sp, #0x48
    a0014650:	f9400000 	ldr	x0, [x0]
    a0014654:	97ffffd6 	bl	a00145ac <z_vrfy_k_queue_peek_head>
    a0014658:	f9002fe0 	str	x0, [sp, #88]
;
	_current->syscall_frame = NULL;
    a001465c:	f0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0014660:	913f8000 	add	x0, x0, #0xfe0
    a0014664:	f9400800 	ldr	x0, [x0, #16]
    a0014668:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a001466c:	f9402fe0 	ldr	x0, [sp, #88]
}
    a0014670:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a0014674:	d65f03c0 	ret

00000000a0014678 <z_vrfy_k_queue_peek_tail>:
#include <syscalls/k_queue_peek_head_mrsh.c>

static inline void *z_vrfy_k_queue_peek_tail(struct k_queue *queue)
{
    a0014678:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a001467c:	910003fd 	mov	x29, sp
    a0014680:	f9000fe0 	str	x0, [sp, #24]
	Z_OOPS(Z_SYSCALL_OBJ(queue, K_OBJ_QUEUE));
    a0014684:	f9400fe0 	ldr	x0, [sp, #24]
    a0014688:	940020e8 	bl	a001ca28 <z_object_find>
    a001468c:	52800003 	mov	w3, #0x0                   	// #0
    a0014690:	528000a2 	mov	w2, #0x5                   	// #5
    a0014694:	f9400fe1 	ldr	x1, [sp, #24]
    a0014698:	97fffd1a 	bl	a0013b00 <z_obj_validation_check>
    a001469c:	7100001f 	cmp	w0, #0x0
    a00146a0:	1a9f07e0 	cset	w0, ne  // ne = any
    a00146a4:	39063fe0 	strb	w0, [sp, #399]
    a00146a8:	39463fe0 	ldrb	w0, [sp, #399]
    a00146ac:	7100001f 	cmp	w0, #0x0
    a00146b0:	39463fe0 	ldrb	w0, [sp, #399]
    a00146b4:	7100001f 	cmp	w0, #0x0
    a00146b8:	540000c0 	b.eq	a00146d0 <z_vrfy_k_queue_peek_tail+0x58>  // b.none
    a00146bc:	f0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00146c0:	913f8000 	add	x0, x0, #0xfe0
    a00146c4:	f9400800 	ldr	x0, [x0, #16]
    a00146c8:	f9408400 	ldr	x0, [x0, #264]
    a00146cc:	97ffd2a3 	bl	a0009158 <arch_syscall_oops>
	return z_impl_k_queue_peek_tail(queue);
    a00146d0:	f9400fe0 	ldr	x0, [sp, #24]
    a00146d4:	97ffff40 	bl	a00143d4 <z_impl_k_queue_peek_tail>
}
    a00146d8:	a8d97bfd 	ldp	x29, x30, [sp], #400
    a00146dc:	d65f03c0 	ret

00000000a00146e0 <z_mrsh_k_queue_peek_tail>:
#include <syscalls/kernel.h>

extern void * z_vrfy_k_queue_peek_tail(struct k_queue * queue);
uintptr_t z_mrsh_k_queue_peek_tail(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a00146e0:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a00146e4:	910003fd 	mov	x29, sp
    a00146e8:	f90027e0 	str	x0, [sp, #72]
    a00146ec:	f90023e1 	str	x1, [sp, #64]
    a00146f0:	f9001fe2 	str	x2, [sp, #56]
    a00146f4:	f9001be3 	str	x3, [sp, #48]
    a00146f8:	f90017e4 	str	x4, [sp, #40]
    a00146fc:	f90013e5 	str	x5, [sp, #32]
    a0014700:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a0014704:	f0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0014708:	913f8000 	add	x0, x0, #0xfe0
    a001470c:	f9400800 	ldr	x0, [x0, #16]
    a0014710:	f9400fe1 	ldr	x1, [sp, #24]
    a0014714:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	void * ret = z_vrfy_k_queue_peek_tail(*(struct k_queue **)&arg0)
    a0014718:	910123e0 	add	x0, sp, #0x48
    a001471c:	f9400000 	ldr	x0, [x0]
    a0014720:	97ffffd6 	bl	a0014678 <z_vrfy_k_queue_peek_tail>
    a0014724:	f9002fe0 	str	x0, [sp, #88]
;
	_current->syscall_frame = NULL;
    a0014728:	f0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001472c:	913f8000 	add	x0, x0, #0xfe0
    a0014730:	f9400800 	ldr	x0, [x0, #16]
    a0014734:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a0014738:	f9402fe0 	ldr	x0, [sp, #88]
}
    a001473c:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a0014740:	d65f03c0 	ret

00000000a0014744 <sys_dlist_init>:
{
    a0014744:	d10043ff 	sub	sp, sp, #0x10
    a0014748:	f90007e0 	str	x0, [sp, #8]
	list->head = (sys_dnode_t *)list;
    a001474c:	f94007e0 	ldr	x0, [sp, #8]
    a0014750:	f94007e1 	ldr	x1, [sp, #8]
    a0014754:	f9000001 	str	x1, [x0]
	list->tail = (sys_dnode_t *)list;
    a0014758:	f94007e0 	ldr	x0, [sp, #8]
    a001475c:	f94007e1 	ldr	x1, [sp, #8]
    a0014760:	f9000401 	str	x1, [x0, #8]
}
    a0014764:	d503201f 	nop
    a0014768:	910043ff 	add	sp, sp, #0x10
    a001476c:	d65f03c0 	ret

00000000a0014770 <z_impl_k_sem_count_get>:
{
    a0014770:	d10043ff 	sub	sp, sp, #0x10
    a0014774:	f90007e0 	str	x0, [sp, #8]
	return sem->count;
    a0014778:	f94007e0 	ldr	x0, [sp, #8]
    a001477c:	b9401000 	ldr	w0, [x0, #16]
}
    a0014780:	910043ff 	add	sp, sp, #0x10
    a0014784:	d65f03c0 	ret

00000000a0014788 <z_waitq_init>:
{
    a0014788:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a001478c:	910003fd 	mov	x29, sp
    a0014790:	f9000fe0 	str	x0, [sp, #24]
	sys_dlist_init(&w->waitq);
    a0014794:	f9400fe0 	ldr	x0, [sp, #24]
    a0014798:	97ffffeb 	bl	a0014744 <sys_dlist_init>
}
    a001479c:	d503201f 	nop
    a00147a0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a00147a4:	d65f03c0 	ret

00000000a00147a8 <z_obj_validation_check>:
{
    a00147a8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    a00147ac:	910003fd 	mov	x29, sp
    a00147b0:	f90017e0 	str	x0, [sp, #40]
    a00147b4:	f90013e1 	str	x1, [sp, #32]
    a00147b8:	b9001fe2 	str	w2, [sp, #28]
    a00147bc:	b9001be3 	str	w3, [sp, #24]
	ret = z_object_validate(ko, otype, init);
    a00147c0:	b9401be2 	ldr	w2, [sp, #24]
    a00147c4:	b9401fe1 	ldr	w1, [sp, #28]
    a00147c8:	f94017e0 	ldr	x0, [sp, #40]
    a00147cc:	940022be 	bl	a001d2c4 <z_object_validate>
    a00147d0:	b9003fe0 	str	w0, [sp, #60]
	return ret;
    a00147d4:	b9403fe0 	ldr	w0, [sp, #60]
}
    a00147d8:	a8c47bfd 	ldp	x29, x30, [sp], #64
    a00147dc:	d65f03c0 	ret

00000000a00147e0 <z_impl_k_sem_init>:
 */
static struct k_spinlock lock;

int z_impl_k_sem_init(struct k_sem *sem, unsigned int initial_count,
		      unsigned int limit)
{
    a00147e0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a00147e4:	910003fd 	mov	x29, sp
    a00147e8:	f9000fe0 	str	x0, [sp, #24]
    a00147ec:	b90017e1 	str	w1, [sp, #20]
    a00147f0:	b90013e2 	str	w2, [sp, #16]
	/*
	 * Limit cannot be zero and count cannot be greater than limit
	 */
	CHECKIF(limit == 0U || limit > K_SEM_MAX_LIMIT || initial_count > limit) {
    a00147f4:	b94013e0 	ldr	w0, [sp, #16]
    a00147f8:	7100001f 	cmp	w0, #0x0
    a00147fc:	540000a0 	b.eq	a0014810 <z_impl_k_sem_init+0x30>  // b.none
    a0014800:	b94017e1 	ldr	w1, [sp, #20]
    a0014804:	b94013e0 	ldr	w0, [sp, #16]
    a0014808:	6b00003f 	cmp	w1, w0
    a001480c:	54000069 	b.ls	a0014818 <z_impl_k_sem_init+0x38>  // b.plast
		SYS_PORT_TRACING_OBJ_FUNC(k_sem, init, sem, -EINVAL);

		return -EINVAL;
    a0014810:	128002a0 	mov	w0, #0xffffffea            	// #-22
    a0014814:	1400000c 	b	a0014844 <z_impl_k_sem_init+0x64>
	}

	sem->count = initial_count;
    a0014818:	f9400fe0 	ldr	x0, [sp, #24]
    a001481c:	b94017e1 	ldr	w1, [sp, #20]
    a0014820:	b9001001 	str	w1, [x0, #16]
	sem->limit = limit;
    a0014824:	f9400fe0 	ldr	x0, [sp, #24]
    a0014828:	b94013e1 	ldr	w1, [sp, #16]
    a001482c:	b9001401 	str	w1, [x0, #20]

	SYS_PORT_TRACING_OBJ_FUNC(k_sem, init, sem, 0);

	z_waitq_init(&sem->wait_q);
    a0014830:	f9400fe0 	ldr	x0, [sp, #24]
    a0014834:	97ffffd5 	bl	a0014788 <z_waitq_init>
#if defined(CONFIG_POLL)
	sys_dlist_init(&sem->poll_events);
#endif
	z_object_init(sem);
    a0014838:	f9400fe0 	ldr	x0, [sp, #24]
    a001483c:	940022f5 	bl	a001d410 <z_object_init>

	return 0;
    a0014840:	52800000 	mov	w0, #0x0                   	// #0
}
    a0014844:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0014848:	d65f03c0 	ret

00000000a001484c <z_vrfy_k_sem_init>:

#ifdef CONFIG_USERSPACE
int z_vrfy_k_sem_init(struct k_sem *sem, unsigned int initial_count,
		      unsigned int limit)
{
    a001484c:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a0014850:	910003fd 	mov	x29, sp
    a0014854:	f9000fe0 	str	x0, [sp, #24]
    a0014858:	b90017e1 	str	w1, [sp, #20]
    a001485c:	b90013e2 	str	w2, [sp, #16]
	Z_OOPS(Z_SYSCALL_OBJ_INIT(sem, K_OBJ_SEM));
    a0014860:	f9400fe0 	ldr	x0, [sp, #24]
    a0014864:	94002071 	bl	a001ca28 <z_object_find>
    a0014868:	52800023 	mov	w3, #0x1                   	// #1
    a001486c:	528000e2 	mov	w2, #0x7                   	// #7
    a0014870:	f9400fe1 	ldr	x1, [sp, #24]
    a0014874:	97ffffcd 	bl	a00147a8 <z_obj_validation_check>
    a0014878:	7100001f 	cmp	w0, #0x0
    a001487c:	1a9f07e0 	cset	w0, ne  // ne = any
    a0014880:	39063fe0 	strb	w0, [sp, #399]
    a0014884:	39463fe0 	ldrb	w0, [sp, #399]
    a0014888:	7100001f 	cmp	w0, #0x0
    a001488c:	39463fe0 	ldrb	w0, [sp, #399]
    a0014890:	7100001f 	cmp	w0, #0x0
    a0014894:	540000c0 	b.eq	a00148ac <z_vrfy_k_sem_init+0x60>  // b.none
    a0014898:	f0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001489c:	913f8000 	add	x0, x0, #0xfe0
    a00148a0:	f9400800 	ldr	x0, [x0, #16]
    a00148a4:	f9408400 	ldr	x0, [x0, #264]
    a00148a8:	97ffd22c 	bl	a0009158 <arch_syscall_oops>
	return z_impl_k_sem_init(sem, initial_count, limit);
    a00148ac:	b94013e2 	ldr	w2, [sp, #16]
    a00148b0:	b94017e1 	ldr	w1, [sp, #20]
    a00148b4:	f9400fe0 	ldr	x0, [sp, #24]
    a00148b8:	97ffffca 	bl	a00147e0 <z_impl_k_sem_init>
}
    a00148bc:	a8d97bfd 	ldp	x29, x30, [sp], #400
    a00148c0:	d65f03c0 	ret

00000000a00148c4 <z_mrsh_k_sem_init>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_sem_init(struct k_sem * sem, unsigned int initial_count, unsigned int limit);
uintptr_t z_mrsh_k_sem_init(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a00148c4:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a00148c8:	910003fd 	mov	x29, sp
    a00148cc:	f90027e0 	str	x0, [sp, #72]
    a00148d0:	f90023e1 	str	x1, [sp, #64]
    a00148d4:	f9001fe2 	str	x2, [sp, #56]
    a00148d8:	f9001be3 	str	x3, [sp, #48]
    a00148dc:	f90017e4 	str	x4, [sp, #40]
    a00148e0:	f90013e5 	str	x5, [sp, #32]
    a00148e4:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a00148e8:	f0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00148ec:	913f8000 	add	x0, x0, #0xfe0
    a00148f0:	f9400800 	ldr	x0, [x0, #16]
    a00148f4:	f9400fe1 	ldr	x1, [sp, #24]
    a00148f8:	f9008401 	str	x1, [x0, #264]
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_sem_init(*(struct k_sem **)&arg0, *(unsigned int*)&arg1, *(unsigned int*)&arg2)
    a00148fc:	910123e0 	add	x0, sp, #0x48
    a0014900:	f9400003 	ldr	x3, [x0]
    a0014904:	910103e0 	add	x0, sp, #0x40
    a0014908:	b9400001 	ldr	w1, [x0]
    a001490c:	9100e3e0 	add	x0, sp, #0x38
    a0014910:	b9400000 	ldr	w0, [x0]
    a0014914:	2a0003e2 	mov	w2, w0
    a0014918:	aa0303e0 	mov	x0, x3
    a001491c:	97ffffcc 	bl	a001484c <z_vrfy_k_sem_init>
    a0014920:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a0014924:	f0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0014928:	913f8000 	add	x0, x0, #0xfe0
    a001492c:	f9400800 	ldr	x0, [x0, #16]
    a0014930:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a0014934:	b9805fe0 	ldrsw	x0, [sp, #92]
}
    a0014938:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a001493c:	d65f03c0 	ret

00000000a0014940 <handle_poll_events>:
#include <syscalls/k_sem_init_mrsh.c>
#endif

static inline void handle_poll_events(struct k_sem *sem)
{
    a0014940:	d10043ff 	sub	sp, sp, #0x10
    a0014944:	f90007e0 	str	x0, [sp, #8]
#ifdef CONFIG_POLL
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
#else
	ARG_UNUSED(sem);
#endif
}
    a0014948:	d503201f 	nop
    a001494c:	910043ff 	add	sp, sp, #0x10
    a0014950:	d65f03c0 	ret

00000000a0014954 <z_impl_k_sem_give>:

void z_impl_k_sem_give(struct k_sem *sem)
{
    a0014954:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a0014958:	910003fd 	mov	x29, sp
    a001495c:	f9000fe0 	str	x0, [sp, #24]
    a0014960:	900001a0 	adrp	x0, a0048000 <_kernel+0x20>
    a0014964:	910a4000 	add	x0, x0, #0x290
    a0014968:	f9002be0 	str	x0, [sp, #80]
    a001496c:	d53b4220 	mrs	x0, daif
    a0014970:	f90027e0 	str	x0, [sp, #72]
    a0014974:	f94027e0 	ldr	x0, [sp, #72]
    a0014978:	d503201f 	nop
	key = read_daif();
    a001497c:	b90047e0 	str	w0, [sp, #68]
	__asm__ volatile ("msr DAIFSet, %0"
    a0014980:	d50342df 	msr	daifset, #0x2
}
    a0014984:	d503201f 	nop
	return key;
    a0014988:	b94047e0 	ldr	w0, [sp, #68]
	k.key = arch_irq_lock();
    a001498c:	b9002be0 	str	w0, [sp, #40]
	return k;
    a0014990:	b9402be0 	ldr	w0, [sp, #40]
    a0014994:	b90033e0 	str	w0, [sp, #48]
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
    a0014998:	f9400fe0 	ldr	x0, [sp, #24]
    a001499c:	94000ca3 	bl	a0017c28 <z_unpend_first_thread>
    a00149a0:	f9002fe0 	str	x0, [sp, #88]

	if (thread != NULL) {
    a00149a4:	f9402fe0 	ldr	x0, [sp, #88]
    a00149a8:	f100001f 	cmp	x0, #0x0
    a00149ac:	54000160 	b.eq	a00149d8 <z_impl_k_sem_give+0x84>  // b.none
    a00149b0:	f9402fe0 	ldr	x0, [sp, #88]
    a00149b4:	f9001fe0 	str	x0, [sp, #56]
    a00149b8:	b90037ff 	str	wzr, [sp, #52]
	thread->swap_retval = value;
    a00149bc:	b94037e1 	ldr	w1, [sp, #52]
    a00149c0:	f9401fe0 	ldr	x0, [sp, #56]
    a00149c4:	b9011001 	str	w1, [x0, #272]
}
    a00149c8:	d503201f 	nop
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
    a00149cc:	f9402fe0 	ldr	x0, [sp, #88]
    a00149d0:	940009c8 	bl	a00170f0 <z_ready_thread>
    a00149d4:	14000011 	b	a0014a18 <z_impl_k_sem_give+0xc4>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
    a00149d8:	f9400fe0 	ldr	x0, [sp, #24]
    a00149dc:	b9401001 	ldr	w1, [x0, #16]
    a00149e0:	f9400fe0 	ldr	x0, [sp, #24]
    a00149e4:	b9401002 	ldr	w2, [x0, #16]
    a00149e8:	f9400fe0 	ldr	x0, [sp, #24]
    a00149ec:	b9401400 	ldr	w0, [x0, #20]
    a00149f0:	6b00005f 	cmp	w2, w0
    a00149f4:	54000060 	b.eq	a0014a00 <z_impl_k_sem_give+0xac>  // b.none
    a00149f8:	52800020 	mov	w0, #0x1                   	// #1
    a00149fc:	14000002 	b	a0014a04 <z_impl_k_sem_give+0xb0>
    a0014a00:	52800000 	mov	w0, #0x0                   	// #0
    a0014a04:	0b010001 	add	w1, w0, w1
    a0014a08:	f9400fe0 	ldr	x0, [sp, #24]
    a0014a0c:	b9001001 	str	w1, [x0, #16]
		handle_poll_events(sem);
    a0014a10:	f9400fe0 	ldr	x0, [sp, #24]
    a0014a14:	97ffffcb 	bl	a0014940 <handle_poll_events>
	}

	z_reschedule(&lock, key);
    a0014a18:	b94033e1 	ldr	w1, [sp, #48]
    a0014a1c:	900001a0 	adrp	x0, a0048000 <_kernel+0x20>
    a0014a20:	910a4000 	add	x0, x0, #0x290
    a0014a24:	94000dbe 	bl	a001811c <z_reschedule>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
    a0014a28:	d503201f 	nop
    a0014a2c:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a0014a30:	d65f03c0 	ret

00000000a0014a34 <z_vrfy_k_sem_give>:

#ifdef CONFIG_USERSPACE
static inline void z_vrfy_k_sem_give(struct k_sem *sem)
{
    a0014a34:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a0014a38:	910003fd 	mov	x29, sp
    a0014a3c:	f9000fe0 	str	x0, [sp, #24]
	Z_OOPS(Z_SYSCALL_OBJ(sem, K_OBJ_SEM));
    a0014a40:	f9400fe0 	ldr	x0, [sp, #24]
    a0014a44:	94001ff9 	bl	a001ca28 <z_object_find>
    a0014a48:	52800003 	mov	w3, #0x0                   	// #0
    a0014a4c:	528000e2 	mov	w2, #0x7                   	// #7
    a0014a50:	f9400fe1 	ldr	x1, [sp, #24]
    a0014a54:	97ffff55 	bl	a00147a8 <z_obj_validation_check>
    a0014a58:	7100001f 	cmp	w0, #0x0
    a0014a5c:	1a9f07e0 	cset	w0, ne  // ne = any
    a0014a60:	39063fe0 	strb	w0, [sp, #399]
    a0014a64:	39463fe0 	ldrb	w0, [sp, #399]
    a0014a68:	7100001f 	cmp	w0, #0x0
    a0014a6c:	39463fe0 	ldrb	w0, [sp, #399]
    a0014a70:	7100001f 	cmp	w0, #0x0
    a0014a74:	540000c0 	b.eq	a0014a8c <z_vrfy_k_sem_give+0x58>  // b.none
    a0014a78:	f0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0014a7c:	913f8000 	add	x0, x0, #0xfe0
    a0014a80:	f9400800 	ldr	x0, [x0, #16]
    a0014a84:	f9408400 	ldr	x0, [x0, #264]
    a0014a88:	97ffd1b4 	bl	a0009158 <arch_syscall_oops>
	z_impl_k_sem_give(sem);
    a0014a8c:	f9400fe0 	ldr	x0, [sp, #24]
    a0014a90:	97ffffb1 	bl	a0014954 <z_impl_k_sem_give>
}
    a0014a94:	d503201f 	nop
    a0014a98:	a8d97bfd 	ldp	x29, x30, [sp], #400
    a0014a9c:	d65f03c0 	ret

00000000a0014aa0 <z_mrsh_k_sem_give>:
#include <syscalls/kernel.h>

extern void z_vrfy_k_sem_give(struct k_sem * sem);
uintptr_t z_mrsh_k_sem_give(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a0014aa0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a0014aa4:	910003fd 	mov	x29, sp
    a0014aa8:	f90027e0 	str	x0, [sp, #72]
    a0014aac:	f90023e1 	str	x1, [sp, #64]
    a0014ab0:	f9001fe2 	str	x2, [sp, #56]
    a0014ab4:	f9001be3 	str	x3, [sp, #48]
    a0014ab8:	f90017e4 	str	x4, [sp, #40]
    a0014abc:	f90013e5 	str	x5, [sp, #32]
    a0014ac0:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a0014ac4:	f0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0014ac8:	913f8000 	add	x0, x0, #0xfe0
    a0014acc:	f9400800 	ldr	x0, [x0, #16]
    a0014ad0:	f9400fe1 	ldr	x1, [sp, #24]
    a0014ad4:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_sem_give(*(struct k_sem **)&arg0)
    a0014ad8:	910123e0 	add	x0, sp, #0x48
    a0014adc:	f9400000 	ldr	x0, [x0]
    a0014ae0:	97ffffd5 	bl	a0014a34 <z_vrfy_k_sem_give>
;
	_current->syscall_frame = NULL;
    a0014ae4:	f0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0014ae8:	913f8000 	add	x0, x0, #0xfe0
    a0014aec:	f9400800 	ldr	x0, [x0, #16]
    a0014af0:	f900841f 	str	xzr, [x0, #264]
	return 0;
    a0014af4:	d2800000 	mov	x0, #0x0                   	// #0
}
    a0014af8:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a0014afc:	d65f03c0 	ret

00000000a0014b00 <z_impl_k_sem_take>:
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
    a0014b00:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
    a0014b04:	910003fd 	mov	x29, sp
    a0014b08:	f9000fe0 	str	x0, [sp, #24]
    a0014b0c:	f9000be1 	str	x1, [sp, #16]
	int ret = 0;
    a0014b10:	b9008fff 	str	wzr, [sp, #140]
    a0014b14:	900001a0 	adrp	x0, a0048000 <_kernel+0x20>
    a0014b18:	910a4000 	add	x0, x0, #0x290
    a0014b1c:	f90043e0 	str	x0, [sp, #128]
MAKE_REG_HELPER(daif)
    a0014b20:	d53b4220 	mrs	x0, daif
    a0014b24:	f9003fe0 	str	x0, [sp, #120]
    a0014b28:	f9403fe0 	ldr	x0, [sp, #120]
    a0014b2c:	d503201f 	nop
	key = read_daif();
    a0014b30:	b90077e0 	str	w0, [sp, #116]
	__asm__ volatile ("msr DAIFSet, %0"
    a0014b34:	d50342df 	msr	daifset, #0x2
}
    a0014b38:	d503201f 	nop
	return key;
    a0014b3c:	b94077e0 	ldr	w0, [sp, #116]
	k.key = arch_irq_lock();
    a0014b40:	b9002be0 	str	w0, [sp, #40]
	return k;
    a0014b44:	b9402be0 	ldr	w0, [sp, #40]
    a0014b48:	b9003be0 	str	w0, [sp, #56]

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
    a0014b4c:	f9400fe0 	ldr	x0, [sp, #24]
    a0014b50:	b9401000 	ldr	w0, [x0, #16]
    a0014b54:	7100001f 	cmp	w0, #0x0
    a0014b58:	1a9f07e0 	cset	w0, ne  // ne = any
    a0014b5c:	12001c00 	and	w0, w0, #0xff
    a0014b60:	92401c00 	and	x0, x0, #0xff
    a0014b64:	f100001f 	cmp	x0, #0x0
    a0014b68:	540002c0 	b.eq	a0014bc0 <z_impl_k_sem_take+0xc0>  // b.none
		sem->count--;
    a0014b6c:	f9400fe0 	ldr	x0, [sp, #24]
    a0014b70:	b9401000 	ldr	w0, [x0, #16]
    a0014b74:	51000401 	sub	w1, w0, #0x1
    a0014b78:	f9400fe0 	ldr	x0, [sp, #24]
    a0014b7c:	b9001001 	str	w1, [x0, #16]
    a0014b80:	900001a0 	adrp	x0, a0048000 <_kernel+0x20>
    a0014b84:	910a4000 	add	x0, x0, #0x290
    a0014b88:	f90037e0 	str	x0, [sp, #104]
    a0014b8c:	b9403be0 	ldr	w0, [sp, #56]
    a0014b90:	b90033e0 	str	w0, [sp, #48]
	arch_irq_unlock(key.key);
    a0014b94:	b94033e0 	ldr	w0, [sp, #48]
    a0014b98:	b90067e0 	str	w0, [sp, #100]
	write_daif(key);
    a0014b9c:	b94067e0 	ldr	w0, [sp, #100]
    a0014ba0:	f9002fe0 	str	x0, [sp, #88]
MAKE_REG_HELPER(daif)
    a0014ba4:	f9402fe0 	ldr	x0, [sp, #88]
    a0014ba8:	d51b4220 	msr	daif, x0
    a0014bac:	d503201f 	nop
}
    a0014bb0:	d503201f 	nop
}
    a0014bb4:	d503201f 	nop
		k_spin_unlock(&lock, key);
		ret = 0;
    a0014bb8:	b9008fff 	str	wzr, [sp, #140]
		goto out;
    a0014bbc:	1400001e 	b	a0014c34 <z_impl_k_sem_take+0x134>
	}

	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    a0014bc0:	f9400be0 	ldr	x0, [sp, #16]
    a0014bc4:	d2800001 	mov	x1, #0x0                   	// #0
    a0014bc8:	eb01001f 	cmp	x0, x1
    a0014bcc:	54000241 	b.ne	a0014c14 <z_impl_k_sem_take+0x114>  // b.any
    a0014bd0:	900001a0 	adrp	x0, a0048000 <_kernel+0x20>
    a0014bd4:	910a4000 	add	x0, x0, #0x290
    a0014bd8:	f9002be0 	str	x0, [sp, #80]
    a0014bdc:	b9403be0 	ldr	w0, [sp, #56]
    a0014be0:	b90023e0 	str	w0, [sp, #32]
	arch_irq_unlock(key.key);
    a0014be4:	b94023e0 	ldr	w0, [sp, #32]
    a0014be8:	b9004fe0 	str	w0, [sp, #76]
	write_daif(key);
    a0014bec:	b9404fe0 	ldr	w0, [sp, #76]
    a0014bf0:	f90023e0 	str	x0, [sp, #64]
    a0014bf4:	f94023e0 	ldr	x0, [sp, #64]
    a0014bf8:	d51b4220 	msr	daif, x0
    a0014bfc:	d503201f 	nop
}
    a0014c00:	d503201f 	nop
}
    a0014c04:	d503201f 	nop
		k_spin_unlock(&lock, key);
		ret = -EBUSY;
    a0014c08:	128001e0 	mov	w0, #0xfffffff0            	// #-16
    a0014c0c:	b9008fe0 	str	w0, [sp, #140]
    a0014c10:	14000009 	b	a0014c34 <z_impl_k_sem_take+0x134>
		goto out;
	}

	SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_sem, take, sem, timeout);

	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
    a0014c14:	f9400fe0 	ldr	x0, [sp, #24]
    a0014c18:	f9400be3 	ldr	x3, [sp, #16]
    a0014c1c:	aa0003e2 	mov	x2, x0
    a0014c20:	b9403be1 	ldr	w1, [sp, #56]
    a0014c24:	900001a0 	adrp	x0, a0048000 <_kernel+0x20>
    a0014c28:	910a4000 	add	x0, x0, #0x290
    a0014c2c:	94000bbc 	bl	a0017b1c <z_pend_curr>
    a0014c30:	b9008fe0 	str	w0, [sp, #140]

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
    a0014c34:	b9408fe0 	ldr	w0, [sp, #140]
}
    a0014c38:	a8c97bfd 	ldp	x29, x30, [sp], #144
    a0014c3c:	d65f03c0 	ret

00000000a0014c40 <z_impl_k_sem_reset>:

void z_impl_k_sem_reset(struct k_sem *sem)
{
    a0014c40:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a0014c44:	910003fd 	mov	x29, sp
    a0014c48:	f9000fe0 	str	x0, [sp, #24]
    a0014c4c:	900001a0 	adrp	x0, a0048000 <_kernel+0x20>
    a0014c50:	910a4000 	add	x0, x0, #0x290
    a0014c54:	f9002be0 	str	x0, [sp, #80]
    a0014c58:	d53b4220 	mrs	x0, daif
    a0014c5c:	f90027e0 	str	x0, [sp, #72]
    a0014c60:	f94027e0 	ldr	x0, [sp, #72]
    a0014c64:	d503201f 	nop
	key = read_daif();
    a0014c68:	b90047e0 	str	w0, [sp, #68]
	__asm__ volatile ("msr DAIFSet, %0"
    a0014c6c:	d50342df 	msr	daifset, #0x2
}
    a0014c70:	d503201f 	nop
	return key;
    a0014c74:	b94047e0 	ldr	w0, [sp, #68]
	k.key = arch_irq_lock();
    a0014c78:	b9002be0 	str	w0, [sp, #40]
	return k;
    a0014c7c:	b9402be0 	ldr	w0, [sp, #40]
    a0014c80:	b90033e0 	str	w0, [sp, #48]
	struct k_thread *thread;
	k_spinlock_key_t key = k_spin_lock(&lock);

	while (true) {
		thread = z_unpend_first_thread(&sem->wait_q);
    a0014c84:	f9400fe0 	ldr	x0, [sp, #24]
    a0014c88:	94000be8 	bl	a0017c28 <z_unpend_first_thread>
    a0014c8c:	f9002fe0 	str	x0, [sp, #88]
		if (thread == NULL) {
    a0014c90:	f9402fe0 	ldr	x0, [sp, #88]
    a0014c94:	f100001f 	cmp	x0, #0x0
    a0014c98:	54000180 	b.eq	a0014cc8 <z_impl_k_sem_reset+0x88>  // b.none
    a0014c9c:	f9402fe0 	ldr	x0, [sp, #88]
    a0014ca0:	f9001fe0 	str	x0, [sp, #56]
    a0014ca4:	12800140 	mov	w0, #0xfffffff5            	// #-11
    a0014ca8:	b90037e0 	str	w0, [sp, #52]
	thread->swap_retval = value;
    a0014cac:	b94037e1 	ldr	w1, [sp, #52]
    a0014cb0:	f9401fe0 	ldr	x0, [sp, #56]
    a0014cb4:	b9011001 	str	w1, [x0, #272]
}
    a0014cb8:	d503201f 	nop
			break;
		}
		arch_thread_return_value_set(thread, -EAGAIN);
		z_ready_thread(thread);
    a0014cbc:	f9402fe0 	ldr	x0, [sp, #88]
    a0014cc0:	9400090c 	bl	a00170f0 <z_ready_thread>
		thread = z_unpend_first_thread(&sem->wait_q);
    a0014cc4:	17fffff0 	b	a0014c84 <z_impl_k_sem_reset+0x44>
			break;
    a0014cc8:	d503201f 	nop
	}
	sem->count = 0;
    a0014ccc:	f9400fe0 	ldr	x0, [sp, #24]
    a0014cd0:	b900101f 	str	wzr, [x0, #16]

	SYS_PORT_TRACING_OBJ_FUNC(k_sem, reset, sem);

	handle_poll_events(sem);
    a0014cd4:	f9400fe0 	ldr	x0, [sp, #24]
    a0014cd8:	97ffff1a 	bl	a0014940 <handle_poll_events>

	z_reschedule(&lock, key);
    a0014cdc:	b94033e1 	ldr	w1, [sp, #48]
    a0014ce0:	900001a0 	adrp	x0, a0048000 <_kernel+0x20>
    a0014ce4:	910a4000 	add	x0, x0, #0x290
    a0014ce8:	94000d0d 	bl	a001811c <z_reschedule>
}
    a0014cec:	d503201f 	nop
    a0014cf0:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a0014cf4:	d65f03c0 	ret

00000000a0014cf8 <z_vrfy_k_sem_take>:

#ifdef CONFIG_USERSPACE
static inline int z_vrfy_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
    a0014cf8:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a0014cfc:	910003fd 	mov	x29, sp
    a0014d00:	f9000fe0 	str	x0, [sp, #24]
    a0014d04:	f9000be1 	str	x1, [sp, #16]
	Z_OOPS(Z_SYSCALL_OBJ(sem, K_OBJ_SEM));
    a0014d08:	f9400fe0 	ldr	x0, [sp, #24]
    a0014d0c:	94001f47 	bl	a001ca28 <z_object_find>
    a0014d10:	52800003 	mov	w3, #0x0                   	// #0
    a0014d14:	528000e2 	mov	w2, #0x7                   	// #7
    a0014d18:	f9400fe1 	ldr	x1, [sp, #24]
    a0014d1c:	97fffea3 	bl	a00147a8 <z_obj_validation_check>
    a0014d20:	7100001f 	cmp	w0, #0x0
    a0014d24:	1a9f07e0 	cset	w0, ne  // ne = any
    a0014d28:	39063fe0 	strb	w0, [sp, #399]
    a0014d2c:	39463fe0 	ldrb	w0, [sp, #399]
    a0014d30:	7100001f 	cmp	w0, #0x0
    a0014d34:	39463fe0 	ldrb	w0, [sp, #399]
    a0014d38:	7100001f 	cmp	w0, #0x0
    a0014d3c:	540000c0 	b.eq	a0014d54 <z_vrfy_k_sem_take+0x5c>  // b.none
    a0014d40:	f0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0014d44:	913f8000 	add	x0, x0, #0xfe0
    a0014d48:	f9400800 	ldr	x0, [x0, #16]
    a0014d4c:	f9408400 	ldr	x0, [x0, #264]
    a0014d50:	97ffd102 	bl	a0009158 <arch_syscall_oops>
	return z_impl_k_sem_take((struct k_sem *)sem, timeout);
    a0014d54:	f9400be1 	ldr	x1, [sp, #16]
    a0014d58:	f9400fe0 	ldr	x0, [sp, #24]
    a0014d5c:	97ffff69 	bl	a0014b00 <z_impl_k_sem_take>
}
    a0014d60:	a8d97bfd 	ldp	x29, x30, [sp], #400
    a0014d64:	d65f03c0 	ret

00000000a0014d68 <z_mrsh_k_sem_take>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_sem_take(struct k_sem * sem, k_timeout_t timeout);
uintptr_t z_mrsh_k_sem_take(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a0014d68:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a0014d6c:	910003fd 	mov	x29, sp
    a0014d70:	f90027e0 	str	x0, [sp, #72]
    a0014d74:	f90023e1 	str	x1, [sp, #64]
    a0014d78:	f9001fe2 	str	x2, [sp, #56]
    a0014d7c:	f9001be3 	str	x3, [sp, #48]
    a0014d80:	f90017e4 	str	x4, [sp, #40]
    a0014d84:	f90013e5 	str	x5, [sp, #32]
    a0014d88:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a0014d8c:	f0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0014d90:	913f8000 	add	x0, x0, #0xfe0
    a0014d94:	f9400800 	ldr	x0, [x0, #16]
    a0014d98:	f9400fe1 	ldr	x1, [sp, #24]
    a0014d9c:	f9008401 	str	x1, [x0, #264]
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_sem_take(*(struct k_sem **)&arg0, *(k_timeout_t*)&arg1)
    a0014da0:	910123e0 	add	x0, sp, #0x48
    a0014da4:	f9400002 	ldr	x2, [x0]
    a0014da8:	910103e0 	add	x0, sp, #0x40
    a0014dac:	f9400001 	ldr	x1, [x0]
    a0014db0:	aa0203e0 	mov	x0, x2
    a0014db4:	97ffffd1 	bl	a0014cf8 <z_vrfy_k_sem_take>
    a0014db8:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a0014dbc:	f0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0014dc0:	913f8000 	add	x0, x0, #0xfe0
    a0014dc4:	f9400800 	ldr	x0, [x0, #16]
    a0014dc8:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a0014dcc:	b9805fe0 	ldrsw	x0, [sp, #92]
}
    a0014dd0:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a0014dd4:	d65f03c0 	ret

00000000a0014dd8 <z_vrfy_k_sem_reset>:
#include <syscalls/k_sem_take_mrsh.c>

static inline void z_vrfy_k_sem_reset(struct k_sem *sem)
{
    a0014dd8:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a0014ddc:	910003fd 	mov	x29, sp
    a0014de0:	f9000fe0 	str	x0, [sp, #24]
	Z_OOPS(Z_SYSCALL_OBJ(sem, K_OBJ_SEM));
    a0014de4:	f9400fe0 	ldr	x0, [sp, #24]
    a0014de8:	94001f10 	bl	a001ca28 <z_object_find>
    a0014dec:	52800003 	mov	w3, #0x0                   	// #0
    a0014df0:	528000e2 	mov	w2, #0x7                   	// #7
    a0014df4:	f9400fe1 	ldr	x1, [sp, #24]
    a0014df8:	97fffe6c 	bl	a00147a8 <z_obj_validation_check>
    a0014dfc:	7100001f 	cmp	w0, #0x0
    a0014e00:	1a9f07e0 	cset	w0, ne  // ne = any
    a0014e04:	39063fe0 	strb	w0, [sp, #399]
    a0014e08:	39463fe0 	ldrb	w0, [sp, #399]
    a0014e0c:	7100001f 	cmp	w0, #0x0
    a0014e10:	39463fe0 	ldrb	w0, [sp, #399]
    a0014e14:	7100001f 	cmp	w0, #0x0
    a0014e18:	540000c0 	b.eq	a0014e30 <z_vrfy_k_sem_reset+0x58>  // b.none
    a0014e1c:	f0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0014e20:	913f8000 	add	x0, x0, #0xfe0
    a0014e24:	f9400800 	ldr	x0, [x0, #16]
    a0014e28:	f9408400 	ldr	x0, [x0, #264]
    a0014e2c:	97ffd0cb 	bl	a0009158 <arch_syscall_oops>
	z_impl_k_sem_reset(sem);
    a0014e30:	f9400fe0 	ldr	x0, [sp, #24]
    a0014e34:	97ffff83 	bl	a0014c40 <z_impl_k_sem_reset>
}
    a0014e38:	d503201f 	nop
    a0014e3c:	a8d97bfd 	ldp	x29, x30, [sp], #400
    a0014e40:	d65f03c0 	ret

00000000a0014e44 <z_mrsh_k_sem_reset>:
#include <syscalls/kernel.h>

extern void z_vrfy_k_sem_reset(struct k_sem * sem);
uintptr_t z_mrsh_k_sem_reset(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a0014e44:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a0014e48:	910003fd 	mov	x29, sp
    a0014e4c:	f90027e0 	str	x0, [sp, #72]
    a0014e50:	f90023e1 	str	x1, [sp, #64]
    a0014e54:	f9001fe2 	str	x2, [sp, #56]
    a0014e58:	f9001be3 	str	x3, [sp, #48]
    a0014e5c:	f90017e4 	str	x4, [sp, #40]
    a0014e60:	f90013e5 	str	x5, [sp, #32]
    a0014e64:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a0014e68:	f0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0014e6c:	913f8000 	add	x0, x0, #0xfe0
    a0014e70:	f9400800 	ldr	x0, [x0, #16]
    a0014e74:	f9400fe1 	ldr	x1, [sp, #24]
    a0014e78:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_sem_reset(*(struct k_sem **)&arg0)
    a0014e7c:	910123e0 	add	x0, sp, #0x48
    a0014e80:	f9400000 	ldr	x0, [x0]
    a0014e84:	97ffffd5 	bl	a0014dd8 <z_vrfy_k_sem_reset>
;
	_current->syscall_frame = NULL;
    a0014e88:	f0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0014e8c:	913f8000 	add	x0, x0, #0xfe0
    a0014e90:	f9400800 	ldr	x0, [x0, #16]
    a0014e94:	f900841f 	str	xzr, [x0, #264]
	return 0;
    a0014e98:	d2800000 	mov	x0, #0x0                   	// #0
}
    a0014e9c:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a0014ea0:	d65f03c0 	ret

00000000a0014ea4 <z_vrfy_k_sem_count_get>:
#include <syscalls/k_sem_reset_mrsh.c>

static inline unsigned int z_vrfy_k_sem_count_get(struct k_sem *sem)
{
    a0014ea4:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a0014ea8:	910003fd 	mov	x29, sp
    a0014eac:	f9000fe0 	str	x0, [sp, #24]
	Z_OOPS(Z_SYSCALL_OBJ(sem, K_OBJ_SEM));
    a0014eb0:	f9400fe0 	ldr	x0, [sp, #24]
    a0014eb4:	94001edd 	bl	a001ca28 <z_object_find>
    a0014eb8:	52800003 	mov	w3, #0x0                   	// #0
    a0014ebc:	528000e2 	mov	w2, #0x7                   	// #7
    a0014ec0:	f9400fe1 	ldr	x1, [sp, #24]
    a0014ec4:	97fffe39 	bl	a00147a8 <z_obj_validation_check>
    a0014ec8:	7100001f 	cmp	w0, #0x0
    a0014ecc:	1a9f07e0 	cset	w0, ne  // ne = any
    a0014ed0:	39063fe0 	strb	w0, [sp, #399]
    a0014ed4:	39463fe0 	ldrb	w0, [sp, #399]
    a0014ed8:	7100001f 	cmp	w0, #0x0
    a0014edc:	39463fe0 	ldrb	w0, [sp, #399]
    a0014ee0:	7100001f 	cmp	w0, #0x0
    a0014ee4:	540000c0 	b.eq	a0014efc <z_vrfy_k_sem_count_get+0x58>  // b.none
    a0014ee8:	f0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0014eec:	913f8000 	add	x0, x0, #0xfe0
    a0014ef0:	f9400800 	ldr	x0, [x0, #16]
    a0014ef4:	f9408400 	ldr	x0, [x0, #264]
    a0014ef8:	97ffd098 	bl	a0009158 <arch_syscall_oops>
	return z_impl_k_sem_count_get(sem);
    a0014efc:	f9400fe0 	ldr	x0, [sp, #24]
    a0014f00:	97fffe1c 	bl	a0014770 <z_impl_k_sem_count_get>
}
    a0014f04:	a8d97bfd 	ldp	x29, x30, [sp], #400
    a0014f08:	d65f03c0 	ret

00000000a0014f0c <z_mrsh_k_sem_count_get>:
#include <syscalls/kernel.h>

extern unsigned int z_vrfy_k_sem_count_get(struct k_sem * sem);
uintptr_t z_mrsh_k_sem_count_get(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a0014f0c:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a0014f10:	910003fd 	mov	x29, sp
    a0014f14:	f90027e0 	str	x0, [sp, #72]
    a0014f18:	f90023e1 	str	x1, [sp, #64]
    a0014f1c:	f9001fe2 	str	x2, [sp, #56]
    a0014f20:	f9001be3 	str	x3, [sp, #48]
    a0014f24:	f90017e4 	str	x4, [sp, #40]
    a0014f28:	f90013e5 	str	x5, [sp, #32]
    a0014f2c:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a0014f30:	f0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0014f34:	913f8000 	add	x0, x0, #0xfe0
    a0014f38:	f9400800 	ldr	x0, [x0, #16]
    a0014f3c:	f9400fe1 	ldr	x1, [sp, #24]
    a0014f40:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	unsigned int ret = z_vrfy_k_sem_count_get(*(struct k_sem **)&arg0)
    a0014f44:	910123e0 	add	x0, sp, #0x48
    a0014f48:	f9400000 	ldr	x0, [x0]
    a0014f4c:	97ffffd6 	bl	a0014ea4 <z_vrfy_k_sem_count_get>
    a0014f50:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a0014f54:	f0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0014f58:	913f8000 	add	x0, x0, #0xfe0
    a0014f5c:	f9400800 	ldr	x0, [x0, #16]
    a0014f60:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a0014f64:	b9405fe0 	ldr	w0, [sp, #92]
}
    a0014f68:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a0014f6c:	d65f03c0 	ret

00000000a0014f70 <sys_dlist_init>:
{
    a0014f70:	d10043ff 	sub	sp, sp, #0x10
    a0014f74:	f90007e0 	str	x0, [sp, #8]
	list->head = (sys_dnode_t *)list;
    a0014f78:	f94007e0 	ldr	x0, [sp, #8]
    a0014f7c:	f94007e1 	ldr	x1, [sp, #8]
    a0014f80:	f9000001 	str	x1, [x0]
	list->tail = (sys_dnode_t *)list;
    a0014f84:	f94007e0 	ldr	x0, [sp, #8]
    a0014f88:	f94007e1 	ldr	x1, [sp, #8]
    a0014f8c:	f9000401 	str	x1, [x0, #8]
}
    a0014f90:	d503201f 	nop
    a0014f94:	910043ff 	add	sp, sp, #0x10
    a0014f98:	d65f03c0 	ret

00000000a0014f9c <sys_dnode_init>:
{
    a0014f9c:	d10043ff 	sub	sp, sp, #0x10
    a0014fa0:	f90007e0 	str	x0, [sp, #8]
	node->next = NULL;
    a0014fa4:	f94007e0 	ldr	x0, [sp, #8]
    a0014fa8:	f900001f 	str	xzr, [x0]
	node->prev = NULL;
    a0014fac:	f94007e0 	ldr	x0, [sp, #8]
    a0014fb0:	f900041f 	str	xzr, [x0, #8]
}
    a0014fb4:	d503201f 	nop
    a0014fb8:	910043ff 	add	sp, sp, #0x10
    a0014fbc:	d65f03c0 	ret

00000000a0014fc0 <sys_dnode_is_linked>:
{
    a0014fc0:	d10043ff 	sub	sp, sp, #0x10
    a0014fc4:	f90007e0 	str	x0, [sp, #8]
	return node->next != NULL;
    a0014fc8:	f94007e0 	ldr	x0, [sp, #8]
    a0014fcc:	f9400000 	ldr	x0, [x0]
    a0014fd0:	f100001f 	cmp	x0, #0x0
    a0014fd4:	1a9f07e0 	cset	w0, ne  // ne = any
    a0014fd8:	12001c00 	and	w0, w0, #0xff
}
    a0014fdc:	910043ff 	add	sp, sp, #0x10
    a0014fe0:	d65f03c0 	ret

00000000a0014fe4 <sys_dlist_is_empty>:
{
    a0014fe4:	d10043ff 	sub	sp, sp, #0x10
    a0014fe8:	f90007e0 	str	x0, [sp, #8]
	return list->head == list;
    a0014fec:	f94007e0 	ldr	x0, [sp, #8]
    a0014ff0:	f9400000 	ldr	x0, [x0]
    a0014ff4:	f94007e1 	ldr	x1, [sp, #8]
    a0014ff8:	eb00003f 	cmp	x1, x0
    a0014ffc:	1a9f17e0 	cset	w0, eq  // eq = none
    a0015000:	12001c00 	and	w0, w0, #0xff
}
    a0015004:	910043ff 	add	sp, sp, #0x10
    a0015008:	d65f03c0 	ret

00000000a001500c <sys_dlist_peek_head>:
{
    a001500c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0015010:	910003fd 	mov	x29, sp
    a0015014:	f9000fe0 	str	x0, [sp, #24]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    a0015018:	f9400fe0 	ldr	x0, [sp, #24]
    a001501c:	97fffff2 	bl	a0014fe4 <sys_dlist_is_empty>
    a0015020:	12001c00 	and	w0, w0, #0xff
    a0015024:	7100001f 	cmp	w0, #0x0
    a0015028:	54000081 	b.ne	a0015038 <sys_dlist_peek_head+0x2c>  // b.any
    a001502c:	f9400fe0 	ldr	x0, [sp, #24]
    a0015030:	f9400000 	ldr	x0, [x0]
    a0015034:	14000002 	b	a001503c <sys_dlist_peek_head+0x30>
    a0015038:	d2800000 	mov	x0, #0x0                   	// #0
}
    a001503c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0015040:	d65f03c0 	ret

00000000a0015044 <sys_dlist_peek_next_no_check>:
 * @return a pointer to the next element from a node, NULL if node is the tail
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
    a0015044:	d10043ff 	sub	sp, sp, #0x10
    a0015048:	f90007e0 	str	x0, [sp, #8]
    a001504c:	f90003e1 	str	x1, [sp]
	return (node == list->tail) ? NULL : node->next;
    a0015050:	f94007e0 	ldr	x0, [sp, #8]
    a0015054:	f9400400 	ldr	x0, [x0, #8]
    a0015058:	f94003e1 	ldr	x1, [sp]
    a001505c:	eb00003f 	cmp	x1, x0
    a0015060:	54000080 	b.eq	a0015070 <sys_dlist_peek_next_no_check+0x2c>  // b.none
    a0015064:	f94003e0 	ldr	x0, [sp]
    a0015068:	f9400000 	ldr	x0, [x0]
    a001506c:	14000002 	b	a0015074 <sys_dlist_peek_next_no_check+0x30>
    a0015070:	d2800000 	mov	x0, #0x0                   	// #0
}
    a0015074:	910043ff 	add	sp, sp, #0x10
    a0015078:	d65f03c0 	ret

00000000a001507c <sys_dlist_peek_next>:
 * or NULL (when node comes from reading the head of an empty list).
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
    a001507c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0015080:	910003fd 	mov	x29, sp
    a0015084:	f9000fe0 	str	x0, [sp, #24]
    a0015088:	f9000be1 	str	x1, [sp, #16]
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    a001508c:	f9400be0 	ldr	x0, [sp, #16]
    a0015090:	f100001f 	cmp	x0, #0x0
    a0015094:	540000a0 	b.eq	a00150a8 <sys_dlist_peek_next+0x2c>  // b.none
    a0015098:	f9400be1 	ldr	x1, [sp, #16]
    a001509c:	f9400fe0 	ldr	x0, [sp, #24]
    a00150a0:	97ffffe9 	bl	a0015044 <sys_dlist_peek_next_no_check>
    a00150a4:	14000002 	b	a00150ac <sys_dlist_peek_next+0x30>
    a00150a8:	d2800000 	mov	x0, #0x0                   	// #0
}
    a00150ac:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a00150b0:	d65f03c0 	ret

00000000a00150b4 <sys_dlist_append>:
 * @param list the doubly-linked list to operate on
 * @param node the element to append
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
    a00150b4:	d10083ff 	sub	sp, sp, #0x20
    a00150b8:	f90007e0 	str	x0, [sp, #8]
    a00150bc:	f90003e1 	str	x1, [sp]
	sys_dnode_t *const tail = list->tail;
    a00150c0:	f94007e0 	ldr	x0, [sp, #8]
    a00150c4:	f9400400 	ldr	x0, [x0, #8]
    a00150c8:	f9000fe0 	str	x0, [sp, #24]

	node->next = list;
    a00150cc:	f94003e0 	ldr	x0, [sp]
    a00150d0:	f94007e1 	ldr	x1, [sp, #8]
    a00150d4:	f9000001 	str	x1, [x0]
	node->prev = tail;
    a00150d8:	f94003e0 	ldr	x0, [sp]
    a00150dc:	f9400fe1 	ldr	x1, [sp, #24]
    a00150e0:	f9000401 	str	x1, [x0, #8]

	tail->next = node;
    a00150e4:	f9400fe0 	ldr	x0, [sp, #24]
    a00150e8:	f94003e1 	ldr	x1, [sp]
    a00150ec:	f9000001 	str	x1, [x0]
	list->tail = node;
    a00150f0:	f94007e0 	ldr	x0, [sp, #8]
    a00150f4:	f94003e1 	ldr	x1, [sp]
    a00150f8:	f9000401 	str	x1, [x0, #8]
}
    a00150fc:	d503201f 	nop
    a0015100:	910083ff 	add	sp, sp, #0x20
    a0015104:	d65f03c0 	ret

00000000a0015108 <sys_dlist_insert>:
 *
 * @param successor the position before which "node" will be inserted
 * @param node the element to insert
 */
static inline void sys_dlist_insert(sys_dnode_t *successor, sys_dnode_t *node)
{
    a0015108:	d10083ff 	sub	sp, sp, #0x20
    a001510c:	f90007e0 	str	x0, [sp, #8]
    a0015110:	f90003e1 	str	x1, [sp]
	sys_dnode_t *const prev = successor->prev;
    a0015114:	f94007e0 	ldr	x0, [sp, #8]
    a0015118:	f9400400 	ldr	x0, [x0, #8]
    a001511c:	f9000fe0 	str	x0, [sp, #24]

	node->prev = prev;
    a0015120:	f94003e0 	ldr	x0, [sp]
    a0015124:	f9400fe1 	ldr	x1, [sp, #24]
    a0015128:	f9000401 	str	x1, [x0, #8]
	node->next = successor;
    a001512c:	f94003e0 	ldr	x0, [sp]
    a0015130:	f94007e1 	ldr	x1, [sp, #8]
    a0015134:	f9000001 	str	x1, [x0]
	prev->next = node;
    a0015138:	f9400fe0 	ldr	x0, [sp, #24]
    a001513c:	f94003e1 	ldr	x1, [sp]
    a0015140:	f9000001 	str	x1, [x0]
	successor->prev = node;
    a0015144:	f94007e0 	ldr	x0, [sp, #8]
    a0015148:	f94003e1 	ldr	x1, [sp]
    a001514c:	f9000401 	str	x1, [x0, #8]
}
    a0015150:	d503201f 	nop
    a0015154:	910083ff 	add	sp, sp, #0x20
    a0015158:	d65f03c0 	ret

00000000a001515c <sys_dlist_remove>:
 *
 * @param node the node to remove
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
    a001515c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0015160:	910003fd 	mov	x29, sp
    a0015164:	f9000fe0 	str	x0, [sp, #24]
	sys_dnode_t *const prev = node->prev;
    a0015168:	f9400fe0 	ldr	x0, [sp, #24]
    a001516c:	f9400400 	ldr	x0, [x0, #8]
    a0015170:	f90017e0 	str	x0, [sp, #40]
	sys_dnode_t *const next = node->next;
    a0015174:	f9400fe0 	ldr	x0, [sp, #24]
    a0015178:	f9400000 	ldr	x0, [x0]
    a001517c:	f90013e0 	str	x0, [sp, #32]

	prev->next = next;
    a0015180:	f94017e0 	ldr	x0, [sp, #40]
    a0015184:	f94013e1 	ldr	x1, [sp, #32]
    a0015188:	f9000001 	str	x1, [x0]
	next->prev = prev;
    a001518c:	f94013e0 	ldr	x0, [sp, #32]
    a0015190:	f94017e1 	ldr	x1, [sp, #40]
    a0015194:	f9000401 	str	x1, [x0, #8]
	sys_dnode_init(node);
    a0015198:	f9400fe0 	ldr	x0, [sp, #24]
    a001519c:	97ffff80 	bl	a0014f9c <sys_dnode_init>
}
    a00151a0:	d503201f 	nop
    a00151a4:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a00151a8:	d65f03c0 	ret

00000000a00151ac <arch_syscall_invoke1>:
{
    a00151ac:	d10043ff 	sub	sp, sp, #0x10
    a00151b0:	f90007e0 	str	x0, [sp, #8]
    a00151b4:	f90003e1 	str	x1, [sp]
	register uint64_t ret __asm__("x0") = arg1;
    a00151b8:	f94007e0 	ldr	x0, [sp, #8]
	register uint64_t r8 __asm__("x8") = call_id;
    a00151bc:	f94003e8 	ldr	x8, [sp]
	__asm__ volatile("svc %[svid]\n"
    a00151c0:	d4000061 	svc	#0x3
}
    a00151c4:	910043ff 	add	sp, sp, #0x10
    a00151c8:	d65f03c0 	ret

00000000a00151cc <arch_syscall_invoke0>:
{
    a00151cc:	d10043ff 	sub	sp, sp, #0x10
    a00151d0:	f90007e0 	str	x0, [sp, #8]
	register uint64_t r8 __asm__("x8") = call_id;
    a00151d4:	f94007e8 	ldr	x8, [sp, #8]
	__asm__ volatile("svc %[svid]\n"
    a00151d8:	d4000061 	svc	#0x3
}
    a00151dc:	910043ff 	add	sp, sp, #0x10
    a00151e0:	d65f03c0 	ret

00000000a00151e4 <arch_cohere_stacks>:
{
    a00151e4:	d10083ff 	sub	sp, sp, #0x20
    a00151e8:	f9000fe0 	str	x0, [sp, #24]
    a00151ec:	f9000be1 	str	x1, [sp, #16]
    a00151f0:	f90007e2 	str	x2, [sp, #8]
}
    a00151f4:	d503201f 	nop
    a00151f8:	910083ff 	add	sp, sp, #0x20
    a00151fc:	d65f03c0 	ret

00000000a0015200 <k_ms_to_ticks_ceil32>:
{
    a0015200:	d10103ff 	sub	sp, sp, #0x40
    a0015204:	b9000fe0 	str	w0, [sp, #12]
	return z_tmcvt(t, Z_HZ_ms, Z_HZ_ticks, true, true, true, false);
    a0015208:	b9400fe0 	ldr	w0, [sp, #12]
    a001520c:	f9001fe0 	str	x0, [sp, #56]
    a0015210:	52807d00 	mov	w0, #0x3e8                 	// #1000
    a0015214:	b90037e0 	str	w0, [sp, #52]
    a0015218:	52800c80 	mov	w0, #0x64                  	// #100
    a001521c:	b90033e0 	str	w0, [sp, #48]
    a0015220:	52800020 	mov	w0, #0x1                   	// #1
    a0015224:	3900bfe0 	strb	w0, [sp, #47]
    a0015228:	52800020 	mov	w0, #0x1                   	// #1
    a001522c:	3900bbe0 	strb	w0, [sp, #46]
    a0015230:	52800020 	mov	w0, #0x1                   	// #1
    a0015234:	3900b7e0 	strb	w0, [sp, #45]
    a0015238:	3900b3ff 	strb	wzr, [sp, #44]
		(to_hz > from_hz) && ((to_hz % from_hz) == 0U);
    a001523c:	3940bfe0 	ldrb	w0, [sp, #47]
    a0015240:	7100001f 	cmp	w0, #0x0
    a0015244:	540001e0 	b.eq	a0015280 <k_ms_to_ticks_ceil32+0x80>  // b.none
	bool mul_ratio = const_hz &&
    a0015248:	b94037e1 	ldr	w1, [sp, #52]
    a001524c:	b94033e0 	ldr	w0, [sp, #48]
    a0015250:	6b00003f 	cmp	w1, w0
    a0015254:	54000162 	b.cs	a0015280 <k_ms_to_ticks_ceil32+0x80>  // b.hs, b.nlast
		(to_hz > from_hz) && ((to_hz % from_hz) == 0U);
    a0015258:	b94033e0 	ldr	w0, [sp, #48]
    a001525c:	b94037e1 	ldr	w1, [sp, #52]
    a0015260:	1ac10802 	udiv	w2, w0, w1
    a0015264:	b94037e1 	ldr	w1, [sp, #52]
    a0015268:	1b017c41 	mul	w1, w2, w1
    a001526c:	4b010000 	sub	w0, w0, w1
    a0015270:	7100001f 	cmp	w0, #0x0
    a0015274:	54000061 	b.ne	a0015280 <k_ms_to_ticks_ceil32+0x80>  // b.any
    a0015278:	52800020 	mov	w0, #0x1                   	// #1
    a001527c:	14000002 	b	a0015284 <k_ms_to_ticks_ceil32+0x84>
    a0015280:	52800000 	mov	w0, #0x0                   	// #0
	bool mul_ratio = const_hz &&
    a0015284:	3900afe0 	strb	w0, [sp, #43]
    a0015288:	3940afe0 	ldrb	w0, [sp, #43]
    a001528c:	12000000 	and	w0, w0, #0x1
    a0015290:	3900afe0 	strb	w0, [sp, #43]
		(from_hz > to_hz) && ((from_hz % to_hz) == 0U);
    a0015294:	3940bfe0 	ldrb	w0, [sp, #47]
    a0015298:	7100001f 	cmp	w0, #0x0
    a001529c:	540001e0 	b.eq	a00152d8 <k_ms_to_ticks_ceil32+0xd8>  // b.none
	bool div_ratio = const_hz &&
    a00152a0:	b94037e1 	ldr	w1, [sp, #52]
    a00152a4:	b94033e0 	ldr	w0, [sp, #48]
    a00152a8:	6b00003f 	cmp	w1, w0
    a00152ac:	54000169 	b.ls	a00152d8 <k_ms_to_ticks_ceil32+0xd8>  // b.plast
		(from_hz > to_hz) && ((from_hz % to_hz) == 0U);
    a00152b0:	b94037e0 	ldr	w0, [sp, #52]
    a00152b4:	b94033e1 	ldr	w1, [sp, #48]
    a00152b8:	1ac10802 	udiv	w2, w0, w1
    a00152bc:	b94033e1 	ldr	w1, [sp, #48]
    a00152c0:	1b017c41 	mul	w1, w2, w1
    a00152c4:	4b010000 	sub	w0, w0, w1
    a00152c8:	7100001f 	cmp	w0, #0x0
    a00152cc:	54000061 	b.ne	a00152d8 <k_ms_to_ticks_ceil32+0xd8>  // b.any
    a00152d0:	52800020 	mov	w0, #0x1                   	// #1
    a00152d4:	14000002 	b	a00152dc <k_ms_to_ticks_ceil32+0xdc>
    a00152d8:	52800000 	mov	w0, #0x0                   	// #0
	bool div_ratio = const_hz &&
    a00152dc:	3900abe0 	strb	w0, [sp, #42]
    a00152e0:	3940abe0 	ldrb	w0, [sp, #42]
    a00152e4:	12000000 	and	w0, w0, #0x1
    a00152e8:	3900abe0 	strb	w0, [sp, #42]
	if (from_hz == to_hz) {
    a00152ec:	b94037e1 	ldr	w1, [sp, #52]
    a00152f0:	b94033e0 	ldr	w0, [sp, #48]
    a00152f4:	6b00003f 	cmp	w1, w0
    a00152f8:	54000121 	b.ne	a001531c <k_ms_to_ticks_ceil32+0x11c>  // b.any
		return result32 ? ((uint32_t)t) : t;
    a00152fc:	3940bbe0 	ldrb	w0, [sp, #46]
    a0015300:	7100001f 	cmp	w0, #0x0
    a0015304:	54000080 	b.eq	a0015314 <k_ms_to_ticks_ceil32+0x114>  // b.none
    a0015308:	f9401fe0 	ldr	x0, [sp, #56]
    a001530c:	2a0003e0 	mov	w0, w0
    a0015310:	14000089 	b	a0015534 <k_ms_to_ticks_ceil32+0x334>
    a0015314:	f9401fe0 	ldr	x0, [sp, #56]
    a0015318:	14000087 	b	a0015534 <k_ms_to_ticks_ceil32+0x334>
	uint64_t off = 0;
    a001531c:	f90013ff 	str	xzr, [sp, #32]
	if (!mul_ratio) {
    a0015320:	3940afe0 	ldrb	w0, [sp, #43]
    a0015324:	52000000 	eor	w0, w0, #0x1
    a0015328:	12001c00 	and	w0, w0, #0xff
    a001532c:	7100001f 	cmp	w0, #0x0
    a0015330:	54000300 	b.eq	a0015390 <k_ms_to_ticks_ceil32+0x190>  // b.none
		uint32_t rdivisor = div_ratio ? (from_hz / to_hz) : from_hz;
    a0015334:	3940abe0 	ldrb	w0, [sp, #42]
    a0015338:	7100001f 	cmp	w0, #0x0
    a001533c:	540000a0 	b.eq	a0015350 <k_ms_to_ticks_ceil32+0x150>  // b.none
    a0015340:	b94037e1 	ldr	w1, [sp, #52]
    a0015344:	b94033e0 	ldr	w0, [sp, #48]
    a0015348:	1ac00820 	udiv	w0, w1, w0
    a001534c:	14000002 	b	a0015354 <k_ms_to_ticks_ceil32+0x154>
    a0015350:	b94037e0 	ldr	w0, [sp, #52]
    a0015354:	b9001fe0 	str	w0, [sp, #28]
		if (round_up) {
    a0015358:	3940b7e0 	ldrb	w0, [sp, #45]
    a001535c:	7100001f 	cmp	w0, #0x0
    a0015360:	540000a0 	b.eq	a0015374 <k_ms_to_ticks_ceil32+0x174>  // b.none
			off = rdivisor - 1U;
    a0015364:	b9401fe0 	ldr	w0, [sp, #28]
    a0015368:	51000400 	sub	w0, w0, #0x1
    a001536c:	2a0003e0 	mov	w0, w0
    a0015370:	f90013e0 	str	x0, [sp, #32]
		if (round_off) {
    a0015374:	3940b3e0 	ldrb	w0, [sp, #44]
    a0015378:	7100001f 	cmp	w0, #0x0
    a001537c:	540000a0 	b.eq	a0015390 <k_ms_to_ticks_ceil32+0x190>  // b.none
			off = rdivisor / 2U;
    a0015380:	b9401fe0 	ldr	w0, [sp, #28]
    a0015384:	53017c00 	lsr	w0, w0, #1
    a0015388:	2a0003e0 	mov	w0, w0
    a001538c:	f90013e0 	str	x0, [sp, #32]
	if (div_ratio) {
    a0015390:	3940abe0 	ldrb	w0, [sp, #42]
    a0015394:	7100001f 	cmp	w0, #0x0
    a0015398:	54000360 	b.eq	a0015404 <k_ms_to_ticks_ceil32+0x204>  // b.none
		t += off;
    a001539c:	f9401fe1 	ldr	x1, [sp, #56]
    a00153a0:	f94013e0 	ldr	x0, [sp, #32]
    a00153a4:	8b000020 	add	x0, x1, x0
    a00153a8:	f9001fe0 	str	x0, [sp, #56]
		if (result32 && (t < BIT64(32))) {
    a00153ac:	3940bbe0 	ldrb	w0, [sp, #46]
    a00153b0:	7100001f 	cmp	w0, #0x0
    a00153b4:	540001a0 	b.eq	a00153e8 <k_ms_to_ticks_ceil32+0x1e8>  // b.none
    a00153b8:	f9401fe1 	ldr	x1, [sp, #56]
    a00153bc:	b2407fe0 	mov	x0, #0xffffffff            	// #4294967295
    a00153c0:	eb00003f 	cmp	x1, x0
    a00153c4:	54000128 	b.hi	a00153e8 <k_ms_to_ticks_ceil32+0x1e8>  // b.pmore
			return ((uint32_t)t) / (from_hz / to_hz);
    a00153c8:	f9401fe0 	ldr	x0, [sp, #56]
    a00153cc:	2a0003e2 	mov	w2, w0
    a00153d0:	b94037e1 	ldr	w1, [sp, #52]
    a00153d4:	b94033e0 	ldr	w0, [sp, #48]
    a00153d8:	1ac00820 	udiv	w0, w1, w0
    a00153dc:	1ac00840 	udiv	w0, w2, w0
    a00153e0:	2a0003e0 	mov	w0, w0
    a00153e4:	14000054 	b	a0015534 <k_ms_to_ticks_ceil32+0x334>
			return t / ((uint64_t)from_hz / to_hz);
    a00153e8:	b94037e1 	ldr	w1, [sp, #52]
    a00153ec:	b94033e0 	ldr	w0, [sp, #48]
    a00153f0:	1ac00820 	udiv	w0, w1, w0
    a00153f4:	2a0003e0 	mov	w0, w0
    a00153f8:	f9401fe1 	ldr	x1, [sp, #56]
    a00153fc:	9ac00820 	udiv	x0, x1, x0
    a0015400:	1400004d 	b	a0015534 <k_ms_to_ticks_ceil32+0x334>
	} else if (mul_ratio) {
    a0015404:	3940afe0 	ldrb	w0, [sp, #43]
    a0015408:	7100001f 	cmp	w0, #0x0
    a001540c:	54000260 	b.eq	a0015458 <k_ms_to_ticks_ceil32+0x258>  // b.none
		if (result32) {
    a0015410:	3940bbe0 	ldrb	w0, [sp, #46]
    a0015414:	7100001f 	cmp	w0, #0x0
    a0015418:	54000120 	b.eq	a001543c <k_ms_to_ticks_ceil32+0x23c>  // b.none
			return ((uint32_t)t) * (to_hz / from_hz);
    a001541c:	f9401fe0 	ldr	x0, [sp, #56]
    a0015420:	2a0003e2 	mov	w2, w0
    a0015424:	b94033e1 	ldr	w1, [sp, #48]
    a0015428:	b94037e0 	ldr	w0, [sp, #52]
    a001542c:	1ac00820 	udiv	w0, w1, w0
    a0015430:	1b007c40 	mul	w0, w2, w0
    a0015434:	2a0003e0 	mov	w0, w0
    a0015438:	1400003f 	b	a0015534 <k_ms_to_ticks_ceil32+0x334>
			return t * ((uint64_t)to_hz / from_hz);
    a001543c:	b94033e1 	ldr	w1, [sp, #48]
    a0015440:	b94037e0 	ldr	w0, [sp, #52]
    a0015444:	1ac00820 	udiv	w0, w1, w0
    a0015448:	2a0003e1 	mov	w1, w0
    a001544c:	f9401fe0 	ldr	x0, [sp, #56]
    a0015450:	9b007c20 	mul	x0, x1, x0
    a0015454:	14000038 	b	a0015534 <k_ms_to_ticks_ceil32+0x334>
		if (result32) {
    a0015458:	3940bbe0 	ldrb	w0, [sp, #46]
    a001545c:	7100001f 	cmp	w0, #0x0
    a0015460:	54000140 	b.eq	a0015488 <k_ms_to_ticks_ceil32+0x288>  // b.none
			return (uint32_t)((t * to_hz + off) / from_hz);
    a0015464:	b94033e1 	ldr	w1, [sp, #48]
    a0015468:	f9401fe0 	ldr	x0, [sp, #56]
    a001546c:	9b007c21 	mul	x1, x1, x0
    a0015470:	f94013e0 	ldr	x0, [sp, #32]
    a0015474:	8b000021 	add	x1, x1, x0
    a0015478:	b94037e0 	ldr	w0, [sp, #52]
    a001547c:	9ac00820 	udiv	x0, x1, x0
    a0015480:	2a0003e0 	mov	w0, w0
    a0015484:	1400002c 	b	a0015534 <k_ms_to_ticks_ceil32+0x334>
		} else if (const_hz && Z_TMCVT_USE_FAST_ALGO(from_hz, to_hz)) {
    a0015488:	3940bfe0 	ldrb	w0, [sp, #47]
    a001548c:	7100001f 	cmp	w0, #0x0
    a0015490:	54000300 	b.eq	a00154f0 <k_ms_to_ticks_ceil32+0x2f0>  // b.none
    a0015494:	b94037e1 	ldr	w1, [sp, #52]
    a0015498:	d2867000 	mov	x0, #0x3380                	// #13184
    a001549c:	f2a03c20 	movk	x0, #0x1e1, lsl #16
    a00154a0:	9b007c21 	mul	x1, x1, x0
    a00154a4:	b27f7be0 	mov	x0, #0xfffffffe            	// #4294967294
    a00154a8:	8b000021 	add	x1, x1, x0
    a00154ac:	320107e0 	mov	w0, #0x80000001            	// #-2147483647
    a00154b0:	f2f00000 	movk	x0, #0x8000, lsl #48
    a00154b4:	9bc07c20 	umulh	x0, x1, x0
    a00154b8:	d35ffc01 	lsr	x1, x0, #31
    a00154bc:	b94033e0 	ldr	w0, [sp, #48]
    a00154c0:	9b007c21 	mul	x1, x1, x0
    a00154c4:	b2407fe0 	mov	x0, #0xffffffff            	// #4294967295
    a00154c8:	eb00003f 	cmp	x1, x0
    a00154cc:	54000128 	b.hi	a00154f0 <k_ms_to_ticks_ceil32+0x2f0>  // b.pmore
			return ((t * to_hz + off) / from_hz);
    a00154d0:	b94033e1 	ldr	w1, [sp, #48]
    a00154d4:	f9401fe0 	ldr	x0, [sp, #56]
    a00154d8:	9b007c21 	mul	x1, x1, x0
    a00154dc:	f94013e0 	ldr	x0, [sp, #32]
    a00154e0:	8b000021 	add	x1, x1, x0
    a00154e4:	b94037e0 	ldr	w0, [sp, #52]
    a00154e8:	9ac00820 	udiv	x0, x1, x0
    a00154ec:	14000012 	b	a0015534 <k_ms_to_ticks_ceil32+0x334>
			return (t / from_hz) * to_hz + ((t % from_hz) * to_hz + off) / from_hz;
    a00154f0:	b94037e0 	ldr	w0, [sp, #52]
    a00154f4:	f9401fe1 	ldr	x1, [sp, #56]
    a00154f8:	9ac00821 	udiv	x1, x1, x0
    a00154fc:	b94033e0 	ldr	w0, [sp, #48]
    a0015500:	9b007c22 	mul	x2, x1, x0
    a0015504:	b94037e1 	ldr	w1, [sp, #52]
    a0015508:	f9401fe0 	ldr	x0, [sp, #56]
    a001550c:	9ac10803 	udiv	x3, x0, x1
    a0015510:	9b017c61 	mul	x1, x3, x1
    a0015514:	cb010001 	sub	x1, x0, x1
    a0015518:	b94033e0 	ldr	w0, [sp, #48]
    a001551c:	9b007c21 	mul	x1, x1, x0
    a0015520:	f94013e0 	ldr	x0, [sp, #32]
    a0015524:	8b000021 	add	x1, x1, x0
    a0015528:	b94037e0 	ldr	w0, [sp, #52]
    a001552c:	9ac00820 	udiv	x0, x1, x0
    a0015530:	8b000040 	add	x0, x2, x0
}
    a0015534:	910103ff 	add	sp, sp, #0x40
    a0015538:	d65f03c0 	ret

00000000a001553c <k_us_to_ticks_ceil64>:
{
    a001553c:	d10103ff 	sub	sp, sp, #0x40
    a0015540:	f90007e0 	str	x0, [sp, #8]
    a0015544:	f94007e0 	ldr	x0, [sp, #8]
    a0015548:	f9001fe0 	str	x0, [sp, #56]
    a001554c:	52884800 	mov	w0, #0x4240                	// #16960
    a0015550:	72a001e0 	movk	w0, #0xf, lsl #16
    a0015554:	b90037e0 	str	w0, [sp, #52]
    a0015558:	52800c80 	mov	w0, #0x64                  	// #100
    a001555c:	b90033e0 	str	w0, [sp, #48]
    a0015560:	52800020 	mov	w0, #0x1                   	// #1
    a0015564:	3900bfe0 	strb	w0, [sp, #47]
    a0015568:	3900bbff 	strb	wzr, [sp, #46]
    a001556c:	52800020 	mov	w0, #0x1                   	// #1
    a0015570:	3900b7e0 	strb	w0, [sp, #45]
    a0015574:	3900b3ff 	strb	wzr, [sp, #44]
		(to_hz > from_hz) && ((to_hz % from_hz) == 0U);
    a0015578:	3940bfe0 	ldrb	w0, [sp, #47]
    a001557c:	7100001f 	cmp	w0, #0x0
    a0015580:	540001e0 	b.eq	a00155bc <k_us_to_ticks_ceil64+0x80>  // b.none
	bool mul_ratio = const_hz &&
    a0015584:	b94037e1 	ldr	w1, [sp, #52]
    a0015588:	b94033e0 	ldr	w0, [sp, #48]
    a001558c:	6b00003f 	cmp	w1, w0
    a0015590:	54000162 	b.cs	a00155bc <k_us_to_ticks_ceil64+0x80>  // b.hs, b.nlast
		(to_hz > from_hz) && ((to_hz % from_hz) == 0U);
    a0015594:	b94033e0 	ldr	w0, [sp, #48]
    a0015598:	b94037e1 	ldr	w1, [sp, #52]
    a001559c:	1ac10802 	udiv	w2, w0, w1
    a00155a0:	b94037e1 	ldr	w1, [sp, #52]
    a00155a4:	1b017c41 	mul	w1, w2, w1
    a00155a8:	4b010000 	sub	w0, w0, w1
    a00155ac:	7100001f 	cmp	w0, #0x0
    a00155b0:	54000061 	b.ne	a00155bc <k_us_to_ticks_ceil64+0x80>  // b.any
    a00155b4:	52800020 	mov	w0, #0x1                   	// #1
    a00155b8:	14000002 	b	a00155c0 <k_us_to_ticks_ceil64+0x84>
    a00155bc:	52800000 	mov	w0, #0x0                   	// #0
	bool mul_ratio = const_hz &&
    a00155c0:	3900afe0 	strb	w0, [sp, #43]
    a00155c4:	3940afe0 	ldrb	w0, [sp, #43]
    a00155c8:	12000000 	and	w0, w0, #0x1
    a00155cc:	3900afe0 	strb	w0, [sp, #43]
		(from_hz > to_hz) && ((from_hz % to_hz) == 0U);
    a00155d0:	3940bfe0 	ldrb	w0, [sp, #47]
    a00155d4:	7100001f 	cmp	w0, #0x0
    a00155d8:	540001e0 	b.eq	a0015614 <k_us_to_ticks_ceil64+0xd8>  // b.none
	bool div_ratio = const_hz &&
    a00155dc:	b94037e1 	ldr	w1, [sp, #52]
    a00155e0:	b94033e0 	ldr	w0, [sp, #48]
    a00155e4:	6b00003f 	cmp	w1, w0
    a00155e8:	54000169 	b.ls	a0015614 <k_us_to_ticks_ceil64+0xd8>  // b.plast
		(from_hz > to_hz) && ((from_hz % to_hz) == 0U);
    a00155ec:	b94037e0 	ldr	w0, [sp, #52]
    a00155f0:	b94033e1 	ldr	w1, [sp, #48]
    a00155f4:	1ac10802 	udiv	w2, w0, w1
    a00155f8:	b94033e1 	ldr	w1, [sp, #48]
    a00155fc:	1b017c41 	mul	w1, w2, w1
    a0015600:	4b010000 	sub	w0, w0, w1
    a0015604:	7100001f 	cmp	w0, #0x0
    a0015608:	54000061 	b.ne	a0015614 <k_us_to_ticks_ceil64+0xd8>  // b.any
    a001560c:	52800020 	mov	w0, #0x1                   	// #1
    a0015610:	14000002 	b	a0015618 <k_us_to_ticks_ceil64+0xdc>
    a0015614:	52800000 	mov	w0, #0x0                   	// #0
	bool div_ratio = const_hz &&
    a0015618:	3900abe0 	strb	w0, [sp, #42]
    a001561c:	3940abe0 	ldrb	w0, [sp, #42]
    a0015620:	12000000 	and	w0, w0, #0x1
    a0015624:	3900abe0 	strb	w0, [sp, #42]
	if (from_hz == to_hz) {
    a0015628:	b94037e1 	ldr	w1, [sp, #52]
    a001562c:	b94033e0 	ldr	w0, [sp, #48]
    a0015630:	6b00003f 	cmp	w1, w0
    a0015634:	54000121 	b.ne	a0015658 <k_us_to_ticks_ceil64+0x11c>  // b.any
		return result32 ? ((uint32_t)t) : t;
    a0015638:	3940bbe0 	ldrb	w0, [sp, #46]
    a001563c:	7100001f 	cmp	w0, #0x0
    a0015640:	54000080 	b.eq	a0015650 <k_us_to_ticks_ceil64+0x114>  // b.none
    a0015644:	f9401fe0 	ldr	x0, [sp, #56]
    a0015648:	2a0003e0 	mov	w0, w0
    a001564c:	14000089 	b	a0015870 <k_us_to_ticks_ceil64+0x334>
    a0015650:	f9401fe0 	ldr	x0, [sp, #56]
    a0015654:	14000087 	b	a0015870 <k_us_to_ticks_ceil64+0x334>
	uint64_t off = 0;
    a0015658:	f90013ff 	str	xzr, [sp, #32]
	if (!mul_ratio) {
    a001565c:	3940afe0 	ldrb	w0, [sp, #43]
    a0015660:	52000000 	eor	w0, w0, #0x1
    a0015664:	12001c00 	and	w0, w0, #0xff
    a0015668:	7100001f 	cmp	w0, #0x0
    a001566c:	54000300 	b.eq	a00156cc <k_us_to_ticks_ceil64+0x190>  // b.none
		uint32_t rdivisor = div_ratio ? (from_hz / to_hz) : from_hz;
    a0015670:	3940abe0 	ldrb	w0, [sp, #42]
    a0015674:	7100001f 	cmp	w0, #0x0
    a0015678:	540000a0 	b.eq	a001568c <k_us_to_ticks_ceil64+0x150>  // b.none
    a001567c:	b94037e1 	ldr	w1, [sp, #52]
    a0015680:	b94033e0 	ldr	w0, [sp, #48]
    a0015684:	1ac00820 	udiv	w0, w1, w0
    a0015688:	14000002 	b	a0015690 <k_us_to_ticks_ceil64+0x154>
    a001568c:	b94037e0 	ldr	w0, [sp, #52]
    a0015690:	b9001fe0 	str	w0, [sp, #28]
		if (round_up) {
    a0015694:	3940b7e0 	ldrb	w0, [sp, #45]
    a0015698:	7100001f 	cmp	w0, #0x0
    a001569c:	540000a0 	b.eq	a00156b0 <k_us_to_ticks_ceil64+0x174>  // b.none
			off = rdivisor - 1U;
    a00156a0:	b9401fe0 	ldr	w0, [sp, #28]
    a00156a4:	51000400 	sub	w0, w0, #0x1
    a00156a8:	2a0003e0 	mov	w0, w0
    a00156ac:	f90013e0 	str	x0, [sp, #32]
		if (round_off) {
    a00156b0:	3940b3e0 	ldrb	w0, [sp, #44]
    a00156b4:	7100001f 	cmp	w0, #0x0
    a00156b8:	540000a0 	b.eq	a00156cc <k_us_to_ticks_ceil64+0x190>  // b.none
			off = rdivisor / 2U;
    a00156bc:	b9401fe0 	ldr	w0, [sp, #28]
    a00156c0:	53017c00 	lsr	w0, w0, #1
    a00156c4:	2a0003e0 	mov	w0, w0
    a00156c8:	f90013e0 	str	x0, [sp, #32]
	if (div_ratio) {
    a00156cc:	3940abe0 	ldrb	w0, [sp, #42]
    a00156d0:	7100001f 	cmp	w0, #0x0
    a00156d4:	54000360 	b.eq	a0015740 <k_us_to_ticks_ceil64+0x204>  // b.none
		t += off;
    a00156d8:	f9401fe1 	ldr	x1, [sp, #56]
    a00156dc:	f94013e0 	ldr	x0, [sp, #32]
    a00156e0:	8b000020 	add	x0, x1, x0
    a00156e4:	f9001fe0 	str	x0, [sp, #56]
		if (result32 && (t < BIT64(32))) {
    a00156e8:	3940bbe0 	ldrb	w0, [sp, #46]
    a00156ec:	7100001f 	cmp	w0, #0x0
    a00156f0:	540001a0 	b.eq	a0015724 <k_us_to_ticks_ceil64+0x1e8>  // b.none
    a00156f4:	f9401fe1 	ldr	x1, [sp, #56]
    a00156f8:	b2407fe0 	mov	x0, #0xffffffff            	// #4294967295
    a00156fc:	eb00003f 	cmp	x1, x0
    a0015700:	54000128 	b.hi	a0015724 <k_us_to_ticks_ceil64+0x1e8>  // b.pmore
			return ((uint32_t)t) / (from_hz / to_hz);
    a0015704:	f9401fe0 	ldr	x0, [sp, #56]
    a0015708:	2a0003e2 	mov	w2, w0
    a001570c:	b94037e1 	ldr	w1, [sp, #52]
    a0015710:	b94033e0 	ldr	w0, [sp, #48]
    a0015714:	1ac00820 	udiv	w0, w1, w0
    a0015718:	1ac00840 	udiv	w0, w2, w0
    a001571c:	2a0003e0 	mov	w0, w0
    a0015720:	14000054 	b	a0015870 <k_us_to_ticks_ceil64+0x334>
			return t / ((uint64_t)from_hz / to_hz);
    a0015724:	b94037e1 	ldr	w1, [sp, #52]
    a0015728:	b94033e0 	ldr	w0, [sp, #48]
    a001572c:	1ac00820 	udiv	w0, w1, w0
    a0015730:	2a0003e0 	mov	w0, w0
    a0015734:	f9401fe1 	ldr	x1, [sp, #56]
    a0015738:	9ac00820 	udiv	x0, x1, x0
    a001573c:	1400004d 	b	a0015870 <k_us_to_ticks_ceil64+0x334>
	} else if (mul_ratio) {
    a0015740:	3940afe0 	ldrb	w0, [sp, #43]
    a0015744:	7100001f 	cmp	w0, #0x0
    a0015748:	54000260 	b.eq	a0015794 <k_us_to_ticks_ceil64+0x258>  // b.none
		if (result32) {
    a001574c:	3940bbe0 	ldrb	w0, [sp, #46]
    a0015750:	7100001f 	cmp	w0, #0x0
    a0015754:	54000120 	b.eq	a0015778 <k_us_to_ticks_ceil64+0x23c>  // b.none
			return ((uint32_t)t) * (to_hz / from_hz);
    a0015758:	f9401fe0 	ldr	x0, [sp, #56]
    a001575c:	2a0003e2 	mov	w2, w0
    a0015760:	b94033e1 	ldr	w1, [sp, #48]
    a0015764:	b94037e0 	ldr	w0, [sp, #52]
    a0015768:	1ac00820 	udiv	w0, w1, w0
    a001576c:	1b007c40 	mul	w0, w2, w0
    a0015770:	2a0003e0 	mov	w0, w0
    a0015774:	1400003f 	b	a0015870 <k_us_to_ticks_ceil64+0x334>
			return t * ((uint64_t)to_hz / from_hz);
    a0015778:	b94033e1 	ldr	w1, [sp, #48]
    a001577c:	b94037e0 	ldr	w0, [sp, #52]
    a0015780:	1ac00820 	udiv	w0, w1, w0
    a0015784:	2a0003e1 	mov	w1, w0
    a0015788:	f9401fe0 	ldr	x0, [sp, #56]
    a001578c:	9b007c20 	mul	x0, x1, x0
    a0015790:	14000038 	b	a0015870 <k_us_to_ticks_ceil64+0x334>
		if (result32) {
    a0015794:	3940bbe0 	ldrb	w0, [sp, #46]
    a0015798:	7100001f 	cmp	w0, #0x0
    a001579c:	54000140 	b.eq	a00157c4 <k_us_to_ticks_ceil64+0x288>  // b.none
			return (uint32_t)((t * to_hz + off) / from_hz);
    a00157a0:	b94033e1 	ldr	w1, [sp, #48]
    a00157a4:	f9401fe0 	ldr	x0, [sp, #56]
    a00157a8:	9b007c21 	mul	x1, x1, x0
    a00157ac:	f94013e0 	ldr	x0, [sp, #32]
    a00157b0:	8b000021 	add	x1, x1, x0
    a00157b4:	b94037e0 	ldr	w0, [sp, #52]
    a00157b8:	9ac00820 	udiv	x0, x1, x0
    a00157bc:	2a0003e0 	mov	w0, w0
    a00157c0:	1400002c 	b	a0015870 <k_us_to_ticks_ceil64+0x334>
		} else if (const_hz && Z_TMCVT_USE_FAST_ALGO(from_hz, to_hz)) {
    a00157c4:	3940bfe0 	ldrb	w0, [sp, #47]
    a00157c8:	7100001f 	cmp	w0, #0x0
    a00157cc:	54000300 	b.eq	a001582c <k_us_to_ticks_ceil64+0x2f0>  // b.none
    a00157d0:	b94037e1 	ldr	w1, [sp, #52]
    a00157d4:	d2867000 	mov	x0, #0x3380                	// #13184
    a00157d8:	f2a03c20 	movk	x0, #0x1e1, lsl #16
    a00157dc:	9b007c21 	mul	x1, x1, x0
    a00157e0:	b27f7be0 	mov	x0, #0xfffffffe            	// #4294967294
    a00157e4:	8b000021 	add	x1, x1, x0
    a00157e8:	320107e0 	mov	w0, #0x80000001            	// #-2147483647
    a00157ec:	f2f00000 	movk	x0, #0x8000, lsl #48
    a00157f0:	9bc07c20 	umulh	x0, x1, x0
    a00157f4:	d35ffc01 	lsr	x1, x0, #31
    a00157f8:	b94033e0 	ldr	w0, [sp, #48]
    a00157fc:	9b007c21 	mul	x1, x1, x0
    a0015800:	b2407fe0 	mov	x0, #0xffffffff            	// #4294967295
    a0015804:	eb00003f 	cmp	x1, x0
    a0015808:	54000128 	b.hi	a001582c <k_us_to_ticks_ceil64+0x2f0>  // b.pmore
			return ((t * to_hz + off) / from_hz);
    a001580c:	b94033e1 	ldr	w1, [sp, #48]
    a0015810:	f9401fe0 	ldr	x0, [sp, #56]
    a0015814:	9b007c21 	mul	x1, x1, x0
    a0015818:	f94013e0 	ldr	x0, [sp, #32]
    a001581c:	8b000021 	add	x1, x1, x0
    a0015820:	b94037e0 	ldr	w0, [sp, #52]
    a0015824:	9ac00820 	udiv	x0, x1, x0
    a0015828:	14000012 	b	a0015870 <k_us_to_ticks_ceil64+0x334>
			return (t / from_hz) * to_hz + ((t % from_hz) * to_hz + off) / from_hz;
    a001582c:	b94037e0 	ldr	w0, [sp, #52]
    a0015830:	f9401fe1 	ldr	x1, [sp, #56]
    a0015834:	9ac00821 	udiv	x1, x1, x0
    a0015838:	b94033e0 	ldr	w0, [sp, #48]
    a001583c:	9b007c22 	mul	x2, x1, x0
    a0015840:	b94037e1 	ldr	w1, [sp, #52]
    a0015844:	f9401fe0 	ldr	x0, [sp, #56]
    a0015848:	9ac10803 	udiv	x3, x0, x1
    a001584c:	9b017c61 	mul	x1, x3, x1
    a0015850:	cb010001 	sub	x1, x0, x1
    a0015854:	b94033e0 	ldr	w0, [sp, #48]
    a0015858:	9b007c21 	mul	x1, x1, x0
    a001585c:	f94013e0 	ldr	x0, [sp, #32]
    a0015860:	8b000021 	add	x1, x1, x0
    a0015864:	b94037e0 	ldr	w0, [sp, #52]
    a0015868:	9ac00820 	udiv	x0, x1, x0
    a001586c:	8b000040 	add	x0, x2, x0
}
    a0015870:	910103ff 	add	sp, sp, #0x40
    a0015874:	d65f03c0 	ret

00000000a0015878 <k_ticks_to_ms_floor64>:
{
    a0015878:	d10103ff 	sub	sp, sp, #0x40
    a001587c:	f90007e0 	str	x0, [sp, #8]
    a0015880:	f94007e0 	ldr	x0, [sp, #8]
    a0015884:	f9001fe0 	str	x0, [sp, #56]
    a0015888:	52800c80 	mov	w0, #0x64                  	// #100
    a001588c:	b90037e0 	str	w0, [sp, #52]
    a0015890:	52807d00 	mov	w0, #0x3e8                 	// #1000
    a0015894:	b90033e0 	str	w0, [sp, #48]
    a0015898:	52800020 	mov	w0, #0x1                   	// #1
    a001589c:	3900bfe0 	strb	w0, [sp, #47]
    a00158a0:	3900bbff 	strb	wzr, [sp, #46]
    a00158a4:	3900b7ff 	strb	wzr, [sp, #45]
    a00158a8:	3900b3ff 	strb	wzr, [sp, #44]
		(to_hz > from_hz) && ((to_hz % from_hz) == 0U);
    a00158ac:	3940bfe0 	ldrb	w0, [sp, #47]
    a00158b0:	7100001f 	cmp	w0, #0x0
    a00158b4:	540001e0 	b.eq	a00158f0 <k_ticks_to_ms_floor64+0x78>  // b.none
	bool mul_ratio = const_hz &&
    a00158b8:	b94037e1 	ldr	w1, [sp, #52]
    a00158bc:	b94033e0 	ldr	w0, [sp, #48]
    a00158c0:	6b00003f 	cmp	w1, w0
    a00158c4:	54000162 	b.cs	a00158f0 <k_ticks_to_ms_floor64+0x78>  // b.hs, b.nlast
		(to_hz > from_hz) && ((to_hz % from_hz) == 0U);
    a00158c8:	b94033e0 	ldr	w0, [sp, #48]
    a00158cc:	b94037e1 	ldr	w1, [sp, #52]
    a00158d0:	1ac10802 	udiv	w2, w0, w1
    a00158d4:	b94037e1 	ldr	w1, [sp, #52]
    a00158d8:	1b017c41 	mul	w1, w2, w1
    a00158dc:	4b010000 	sub	w0, w0, w1
    a00158e0:	7100001f 	cmp	w0, #0x0
    a00158e4:	54000061 	b.ne	a00158f0 <k_ticks_to_ms_floor64+0x78>  // b.any
    a00158e8:	52800020 	mov	w0, #0x1                   	// #1
    a00158ec:	14000002 	b	a00158f4 <k_ticks_to_ms_floor64+0x7c>
    a00158f0:	52800000 	mov	w0, #0x0                   	// #0
	bool mul_ratio = const_hz &&
    a00158f4:	3900afe0 	strb	w0, [sp, #43]
    a00158f8:	3940afe0 	ldrb	w0, [sp, #43]
    a00158fc:	12000000 	and	w0, w0, #0x1
    a0015900:	3900afe0 	strb	w0, [sp, #43]
		(from_hz > to_hz) && ((from_hz % to_hz) == 0U);
    a0015904:	3940bfe0 	ldrb	w0, [sp, #47]
    a0015908:	7100001f 	cmp	w0, #0x0
    a001590c:	540001e0 	b.eq	a0015948 <k_ticks_to_ms_floor64+0xd0>  // b.none
	bool div_ratio = const_hz &&
    a0015910:	b94037e1 	ldr	w1, [sp, #52]
    a0015914:	b94033e0 	ldr	w0, [sp, #48]
    a0015918:	6b00003f 	cmp	w1, w0
    a001591c:	54000169 	b.ls	a0015948 <k_ticks_to_ms_floor64+0xd0>  // b.plast
		(from_hz > to_hz) && ((from_hz % to_hz) == 0U);
    a0015920:	b94037e0 	ldr	w0, [sp, #52]
    a0015924:	b94033e1 	ldr	w1, [sp, #48]
    a0015928:	1ac10802 	udiv	w2, w0, w1
    a001592c:	b94033e1 	ldr	w1, [sp, #48]
    a0015930:	1b017c41 	mul	w1, w2, w1
    a0015934:	4b010000 	sub	w0, w0, w1
    a0015938:	7100001f 	cmp	w0, #0x0
    a001593c:	54000061 	b.ne	a0015948 <k_ticks_to_ms_floor64+0xd0>  // b.any
    a0015940:	52800020 	mov	w0, #0x1                   	// #1
    a0015944:	14000002 	b	a001594c <k_ticks_to_ms_floor64+0xd4>
    a0015948:	52800000 	mov	w0, #0x0                   	// #0
	bool div_ratio = const_hz &&
    a001594c:	3900abe0 	strb	w0, [sp, #42]
    a0015950:	3940abe0 	ldrb	w0, [sp, #42]
    a0015954:	12000000 	and	w0, w0, #0x1
    a0015958:	3900abe0 	strb	w0, [sp, #42]
	if (from_hz == to_hz) {
    a001595c:	b94037e1 	ldr	w1, [sp, #52]
    a0015960:	b94033e0 	ldr	w0, [sp, #48]
    a0015964:	6b00003f 	cmp	w1, w0
    a0015968:	54000121 	b.ne	a001598c <k_ticks_to_ms_floor64+0x114>  // b.any
		return result32 ? ((uint32_t)t) : t;
    a001596c:	3940bbe0 	ldrb	w0, [sp, #46]
    a0015970:	7100001f 	cmp	w0, #0x0
    a0015974:	54000080 	b.eq	a0015984 <k_ticks_to_ms_floor64+0x10c>  // b.none
    a0015978:	f9401fe0 	ldr	x0, [sp, #56]
    a001597c:	2a0003e0 	mov	w0, w0
    a0015980:	14000089 	b	a0015ba4 <k_ticks_to_ms_floor64+0x32c>
    a0015984:	f9401fe0 	ldr	x0, [sp, #56]
    a0015988:	14000087 	b	a0015ba4 <k_ticks_to_ms_floor64+0x32c>
	uint64_t off = 0;
    a001598c:	f90013ff 	str	xzr, [sp, #32]
	if (!mul_ratio) {
    a0015990:	3940afe0 	ldrb	w0, [sp, #43]
    a0015994:	52000000 	eor	w0, w0, #0x1
    a0015998:	12001c00 	and	w0, w0, #0xff
    a001599c:	7100001f 	cmp	w0, #0x0
    a00159a0:	54000300 	b.eq	a0015a00 <k_ticks_to_ms_floor64+0x188>  // b.none
		uint32_t rdivisor = div_ratio ? (from_hz / to_hz) : from_hz;
    a00159a4:	3940abe0 	ldrb	w0, [sp, #42]
    a00159a8:	7100001f 	cmp	w0, #0x0
    a00159ac:	540000a0 	b.eq	a00159c0 <k_ticks_to_ms_floor64+0x148>  // b.none
    a00159b0:	b94037e1 	ldr	w1, [sp, #52]
    a00159b4:	b94033e0 	ldr	w0, [sp, #48]
    a00159b8:	1ac00820 	udiv	w0, w1, w0
    a00159bc:	14000002 	b	a00159c4 <k_ticks_to_ms_floor64+0x14c>
    a00159c0:	b94037e0 	ldr	w0, [sp, #52]
    a00159c4:	b9001fe0 	str	w0, [sp, #28]
		if (round_up) {
    a00159c8:	3940b7e0 	ldrb	w0, [sp, #45]
    a00159cc:	7100001f 	cmp	w0, #0x0
    a00159d0:	540000a0 	b.eq	a00159e4 <k_ticks_to_ms_floor64+0x16c>  // b.none
			off = rdivisor - 1U;
    a00159d4:	b9401fe0 	ldr	w0, [sp, #28]
    a00159d8:	51000400 	sub	w0, w0, #0x1
    a00159dc:	2a0003e0 	mov	w0, w0
    a00159e0:	f90013e0 	str	x0, [sp, #32]
		if (round_off) {
    a00159e4:	3940b3e0 	ldrb	w0, [sp, #44]
    a00159e8:	7100001f 	cmp	w0, #0x0
    a00159ec:	540000a0 	b.eq	a0015a00 <k_ticks_to_ms_floor64+0x188>  // b.none
			off = rdivisor / 2U;
    a00159f0:	b9401fe0 	ldr	w0, [sp, #28]
    a00159f4:	53017c00 	lsr	w0, w0, #1
    a00159f8:	2a0003e0 	mov	w0, w0
    a00159fc:	f90013e0 	str	x0, [sp, #32]
	if (div_ratio) {
    a0015a00:	3940abe0 	ldrb	w0, [sp, #42]
    a0015a04:	7100001f 	cmp	w0, #0x0
    a0015a08:	54000360 	b.eq	a0015a74 <k_ticks_to_ms_floor64+0x1fc>  // b.none
		t += off;
    a0015a0c:	f9401fe1 	ldr	x1, [sp, #56]
    a0015a10:	f94013e0 	ldr	x0, [sp, #32]
    a0015a14:	8b000020 	add	x0, x1, x0
    a0015a18:	f9001fe0 	str	x0, [sp, #56]
		if (result32 && (t < BIT64(32))) {
    a0015a1c:	3940bbe0 	ldrb	w0, [sp, #46]
    a0015a20:	7100001f 	cmp	w0, #0x0
    a0015a24:	540001a0 	b.eq	a0015a58 <k_ticks_to_ms_floor64+0x1e0>  // b.none
    a0015a28:	f9401fe1 	ldr	x1, [sp, #56]
    a0015a2c:	b2407fe0 	mov	x0, #0xffffffff            	// #4294967295
    a0015a30:	eb00003f 	cmp	x1, x0
    a0015a34:	54000128 	b.hi	a0015a58 <k_ticks_to_ms_floor64+0x1e0>  // b.pmore
			return ((uint32_t)t) / (from_hz / to_hz);
    a0015a38:	f9401fe0 	ldr	x0, [sp, #56]
    a0015a3c:	2a0003e2 	mov	w2, w0
    a0015a40:	b94037e1 	ldr	w1, [sp, #52]
    a0015a44:	b94033e0 	ldr	w0, [sp, #48]
    a0015a48:	1ac00820 	udiv	w0, w1, w0
    a0015a4c:	1ac00840 	udiv	w0, w2, w0
    a0015a50:	2a0003e0 	mov	w0, w0
    a0015a54:	14000054 	b	a0015ba4 <k_ticks_to_ms_floor64+0x32c>
			return t / ((uint64_t)from_hz / to_hz);
    a0015a58:	b94037e1 	ldr	w1, [sp, #52]
    a0015a5c:	b94033e0 	ldr	w0, [sp, #48]
    a0015a60:	1ac00820 	udiv	w0, w1, w0
    a0015a64:	2a0003e0 	mov	w0, w0
    a0015a68:	f9401fe1 	ldr	x1, [sp, #56]
    a0015a6c:	9ac00820 	udiv	x0, x1, x0
    a0015a70:	1400004d 	b	a0015ba4 <k_ticks_to_ms_floor64+0x32c>
	} else if (mul_ratio) {
    a0015a74:	3940afe0 	ldrb	w0, [sp, #43]
    a0015a78:	7100001f 	cmp	w0, #0x0
    a0015a7c:	54000260 	b.eq	a0015ac8 <k_ticks_to_ms_floor64+0x250>  // b.none
		if (result32) {
    a0015a80:	3940bbe0 	ldrb	w0, [sp, #46]
    a0015a84:	7100001f 	cmp	w0, #0x0
    a0015a88:	54000120 	b.eq	a0015aac <k_ticks_to_ms_floor64+0x234>  // b.none
			return ((uint32_t)t) * (to_hz / from_hz);
    a0015a8c:	f9401fe0 	ldr	x0, [sp, #56]
    a0015a90:	2a0003e2 	mov	w2, w0
    a0015a94:	b94033e1 	ldr	w1, [sp, #48]
    a0015a98:	b94037e0 	ldr	w0, [sp, #52]
    a0015a9c:	1ac00820 	udiv	w0, w1, w0
    a0015aa0:	1b007c40 	mul	w0, w2, w0
    a0015aa4:	2a0003e0 	mov	w0, w0
    a0015aa8:	1400003f 	b	a0015ba4 <k_ticks_to_ms_floor64+0x32c>
			return t * ((uint64_t)to_hz / from_hz);
    a0015aac:	b94033e1 	ldr	w1, [sp, #48]
    a0015ab0:	b94037e0 	ldr	w0, [sp, #52]
    a0015ab4:	1ac00820 	udiv	w0, w1, w0
    a0015ab8:	2a0003e1 	mov	w1, w0
    a0015abc:	f9401fe0 	ldr	x0, [sp, #56]
    a0015ac0:	9b007c20 	mul	x0, x1, x0
    a0015ac4:	14000038 	b	a0015ba4 <k_ticks_to_ms_floor64+0x32c>
		if (result32) {
    a0015ac8:	3940bbe0 	ldrb	w0, [sp, #46]
    a0015acc:	7100001f 	cmp	w0, #0x0
    a0015ad0:	54000140 	b.eq	a0015af8 <k_ticks_to_ms_floor64+0x280>  // b.none
			return (uint32_t)((t * to_hz + off) / from_hz);
    a0015ad4:	b94033e1 	ldr	w1, [sp, #48]
    a0015ad8:	f9401fe0 	ldr	x0, [sp, #56]
    a0015adc:	9b007c21 	mul	x1, x1, x0
    a0015ae0:	f94013e0 	ldr	x0, [sp, #32]
    a0015ae4:	8b000021 	add	x1, x1, x0
    a0015ae8:	b94037e0 	ldr	w0, [sp, #52]
    a0015aec:	9ac00820 	udiv	x0, x1, x0
    a0015af0:	2a0003e0 	mov	w0, w0
    a0015af4:	1400002c 	b	a0015ba4 <k_ticks_to_ms_floor64+0x32c>
		} else if (const_hz && Z_TMCVT_USE_FAST_ALGO(from_hz, to_hz)) {
    a0015af8:	3940bfe0 	ldrb	w0, [sp, #47]
    a0015afc:	7100001f 	cmp	w0, #0x0
    a0015b00:	54000300 	b.eq	a0015b60 <k_ticks_to_ms_floor64+0x2e8>  // b.none
    a0015b04:	b94037e1 	ldr	w1, [sp, #52]
    a0015b08:	d2867000 	mov	x0, #0x3380                	// #13184
    a0015b0c:	f2a03c20 	movk	x0, #0x1e1, lsl #16
    a0015b10:	9b007c21 	mul	x1, x1, x0
    a0015b14:	b27f7be0 	mov	x0, #0xfffffffe            	// #4294967294
    a0015b18:	8b000021 	add	x1, x1, x0
    a0015b1c:	320107e0 	mov	w0, #0x80000001            	// #-2147483647
    a0015b20:	f2f00000 	movk	x0, #0x8000, lsl #48
    a0015b24:	9bc07c20 	umulh	x0, x1, x0
    a0015b28:	d35ffc01 	lsr	x1, x0, #31
    a0015b2c:	b94033e0 	ldr	w0, [sp, #48]
    a0015b30:	9b007c21 	mul	x1, x1, x0
    a0015b34:	b2407fe0 	mov	x0, #0xffffffff            	// #4294967295
    a0015b38:	eb00003f 	cmp	x1, x0
    a0015b3c:	54000128 	b.hi	a0015b60 <k_ticks_to_ms_floor64+0x2e8>  // b.pmore
			return ((t * to_hz + off) / from_hz);
    a0015b40:	b94033e1 	ldr	w1, [sp, #48]
    a0015b44:	f9401fe0 	ldr	x0, [sp, #56]
    a0015b48:	9b007c21 	mul	x1, x1, x0
    a0015b4c:	f94013e0 	ldr	x0, [sp, #32]
    a0015b50:	8b000021 	add	x1, x1, x0
    a0015b54:	b94037e0 	ldr	w0, [sp, #52]
    a0015b58:	9ac00820 	udiv	x0, x1, x0
    a0015b5c:	14000012 	b	a0015ba4 <k_ticks_to_ms_floor64+0x32c>
			return (t / from_hz) * to_hz + ((t % from_hz) * to_hz + off) / from_hz;
    a0015b60:	b94037e0 	ldr	w0, [sp, #52]
    a0015b64:	f9401fe1 	ldr	x1, [sp, #56]
    a0015b68:	9ac00821 	udiv	x1, x1, x0
    a0015b6c:	b94033e0 	ldr	w0, [sp, #48]
    a0015b70:	9b007c22 	mul	x2, x1, x0
    a0015b74:	b94037e1 	ldr	w1, [sp, #52]
    a0015b78:	f9401fe0 	ldr	x0, [sp, #56]
    a0015b7c:	9ac10803 	udiv	x3, x0, x1
    a0015b80:	9b017c61 	mul	x1, x3, x1
    a0015b84:	cb010001 	sub	x1, x0, x1
    a0015b88:	b94033e0 	ldr	w0, [sp, #48]
    a0015b8c:	9b007c21 	mul	x1, x1, x0
    a0015b90:	f94013e0 	ldr	x0, [sp, #32]
    a0015b94:	8b000021 	add	x1, x1, x0
    a0015b98:	b94037e0 	ldr	w0, [sp, #52]
    a0015b9c:	9ac00820 	udiv	x0, x1, x0
    a0015ba0:	8b000040 	add	x0, x2, x0
}
    a0015ba4:	910103ff 	add	sp, sp, #0x40
    a0015ba8:	d65f03c0 	ret

00000000a0015bac <k_ticks_to_us_floor64>:
{
    a0015bac:	d10103ff 	sub	sp, sp, #0x40
    a0015bb0:	f90007e0 	str	x0, [sp, #8]
    a0015bb4:	f94007e0 	ldr	x0, [sp, #8]
    a0015bb8:	f9001fe0 	str	x0, [sp, #56]
    a0015bbc:	52800c80 	mov	w0, #0x64                  	// #100
    a0015bc0:	b90037e0 	str	w0, [sp, #52]
    a0015bc4:	52884800 	mov	w0, #0x4240                	// #16960
    a0015bc8:	72a001e0 	movk	w0, #0xf, lsl #16
    a0015bcc:	b90033e0 	str	w0, [sp, #48]
    a0015bd0:	52800020 	mov	w0, #0x1                   	// #1
    a0015bd4:	3900bfe0 	strb	w0, [sp, #47]
    a0015bd8:	3900bbff 	strb	wzr, [sp, #46]
    a0015bdc:	3900b7ff 	strb	wzr, [sp, #45]
    a0015be0:	3900b3ff 	strb	wzr, [sp, #44]
		(to_hz > from_hz) && ((to_hz % from_hz) == 0U);
    a0015be4:	3940bfe0 	ldrb	w0, [sp, #47]
    a0015be8:	7100001f 	cmp	w0, #0x0
    a0015bec:	540001e0 	b.eq	a0015c28 <k_ticks_to_us_floor64+0x7c>  // b.none
	bool mul_ratio = const_hz &&
    a0015bf0:	b94037e1 	ldr	w1, [sp, #52]
    a0015bf4:	b94033e0 	ldr	w0, [sp, #48]
    a0015bf8:	6b00003f 	cmp	w1, w0
    a0015bfc:	54000162 	b.cs	a0015c28 <k_ticks_to_us_floor64+0x7c>  // b.hs, b.nlast
		(to_hz > from_hz) && ((to_hz % from_hz) == 0U);
    a0015c00:	b94033e0 	ldr	w0, [sp, #48]
    a0015c04:	b94037e1 	ldr	w1, [sp, #52]
    a0015c08:	1ac10802 	udiv	w2, w0, w1
    a0015c0c:	b94037e1 	ldr	w1, [sp, #52]
    a0015c10:	1b017c41 	mul	w1, w2, w1
    a0015c14:	4b010000 	sub	w0, w0, w1
    a0015c18:	7100001f 	cmp	w0, #0x0
    a0015c1c:	54000061 	b.ne	a0015c28 <k_ticks_to_us_floor64+0x7c>  // b.any
    a0015c20:	52800020 	mov	w0, #0x1                   	// #1
    a0015c24:	14000002 	b	a0015c2c <k_ticks_to_us_floor64+0x80>
    a0015c28:	52800000 	mov	w0, #0x0                   	// #0
	bool mul_ratio = const_hz &&
    a0015c2c:	3900afe0 	strb	w0, [sp, #43]
    a0015c30:	3940afe0 	ldrb	w0, [sp, #43]
    a0015c34:	12000000 	and	w0, w0, #0x1
    a0015c38:	3900afe0 	strb	w0, [sp, #43]
		(from_hz > to_hz) && ((from_hz % to_hz) == 0U);
    a0015c3c:	3940bfe0 	ldrb	w0, [sp, #47]
    a0015c40:	7100001f 	cmp	w0, #0x0
    a0015c44:	540001e0 	b.eq	a0015c80 <k_ticks_to_us_floor64+0xd4>  // b.none
	bool div_ratio = const_hz &&
    a0015c48:	b94037e1 	ldr	w1, [sp, #52]
    a0015c4c:	b94033e0 	ldr	w0, [sp, #48]
    a0015c50:	6b00003f 	cmp	w1, w0
    a0015c54:	54000169 	b.ls	a0015c80 <k_ticks_to_us_floor64+0xd4>  // b.plast
		(from_hz > to_hz) && ((from_hz % to_hz) == 0U);
    a0015c58:	b94037e0 	ldr	w0, [sp, #52]
    a0015c5c:	b94033e1 	ldr	w1, [sp, #48]
    a0015c60:	1ac10802 	udiv	w2, w0, w1
    a0015c64:	b94033e1 	ldr	w1, [sp, #48]
    a0015c68:	1b017c41 	mul	w1, w2, w1
    a0015c6c:	4b010000 	sub	w0, w0, w1
    a0015c70:	7100001f 	cmp	w0, #0x0
    a0015c74:	54000061 	b.ne	a0015c80 <k_ticks_to_us_floor64+0xd4>  // b.any
    a0015c78:	52800020 	mov	w0, #0x1                   	// #1
    a0015c7c:	14000002 	b	a0015c84 <k_ticks_to_us_floor64+0xd8>
    a0015c80:	52800000 	mov	w0, #0x0                   	// #0
	bool div_ratio = const_hz &&
    a0015c84:	3900abe0 	strb	w0, [sp, #42]
    a0015c88:	3940abe0 	ldrb	w0, [sp, #42]
    a0015c8c:	12000000 	and	w0, w0, #0x1
    a0015c90:	3900abe0 	strb	w0, [sp, #42]
	if (from_hz == to_hz) {
    a0015c94:	b94037e1 	ldr	w1, [sp, #52]
    a0015c98:	b94033e0 	ldr	w0, [sp, #48]
    a0015c9c:	6b00003f 	cmp	w1, w0
    a0015ca0:	54000121 	b.ne	a0015cc4 <k_ticks_to_us_floor64+0x118>  // b.any
		return result32 ? ((uint32_t)t) : t;
    a0015ca4:	3940bbe0 	ldrb	w0, [sp, #46]
    a0015ca8:	7100001f 	cmp	w0, #0x0
    a0015cac:	54000080 	b.eq	a0015cbc <k_ticks_to_us_floor64+0x110>  // b.none
    a0015cb0:	f9401fe0 	ldr	x0, [sp, #56]
    a0015cb4:	2a0003e0 	mov	w0, w0
    a0015cb8:	14000089 	b	a0015edc <k_ticks_to_us_floor64+0x330>
    a0015cbc:	f9401fe0 	ldr	x0, [sp, #56]
    a0015cc0:	14000087 	b	a0015edc <k_ticks_to_us_floor64+0x330>
	uint64_t off = 0;
    a0015cc4:	f90013ff 	str	xzr, [sp, #32]
	if (!mul_ratio) {
    a0015cc8:	3940afe0 	ldrb	w0, [sp, #43]
    a0015ccc:	52000000 	eor	w0, w0, #0x1
    a0015cd0:	12001c00 	and	w0, w0, #0xff
    a0015cd4:	7100001f 	cmp	w0, #0x0
    a0015cd8:	54000300 	b.eq	a0015d38 <k_ticks_to_us_floor64+0x18c>  // b.none
		uint32_t rdivisor = div_ratio ? (from_hz / to_hz) : from_hz;
    a0015cdc:	3940abe0 	ldrb	w0, [sp, #42]
    a0015ce0:	7100001f 	cmp	w0, #0x0
    a0015ce4:	540000a0 	b.eq	a0015cf8 <k_ticks_to_us_floor64+0x14c>  // b.none
    a0015ce8:	b94037e1 	ldr	w1, [sp, #52]
    a0015cec:	b94033e0 	ldr	w0, [sp, #48]
    a0015cf0:	1ac00820 	udiv	w0, w1, w0
    a0015cf4:	14000002 	b	a0015cfc <k_ticks_to_us_floor64+0x150>
    a0015cf8:	b94037e0 	ldr	w0, [sp, #52]
    a0015cfc:	b9001fe0 	str	w0, [sp, #28]
		if (round_up) {
    a0015d00:	3940b7e0 	ldrb	w0, [sp, #45]
    a0015d04:	7100001f 	cmp	w0, #0x0
    a0015d08:	540000a0 	b.eq	a0015d1c <k_ticks_to_us_floor64+0x170>  // b.none
			off = rdivisor - 1U;
    a0015d0c:	b9401fe0 	ldr	w0, [sp, #28]
    a0015d10:	51000400 	sub	w0, w0, #0x1
    a0015d14:	2a0003e0 	mov	w0, w0
    a0015d18:	f90013e0 	str	x0, [sp, #32]
		if (round_off) {
    a0015d1c:	3940b3e0 	ldrb	w0, [sp, #44]
    a0015d20:	7100001f 	cmp	w0, #0x0
    a0015d24:	540000a0 	b.eq	a0015d38 <k_ticks_to_us_floor64+0x18c>  // b.none
			off = rdivisor / 2U;
    a0015d28:	b9401fe0 	ldr	w0, [sp, #28]
    a0015d2c:	53017c00 	lsr	w0, w0, #1
    a0015d30:	2a0003e0 	mov	w0, w0
    a0015d34:	f90013e0 	str	x0, [sp, #32]
	if (div_ratio) {
    a0015d38:	3940abe0 	ldrb	w0, [sp, #42]
    a0015d3c:	7100001f 	cmp	w0, #0x0
    a0015d40:	54000360 	b.eq	a0015dac <k_ticks_to_us_floor64+0x200>  // b.none
		t += off;
    a0015d44:	f9401fe1 	ldr	x1, [sp, #56]
    a0015d48:	f94013e0 	ldr	x0, [sp, #32]
    a0015d4c:	8b000020 	add	x0, x1, x0
    a0015d50:	f9001fe0 	str	x0, [sp, #56]
		if (result32 && (t < BIT64(32))) {
    a0015d54:	3940bbe0 	ldrb	w0, [sp, #46]
    a0015d58:	7100001f 	cmp	w0, #0x0
    a0015d5c:	540001a0 	b.eq	a0015d90 <k_ticks_to_us_floor64+0x1e4>  // b.none
    a0015d60:	f9401fe1 	ldr	x1, [sp, #56]
    a0015d64:	b2407fe0 	mov	x0, #0xffffffff            	// #4294967295
    a0015d68:	eb00003f 	cmp	x1, x0
    a0015d6c:	54000128 	b.hi	a0015d90 <k_ticks_to_us_floor64+0x1e4>  // b.pmore
			return ((uint32_t)t) / (from_hz / to_hz);
    a0015d70:	f9401fe0 	ldr	x0, [sp, #56]
    a0015d74:	2a0003e2 	mov	w2, w0
    a0015d78:	b94037e1 	ldr	w1, [sp, #52]
    a0015d7c:	b94033e0 	ldr	w0, [sp, #48]
    a0015d80:	1ac00820 	udiv	w0, w1, w0
    a0015d84:	1ac00840 	udiv	w0, w2, w0
    a0015d88:	2a0003e0 	mov	w0, w0
    a0015d8c:	14000054 	b	a0015edc <k_ticks_to_us_floor64+0x330>
			return t / ((uint64_t)from_hz / to_hz);
    a0015d90:	b94037e1 	ldr	w1, [sp, #52]
    a0015d94:	b94033e0 	ldr	w0, [sp, #48]
    a0015d98:	1ac00820 	udiv	w0, w1, w0
    a0015d9c:	2a0003e0 	mov	w0, w0
    a0015da0:	f9401fe1 	ldr	x1, [sp, #56]
    a0015da4:	9ac00820 	udiv	x0, x1, x0
    a0015da8:	1400004d 	b	a0015edc <k_ticks_to_us_floor64+0x330>
	} else if (mul_ratio) {
    a0015dac:	3940afe0 	ldrb	w0, [sp, #43]
    a0015db0:	7100001f 	cmp	w0, #0x0
    a0015db4:	54000260 	b.eq	a0015e00 <k_ticks_to_us_floor64+0x254>  // b.none
		if (result32) {
    a0015db8:	3940bbe0 	ldrb	w0, [sp, #46]
    a0015dbc:	7100001f 	cmp	w0, #0x0
    a0015dc0:	54000120 	b.eq	a0015de4 <k_ticks_to_us_floor64+0x238>  // b.none
			return ((uint32_t)t) * (to_hz / from_hz);
    a0015dc4:	f9401fe0 	ldr	x0, [sp, #56]
    a0015dc8:	2a0003e2 	mov	w2, w0
    a0015dcc:	b94033e1 	ldr	w1, [sp, #48]
    a0015dd0:	b94037e0 	ldr	w0, [sp, #52]
    a0015dd4:	1ac00820 	udiv	w0, w1, w0
    a0015dd8:	1b007c40 	mul	w0, w2, w0
    a0015ddc:	2a0003e0 	mov	w0, w0
    a0015de0:	1400003f 	b	a0015edc <k_ticks_to_us_floor64+0x330>
			return t * ((uint64_t)to_hz / from_hz);
    a0015de4:	b94033e1 	ldr	w1, [sp, #48]
    a0015de8:	b94037e0 	ldr	w0, [sp, #52]
    a0015dec:	1ac00820 	udiv	w0, w1, w0
    a0015df0:	2a0003e1 	mov	w1, w0
    a0015df4:	f9401fe0 	ldr	x0, [sp, #56]
    a0015df8:	9b007c20 	mul	x0, x1, x0
    a0015dfc:	14000038 	b	a0015edc <k_ticks_to_us_floor64+0x330>
		if (result32) {
    a0015e00:	3940bbe0 	ldrb	w0, [sp, #46]
    a0015e04:	7100001f 	cmp	w0, #0x0
    a0015e08:	54000140 	b.eq	a0015e30 <k_ticks_to_us_floor64+0x284>  // b.none
			return (uint32_t)((t * to_hz + off) / from_hz);
    a0015e0c:	b94033e1 	ldr	w1, [sp, #48]
    a0015e10:	f9401fe0 	ldr	x0, [sp, #56]
    a0015e14:	9b007c21 	mul	x1, x1, x0
    a0015e18:	f94013e0 	ldr	x0, [sp, #32]
    a0015e1c:	8b000021 	add	x1, x1, x0
    a0015e20:	b94037e0 	ldr	w0, [sp, #52]
    a0015e24:	9ac00820 	udiv	x0, x1, x0
    a0015e28:	2a0003e0 	mov	w0, w0
    a0015e2c:	1400002c 	b	a0015edc <k_ticks_to_us_floor64+0x330>
		} else if (const_hz && Z_TMCVT_USE_FAST_ALGO(from_hz, to_hz)) {
    a0015e30:	3940bfe0 	ldrb	w0, [sp, #47]
    a0015e34:	7100001f 	cmp	w0, #0x0
    a0015e38:	54000300 	b.eq	a0015e98 <k_ticks_to_us_floor64+0x2ec>  // b.none
    a0015e3c:	b94037e1 	ldr	w1, [sp, #52]
    a0015e40:	d2867000 	mov	x0, #0x3380                	// #13184
    a0015e44:	f2a03c20 	movk	x0, #0x1e1, lsl #16
    a0015e48:	9b007c21 	mul	x1, x1, x0
    a0015e4c:	b27f7be0 	mov	x0, #0xfffffffe            	// #4294967294
    a0015e50:	8b000021 	add	x1, x1, x0
    a0015e54:	320107e0 	mov	w0, #0x80000001            	// #-2147483647
    a0015e58:	f2f00000 	movk	x0, #0x8000, lsl #48
    a0015e5c:	9bc07c20 	umulh	x0, x1, x0
    a0015e60:	d35ffc01 	lsr	x1, x0, #31
    a0015e64:	b94033e0 	ldr	w0, [sp, #48]
    a0015e68:	9b007c21 	mul	x1, x1, x0
    a0015e6c:	b2407fe0 	mov	x0, #0xffffffff            	// #4294967295
    a0015e70:	eb00003f 	cmp	x1, x0
    a0015e74:	54000128 	b.hi	a0015e98 <k_ticks_to_us_floor64+0x2ec>  // b.pmore
			return ((t * to_hz + off) / from_hz);
    a0015e78:	b94033e1 	ldr	w1, [sp, #48]
    a0015e7c:	f9401fe0 	ldr	x0, [sp, #56]
    a0015e80:	9b007c21 	mul	x1, x1, x0
    a0015e84:	f94013e0 	ldr	x0, [sp, #32]
    a0015e88:	8b000021 	add	x1, x1, x0
    a0015e8c:	b94037e0 	ldr	w0, [sp, #52]
    a0015e90:	9ac00820 	udiv	x0, x1, x0
    a0015e94:	14000012 	b	a0015edc <k_ticks_to_us_floor64+0x330>
			return (t / from_hz) * to_hz + ((t % from_hz) * to_hz + off) / from_hz;
    a0015e98:	b94037e0 	ldr	w0, [sp, #52]
    a0015e9c:	f9401fe1 	ldr	x1, [sp, #56]
    a0015ea0:	9ac00821 	udiv	x1, x1, x0
    a0015ea4:	b94033e0 	ldr	w0, [sp, #48]
    a0015ea8:	9b007c22 	mul	x2, x1, x0
    a0015eac:	b94037e1 	ldr	w1, [sp, #52]
    a0015eb0:	f9401fe0 	ldr	x0, [sp, #56]
    a0015eb4:	9ac10803 	udiv	x3, x0, x1
    a0015eb8:	9b017c61 	mul	x1, x3, x1
    a0015ebc:	cb010001 	sub	x1, x0, x1
    a0015ec0:	b94033e0 	ldr	w0, [sp, #48]
    a0015ec4:	9b007c21 	mul	x1, x1, x0
    a0015ec8:	f94013e0 	ldr	x0, [sp, #32]
    a0015ecc:	8b000021 	add	x1, x1, x0
    a0015ed0:	b94037e0 	ldr	w0, [sp, #52]
    a0015ed4:	9ac00820 	udiv	x0, x1, x0
    a0015ed8:	8b000040 	add	x0, x2, x0
}
    a0015edc:	910103ff 	add	sp, sp, #0x40
    a0015ee0:	d65f03c0 	ret

00000000a0015ee4 <k_yield>:
{
    a0015ee4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0015ee8:	910003fd 	mov	x29, sp
	bool ret = false;
    a0015eec:	39007fff 	strb	wzr, [sp, #31]
	ret = false;
    a0015ef0:	39007fff 	strb	wzr, [sp, #31]
	return ret;
    a0015ef4:	39407fe0 	ldrb	w0, [sp, #31]
	if (z_syscall_trap()) {
    a0015ef8:	7100001f 	cmp	w0, #0x0
    a0015efc:	54000080 	b.eq	a0015f0c <k_yield+0x28>  // b.none
		arch_syscall_invoke0(K_SYSCALL_K_YIELD);
    a0015f00:	d2801b60 	mov	x0, #0xdb                  	// #219
    a0015f04:	97fffcb2 	bl	a00151cc <arch_syscall_invoke0>
		return;
    a0015f08:	14000002 	b	a0015f10 <k_yield+0x2c>
	z_impl_k_yield();
    a0015f0c:	94000a22 	bl	a0018794 <z_impl_k_yield>
}
    a0015f10:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0015f14:	d65f03c0 	ret

00000000a0015f18 <k_thread_suspend>:
{
    a0015f18:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0015f1c:	910003fd 	mov	x29, sp
    a0015f20:	f9000fe0 	str	x0, [sp, #24]
	bool ret = false;
    a0015f24:	3900bfff 	strb	wzr, [sp, #47]
	ret = false;
    a0015f28:	3900bfff 	strb	wzr, [sp, #47]
	return ret;
    a0015f2c:	3940bfe0 	ldrb	w0, [sp, #47]
	if (z_syscall_trap()) {
    a0015f30:	7100001f 	cmp	w0, #0x0
    a0015f34:	540000c0 	b.eq	a0015f4c <k_thread_suspend+0x34>  // b.none
		arch_syscall_invoke1(*(uintptr_t *)&thread, K_SYSCALL_K_THREAD_SUSPEND);
    a0015f38:	910063e0 	add	x0, sp, #0x18
    a0015f3c:	f9400000 	ldr	x0, [x0]
    a0015f40:	d28019a1 	mov	x1, #0xcd                  	// #205
    a0015f44:	97fffc9a 	bl	a00151ac <arch_syscall_invoke1>
		return;
    a0015f48:	14000003 	b	a0015f54 <k_thread_suspend+0x3c>
	z_impl_k_thread_suspend(thread);
    a0015f4c:	f9400fe0 	ldr	x0, [sp, #24]
    a0015f50:	940004c9 	bl	a0017274 <z_impl_k_thread_suspend>
}
    a0015f54:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0015f58:	d65f03c0 	ret

00000000a0015f5c <arch_switch>:
{
    a0015f5c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0015f60:	910003fd 	mov	x29, sp
    a0015f64:	f9000fe0 	str	x0, [sp, #24]
    a0015f68:	f9000be1 	str	x1, [sp, #16]
	z_arm64_call_svc(switch_to, switched_from);
    a0015f6c:	f9400be1 	ldr	x1, [sp, #16]
    a0015f70:	f9400fe0 	ldr	x0, [sp, #24]
    a0015f74:	97ffce19 	bl	a00097d8 <z_arm64_call_svc>
	return;
    a0015f78:	d503201f 	nop
}
    a0015f7c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0015f80:	d65f03c0 	ret

00000000a0015f84 <z_is_inactive_timeout>:
{
    a0015f84:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0015f88:	910003fd 	mov	x29, sp
    a0015f8c:	f9000fe0 	str	x0, [sp, #24]
	return !sys_dnode_is_linked(&to->node);
    a0015f90:	f9400fe0 	ldr	x0, [sp, #24]
    a0015f94:	97fffc0b 	bl	a0014fc0 <sys_dnode_is_linked>
    a0015f98:	12001c00 	and	w0, w0, #0xff
    a0015f9c:	7100001f 	cmp	w0, #0x0
    a0015fa0:	1a9f07e0 	cset	w0, ne  // ne = any
    a0015fa4:	12001c00 	and	w0, w0, #0xff
    a0015fa8:	52000000 	eor	w0, w0, #0x1
    a0015fac:	12001c00 	and	w0, w0, #0xff
    a0015fb0:	12000000 	and	w0, w0, #0x1
    a0015fb4:	12001c00 	and	w0, w0, #0xff
}
    a0015fb8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0015fbc:	d65f03c0 	ret

00000000a0015fc0 <z_add_thread_timeout>:
{
    a0015fc0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0015fc4:	910003fd 	mov	x29, sp
    a0015fc8:	f9000fe0 	str	x0, [sp, #24]
    a0015fcc:	f9000be1 	str	x1, [sp, #16]
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
    a0015fd0:	f9400fe0 	ldr	x0, [sp, #24]
    a0015fd4:	9100a003 	add	x3, x0, #0x28
    a0015fd8:	f9400be2 	ldr	x2, [sp, #16]
    a0015fdc:	d0000000 	adrp	x0, a0017000 <ready_thread+0x70>
    a0015fe0:	91276001 	add	x1, x0, #0x9d8
    a0015fe4:	aa0303e0 	mov	x0, x3
    a0015fe8:	94000e72 	bl	a00199b0 <z_add_timeout>
}
    a0015fec:	d503201f 	nop
    a0015ff0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0015ff4:	d65f03c0 	ret

00000000a0015ff8 <z_abort_thread_timeout>:

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
    a0015ff8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0015ffc:	910003fd 	mov	x29, sp
    a0016000:	f9000fe0 	str	x0, [sp, #24]
	return z_abort_timeout(&thread->base.timeout);
    a0016004:	f9400fe0 	ldr	x0, [sp, #24]
    a0016008:	9100a000 	add	x0, x0, #0x28
    a001600c:	94000ef7 	bl	a0019be8 <z_abort_timeout>
}
    a0016010:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0016014:	d65f03c0 	ret

00000000a0016018 <z_reschedule_unlocked>:
{
    a0016018:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a001601c:	910003fd 	mov	x29, sp
MAKE_REG_HELPER(daif)
    a0016020:	d53b4220 	mrs	x0, daif
    a0016024:	f9000fe0 	str	x0, [sp, #24]
    a0016028:	f9400fe0 	ldr	x0, [sp, #24]
    a001602c:	d503201f 	nop
	key = read_daif();
    a0016030:	b90017e0 	str	w0, [sp, #20]
	__asm__ volatile ("msr DAIFSet, %0"
    a0016034:	d50342df 	msr	daifset, #0x2
}
    a0016038:	d503201f 	nop
	return key;
    a001603c:	b94017e0 	ldr	w0, [sp, #20]
	(void) z_reschedule_irqlock(arch_irq_lock());
    a0016040:	94000858 	bl	a00181a0 <z_reschedule_irqlock>
}
    a0016044:	d503201f 	nop
    a0016048:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a001604c:	d65f03c0 	ret

00000000a0016050 <z_is_idle_thread_entry>:
{
    a0016050:	d10043ff 	sub	sp, sp, #0x10
    a0016054:	f90007e0 	str	x0, [sp, #8]
	return entry_point == idle;
    a0016058:	f94007e1 	ldr	x1, [sp, #8]
    a001605c:	90ffffe0 	adrp	x0, a0012000 <setup_thread_stack+0x14>
    a0016060:	9134b000 	add	x0, x0, #0xd2c
    a0016064:	eb00003f 	cmp	x1, x0
    a0016068:	1a9f17e0 	cset	w0, eq  // eq = none
    a001606c:	12001c00 	and	w0, w0, #0xff
}
    a0016070:	910043ff 	add	sp, sp, #0x10
    a0016074:	d65f03c0 	ret

00000000a0016078 <z_is_idle_thread_object>:
{
    a0016078:	d10043ff 	sub	sp, sp, #0x10
    a001607c:	f90007e0 	str	x0, [sp, #8]
	return thread == &z_idle_threads[0];
    a0016080:	f94007e1 	ldr	x1, [sp, #8]
    a0016084:	d0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0016088:	91056000 	add	x0, x0, #0x158
    a001608c:	eb00003f 	cmp	x1, x0
    a0016090:	1a9f17e0 	cset	w0, eq  // eq = none
    a0016094:	12001c00 	and	w0, w0, #0xff
}
    a0016098:	910043ff 	add	sp, sp, #0x10
    a001609c:	d65f03c0 	ret

00000000a00160a0 <z_is_thread_suspended>:
{
    a00160a0:	d10043ff 	sub	sp, sp, #0x10
    a00160a4:	f90007e0 	str	x0, [sp, #8]
	return (thread->base.thread_state & _THREAD_SUSPENDED) != 0U;
    a00160a8:	f94007e0 	ldr	x0, [sp, #8]
    a00160ac:	39406400 	ldrb	w0, [x0, #25]
    a00160b0:	92401c00 	and	x0, x0, #0xff
    a00160b4:	927c0000 	and	x0, x0, #0x10
    a00160b8:	f100001f 	cmp	x0, #0x0
    a00160bc:	1a9f07e0 	cset	w0, ne  // ne = any
    a00160c0:	12001c00 	and	w0, w0, #0xff
}
    a00160c4:	910043ff 	add	sp, sp, #0x10
    a00160c8:	d65f03c0 	ret

00000000a00160cc <z_is_thread_pending>:
{
    a00160cc:	d10043ff 	sub	sp, sp, #0x10
    a00160d0:	f90007e0 	str	x0, [sp, #8]
	return (thread->base.thread_state & _THREAD_PENDING) != 0U;
    a00160d4:	f94007e0 	ldr	x0, [sp, #8]
    a00160d8:	39406400 	ldrb	w0, [x0, #25]
    a00160dc:	92401c00 	and	x0, x0, #0xff
    a00160e0:	927f0000 	and	x0, x0, #0x2
    a00160e4:	f100001f 	cmp	x0, #0x0
    a00160e8:	1a9f07e0 	cset	w0, ne  // ne = any
    a00160ec:	12001c00 	and	w0, w0, #0xff
}
    a00160f0:	910043ff 	add	sp, sp, #0x10
    a00160f4:	d65f03c0 	ret

00000000a00160f8 <z_is_thread_prevented_from_running>:
{
    a00160f8:	d10083ff 	sub	sp, sp, #0x20
    a00160fc:	f90007e0 	str	x0, [sp, #8]
	uint8_t state = thread->base.thread_state;
    a0016100:	f94007e0 	ldr	x0, [sp, #8]
    a0016104:	39406400 	ldrb	w0, [x0, #25]
    a0016108:	39007fe0 	strb	w0, [sp, #31]
	return (state & (_THREAD_PENDING | _THREAD_PRESTART | _THREAD_DEAD |
    a001610c:	39407fe0 	ldrb	w0, [sp, #31]
    a0016110:	92401000 	and	x0, x0, #0x1f
			 _THREAD_DUMMY | _THREAD_SUSPENDED)) != 0U;
    a0016114:	f100001f 	cmp	x0, #0x0
    a0016118:	1a9f07e0 	cset	w0, ne  // ne = any
    a001611c:	12001c00 	and	w0, w0, #0xff
}
    a0016120:	910083ff 	add	sp, sp, #0x20
    a0016124:	d65f03c0 	ret

00000000a0016128 <z_is_thread_timeout_active>:
{
    a0016128:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a001612c:	910003fd 	mov	x29, sp
    a0016130:	f9000fe0 	str	x0, [sp, #24]
	return !z_is_inactive_timeout(&thread->base.timeout);
    a0016134:	f9400fe0 	ldr	x0, [sp, #24]
    a0016138:	9100a000 	add	x0, x0, #0x28
    a001613c:	97ffff92 	bl	a0015f84 <z_is_inactive_timeout>
    a0016140:	12001c00 	and	w0, w0, #0xff
    a0016144:	7100001f 	cmp	w0, #0x0
    a0016148:	1a9f07e0 	cset	w0, ne  // ne = any
    a001614c:	12001c00 	and	w0, w0, #0xff
    a0016150:	52000000 	eor	w0, w0, #0x1
    a0016154:	12001c00 	and	w0, w0, #0xff
    a0016158:	12000000 	and	w0, w0, #0x1
    a001615c:	12001c00 	and	w0, w0, #0xff
}
    a0016160:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0016164:	d65f03c0 	ret

00000000a0016168 <z_is_thread_ready>:
{
    a0016168:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a001616c:	910003fd 	mov	x29, sp
    a0016170:	f9000fe0 	str	x0, [sp, #24]
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
    a0016174:	f9400fe0 	ldr	x0, [sp, #24]
    a0016178:	97ffffe0 	bl	a00160f8 <z_is_thread_prevented_from_running>
    a001617c:	12001c00 	and	w0, w0, #0xff
    a0016180:	52000000 	eor	w0, w0, #0x1
    a0016184:	12001c00 	and	w0, w0, #0xff
    a0016188:	7100001f 	cmp	w0, #0x0
    a001618c:	54000140 	b.eq	a00161b4 <z_is_thread_ready+0x4c>  // b.none
		 z_is_thread_timeout_active(thread));
    a0016190:	f9400fe0 	ldr	x0, [sp, #24]
    a0016194:	97ffffe5 	bl	a0016128 <z_is_thread_timeout_active>
    a0016198:	12001c00 	and	w0, w0, #0xff
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
    a001619c:	52000000 	eor	w0, w0, #0x1
    a00161a0:	12001c00 	and	w0, w0, #0xff
    a00161a4:	7100001f 	cmp	w0, #0x0
    a00161a8:	54000060 	b.eq	a00161b4 <z_is_thread_ready+0x4c>  // b.none
    a00161ac:	52800020 	mov	w0, #0x1                   	// #1
    a00161b0:	14000002 	b	a00161b8 <z_is_thread_ready+0x50>
    a00161b4:	52800000 	mov	w0, #0x0                   	// #0
    a00161b8:	12000000 	and	w0, w0, #0x1
    a00161bc:	12001c00 	and	w0, w0, #0xff
}
    a00161c0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a00161c4:	d65f03c0 	ret

00000000a00161c8 <z_has_thread_started>:
{
    a00161c8:	d10043ff 	sub	sp, sp, #0x10
    a00161cc:	f90007e0 	str	x0, [sp, #8]
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
    a00161d0:	f94007e0 	ldr	x0, [sp, #8]
    a00161d4:	39406400 	ldrb	w0, [x0, #25]
    a00161d8:	92401c00 	and	x0, x0, #0xff
    a00161dc:	927e0000 	and	x0, x0, #0x4
    a00161e0:	f100001f 	cmp	x0, #0x0
    a00161e4:	1a9f17e0 	cset	w0, eq  // eq = none
    a00161e8:	12001c00 	and	w0, w0, #0xff
}
    a00161ec:	910043ff 	add	sp, sp, #0x10
    a00161f0:	d65f03c0 	ret

00000000a00161f4 <z_is_thread_state_set>:
{
    a00161f4:	d10043ff 	sub	sp, sp, #0x10
    a00161f8:	f90007e0 	str	x0, [sp, #8]
    a00161fc:	b90007e1 	str	w1, [sp, #4]
	return (thread->base.thread_state & state) != 0U;
    a0016200:	f94007e0 	ldr	x0, [sp, #8]
    a0016204:	39406400 	ldrb	w0, [x0, #25]
    a0016208:	2a0003e1 	mov	w1, w0
    a001620c:	b94007e0 	ldr	w0, [sp, #4]
    a0016210:	0a000020 	and	w0, w1, w0
    a0016214:	7100001f 	cmp	w0, #0x0
    a0016218:	1a9f07e0 	cset	w0, ne  // ne = any
    a001621c:	12001c00 	and	w0, w0, #0xff
}
    a0016220:	910043ff 	add	sp, sp, #0x10
    a0016224:	d65f03c0 	ret

00000000a0016228 <z_is_thread_queued>:
{
    a0016228:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a001622c:	910003fd 	mov	x29, sp
    a0016230:	f9000fe0 	str	x0, [sp, #24]
	return z_is_thread_state_set(thread, _THREAD_QUEUED);
    a0016234:	52801001 	mov	w1, #0x80                  	// #128
    a0016238:	f9400fe0 	ldr	x0, [sp, #24]
    a001623c:	97ffffee 	bl	a00161f4 <z_is_thread_state_set>
    a0016240:	12001c00 	and	w0, w0, #0xff
}
    a0016244:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0016248:	d65f03c0 	ret

00000000a001624c <z_mark_thread_as_suspended>:
{
    a001624c:	d10043ff 	sub	sp, sp, #0x10
    a0016250:	f90007e0 	str	x0, [sp, #8]
	thread->base.thread_state |= _THREAD_SUSPENDED;
    a0016254:	f94007e0 	ldr	x0, [sp, #8]
    a0016258:	39406400 	ldrb	w0, [x0, #25]
    a001625c:	321c0000 	orr	w0, w0, #0x10
    a0016260:	12001c01 	and	w1, w0, #0xff
    a0016264:	f94007e0 	ldr	x0, [sp, #8]
    a0016268:	39006401 	strb	w1, [x0, #25]
}
    a001626c:	d503201f 	nop
    a0016270:	910043ff 	add	sp, sp, #0x10
    a0016274:	d65f03c0 	ret

00000000a0016278 <z_mark_thread_as_not_suspended>:
{
    a0016278:	d10043ff 	sub	sp, sp, #0x10
    a001627c:	f90007e0 	str	x0, [sp, #8]
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
    a0016280:	f94007e0 	ldr	x0, [sp, #8]
    a0016284:	39406400 	ldrb	w0, [x0, #25]
    a0016288:	121b7800 	and	w0, w0, #0xffffffef
    a001628c:	12001c01 	and	w1, w0, #0xff
    a0016290:	f94007e0 	ldr	x0, [sp, #8]
    a0016294:	39006401 	strb	w1, [x0, #25]
}
    a0016298:	d503201f 	nop
    a001629c:	910043ff 	add	sp, sp, #0x10
    a00162a0:	d65f03c0 	ret

00000000a00162a4 <z_mark_thread_as_started>:
{
    a00162a4:	d10043ff 	sub	sp, sp, #0x10
    a00162a8:	f90007e0 	str	x0, [sp, #8]
	thread->base.thread_state &= ~_THREAD_PRESTART;
    a00162ac:	f94007e0 	ldr	x0, [sp, #8]
    a00162b0:	39406400 	ldrb	w0, [x0, #25]
    a00162b4:	121d7800 	and	w0, w0, #0xfffffffb
    a00162b8:	12001c01 	and	w1, w0, #0xff
    a00162bc:	f94007e0 	ldr	x0, [sp, #8]
    a00162c0:	39006401 	strb	w1, [x0, #25]
}
    a00162c4:	d503201f 	nop
    a00162c8:	910043ff 	add	sp, sp, #0x10
    a00162cc:	d65f03c0 	ret

00000000a00162d0 <z_mark_thread_as_pending>:
{
    a00162d0:	d10043ff 	sub	sp, sp, #0x10
    a00162d4:	f90007e0 	str	x0, [sp, #8]
	thread->base.thread_state |= _THREAD_PENDING;
    a00162d8:	f94007e0 	ldr	x0, [sp, #8]
    a00162dc:	39406400 	ldrb	w0, [x0, #25]
    a00162e0:	321f0000 	orr	w0, w0, #0x2
    a00162e4:	12001c01 	and	w1, w0, #0xff
    a00162e8:	f94007e0 	ldr	x0, [sp, #8]
    a00162ec:	39006401 	strb	w1, [x0, #25]
}
    a00162f0:	d503201f 	nop
    a00162f4:	910043ff 	add	sp, sp, #0x10
    a00162f8:	d65f03c0 	ret

00000000a00162fc <z_mark_thread_as_not_pending>:
{
    a00162fc:	d10043ff 	sub	sp, sp, #0x10
    a0016300:	f90007e0 	str	x0, [sp, #8]
	thread->base.thread_state &= ~_THREAD_PENDING;
    a0016304:	f94007e0 	ldr	x0, [sp, #8]
    a0016308:	39406400 	ldrb	w0, [x0, #25]
    a001630c:	121e7800 	and	w0, w0, #0xfffffffd
    a0016310:	12001c01 	and	w1, w0, #0xff
    a0016314:	f94007e0 	ldr	x0, [sp, #8]
    a0016318:	39006401 	strb	w1, [x0, #25]
}
    a001631c:	d503201f 	nop
    a0016320:	910043ff 	add	sp, sp, #0x10
    a0016324:	d65f03c0 	ret

00000000a0016328 <z_is_prio1_higher_than_or_equal_to_prio2>:
{
    a0016328:	d10043ff 	sub	sp, sp, #0x10
    a001632c:	b9000fe0 	str	w0, [sp, #12]
    a0016330:	b9000be1 	str	w1, [sp, #8]
	return prio1 <= prio2;
    a0016334:	b9400fe1 	ldr	w1, [sp, #12]
    a0016338:	b9400be0 	ldr	w0, [sp, #8]
    a001633c:	6b00003f 	cmp	w1, w0
    a0016340:	1a9fc7e0 	cset	w0, le
    a0016344:	12001c00 	and	w0, w0, #0xff
}
    a0016348:	910043ff 	add	sp, sp, #0x10
    a001634c:	d65f03c0 	ret

00000000a0016350 <z_is_prio_higher_or_equal>:
{
    a0016350:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0016354:	910003fd 	mov	x29, sp
    a0016358:	b9001fe0 	str	w0, [sp, #28]
    a001635c:	b9001be1 	str	w1, [sp, #24]
	return z_is_prio1_higher_than_or_equal_to_prio2(prio1, prio2);
    a0016360:	b9401be1 	ldr	w1, [sp, #24]
    a0016364:	b9401fe0 	ldr	w0, [sp, #28]
    a0016368:	97fffff0 	bl	a0016328 <z_is_prio1_higher_than_or_equal_to_prio2>
    a001636c:	12001c00 	and	w0, w0, #0xff
}
    a0016370:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0016374:	d65f03c0 	ret

00000000a0016378 <z_is_prio1_lower_than_or_equal_to_prio2>:
{
    a0016378:	d10043ff 	sub	sp, sp, #0x10
    a001637c:	b9000fe0 	str	w0, [sp, #12]
    a0016380:	b9000be1 	str	w1, [sp, #8]
	return prio1 >= prio2;
    a0016384:	b9400fe1 	ldr	w1, [sp, #12]
    a0016388:	b9400be0 	ldr	w0, [sp, #8]
    a001638c:	6b00003f 	cmp	w1, w0
    a0016390:	1a9fb7e0 	cset	w0, ge  // ge = tcont
    a0016394:	12001c00 	and	w0, w0, #0xff
}
    a0016398:	910043ff 	add	sp, sp, #0x10
    a001639c:	d65f03c0 	ret

00000000a00163a0 <z_is_prio1_higher_than_prio2>:
{
    a00163a0:	d10043ff 	sub	sp, sp, #0x10
    a00163a4:	b9000fe0 	str	w0, [sp, #12]
    a00163a8:	b9000be1 	str	w1, [sp, #8]
	return prio1 < prio2;
    a00163ac:	b9400fe1 	ldr	w1, [sp, #12]
    a00163b0:	b9400be0 	ldr	w0, [sp, #8]
    a00163b4:	6b00003f 	cmp	w1, w0
    a00163b8:	1a9fa7e0 	cset	w0, lt  // lt = tstop
    a00163bc:	12001c00 	and	w0, w0, #0xff
}
    a00163c0:	910043ff 	add	sp, sp, #0x10
    a00163c4:	d65f03c0 	ret

00000000a00163c8 <z_is_prio_higher>:
{
    a00163c8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a00163cc:	910003fd 	mov	x29, sp
    a00163d0:	b9001fe0 	str	w0, [sp, #28]
    a00163d4:	b9001be1 	str	w1, [sp, #24]
	return z_is_prio1_higher_than_prio2(prio, test_prio);
    a00163d8:	b9401be1 	ldr	w1, [sp, #24]
    a00163dc:	b9401fe0 	ldr	w0, [sp, #28]
    a00163e0:	97fffff0 	bl	a00163a0 <z_is_prio1_higher_than_prio2>
    a00163e4:	12001c00 	and	w0, w0, #0xff
}
    a00163e8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a00163ec:	d65f03c0 	ret

00000000a00163f0 <z_is_prio_lower_or_equal>:
{
    a00163f0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a00163f4:	910003fd 	mov	x29, sp
    a00163f8:	b9001fe0 	str	w0, [sp, #28]
    a00163fc:	b9001be1 	str	w1, [sp, #24]
	return z_is_prio1_lower_than_or_equal_to_prio2(prio1, prio2);
    a0016400:	b9401be1 	ldr	w1, [sp, #24]
    a0016404:	b9401fe0 	ldr	w0, [sp, #28]
    a0016408:	97ffffdc 	bl	a0016378 <z_is_prio1_lower_than_or_equal_to_prio2>
    a001640c:	12001c00 	and	w0, w0, #0xff
}
    a0016410:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0016414:	d65f03c0 	ret

00000000a0016418 <_is_valid_prio>:
{
    a0016418:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a001641c:	910003fd 	mov	x29, sp
    a0016420:	b9001fe0 	str	w0, [sp, #28]
    a0016424:	f9000be1 	str	x1, [sp, #16]
	if (prio == K_IDLE_PRIO && z_is_idle_thread_entry(entry_point)) {
    a0016428:	b9401fe0 	ldr	w0, [sp, #28]
    a001642c:	71003c1f 	cmp	w0, #0xf
    a0016430:	54000101 	b.ne	a0016450 <_is_valid_prio+0x38>  // b.any
    a0016434:	f9400be0 	ldr	x0, [sp, #16]
    a0016438:	97ffff06 	bl	a0016050 <z_is_idle_thread_entry>
    a001643c:	12001c00 	and	w0, w0, #0xff
    a0016440:	7100001f 	cmp	w0, #0x0
    a0016444:	54000060 	b.eq	a0016450 <_is_valid_prio+0x38>  // b.none
		return true;
    a0016448:	52800020 	mov	w0, #0x1                   	// #1
    a001644c:	14000016 	b	a00164a4 <_is_valid_prio+0x8c>
	if (!z_is_prio_higher_or_equal(prio,
    a0016450:	528001c1 	mov	w1, #0xe                   	// #14
    a0016454:	b9401fe0 	ldr	w0, [sp, #28]
    a0016458:	97ffffbe 	bl	a0016350 <z_is_prio_higher_or_equal>
    a001645c:	12001c00 	and	w0, w0, #0xff
    a0016460:	52000000 	eor	w0, w0, #0x1
    a0016464:	12001c00 	and	w0, w0, #0xff
    a0016468:	7100001f 	cmp	w0, #0x0
    a001646c:	54000060 	b.eq	a0016478 <_is_valid_prio+0x60>  // b.none
		return false;
    a0016470:	52800000 	mov	w0, #0x0                   	// #0
    a0016474:	1400000c 	b	a00164a4 <_is_valid_prio+0x8c>
	if (!z_is_prio_lower_or_equal(prio,
    a0016478:	128001e1 	mov	w1, #0xfffffff0            	// #-16
    a001647c:	b9401fe0 	ldr	w0, [sp, #28]
    a0016480:	97ffffdc 	bl	a00163f0 <z_is_prio_lower_or_equal>
    a0016484:	12001c00 	and	w0, w0, #0xff
    a0016488:	52000000 	eor	w0, w0, #0x1
    a001648c:	12001c00 	and	w0, w0, #0xff
    a0016490:	7100001f 	cmp	w0, #0x0
    a0016494:	54000060 	b.eq	a00164a0 <_is_valid_prio+0x88>  // b.none
		return false;
    a0016498:	52800000 	mov	w0, #0x0                   	// #0
    a001649c:	14000002 	b	a00164a4 <_is_valid_prio+0x8c>
	return true;
    a00164a0:	52800020 	mov	w0, #0x1                   	// #1
}
    a00164a4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a00164a8:	d65f03c0 	ret

00000000a00164ac <z_sched_lock>:
	--_current->base.sched_locked;
    a00164ac:	b0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00164b0:	913f8000 	add	x0, x0, #0xfe0
    a00164b4:	f9400800 	ldr	x0, [x0, #16]
    a00164b8:	39406c01 	ldrb	w1, [x0, #27]
    a00164bc:	51000421 	sub	w1, w1, #0x1
    a00164c0:	12001c21 	and	w1, w1, #0xff
    a00164c4:	39006c01 	strb	w1, [x0, #27]
}
    a00164c8:	d503201f 	nop
    a00164cc:	d65f03c0 	ret

00000000a00164d0 <z_sched_usage_switch>:
{
    a00164d0:	d10043ff 	sub	sp, sp, #0x10
    a00164d4:	f90007e0 	str	x0, [sp, #8]
}
    a00164d8:	d503201f 	nop
    a00164dc:	910043ff 	add	sp, sp, #0x10
    a00164e0:	d65f03c0 	ret

00000000a00164e4 <z_waitq_head>:
{
    a00164e4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a00164e8:	910003fd 	mov	x29, sp
    a00164ec:	f9000fe0 	str	x0, [sp, #24]
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
    a00164f0:	f9400fe0 	ldr	x0, [sp, #24]
    a00164f4:	97fffac6 	bl	a001500c <sys_dlist_peek_head>
}
    a00164f8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a00164fc:	d65f03c0 	ret

00000000a0016500 <wait_for_switch>:
{
    a0016500:	d10043ff 	sub	sp, sp, #0x10
    a0016504:	f90007e0 	str	x0, [sp, #8]
}
    a0016508:	d503201f 	nop
    a001650c:	910043ff 	add	sp, sp, #0x10
    a0016510:	d65f03c0 	ret

00000000a0016514 <z_swap_irqlock>:
{
    a0016514:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
    a0016518:	910003fd 	mov	x29, sp
    a001651c:	b9001fe0 	str	w0, [sp, #28]
    a0016520:	b9401fe0 	ldr	w0, [sp, #28]
    a0016524:	b900afe0 	str	w0, [sp, #172]
    a0016528:	f90053ff 	str	xzr, [sp, #160]
    a001652c:	b9009fff 	str	wzr, [sp, #156]
	old_thread = _current;
    a0016530:	b0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0016534:	913f8000 	add	x0, x0, #0xfe0
    a0016538:	f9400800 	ldr	x0, [x0, #16]
    a001653c:	f9004be0 	str	x0, [sp, #144]
	old_thread->swap_retval = -EAGAIN;
    a0016540:	f9404be0 	ldr	x0, [sp, #144]
    a0016544:	12800141 	mov	w1, #0xfffffff5            	// #-11
    a0016548:	b9011001 	str	w1, [x0, #272]
	if (is_spinlock && lock != NULL && lock != &sched_spinlock) {
    a001654c:	b9409fe0 	ldr	w0, [sp, #156]
    a0016550:	7100001f 	cmp	w0, #0x0
    a0016554:	54000180 	b.eq	a0016584 <z_swap_irqlock+0x70>  // b.none
    a0016558:	f94053e0 	ldr	x0, [sp, #160]
    a001655c:	f100001f 	cmp	x0, #0x0
    a0016560:	54000120 	b.eq	a0016584 <z_swap_irqlock+0x70>  // b.none
    a0016564:	f94053e1 	ldr	x1, [sp, #160]
    a0016568:	d0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a001656c:	910a4000 	add	x0, x0, #0x290
    a0016570:	eb00003f 	cmp	x1, x0
    a0016574:	54000080 	b.eq	a0016584 <z_swap_irqlock+0x70>  // b.none
    a0016578:	f94053e0 	ldr	x0, [sp, #160]
    a001657c:	f90047e0 	str	x0, [sp, #136]
}
    a0016580:	d503201f 	nop
	if (!is_spinlock || lock != &sched_spinlock) {
    a0016584:	b9409fe0 	ldr	w0, [sp, #156]
    a0016588:	7100001f 	cmp	w0, #0x0
    a001658c:	540000c0 	b.eq	a00165a4 <z_swap_irqlock+0x90>  // b.none
    a0016590:	f94053e1 	ldr	x1, [sp, #160]
    a0016594:	d0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0016598:	910a4000 	add	x0, x0, #0x290
    a001659c:	eb00003f 	cmp	x1, x0
    a00165a0:	540001c0 	b.eq	a00165d8 <z_swap_irqlock+0xc4>  // b.none
    a00165a4:	d0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a00165a8:	910a4000 	add	x0, x0, #0x290
    a00165ac:	f90043e0 	str	x0, [sp, #128]
MAKE_REG_HELPER(daif)
    a00165b0:	d53b4220 	mrs	x0, daif
    a00165b4:	f9003fe0 	str	x0, [sp, #120]
    a00165b8:	f9403fe0 	ldr	x0, [sp, #120]
    a00165bc:	d503201f 	nop
	key = read_daif();
    a00165c0:	b90077e0 	str	w0, [sp, #116]
	__asm__ volatile ("msr DAIFSet, %0"
    a00165c4:	d50342df 	msr	daifset, #0x2
}
    a00165c8:	d503201f 	nop
	return key;
    a00165cc:	b94077e0 	ldr	w0, [sp, #116]
	k.key = arch_irq_lock();
    a00165d0:	b9002be0 	str	w0, [sp, #40]
	return k;
    a00165d4:	d503201f 	nop
	new_thread = z_swap_next_thread();
    a00165d8:	94000764 	bl	a0018368 <z_swap_next_thread>
    a00165dc:	f90037e0 	str	x0, [sp, #104]
	if (new_thread != old_thread) {
    a00165e0:	f9404be1 	ldr	x1, [sp, #144]
    a00165e4:	f94037e0 	ldr	x0, [sp, #104]
    a00165e8:	eb00003f 	cmp	x1, x0
    a00165ec:	54000360 	b.eq	a0016658 <z_swap_irqlock+0x144>  // b.none
		z_reset_time_slice();
    a00165f0:	9400014b 	bl	a0016b1c <z_reset_time_slice>
		z_sched_usage_switch(new_thread);
    a00165f4:	f94037e0 	ldr	x0, [sp, #104]
    a00165f8:	97ffffb6 	bl	a00164d0 <z_sched_usage_switch>
		wait_for_switch(new_thread);
    a00165fc:	f94037e0 	ldr	x0, [sp, #104]
    a0016600:	97ffffc0 	bl	a0016500 <wait_for_switch>
		_current_cpu->current = new_thread;
    a0016604:	b0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0016608:	913f8000 	add	x0, x0, #0xfe0
    a001660c:	f94037e1 	ldr	x1, [sp, #104]
    a0016610:	f9000801 	str	x1, [x0, #16]
		arch_cohere_stacks(old_thread, NULL, new_thread);
    a0016614:	f94037e2 	ldr	x2, [sp, #104]
    a0016618:	d2800001 	mov	x1, #0x0                   	// #0
    a001661c:	f9404be0 	ldr	x0, [sp, #144]
    a0016620:	97fffaf1 	bl	a00151e4 <arch_cohere_stacks>
		void *newsh = new_thread->switch_handle;
    a0016624:	f94037e0 	ldr	x0, [sp, #104]
    a0016628:	f9408c00 	ldr	x0, [x0, #280]
    a001662c:	f90033e0 	str	x0, [sp, #96]
    a0016630:	d0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0016634:	910a4000 	add	x0, x0, #0x290
    a0016638:	f9002fe0 	str	x0, [sp, #88]
}
    a001663c:	d503201f 	nop
		arch_switch(newsh, &old_thread->switch_handle);
    a0016640:	f9404be0 	ldr	x0, [sp, #144]
    a0016644:	91046000 	add	x0, x0, #0x118
    a0016648:	aa0003e1 	mov	x1, x0
    a001664c:	f94033e0 	ldr	x0, [sp, #96]
    a0016650:	97fffe43 	bl	a0015f5c <arch_switch>
    a0016654:	14000005 	b	a0016668 <z_swap_irqlock+0x154>
    a0016658:	d0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a001665c:	910a4000 	add	x0, x0, #0x290
    a0016660:	f9002be0 	str	x0, [sp, #80]
    a0016664:	d503201f 	nop
	if (is_spinlock) {
    a0016668:	b9409fe0 	ldr	w0, [sp, #156]
    a001666c:	7100001f 	cmp	w0, #0x0
    a0016670:	54000120 	b.eq	a0016694 <z_swap_irqlock+0x180>  // b.none
    a0016674:	b940afe0 	ldr	w0, [sp, #172]
    a0016678:	b9004fe0 	str	w0, [sp, #76]
	write_daif(key);
    a001667c:	b9404fe0 	ldr	w0, [sp, #76]
    a0016680:	f90023e0 	str	x0, [sp, #64]
MAKE_REG_HELPER(daif)
    a0016684:	f94023e0 	ldr	x0, [sp, #64]
    a0016688:	d51b4220 	msr	daif, x0
    a001668c:	d503201f 	nop
}
    a0016690:	14000009 	b	a00166b4 <z_swap_irqlock+0x1a0>
    a0016694:	b940afe0 	ldr	w0, [sp, #172]
    a0016698:	b9003fe0 	str	w0, [sp, #60]
	write_daif(key);
    a001669c:	b9403fe0 	ldr	w0, [sp, #60]
    a00166a0:	f9001be0 	str	x0, [sp, #48]
    a00166a4:	f9401be0 	ldr	x0, [sp, #48]
    a00166a8:	d51b4220 	msr	daif, x0
    a00166ac:	d503201f 	nop
}
    a00166b0:	d503201f 	nop
	return _current->swap_retval;
    a00166b4:	b0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00166b8:	913f8000 	add	x0, x0, #0xfe0
    a00166bc:	f9400800 	ldr	x0, [x0, #16]
    a00166c0:	b9411000 	ldr	w0, [x0, #272]
}
    a00166c4:	a8cb7bfd 	ldp	x29, x30, [sp], #176
    a00166c8:	d65f03c0 	ret

00000000a00166cc <z_swap>:
{
    a00166cc:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
    a00166d0:	910003fd 	mov	x29, sp
    a00166d4:	f9000fe0 	str	x0, [sp, #24]
    a00166d8:	b90013e1 	str	w1, [sp, #16]
	return do_swap(key.key, lock, 1);
    a00166dc:	b94013e0 	ldr	w0, [sp, #16]
    a00166e0:	b900afe0 	str	w0, [sp, #172]
    a00166e4:	f9400fe0 	ldr	x0, [sp, #24]
    a00166e8:	f90053e0 	str	x0, [sp, #160]
    a00166ec:	52800020 	mov	w0, #0x1                   	// #1
    a00166f0:	b9009fe0 	str	w0, [sp, #156]
	old_thread = _current;
    a00166f4:	b0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00166f8:	913f8000 	add	x0, x0, #0xfe0
    a00166fc:	f9400800 	ldr	x0, [x0, #16]
    a0016700:	f9004be0 	str	x0, [sp, #144]
	old_thread->swap_retval = -EAGAIN;
    a0016704:	f9404be0 	ldr	x0, [sp, #144]
    a0016708:	12800141 	mov	w1, #0xfffffff5            	// #-11
    a001670c:	b9011001 	str	w1, [x0, #272]
	if (is_spinlock && lock != NULL && lock != &sched_spinlock) {
    a0016710:	b9409fe0 	ldr	w0, [sp, #156]
    a0016714:	7100001f 	cmp	w0, #0x0
    a0016718:	54000180 	b.eq	a0016748 <z_swap+0x7c>  // b.none
    a001671c:	f94053e0 	ldr	x0, [sp, #160]
    a0016720:	f100001f 	cmp	x0, #0x0
    a0016724:	54000120 	b.eq	a0016748 <z_swap+0x7c>  // b.none
    a0016728:	f94053e1 	ldr	x1, [sp, #160]
    a001672c:	d0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0016730:	910a4000 	add	x0, x0, #0x290
    a0016734:	eb00003f 	cmp	x1, x0
    a0016738:	54000080 	b.eq	a0016748 <z_swap+0x7c>  // b.none
    a001673c:	f94053e0 	ldr	x0, [sp, #160]
    a0016740:	f90047e0 	str	x0, [sp, #136]
    a0016744:	d503201f 	nop
	if (!is_spinlock || lock != &sched_spinlock) {
    a0016748:	b9409fe0 	ldr	w0, [sp, #156]
    a001674c:	7100001f 	cmp	w0, #0x0
    a0016750:	540000c0 	b.eq	a0016768 <z_swap+0x9c>  // b.none
    a0016754:	f94053e1 	ldr	x1, [sp, #160]
    a0016758:	d0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a001675c:	910a4000 	add	x0, x0, #0x290
    a0016760:	eb00003f 	cmp	x1, x0
    a0016764:	540001c0 	b.eq	a001679c <z_swap+0xd0>  // b.none
    a0016768:	d0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a001676c:	910a4000 	add	x0, x0, #0x290
    a0016770:	f90043e0 	str	x0, [sp, #128]
    a0016774:	d53b4220 	mrs	x0, daif
    a0016778:	f9003fe0 	str	x0, [sp, #120]
    a001677c:	f9403fe0 	ldr	x0, [sp, #120]
    a0016780:	d503201f 	nop
	key = read_daif();
    a0016784:	b90077e0 	str	w0, [sp, #116]
	__asm__ volatile ("msr DAIFSet, %0"
    a0016788:	d50342df 	msr	daifset, #0x2
}
    a001678c:	d503201f 	nop
	return key;
    a0016790:	b94077e0 	ldr	w0, [sp, #116]
	k.key = arch_irq_lock();
    a0016794:	b9002be0 	str	w0, [sp, #40]
	return k;
    a0016798:	d503201f 	nop
	new_thread = z_swap_next_thread();
    a001679c:	940006f3 	bl	a0018368 <z_swap_next_thread>
    a00167a0:	f90037e0 	str	x0, [sp, #104]
	if (new_thread != old_thread) {
    a00167a4:	f9404be1 	ldr	x1, [sp, #144]
    a00167a8:	f94037e0 	ldr	x0, [sp, #104]
    a00167ac:	eb00003f 	cmp	x1, x0
    a00167b0:	54000360 	b.eq	a001681c <z_swap+0x150>  // b.none
		z_reset_time_slice();
    a00167b4:	940000da 	bl	a0016b1c <z_reset_time_slice>
		z_sched_usage_switch(new_thread);
    a00167b8:	f94037e0 	ldr	x0, [sp, #104]
    a00167bc:	97ffff45 	bl	a00164d0 <z_sched_usage_switch>
		wait_for_switch(new_thread);
    a00167c0:	f94037e0 	ldr	x0, [sp, #104]
    a00167c4:	97ffff4f 	bl	a0016500 <wait_for_switch>
		_current_cpu->current = new_thread;
    a00167c8:	b0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00167cc:	913f8000 	add	x0, x0, #0xfe0
    a00167d0:	f94037e1 	ldr	x1, [sp, #104]
    a00167d4:	f9000801 	str	x1, [x0, #16]
		arch_cohere_stacks(old_thread, NULL, new_thread);
    a00167d8:	f94037e2 	ldr	x2, [sp, #104]
    a00167dc:	d2800001 	mov	x1, #0x0                   	// #0
    a00167e0:	f9404be0 	ldr	x0, [sp, #144]
    a00167e4:	97fffa80 	bl	a00151e4 <arch_cohere_stacks>
		void *newsh = new_thread->switch_handle;
    a00167e8:	f94037e0 	ldr	x0, [sp, #104]
    a00167ec:	f9408c00 	ldr	x0, [x0, #280]
    a00167f0:	f90033e0 	str	x0, [sp, #96]
    a00167f4:	d0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a00167f8:	910a4000 	add	x0, x0, #0x290
    a00167fc:	f9002fe0 	str	x0, [sp, #88]
}
    a0016800:	d503201f 	nop
		arch_switch(newsh, &old_thread->switch_handle);
    a0016804:	f9404be0 	ldr	x0, [sp, #144]
    a0016808:	91046000 	add	x0, x0, #0x118
    a001680c:	aa0003e1 	mov	x1, x0
    a0016810:	f94033e0 	ldr	x0, [sp, #96]
    a0016814:	97fffdd2 	bl	a0015f5c <arch_switch>
    a0016818:	14000005 	b	a001682c <z_swap+0x160>
    a001681c:	d0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0016820:	910a4000 	add	x0, x0, #0x290
    a0016824:	f9002be0 	str	x0, [sp, #80]
    a0016828:	d503201f 	nop
	if (is_spinlock) {
    a001682c:	b9409fe0 	ldr	w0, [sp, #156]
    a0016830:	7100001f 	cmp	w0, #0x0
    a0016834:	54000120 	b.eq	a0016858 <z_swap+0x18c>  // b.none
    a0016838:	b940afe0 	ldr	w0, [sp, #172]
    a001683c:	b9004fe0 	str	w0, [sp, #76]
	write_daif(key);
    a0016840:	b9404fe0 	ldr	w0, [sp, #76]
    a0016844:	f90023e0 	str	x0, [sp, #64]
MAKE_REG_HELPER(daif)
    a0016848:	f94023e0 	ldr	x0, [sp, #64]
    a001684c:	d51b4220 	msr	daif, x0
    a0016850:	d503201f 	nop
}
    a0016854:	14000009 	b	a0016878 <z_swap+0x1ac>
    a0016858:	b940afe0 	ldr	w0, [sp, #172]
    a001685c:	b9003fe0 	str	w0, [sp, #60]
	write_daif(key);
    a0016860:	b9403fe0 	ldr	w0, [sp, #60]
    a0016864:	f9001be0 	str	x0, [sp, #48]
    a0016868:	f9401be0 	ldr	x0, [sp, #48]
    a001686c:	d51b4220 	msr	daif, x0
    a0016870:	d503201f 	nop
}
    a0016874:	d503201f 	nop
	return _current->swap_retval;
    a0016878:	b0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001687c:	913f8000 	add	x0, x0, #0xfe0
    a0016880:	f9400800 	ldr	x0, [x0, #16]
    a0016884:	b9411000 	ldr	w0, [x0, #272]
}
    a0016888:	a8cb7bfd 	ldp	x29, x30, [sp], #176
    a001688c:	d65f03c0 	ret

00000000a0016890 <z_obj_validation_check>:
{
    a0016890:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    a0016894:	910003fd 	mov	x29, sp
    a0016898:	f90017e0 	str	x0, [sp, #40]
    a001689c:	f90013e1 	str	x1, [sp, #32]
    a00168a0:	b9001fe2 	str	w2, [sp, #28]
    a00168a4:	b9001be3 	str	w3, [sp, #24]
	ret = z_object_validate(ko, otype, init);
    a00168a8:	b9401be2 	ldr	w2, [sp, #24]
    a00168ac:	b9401fe1 	ldr	w1, [sp, #28]
    a00168b0:	f94017e0 	ldr	x0, [sp, #40]
    a00168b4:	94001a84 	bl	a001d2c4 <z_object_validate>
    a00168b8:	b9003fe0 	str	w0, [sp, #60]
	return ret;
    a00168bc:	b9403fe0 	ldr	w0, [sp, #60]
}
    a00168c0:	a8c47bfd 	ldp	x29, x30, [sp], #64
    a00168c4:	d65f03c0 	ret

00000000a00168c8 <is_preempt>:
static void update_cache(int preempt_ok);
static void end_thread(struct k_thread *thread);


static inline int is_preempt(struct k_thread *thread)
{
    a00168c8:	d10043ff 	sub	sp, sp, #0x10
    a00168cc:	f90007e0 	str	x0, [sp, #8]
	/* explanation in kernel_struct.h */
	return thread->base.preempt <= _PREEMPT_THRESHOLD;
    a00168d0:	f94007e0 	ldr	x0, [sp, #8]
    a00168d4:	79403400 	ldrh	w0, [x0, #26]
    a00168d8:	7101fc1f 	cmp	w0, #0x7f
    a00168dc:	1a9f87e0 	cset	w0, ls  // ls = plast
    a00168e0:	12001c00 	and	w0, w0, #0xff
}
    a00168e4:	910043ff 	add	sp, sp, #0x10
    a00168e8:	d65f03c0 	ret

00000000a00168ec <is_metairq>:

static inline int is_metairq(struct k_thread *thread)
{
    a00168ec:	d10043ff 	sub	sp, sp, #0x10
    a00168f0:	f90007e0 	str	x0, [sp, #8]
#if CONFIG_NUM_METAIRQ_PRIORITIES > 0
	return (thread->base.prio - K_HIGHEST_THREAD_PRIO)
		< CONFIG_NUM_METAIRQ_PRIORITIES;
#else
	return 0;
    a00168f4:	52800000 	mov	w0, #0x0                   	// #0
#endif
}
    a00168f8:	910043ff 	add	sp, sp, #0x10
    a00168fc:	d65f03c0 	ret

00000000a0016900 <z_sched_prio_cmp>:
 * Do not rely on the actual value returned aside from the above.
 * (Again, like memcmp.)
 */
int32_t z_sched_prio_cmp(struct k_thread *thread_1,
	struct k_thread *thread_2)
{
    a0016900:	d10083ff 	sub	sp, sp, #0x20
    a0016904:	f90007e0 	str	x0, [sp, #8]
    a0016908:	f90003e1 	str	x1, [sp]
	/* `prio` is <32b, so the below cannot overflow. */
	int32_t b1 = thread_1->base.prio;
    a001690c:	f94007e0 	ldr	x0, [sp, #8]
    a0016910:	39c06800 	ldrsb	w0, [x0, #26]
    a0016914:	b9001fe0 	str	w0, [sp, #28]
	int32_t b2 = thread_2->base.prio;
    a0016918:	f94003e0 	ldr	x0, [sp]
    a001691c:	39c06800 	ldrsb	w0, [x0, #26]
    a0016920:	b9001be0 	str	w0, [sp, #24]

	if (b1 != b2) {
    a0016924:	b9401fe1 	ldr	w1, [sp, #28]
    a0016928:	b9401be0 	ldr	w0, [sp, #24]
    a001692c:	6b00003f 	cmp	w1, w0
    a0016930:	540000a0 	b.eq	a0016944 <z_sched_prio_cmp+0x44>  // b.none
		return b2 - b1;
    a0016934:	b9401be1 	ldr	w1, [sp, #24]
    a0016938:	b9401fe0 	ldr	w0, [sp, #28]
    a001693c:	4b000020 	sub	w0, w1, w0
    a0016940:	14000002 	b	a0016948 <z_sched_prio_cmp+0x48>
		 * from UB on overflow to impdef.
		 */
		return (int32_t) (d2 - d1);
	}
#endif
	return 0;
    a0016944:	52800000 	mov	w0, #0x0                   	// #0
}
    a0016948:	910083ff 	add	sp, sp, #0x20
    a001694c:	d65f03c0 	ret

00000000a0016950 <should_queue_thread>:

/* _current is never in the run queue until context switch on
 * SMP configurations, see z_requeue_current()
 */
static inline bool should_queue_thread(struct k_thread *th)
{
    a0016950:	d10043ff 	sub	sp, sp, #0x10
    a0016954:	f90007e0 	str	x0, [sp, #8]
	return !IS_ENABLED(CONFIG_SMP) || th != _current;
    a0016958:	52800020 	mov	w0, #0x1                   	// #1
}
    a001695c:	910043ff 	add	sp, sp, #0x10
    a0016960:	d65f03c0 	ret

00000000a0016964 <move_thread_to_end_of_prio_q>:
	return thread;
#endif
}

static void move_thread_to_end_of_prio_q(struct k_thread *thread)
{
    a0016964:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    a0016968:	910003fd 	mov	x29, sp
    a001696c:	f9000fe0 	str	x0, [sp, #24]
	if (z_is_thread_queued(thread)) {
    a0016970:	f9400fe0 	ldr	x0, [sp, #24]
    a0016974:	97fffe2d 	bl	a0016228 <z_is_thread_queued>
    a0016978:	12001c00 	and	w0, w0, #0xff
    a001697c:	7100001f 	cmp	w0, #0x0
    a0016980:	54000300 	b.eq	a00169e0 <move_thread_to_end_of_prio_q+0x7c>  // b.none
    a0016984:	f9400fe0 	ldr	x0, [sp, #24]
    a0016988:	f90037e0 	str	x0, [sp, #104]
	thread->base.thread_state &= ~_THREAD_QUEUED;
    a001698c:	f94037e0 	ldr	x0, [sp, #104]
    a0016990:	39406400 	ldrb	w0, [x0, #25]
    a0016994:	12001800 	and	w0, w0, #0x7f
    a0016998:	12001c01 	and	w1, w0, #0xff
    a001699c:	f94037e0 	ldr	x0, [sp, #104]
    a00169a0:	39006401 	strb	w1, [x0, #25]
	if (should_queue_thread(thread)) {
    a00169a4:	f94037e0 	ldr	x0, [sp, #104]
    a00169a8:	97ffffea 	bl	a0016950 <should_queue_thread>
    a00169ac:	12001c00 	and	w0, w0, #0xff
    a00169b0:	7100001f 	cmp	w0, #0x0
    a00169b4:	54000140 	b.eq	a00169dc <move_thread_to_end_of_prio_q+0x78>  // b.none
    a00169b8:	f94037e0 	ldr	x0, [sp, #104]
    a00169bc:	f90033e0 	str	x0, [sp, #96]
    a00169c0:	f94033e0 	ldr	x0, [sp, #96]
    a00169c4:	f9002fe0 	str	x0, [sp, #88]
	return &_kernel.ready_q.runq;
    a00169c8:	d0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a00169cc:	91004000 	add	x0, x0, #0x10
	_priq_run_remove(thread_runq(thread), thread);
    a00169d0:	f94033e1 	ldr	x1, [sp, #96]
    a00169d4:	94000688 	bl	a00183f4 <z_priq_dumb_remove>
}
    a00169d8:	d503201f 	nop
}
    a00169dc:	d503201f 	nop
    a00169e0:	f9400fe0 	ldr	x0, [sp, #24]
    a00169e4:	f9002be0 	str	x0, [sp, #80]
	thread->base.thread_state |= _THREAD_QUEUED;
    a00169e8:	f9402be0 	ldr	x0, [sp, #80]
    a00169ec:	39406400 	ldrb	w0, [x0, #25]
    a00169f0:	32196000 	orr	w0, w0, #0xffffff80
    a00169f4:	12001c01 	and	w1, w0, #0xff
    a00169f8:	f9402be0 	ldr	x0, [sp, #80]
    a00169fc:	39006401 	strb	w1, [x0, #25]
	if (should_queue_thread(thread)) {
    a0016a00:	f9402be0 	ldr	x0, [sp, #80]
    a0016a04:	97ffffd3 	bl	a0016950 <should_queue_thread>
    a0016a08:	12001c00 	and	w0, w0, #0xff
    a0016a0c:	7100001f 	cmp	w0, #0x0
    a0016a10:	540006e0 	b.eq	a0016aec <move_thread_to_end_of_prio_q+0x188>  // b.none
    a0016a14:	f9402be0 	ldr	x0, [sp, #80]
    a0016a18:	f90027e0 	str	x0, [sp, #72]
    a0016a1c:	f94027e0 	ldr	x0, [sp, #72]
    a0016a20:	f90023e0 	str	x0, [sp, #64]
	return &_kernel.ready_q.runq;
    a0016a24:	d0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0016a28:	91004000 	add	x0, x0, #0x10
    a0016a2c:	f9001fe0 	str	x0, [sp, #56]
    a0016a30:	f94027e0 	ldr	x0, [sp, #72]
    a0016a34:	f9001be0 	str	x0, [sp, #48]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    a0016a38:	f9401fe0 	ldr	x0, [sp, #56]
    a0016a3c:	97fff974 	bl	a001500c <sys_dlist_peek_head>
    a0016a40:	f100001f 	cmp	x0, #0x0
    a0016a44:	54000080 	b.eq	a0016a54 <move_thread_to_end_of_prio_q+0xf0>  // b.none
    a0016a48:	f9401fe0 	ldr	x0, [sp, #56]
    a0016a4c:	97fff970 	bl	a001500c <sys_dlist_peek_head>
    a0016a50:	14000002 	b	a0016a58 <move_thread_to_end_of_prio_q+0xf4>
    a0016a54:	d2800000 	mov	x0, #0x0                   	// #0
    a0016a58:	f90017e0 	str	x0, [sp, #40]
    a0016a5c:	1400001c 	b	a0016acc <move_thread_to_end_of_prio_q+0x168>
		if (z_sched_prio_cmp(thread, t) > 0) {
    a0016a60:	f94017e1 	ldr	x1, [sp, #40]
    a0016a64:	f9401be0 	ldr	x0, [sp, #48]
    a0016a68:	97ffffa6 	bl	a0016900 <z_sched_prio_cmp>
    a0016a6c:	7100001f 	cmp	w0, #0x0
    a0016a70:	540000ad 	b.le	a0016a84 <move_thread_to_end_of_prio_q+0x120>
			sys_dlist_insert(&t->base.qnode_dlist,
    a0016a74:	f94017e0 	ldr	x0, [sp, #40]
    a0016a78:	f9401be1 	ldr	x1, [sp, #48]
    a0016a7c:	97fff9a3 	bl	a0015108 <sys_dlist_insert>
			return;
    a0016a80:	1400001a 	b	a0016ae8 <move_thread_to_end_of_prio_q+0x184>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    a0016a84:	f94017e0 	ldr	x0, [sp, #40]
    a0016a88:	f100001f 	cmp	x0, #0x0
    a0016a8c:	540001c0 	b.eq	a0016ac4 <move_thread_to_end_of_prio_q+0x160>  // b.none
    a0016a90:	f94017e0 	ldr	x0, [sp, #40]
    a0016a94:	aa0003e1 	mov	x1, x0
    a0016a98:	f9401fe0 	ldr	x0, [sp, #56]
    a0016a9c:	97fff978 	bl	a001507c <sys_dlist_peek_next>
    a0016aa0:	f100001f 	cmp	x0, #0x0
    a0016aa4:	540000c0 	b.eq	a0016abc <move_thread_to_end_of_prio_q+0x158>  // b.none
    a0016aa8:	f94017e0 	ldr	x0, [sp, #40]
    a0016aac:	aa0003e1 	mov	x1, x0
    a0016ab0:	f9401fe0 	ldr	x0, [sp, #56]
    a0016ab4:	97fff972 	bl	a001507c <sys_dlist_peek_next>
    a0016ab8:	14000004 	b	a0016ac8 <move_thread_to_end_of_prio_q+0x164>
    a0016abc:	d2800000 	mov	x0, #0x0                   	// #0
    a0016ac0:	14000002 	b	a0016ac8 <move_thread_to_end_of_prio_q+0x164>
    a0016ac4:	d2800000 	mov	x0, #0x0                   	// #0
    a0016ac8:	f90017e0 	str	x0, [sp, #40]
    a0016acc:	f94017e0 	ldr	x0, [sp, #40]
    a0016ad0:	f100001f 	cmp	x0, #0x0
    a0016ad4:	54fffc61 	b.ne	a0016a60 <move_thread_to_end_of_prio_q+0xfc>  // b.any
	sys_dlist_append(pq, &thread->base.qnode_dlist);
    a0016ad8:	f9401be0 	ldr	x0, [sp, #48]
    a0016adc:	aa0003e1 	mov	x1, x0
    a0016ae0:	f9401fe0 	ldr	x0, [sp, #56]
    a0016ae4:	97fff974 	bl	a00150b4 <sys_dlist_append>
}
    a0016ae8:	d503201f 	nop
}
    a0016aec:	d503201f 	nop
		dequeue_thread(thread);
	}
	queue_thread(thread);
	update_cache(thread == _current);
    a0016af0:	b0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0016af4:	913f8000 	add	x0, x0, #0xfe0
    a0016af8:	f9400800 	ldr	x0, [x0, #16]
    a0016afc:	f9400fe1 	ldr	x1, [sp, #24]
    a0016b00:	eb00003f 	cmp	x1, x0
    a0016b04:	1a9f17e0 	cset	w0, eq  // eq = none
    a0016b08:	12001c00 	and	w0, w0, #0xff
    a0016b0c:	940000d4 	bl	a0016e5c <update_cache>
}
    a0016b10:	d503201f 	nop
    a0016b14:	a8c77bfd 	ldp	x29, x30, [sp], #112
    a0016b18:	d65f03c0 	ret

00000000a0016b1c <z_reset_time_slice>:
 */
static struct k_thread *pending_current;
#endif

void z_reset_time_slice(void)
{
    a0016b1c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    a0016b20:	910003fd 	mov	x29, sp
	/* Add the elapsed time since the last announced tick to the
	 * slice count, as we'll see those "expired" ticks arrive in a
	 * FUTURE z_time_slice() call.
	 */
	if (slice_time != 0) {
    a0016b24:	d00003c0 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a0016b28:	91119000 	add	x0, x0, #0x464
    a0016b2c:	b9400000 	ldr	w0, [x0]
    a0016b30:	7100001f 	cmp	w0, #0x0
    a0016b34:	54000200 	b.eq	a0016b74 <z_reset_time_slice+0x58>  // b.none
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
    a0016b38:	97ffe6ab 	bl	a00105e4 <sys_clock_elapsed>
    a0016b3c:	2a0003e1 	mov	w1, w0
    a0016b40:	d00003c0 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a0016b44:	91119000 	add	x0, x0, #0x464
    a0016b48:	b9400000 	ldr	w0, [x0]
    a0016b4c:	0b000020 	add	w0, w1, w0
    a0016b50:	2a0003e1 	mov	w1, w0
    a0016b54:	b0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0016b58:	913f8000 	add	x0, x0, #0xfe0
    a0016b5c:	b9002001 	str	w1, [x0, #32]
		z_set_timeout_expiry(slice_time, false);
    a0016b60:	d00003c0 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a0016b64:	91119000 	add	x0, x0, #0x464
    a0016b68:	b9400000 	ldr	w0, [x0]
    a0016b6c:	52800001 	mov	w1, #0x0                   	// #0
    a0016b70:	94000cd5 	bl	a0019ec4 <z_set_timeout_expiry>
	}
}
    a0016b74:	d503201f 	nop
    a0016b78:	a8c17bfd 	ldp	x29, x30, [sp], #16
    a0016b7c:	d65f03c0 	ret

00000000a0016b80 <k_sched_time_slice_set>:

void k_sched_time_slice_set(int32_t slice, int prio)
{
    a0016b80:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    a0016b84:	910003fd 	mov	x29, sp
    a0016b88:	b9001fe0 	str	w0, [sp, #28]
    a0016b8c:	b9001be1 	str	w1, [sp, #24]
	LOCKED(&sched_spinlock) {
    a0016b90:	b9003bff 	str	wzr, [sp, #56]
    a0016b94:	d0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0016b98:	910a4000 	add	x0, x0, #0x290
    a0016b9c:	f90037e0 	str	x0, [sp, #104]
    a0016ba0:	d53b4220 	mrs	x0, daif
    a0016ba4:	f90033e0 	str	x0, [sp, #96]
    a0016ba8:	f94033e0 	ldr	x0, [sp, #96]
    a0016bac:	d503201f 	nop
	key = read_daif();
    a0016bb0:	b9005fe0 	str	w0, [sp, #92]
	__asm__ volatile ("msr DAIFSet, %0"
    a0016bb4:	d50342df 	msr	daifset, #0x2
}
    a0016bb8:	d503201f 	nop
	return key;
    a0016bbc:	b9405fe0 	ldr	w0, [sp, #92]
	k.key = arch_irq_lock();
    a0016bc0:	b90023e0 	str	w0, [sp, #32]
	return k;
    a0016bc4:	b94023e0 	ldr	w0, [sp, #32]
    a0016bc8:	b90033e0 	str	w0, [sp, #48]
    a0016bcc:	1400002b 	b	a0016c78 <k_sched_time_slice_set+0xf8>
		_current_cpu->slice_ticks = 0;
    a0016bd0:	b0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0016bd4:	913f8000 	add	x0, x0, #0xfe0
    a0016bd8:	b900201f 	str	wzr, [x0, #32]
		slice_time = k_ms_to_ticks_ceil32(slice);
    a0016bdc:	b9401fe0 	ldr	w0, [sp, #28]
    a0016be0:	97fff988 	bl	a0015200 <k_ms_to_ticks_ceil32>
    a0016be4:	2a0003e1 	mov	w1, w0
    a0016be8:	d00003c0 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a0016bec:	91119000 	add	x0, x0, #0x464
    a0016bf0:	b9000001 	str	w1, [x0]
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
    a0016bf4:	b9401fe0 	ldr	w0, [sp, #28]
    a0016bf8:	7100001f 	cmp	w0, #0x0
    a0016bfc:	5400014d 	b.le	a0016c24 <k_sched_time_slice_set+0xa4>
			/* It's not possible to reliably set a 1-tick
			 * timeout if ticks aren't regular.
			 */
			slice_time = MAX(2, slice_time);
    a0016c00:	d00003c0 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a0016c04:	91119000 	add	x0, x0, #0x464
    a0016c08:	b9400000 	ldr	w0, [x0]
    a0016c0c:	52800041 	mov	w1, #0x2                   	// #2
    a0016c10:	7100081f 	cmp	w0, #0x2
    a0016c14:	1a81a001 	csel	w1, w0, w1, ge  // ge = tcont
    a0016c18:	d00003c0 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a0016c1c:	91119000 	add	x0, x0, #0x464
    a0016c20:	b9000001 	str	w1, [x0]
		}
		slice_max_prio = prio;
    a0016c24:	d00003c0 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a0016c28:	9111a000 	add	x0, x0, #0x468
    a0016c2c:	b9401be1 	ldr	w1, [sp, #24]
    a0016c30:	b9000001 	str	w1, [x0]
		z_reset_time_slice();
    a0016c34:	97ffffba 	bl	a0016b1c <z_reset_time_slice>
    a0016c38:	d0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0016c3c:	910a4000 	add	x0, x0, #0x290
    a0016c40:	f9002be0 	str	x0, [sp, #80]
    a0016c44:	b94033e0 	ldr	w0, [sp, #48]
    a0016c48:	b9002be0 	str	w0, [sp, #40]
	arch_irq_unlock(key.key);
    a0016c4c:	b9402be0 	ldr	w0, [sp, #40]
    a0016c50:	b9004fe0 	str	w0, [sp, #76]
	write_daif(key);
    a0016c54:	b9404fe0 	ldr	w0, [sp, #76]
    a0016c58:	f90023e0 	str	x0, [sp, #64]
MAKE_REG_HELPER(daif)
    a0016c5c:	f94023e0 	ldr	x0, [sp, #64]
    a0016c60:	d51b4220 	msr	daif, x0
    a0016c64:	d503201f 	nop
}
    a0016c68:	d503201f 	nop
}
    a0016c6c:	d503201f 	nop
	LOCKED(&sched_spinlock) {
    a0016c70:	52800020 	mov	w0, #0x1                   	// #1
    a0016c74:	b9003be0 	str	w0, [sp, #56]
    a0016c78:	b9403be0 	ldr	w0, [sp, #56]
    a0016c7c:	7100001f 	cmp	w0, #0x0
    a0016c80:	54fffa80 	b.eq	a0016bd0 <k_sched_time_slice_set+0x50>  // b.none
	}
}
    a0016c84:	d503201f 	nop
    a0016c88:	d503201f 	nop
    a0016c8c:	a8c77bfd 	ldp	x29, x30, [sp], #112
    a0016c90:	d65f03c0 	ret

00000000a0016c94 <sliceable>:

static inline int sliceable(struct k_thread *thread)
{
    a0016c94:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0016c98:	910003fd 	mov	x29, sp
    a0016c9c:	f9000fe0 	str	x0, [sp, #24]
	return is_preempt(thread)
    a0016ca0:	f9400fe0 	ldr	x0, [sp, #24]
    a0016ca4:	97ffff09 	bl	a00168c8 <is_preempt>
		&& !z_is_thread_prevented_from_running(thread)
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
		&& !z_is_idle_thread_object(thread);
    a0016ca8:	7100001f 	cmp	w0, #0x0
    a0016cac:	540003e0 	b.eq	a0016d28 <sliceable+0x94>  // b.none
		&& !z_is_thread_prevented_from_running(thread)
    a0016cb0:	f9400fe0 	ldr	x0, [sp, #24]
    a0016cb4:	97fffd11 	bl	a00160f8 <z_is_thread_prevented_from_running>
    a0016cb8:	12001c00 	and	w0, w0, #0xff
    a0016cbc:	52000000 	eor	w0, w0, #0x1
    a0016cc0:	12001c00 	and	w0, w0, #0xff
    a0016cc4:	7100001f 	cmp	w0, #0x0
    a0016cc8:	54000300 	b.eq	a0016d28 <sliceable+0x94>  // b.none
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
    a0016ccc:	f9400fe0 	ldr	x0, [sp, #24]
    a0016cd0:	39c06800 	ldrsb	w0, [x0, #26]
    a0016cd4:	2a0003e2 	mov	w2, w0
    a0016cd8:	d00003c0 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a0016cdc:	9111a000 	add	x0, x0, #0x468
    a0016ce0:	b9400000 	ldr	w0, [x0]
    a0016ce4:	2a0003e1 	mov	w1, w0
    a0016ce8:	2a0203e0 	mov	w0, w2
    a0016cec:	97fffdb7 	bl	a00163c8 <z_is_prio_higher>
    a0016cf0:	12001c00 	and	w0, w0, #0xff
    a0016cf4:	52000000 	eor	w0, w0, #0x1
    a0016cf8:	12001c00 	and	w0, w0, #0xff
    a0016cfc:	7100001f 	cmp	w0, #0x0
    a0016d00:	54000140 	b.eq	a0016d28 <sliceable+0x94>  // b.none
		&& !z_is_idle_thread_object(thread);
    a0016d04:	f9400fe0 	ldr	x0, [sp, #24]
    a0016d08:	97fffcdc 	bl	a0016078 <z_is_idle_thread_object>
    a0016d0c:	12001c00 	and	w0, w0, #0xff
    a0016d10:	52000000 	eor	w0, w0, #0x1
    a0016d14:	12001c00 	and	w0, w0, #0xff
    a0016d18:	7100001f 	cmp	w0, #0x0
    a0016d1c:	54000060 	b.eq	a0016d28 <sliceable+0x94>  // b.none
    a0016d20:	52800020 	mov	w0, #0x1                   	// #1
    a0016d24:	14000002 	b	a0016d2c <sliceable+0x98>
    a0016d28:	52800000 	mov	w0, #0x0                   	// #0
}
    a0016d2c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0016d30:	d65f03c0 	ret

00000000a0016d34 <z_time_slice>:

/* Called out of each timer interrupt */
void z_time_slice(int ticks)
{
    a0016d34:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    a0016d38:	910003fd 	mov	x29, sp
    a0016d3c:	b9001fe0 	str	w0, [sp, #28]
    a0016d40:	d0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0016d44:	910a4000 	add	x0, x0, #0x290
    a0016d48:	f90037e0 	str	x0, [sp, #104]
    a0016d4c:	d53b4220 	mrs	x0, daif
    a0016d50:	f90033e0 	str	x0, [sp, #96]
    a0016d54:	f94033e0 	ldr	x0, [sp, #96]
    a0016d58:	d503201f 	nop
	key = read_daif();
    a0016d5c:	b9005fe0 	str	w0, [sp, #92]
	__asm__ volatile ("msr DAIFSet, %0"
    a0016d60:	d50342df 	msr	daifset, #0x2
}
    a0016d64:	d503201f 	nop
	return key;
    a0016d68:	b9405fe0 	ldr	w0, [sp, #92]
	k.key = arch_irq_lock();
    a0016d6c:	b9002be0 	str	w0, [sp, #40]
	return k;
    a0016d70:	b9402be0 	ldr	w0, [sp, #40]
    a0016d74:	b9003be0 	str	w0, [sp, #56]
		return;
	}
	pending_current = NULL;
#endif

	if (slice_time && sliceable(_current)) {
    a0016d78:	d00003c0 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a0016d7c:	91119000 	add	x0, x0, #0x464
    a0016d80:	b9400000 	ldr	w0, [x0]
    a0016d84:	7100001f 	cmp	w0, #0x0
    a0016d88:	54000380 	b.eq	a0016df8 <z_time_slice+0xc4>  // b.none
    a0016d8c:	b0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0016d90:	913f8000 	add	x0, x0, #0xfe0
    a0016d94:	f9400800 	ldr	x0, [x0, #16]
    a0016d98:	97ffffbf 	bl	a0016c94 <sliceable>
    a0016d9c:	7100001f 	cmp	w0, #0x0
    a0016da0:	540002c0 	b.eq	a0016df8 <z_time_slice+0xc4>  // b.none
		if (ticks >= _current_cpu->slice_ticks) {
    a0016da4:	b0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0016da8:	913f8000 	add	x0, x0, #0xfe0
    a0016dac:	b9402000 	ldr	w0, [x0, #32]
    a0016db0:	b9401fe1 	ldr	w1, [sp, #28]
    a0016db4:	6b00003f 	cmp	w1, w0
    a0016db8:	540000eb 	b.lt	a0016dd4 <z_time_slice+0xa0>  // b.tstop
			move_thread_to_end_of_prio_q(_current);
    a0016dbc:	b0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0016dc0:	913f8000 	add	x0, x0, #0xfe0
    a0016dc4:	f9400800 	ldr	x0, [x0, #16]
    a0016dc8:	97fffee7 	bl	a0016964 <move_thread_to_end_of_prio_q>
			z_reset_time_slice();
    a0016dcc:	97ffff54 	bl	a0016b1c <z_reset_time_slice>
		if (ticks >= _current_cpu->slice_ticks) {
    a0016dd0:	1400000d 	b	a0016e04 <z_time_slice+0xd0>
		} else {
			_current_cpu->slice_ticks -= ticks;
    a0016dd4:	b0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0016dd8:	913f8000 	add	x0, x0, #0xfe0
    a0016ddc:	b9402001 	ldr	w1, [x0, #32]
    a0016de0:	b9401fe0 	ldr	w0, [sp, #28]
    a0016de4:	4b000021 	sub	w1, w1, w0
    a0016de8:	b0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0016dec:	913f8000 	add	x0, x0, #0xfe0
    a0016df0:	b9002001 	str	w1, [x0, #32]
		if (ticks >= _current_cpu->slice_ticks) {
    a0016df4:	14000004 	b	a0016e04 <z_time_slice+0xd0>
		}
	} else {
		_current_cpu->slice_ticks = 0;
    a0016df8:	b0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0016dfc:	913f8000 	add	x0, x0, #0xfe0
    a0016e00:	b900201f 	str	wzr, [x0, #32]
    a0016e04:	d0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0016e08:	910a4000 	add	x0, x0, #0x290
    a0016e0c:	f9002be0 	str	x0, [sp, #80]
    a0016e10:	b9403be0 	ldr	w0, [sp, #56]
    a0016e14:	b90033e0 	str	w0, [sp, #48]
	arch_irq_unlock(key.key);
    a0016e18:	b94033e0 	ldr	w0, [sp, #48]
    a0016e1c:	b9004fe0 	str	w0, [sp, #76]
	write_daif(key);
    a0016e20:	b9404fe0 	ldr	w0, [sp, #76]
    a0016e24:	f90023e0 	str	x0, [sp, #64]
MAKE_REG_HELPER(daif)
    a0016e28:	f94023e0 	ldr	x0, [sp, #64]
    a0016e2c:	d51b4220 	msr	daif, x0
    a0016e30:	d503201f 	nop
}
    a0016e34:	d503201f 	nop
}
    a0016e38:	d503201f 	nop
	}
	k_spin_unlock(&sched_spinlock, key);
}
    a0016e3c:	d503201f 	nop
    a0016e40:	a8c77bfd 	ldp	x29, x30, [sp], #112
    a0016e44:	d65f03c0 	ret

00000000a0016e48 <update_metairq_preempt>:
/* Track cooperative threads preempted by metairqs so we can return to
 * them specifically.  Called at the moment a new thread has been
 * selected to run.
 */
static void update_metairq_preempt(struct k_thread *thread)
{
    a0016e48:	d10043ff 	sub	sp, sp, #0x10
    a0016e4c:	f90007e0 	str	x0, [sp, #8]
	} else if (!is_metairq(thread) && !z_is_idle_thread_object(thread)) {
		/* Returning from existing preemption */
		_current_cpu->metairq_preempted = NULL;
	}
#endif
}
    a0016e50:	d503201f 	nop
    a0016e54:	910043ff 	add	sp, sp, #0x10
    a0016e58:	d65f03c0 	ret

00000000a0016e5c <update_cache>:

static void update_cache(int preempt_ok)
{
    a0016e5c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    a0016e60:	910003fd 	mov	x29, sp
    a0016e64:	b9001fe0 	str	w0, [sp, #28]
	return &_kernel.ready_q.runq;
    a0016e68:	d0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0016e6c:	91004000 	add	x0, x0, #0x10
	return _priq_run_best(curr_cpu_runq());
    a0016e70:	9400056a 	bl	a0018418 <z_priq_dumb_best>
	struct k_thread *thread = runq_best();
    a0016e74:	f90013e0 	str	x0, [sp, #32]
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
    a0016e78:	f94013e0 	ldr	x0, [sp, #32]
    a0016e7c:	f100001f 	cmp	x0, #0x0
    a0016e80:	540000a1 	b.ne	a0016e94 <update_cache+0x38>  // b.any
    a0016e84:	b0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0016e88:	913f8000 	add	x0, x0, #0xfe0
    a0016e8c:	f9400c00 	ldr	x0, [x0, #24]
    a0016e90:	14000002 	b	a0016e98 <update_cache+0x3c>
    a0016e94:	f94013e0 	ldr	x0, [sp, #32]
#ifndef CONFIG_SMP
	struct k_thread *thread = next_up();
    a0016e98:	f9001fe0 	str	x0, [sp, #56]
    a0016e9c:	f9401fe0 	ldr	x0, [sp, #56]
    a0016ea0:	f9001be0 	str	x0, [sp, #48]
    a0016ea4:	b9401fe0 	ldr	w0, [sp, #28]
    a0016ea8:	b9002fe0 	str	w0, [sp, #44]
	if (preempt_ok != 0) {
    a0016eac:	b9402fe0 	ldr	w0, [sp, #44]
    a0016eb0:	7100001f 	cmp	w0, #0x0
    a0016eb4:	54000060 	b.eq	a0016ec0 <update_cache+0x64>  // b.none
		return true;
    a0016eb8:	52800020 	mov	w0, #0x1                   	// #1
    a0016ebc:	14000017 	b	a0016f18 <update_cache+0xbc>
	if (z_is_thread_prevented_from_running(_current)) {
    a0016ec0:	b0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0016ec4:	913f8000 	add	x0, x0, #0xfe0
    a0016ec8:	f9400800 	ldr	x0, [x0, #16]
    a0016ecc:	97fffc8b 	bl	a00160f8 <z_is_thread_prevented_from_running>
    a0016ed0:	12001c00 	and	w0, w0, #0xff
    a0016ed4:	7100001f 	cmp	w0, #0x0
    a0016ed8:	54000060 	b.eq	a0016ee4 <update_cache+0x88>  // b.none
		return true;
    a0016edc:	52800020 	mov	w0, #0x1                   	// #1
    a0016ee0:	1400000e 	b	a0016f18 <update_cache+0xbc>
	if (is_preempt(_current) || is_metairq(thread)) {
    a0016ee4:	b0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0016ee8:	913f8000 	add	x0, x0, #0xfe0
    a0016eec:	f9400800 	ldr	x0, [x0, #16]
    a0016ef0:	97fffe76 	bl	a00168c8 <is_preempt>
    a0016ef4:	7100001f 	cmp	w0, #0x0
    a0016ef8:	540000a1 	b.ne	a0016f0c <update_cache+0xb0>  // b.any
    a0016efc:	f9401be0 	ldr	x0, [sp, #48]
    a0016f00:	97fffe7b 	bl	a00168ec <is_metairq>
    a0016f04:	7100001f 	cmp	w0, #0x0
    a0016f08:	54000060 	b.eq	a0016f14 <update_cache+0xb8>  // b.none
		return true;
    a0016f0c:	52800020 	mov	w0, #0x1                   	// #1
    a0016f10:	14000002 	b	a0016f18 <update_cache+0xbc>
	return false;
    a0016f14:	52800000 	mov	w0, #0x0                   	// #0

	if (should_preempt(thread, preempt_ok)) {
    a0016f18:	7100001f 	cmp	w0, #0x0
    a0016f1c:	540001e0 	b.eq	a0016f58 <update_cache+0xfc>  // b.none
#ifdef CONFIG_TIMESLICING
		if (thread != _current) {
    a0016f20:	b0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0016f24:	913f8000 	add	x0, x0, #0xfe0
    a0016f28:	f9400800 	ldr	x0, [x0, #16]
    a0016f2c:	f9401fe1 	ldr	x1, [sp, #56]
    a0016f30:	eb00003f 	cmp	x1, x0
    a0016f34:	54000040 	b.eq	a0016f3c <update_cache+0xe0>  // b.none
			z_reset_time_slice();
    a0016f38:	97fffef9 	bl	a0016b1c <z_reset_time_slice>
		}
#endif
		update_metairq_preempt(thread);
    a0016f3c:	f9401fe0 	ldr	x0, [sp, #56]
    a0016f40:	97ffffc2 	bl	a0016e48 <update_metairq_preempt>
		_kernel.ready_q.cache = thread;
    a0016f44:	b0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0016f48:	913f8000 	add	x0, x0, #0xfe0
    a0016f4c:	f9401fe1 	ldr	x1, [sp, #56]
    a0016f50:	f9001401 	str	x1, [x0, #40]
	 * thread because if the thread gets preempted for whatever
	 * reason the scheduler will make the same decision anyway.
	 */
	_current_cpu->swap_ok = preempt_ok;
#endif
}
    a0016f54:	14000007 	b	a0016f70 <update_cache+0x114>
		_kernel.ready_q.cache = _current;
    a0016f58:	b0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0016f5c:	913f8000 	add	x0, x0, #0xfe0
    a0016f60:	f9400801 	ldr	x1, [x0, #16]
    a0016f64:	b0000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0016f68:	913f8000 	add	x0, x0, #0xfe0
    a0016f6c:	f9001401 	str	x1, [x0, #40]
}
    a0016f70:	d503201f 	nop
    a0016f74:	a8c47bfd 	ldp	x29, x30, [sp], #64
    a0016f78:	d65f03c0 	ret

00000000a0016f7c <thread_active_elsewhere>:

static bool thread_active_elsewhere(struct k_thread *thread)
{
    a0016f7c:	d10043ff 	sub	sp, sp, #0x10
    a0016f80:	f90007e0 	str	x0, [sp, #8]
		    (_kernel.cpus[i].current == thread)) {
			return true;
		}
	}
#endif
	return false;
    a0016f84:	52800000 	mov	w0, #0x0                   	// #0
}
    a0016f88:	910043ff 	add	sp, sp, #0x10
    a0016f8c:	d65f03c0 	ret

00000000a0016f90 <ready_thread>:

static void ready_thread(struct k_thread *thread)
{
    a0016f90:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a0016f94:	910003fd 	mov	x29, sp
    a0016f98:	f9000fe0 	str	x0, [sp, #24]
#endif

	/* If thread is queued already, do not try and added it to the
	 * run queue again
	 */
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
    a0016f9c:	f9400fe0 	ldr	x0, [sp, #24]
    a0016fa0:	97fffca2 	bl	a0016228 <z_is_thread_queued>
    a0016fa4:	12001c00 	and	w0, w0, #0xff
    a0016fa8:	52000000 	eor	w0, w0, #0x1
    a0016fac:	12001c00 	and	w0, w0, #0xff
    a0016fb0:	7100001f 	cmp	w0, #0x0
    a0016fb4:	54000980 	b.eq	a00170e4 <ready_thread+0x154>  // b.none
    a0016fb8:	f9400fe0 	ldr	x0, [sp, #24]
    a0016fbc:	97fffc6b 	bl	a0016168 <z_is_thread_ready>
    a0016fc0:	12001c00 	and	w0, w0, #0xff
    a0016fc4:	7100001f 	cmp	w0, #0x0
    a0016fc8:	540008e0 	b.eq	a00170e4 <ready_thread+0x154>  // b.none
    a0016fcc:	f9400fe0 	ldr	x0, [sp, #24]
    a0016fd0:	f90027e0 	str	x0, [sp, #72]
	thread->base.thread_state |= _THREAD_QUEUED;
    a0016fd4:	f94027e0 	ldr	x0, [sp, #72]
    a0016fd8:	39406400 	ldrb	w0, [x0, #25]
    a0016fdc:	32196000 	orr	w0, w0, #0xffffff80
    a0016fe0:	12001c01 	and	w1, w0, #0xff
    a0016fe4:	f94027e0 	ldr	x0, [sp, #72]
    a0016fe8:	39006401 	strb	w1, [x0, #25]
	if (should_queue_thread(thread)) {
    a0016fec:	f94027e0 	ldr	x0, [sp, #72]
    a0016ff0:	97fffe58 	bl	a0016950 <should_queue_thread>
    a0016ff4:	12001c00 	and	w0, w0, #0xff
    a0016ff8:	7100001f 	cmp	w0, #0x0
    a0016ffc:	540006e0 	b.eq	a00170d8 <ready_thread+0x148>  // b.none
    a0017000:	f94027e0 	ldr	x0, [sp, #72]
    a0017004:	f90023e0 	str	x0, [sp, #64]
    a0017008:	f94023e0 	ldr	x0, [sp, #64]
    a001700c:	f9001fe0 	str	x0, [sp, #56]
	return &_kernel.ready_q.runq;
    a0017010:	b0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0017014:	91004000 	add	x0, x0, #0x10
    a0017018:	f9001be0 	str	x0, [sp, #48]
    a001701c:	f94023e0 	ldr	x0, [sp, #64]
    a0017020:	f90017e0 	str	x0, [sp, #40]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    a0017024:	f9401be0 	ldr	x0, [sp, #48]
    a0017028:	97fff7f9 	bl	a001500c <sys_dlist_peek_head>
    a001702c:	f100001f 	cmp	x0, #0x0
    a0017030:	54000080 	b.eq	a0017040 <ready_thread+0xb0>  // b.none
    a0017034:	f9401be0 	ldr	x0, [sp, #48]
    a0017038:	97fff7f5 	bl	a001500c <sys_dlist_peek_head>
    a001703c:	14000002 	b	a0017044 <ready_thread+0xb4>
    a0017040:	d2800000 	mov	x0, #0x0                   	// #0
    a0017044:	f90013e0 	str	x0, [sp, #32]
    a0017048:	1400001c 	b	a00170b8 <ready_thread+0x128>
		if (z_sched_prio_cmp(thread, t) > 0) {
    a001704c:	f94013e1 	ldr	x1, [sp, #32]
    a0017050:	f94017e0 	ldr	x0, [sp, #40]
    a0017054:	97fffe2b 	bl	a0016900 <z_sched_prio_cmp>
    a0017058:	7100001f 	cmp	w0, #0x0
    a001705c:	540000ad 	b.le	a0017070 <ready_thread+0xe0>
			sys_dlist_insert(&t->base.qnode_dlist,
    a0017060:	f94013e0 	ldr	x0, [sp, #32]
    a0017064:	f94017e1 	ldr	x1, [sp, #40]
    a0017068:	97fff828 	bl	a0015108 <sys_dlist_insert>
			return;
    a001706c:	1400001a 	b	a00170d4 <ready_thread+0x144>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    a0017070:	f94013e0 	ldr	x0, [sp, #32]
    a0017074:	f100001f 	cmp	x0, #0x0
    a0017078:	540001c0 	b.eq	a00170b0 <ready_thread+0x120>  // b.none
    a001707c:	f94013e0 	ldr	x0, [sp, #32]
    a0017080:	aa0003e1 	mov	x1, x0
    a0017084:	f9401be0 	ldr	x0, [sp, #48]
    a0017088:	97fff7fd 	bl	a001507c <sys_dlist_peek_next>
    a001708c:	f100001f 	cmp	x0, #0x0
    a0017090:	540000c0 	b.eq	a00170a8 <ready_thread+0x118>  // b.none
    a0017094:	f94013e0 	ldr	x0, [sp, #32]
    a0017098:	aa0003e1 	mov	x1, x0
    a001709c:	f9401be0 	ldr	x0, [sp, #48]
    a00170a0:	97fff7f7 	bl	a001507c <sys_dlist_peek_next>
    a00170a4:	14000004 	b	a00170b4 <ready_thread+0x124>
    a00170a8:	d2800000 	mov	x0, #0x0                   	// #0
    a00170ac:	14000002 	b	a00170b4 <ready_thread+0x124>
    a00170b0:	d2800000 	mov	x0, #0x0                   	// #0
    a00170b4:	f90013e0 	str	x0, [sp, #32]
    a00170b8:	f94013e0 	ldr	x0, [sp, #32]
    a00170bc:	f100001f 	cmp	x0, #0x0
    a00170c0:	54fffc61 	b.ne	a001704c <ready_thread+0xbc>  // b.any
	sys_dlist_append(pq, &thread->base.qnode_dlist);
    a00170c4:	f94017e0 	ldr	x0, [sp, #40]
    a00170c8:	aa0003e1 	mov	x1, x0
    a00170cc:	f9401be0 	ldr	x0, [sp, #48]
    a00170d0:	97fff7f9 	bl	a00150b4 <sys_dlist_append>
}
    a00170d4:	d503201f 	nop
}
    a00170d8:	d503201f 	nop
		SYS_PORT_TRACING_OBJ_FUNC(k_thread, sched_ready, thread);

		queue_thread(thread);
		update_cache(0);
    a00170dc:	52800000 	mov	w0, #0x0                   	// #0
    a00170e0:	97ffff5f 	bl	a0016e5c <update_cache>
#if defined(CONFIG_SMP) &&  defined(CONFIG_SCHED_IPI_SUPPORTED)
		arch_sched_ipi();
#endif
	}
}
    a00170e4:	d503201f 	nop
    a00170e8:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a00170ec:	d65f03c0 	ret

00000000a00170f0 <z_ready_thread>:

void z_ready_thread(struct k_thread *thread)
{
    a00170f0:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    a00170f4:	910003fd 	mov	x29, sp
    a00170f8:	f9000fe0 	str	x0, [sp, #24]
	LOCKED(&sched_spinlock) {
    a00170fc:	b9003bff 	str	wzr, [sp, #56]
    a0017100:	b0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0017104:	910a4000 	add	x0, x0, #0x290
    a0017108:	f90037e0 	str	x0, [sp, #104]
    a001710c:	d53b4220 	mrs	x0, daif
    a0017110:	f90033e0 	str	x0, [sp, #96]
    a0017114:	f94033e0 	ldr	x0, [sp, #96]
    a0017118:	d503201f 	nop
	key = read_daif();
    a001711c:	b9005fe0 	str	w0, [sp, #92]
	__asm__ volatile ("msr DAIFSet, %0"
    a0017120:	d50342df 	msr	daifset, #0x2
}
    a0017124:	d503201f 	nop
	return key;
    a0017128:	b9405fe0 	ldr	w0, [sp, #92]
	k.key = arch_irq_lock();
    a001712c:	b90023e0 	str	w0, [sp, #32]
	return k;
    a0017130:	b94023e0 	ldr	w0, [sp, #32]
    a0017134:	b90033e0 	str	w0, [sp, #48]
    a0017138:	1400001a 	b	a00171a0 <z_ready_thread+0xb0>
		if (!thread_active_elsewhere(thread)) {
    a001713c:	f9400fe0 	ldr	x0, [sp, #24]
    a0017140:	97ffff8f 	bl	a0016f7c <thread_active_elsewhere>
    a0017144:	12001c00 	and	w0, w0, #0xff
    a0017148:	52000000 	eor	w0, w0, #0x1
    a001714c:	12001c00 	and	w0, w0, #0xff
    a0017150:	7100001f 	cmp	w0, #0x0
    a0017154:	54000060 	b.eq	a0017160 <z_ready_thread+0x70>  // b.none
			ready_thread(thread);
    a0017158:	f9400fe0 	ldr	x0, [sp, #24]
    a001715c:	97ffff8d 	bl	a0016f90 <ready_thread>
    a0017160:	b0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0017164:	910a4000 	add	x0, x0, #0x290
    a0017168:	f9002be0 	str	x0, [sp, #80]
    a001716c:	b94033e0 	ldr	w0, [sp, #48]
    a0017170:	b9002be0 	str	w0, [sp, #40]
	arch_irq_unlock(key.key);
    a0017174:	b9402be0 	ldr	w0, [sp, #40]
    a0017178:	b9004fe0 	str	w0, [sp, #76]
	write_daif(key);
    a001717c:	b9404fe0 	ldr	w0, [sp, #76]
    a0017180:	f90023e0 	str	x0, [sp, #64]
MAKE_REG_HELPER(daif)
    a0017184:	f94023e0 	ldr	x0, [sp, #64]
    a0017188:	d51b4220 	msr	daif, x0
    a001718c:	d503201f 	nop
}
    a0017190:	d503201f 	nop
}
    a0017194:	d503201f 	nop
	LOCKED(&sched_spinlock) {
    a0017198:	52800020 	mov	w0, #0x1                   	// #1
    a001719c:	b9003be0 	str	w0, [sp, #56]
    a00171a0:	b9403be0 	ldr	w0, [sp, #56]
    a00171a4:	7100001f 	cmp	w0, #0x0
    a00171a8:	54fffca0 	b.eq	a001713c <z_ready_thread+0x4c>  // b.none
		}
	}
}
    a00171ac:	d503201f 	nop
    a00171b0:	d503201f 	nop
    a00171b4:	a8c77bfd 	ldp	x29, x30, [sp], #112
    a00171b8:	d65f03c0 	ret

00000000a00171bc <z_sched_start>:
		move_thread_to_end_of_prio_q(thread);
	}
}

void z_sched_start(struct k_thread *thread)
{
    a00171bc:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    a00171c0:	910003fd 	mov	x29, sp
    a00171c4:	f9000fe0 	str	x0, [sp, #24]
    a00171c8:	b0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a00171cc:	910a4000 	add	x0, x0, #0x290
    a00171d0:	f90037e0 	str	x0, [sp, #104]
    a00171d4:	d53b4220 	mrs	x0, daif
    a00171d8:	f90033e0 	str	x0, [sp, #96]
    a00171dc:	f94033e0 	ldr	x0, [sp, #96]
    a00171e0:	d503201f 	nop
	key = read_daif();
    a00171e4:	b9005fe0 	str	w0, [sp, #92]
	__asm__ volatile ("msr DAIFSet, %0"
    a00171e8:	d50342df 	msr	daifset, #0x2
}
    a00171ec:	d503201f 	nop
	return key;
    a00171f0:	b9405fe0 	ldr	w0, [sp, #92]
	k.key = arch_irq_lock();
    a00171f4:	b9002be0 	str	w0, [sp, #40]
	return k;
    a00171f8:	b9402be0 	ldr	w0, [sp, #40]
    a00171fc:	b9003be0 	str	w0, [sp, #56]
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if (z_has_thread_started(thread)) {
    a0017200:	f9400fe0 	ldr	x0, [sp, #24]
    a0017204:	97fffbf1 	bl	a00161c8 <z_has_thread_started>
    a0017208:	12001c00 	and	w0, w0, #0xff
    a001720c:	7100001f 	cmp	w0, #0x0
    a0017210:	540001e0 	b.eq	a001724c <z_sched_start+0x90>  // b.none
    a0017214:	b0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0017218:	910a4000 	add	x0, x0, #0x290
    a001721c:	f9002be0 	str	x0, [sp, #80]
    a0017220:	b9403be0 	ldr	w0, [sp, #56]
    a0017224:	b90033e0 	str	w0, [sp, #48]
	arch_irq_unlock(key.key);
    a0017228:	b94033e0 	ldr	w0, [sp, #48]
    a001722c:	b9004fe0 	str	w0, [sp, #76]
	write_daif(key);
    a0017230:	b9404fe0 	ldr	w0, [sp, #76]
    a0017234:	f90023e0 	str	x0, [sp, #64]
MAKE_REG_HELPER(daif)
    a0017238:	f94023e0 	ldr	x0, [sp, #64]
    a001723c:	d51b4220 	msr	daif, x0
    a0017240:	d503201f 	nop
}
    a0017244:	d503201f 	nop
}
    a0017248:	14000009 	b	a001726c <z_sched_start+0xb0>
		k_spin_unlock(&sched_spinlock, key);
		return;
	}

	z_mark_thread_as_started(thread);
    a001724c:	f9400fe0 	ldr	x0, [sp, #24]
    a0017250:	97fffc15 	bl	a00162a4 <z_mark_thread_as_started>
	ready_thread(thread);
    a0017254:	f9400fe0 	ldr	x0, [sp, #24]
    a0017258:	97ffff4e 	bl	a0016f90 <ready_thread>
	z_reschedule(&sched_spinlock, key);
    a001725c:	b9403be1 	ldr	w1, [sp, #56]
    a0017260:	b0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0017264:	910a4000 	add	x0, x0, #0x290
    a0017268:	940003ad 	bl	a001811c <z_reschedule>
}
    a001726c:	a8c77bfd 	ldp	x29, x30, [sp], #112
    a0017270:	d65f03c0 	ret

00000000a0017274 <z_impl_k_thread_suspend>:

void z_impl_k_thread_suspend(struct k_thread *thread)
{
    a0017274:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
    a0017278:	910003fd 	mov	x29, sp
    a001727c:	f9000fe0 	str	x0, [sp, #24]
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_thread, suspend, thread);

	(void)z_abort_thread_timeout(thread);
    a0017280:	f9400fe0 	ldr	x0, [sp, #24]
    a0017284:	97fffb5d 	bl	a0015ff8 <z_abort_thread_timeout>

	LOCKED(&sched_spinlock) {
    a0017288:	b90043ff 	str	wzr, [sp, #64]
    a001728c:	b0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0017290:	910a4000 	add	x0, x0, #0x290
    a0017294:	f90047e0 	str	x0, [sp, #136]
    a0017298:	d53b4220 	mrs	x0, daif
    a001729c:	f90043e0 	str	x0, [sp, #128]
    a00172a0:	f94043e0 	ldr	x0, [sp, #128]
    a00172a4:	d503201f 	nop
	key = read_daif();
    a00172a8:	b9007fe0 	str	w0, [sp, #124]
	__asm__ volatile ("msr DAIFSet, %0"
    a00172ac:	d50342df 	msr	daifset, #0x2
}
    a00172b0:	d503201f 	nop
	return key;
    a00172b4:	b9407fe0 	ldr	w0, [sp, #124]
	k.key = arch_irq_lock();
    a00172b8:	b9002be0 	str	w0, [sp, #40]
	return k;
    a00172bc:	b9402be0 	ldr	w0, [sp, #40]
    a00172c0:	b9003be0 	str	w0, [sp, #56]
    a00172c4:	14000037 	b	a00173a0 <z_impl_k_thread_suspend+0x12c>
		if (z_is_thread_queued(thread)) {
    a00172c8:	f9400fe0 	ldr	x0, [sp, #24]
    a00172cc:	97fffbd7 	bl	a0016228 <z_is_thread_queued>
    a00172d0:	12001c00 	and	w0, w0, #0xff
    a00172d4:	7100001f 	cmp	w0, #0x0
    a00172d8:	54000300 	b.eq	a0017338 <z_impl_k_thread_suspend+0xc4>  // b.none
    a00172dc:	f9400fe0 	ldr	x0, [sp, #24]
    a00172e0:	f9003be0 	str	x0, [sp, #112]
	thread->base.thread_state &= ~_THREAD_QUEUED;
    a00172e4:	f9403be0 	ldr	x0, [sp, #112]
    a00172e8:	39406400 	ldrb	w0, [x0, #25]
    a00172ec:	12001800 	and	w0, w0, #0x7f
    a00172f0:	12001c01 	and	w1, w0, #0xff
    a00172f4:	f9403be0 	ldr	x0, [sp, #112]
    a00172f8:	39006401 	strb	w1, [x0, #25]
	if (should_queue_thread(thread)) {
    a00172fc:	f9403be0 	ldr	x0, [sp, #112]
    a0017300:	97fffd94 	bl	a0016950 <should_queue_thread>
    a0017304:	12001c00 	and	w0, w0, #0xff
    a0017308:	7100001f 	cmp	w0, #0x0
    a001730c:	54000140 	b.eq	a0017334 <z_impl_k_thread_suspend+0xc0>  // b.none
    a0017310:	f9403be0 	ldr	x0, [sp, #112]
    a0017314:	f90037e0 	str	x0, [sp, #104]
    a0017318:	f94037e0 	ldr	x0, [sp, #104]
    a001731c:	f90033e0 	str	x0, [sp, #96]
	return &_kernel.ready_q.runq;
    a0017320:	b0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0017324:	91004000 	add	x0, x0, #0x10
	_priq_run_remove(thread_runq(thread), thread);
    a0017328:	f94037e1 	ldr	x1, [sp, #104]
    a001732c:	94000432 	bl	a00183f4 <z_priq_dumb_remove>
}
    a0017330:	d503201f 	nop
}
    a0017334:	d503201f 	nop
			dequeue_thread(thread);
		}
		z_mark_thread_as_suspended(thread);
    a0017338:	f9400fe0 	ldr	x0, [sp, #24]
    a001733c:	97fffbc4 	bl	a001624c <z_mark_thread_as_suspended>
		update_cache(thread == _current);
    a0017340:	90000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0017344:	913f8000 	add	x0, x0, #0xfe0
    a0017348:	f9400800 	ldr	x0, [x0, #16]
    a001734c:	f9400fe1 	ldr	x1, [sp, #24]
    a0017350:	eb00003f 	cmp	x1, x0
    a0017354:	1a9f17e0 	cset	w0, eq  // eq = none
    a0017358:	12001c00 	and	w0, w0, #0xff
    a001735c:	97fffec0 	bl	a0016e5c <update_cache>
    a0017360:	b0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0017364:	910a4000 	add	x0, x0, #0x290
    a0017368:	f9002fe0 	str	x0, [sp, #88]
    a001736c:	b9403be0 	ldr	w0, [sp, #56]
    a0017370:	b90033e0 	str	w0, [sp, #48]
	arch_irq_unlock(key.key);
    a0017374:	b94033e0 	ldr	w0, [sp, #48]
    a0017378:	b90057e0 	str	w0, [sp, #84]
	write_daif(key);
    a001737c:	b94057e0 	ldr	w0, [sp, #84]
    a0017380:	f90027e0 	str	x0, [sp, #72]
MAKE_REG_HELPER(daif)
    a0017384:	f94027e0 	ldr	x0, [sp, #72]
    a0017388:	d51b4220 	msr	daif, x0
    a001738c:	d503201f 	nop
}
    a0017390:	d503201f 	nop
}
    a0017394:	d503201f 	nop
	LOCKED(&sched_spinlock) {
    a0017398:	52800020 	mov	w0, #0x1                   	// #1
    a001739c:	b90043e0 	str	w0, [sp, #64]
    a00173a0:	b94043e0 	ldr	w0, [sp, #64]
    a00173a4:	7100001f 	cmp	w0, #0x0
    a00173a8:	54fff900 	b.eq	a00172c8 <z_impl_k_thread_suspend+0x54>  // b.none
	}

	if (thread == _current) {
    a00173ac:	90000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00173b0:	913f8000 	add	x0, x0, #0xfe0
    a00173b4:	f9400800 	ldr	x0, [x0, #16]
    a00173b8:	f9400fe1 	ldr	x1, [sp, #24]
    a00173bc:	eb00003f 	cmp	x1, x0
    a00173c0:	54000041 	b.ne	a00173c8 <z_impl_k_thread_suspend+0x154>  // b.any
		z_reschedule_unlocked();
    a00173c4:	97fffb15 	bl	a0016018 <z_reschedule_unlocked>
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_thread, suspend, thread);
}
    a00173c8:	d503201f 	nop
    a00173cc:	a8c97bfd 	ldp	x29, x30, [sp], #144
    a00173d0:	d65f03c0 	ret

00000000a00173d4 <z_vrfy_k_thread_suspend>:

#ifdef CONFIG_USERSPACE
static inline void z_vrfy_k_thread_suspend(struct k_thread *thread)
{
    a00173d4:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a00173d8:	910003fd 	mov	x29, sp
    a00173dc:	f9000fe0 	str	x0, [sp, #24]
	Z_OOPS(Z_SYSCALL_OBJ(thread, K_OBJ_THREAD));
    a00173e0:	f9400fe0 	ldr	x0, [sp, #24]
    a00173e4:	94001591 	bl	a001ca28 <z_object_find>
    a00173e8:	52800003 	mov	w3, #0x0                   	// #0
    a00173ec:	52800122 	mov	w2, #0x9                   	// #9
    a00173f0:	f9400fe1 	ldr	x1, [sp, #24]
    a00173f4:	97fffd27 	bl	a0016890 <z_obj_validation_check>
    a00173f8:	7100001f 	cmp	w0, #0x0
    a00173fc:	1a9f07e0 	cset	w0, ne  // ne = any
    a0017400:	39063fe0 	strb	w0, [sp, #399]
    a0017404:	39463fe0 	ldrb	w0, [sp, #399]
    a0017408:	7100001f 	cmp	w0, #0x0
    a001740c:	39463fe0 	ldrb	w0, [sp, #399]
    a0017410:	7100001f 	cmp	w0, #0x0
    a0017414:	540000c0 	b.eq	a001742c <z_vrfy_k_thread_suspend+0x58>  // b.none
    a0017418:	90000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001741c:	913f8000 	add	x0, x0, #0xfe0
    a0017420:	f9400800 	ldr	x0, [x0, #16]
    a0017424:	f9408400 	ldr	x0, [x0, #264]
    a0017428:	97ffc74c 	bl	a0009158 <arch_syscall_oops>
	z_impl_k_thread_suspend(thread);
    a001742c:	f9400fe0 	ldr	x0, [sp, #24]
    a0017430:	97ffff91 	bl	a0017274 <z_impl_k_thread_suspend>
}
    a0017434:	d503201f 	nop
    a0017438:	a8d97bfd 	ldp	x29, x30, [sp], #400
    a001743c:	d65f03c0 	ret

00000000a0017440 <z_mrsh_k_thread_suspend>:
#include <syscalls/kernel.h>

extern void z_vrfy_k_thread_suspend(k_tid_t thread);
uintptr_t z_mrsh_k_thread_suspend(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a0017440:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a0017444:	910003fd 	mov	x29, sp
    a0017448:	f90027e0 	str	x0, [sp, #72]
    a001744c:	f90023e1 	str	x1, [sp, #64]
    a0017450:	f9001fe2 	str	x2, [sp, #56]
    a0017454:	f9001be3 	str	x3, [sp, #48]
    a0017458:	f90017e4 	str	x4, [sp, #40]
    a001745c:	f90013e5 	str	x5, [sp, #32]
    a0017460:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a0017464:	90000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0017468:	913f8000 	add	x0, x0, #0xfe0
    a001746c:	f9400800 	ldr	x0, [x0, #16]
    a0017470:	f9400fe1 	ldr	x1, [sp, #24]
    a0017474:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_thread_suspend(*(k_tid_t*)&arg0)
    a0017478:	910123e0 	add	x0, sp, #0x48
    a001747c:	f9400000 	ldr	x0, [x0]
    a0017480:	97ffffd5 	bl	a00173d4 <z_vrfy_k_thread_suspend>
;
	_current->syscall_frame = NULL;
    a0017484:	90000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0017488:	913f8000 	add	x0, x0, #0xfe0
    a001748c:	f9400800 	ldr	x0, [x0, #16]
    a0017490:	f900841f 	str	xzr, [x0, #264]
	return 0;
    a0017494:	d2800000 	mov	x0, #0x0                   	// #0
}
    a0017498:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a001749c:	d65f03c0 	ret

00000000a00174a0 <z_impl_k_thread_resume>:
#include <syscalls/k_thread_suspend_mrsh.c>
#endif

void z_impl_k_thread_resume(struct k_thread *thread)
{
    a00174a0:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    a00174a4:	910003fd 	mov	x29, sp
    a00174a8:	f9000fe0 	str	x0, [sp, #24]
    a00174ac:	b0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a00174b0:	910a4000 	add	x0, x0, #0x290
    a00174b4:	f90037e0 	str	x0, [sp, #104]
    a00174b8:	d53b4220 	mrs	x0, daif
    a00174bc:	f90033e0 	str	x0, [sp, #96]
    a00174c0:	f94033e0 	ldr	x0, [sp, #96]
    a00174c4:	d503201f 	nop
	key = read_daif();
    a00174c8:	b9005fe0 	str	w0, [sp, #92]
	__asm__ volatile ("msr DAIFSet, %0"
    a00174cc:	d50342df 	msr	daifset, #0x2
}
    a00174d0:	d503201f 	nop
	return key;
    a00174d4:	b9405fe0 	ldr	w0, [sp, #92]
	k.key = arch_irq_lock();
    a00174d8:	b9002be0 	str	w0, [sp, #40]
	return k;
    a00174dc:	b9402be0 	ldr	w0, [sp, #40]
    a00174e0:	b9003be0 	str	w0, [sp, #56]
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_thread, resume, thread);

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	/* Do not try to resume a thread that was not suspended */
	if (!z_is_thread_suspended(thread)) {
    a00174e4:	f9400fe0 	ldr	x0, [sp, #24]
    a00174e8:	97fffaee 	bl	a00160a0 <z_is_thread_suspended>
    a00174ec:	12001c00 	and	w0, w0, #0xff
    a00174f0:	52000000 	eor	w0, w0, #0x1
    a00174f4:	12001c00 	and	w0, w0, #0xff
    a00174f8:	7100001f 	cmp	w0, #0x0
    a00174fc:	540001e0 	b.eq	a0017538 <z_impl_k_thread_resume+0x98>  // b.none
    a0017500:	b0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0017504:	910a4000 	add	x0, x0, #0x290
    a0017508:	f9002be0 	str	x0, [sp, #80]
    a001750c:	b9403be0 	ldr	w0, [sp, #56]
    a0017510:	b90033e0 	str	w0, [sp, #48]
	arch_irq_unlock(key.key);
    a0017514:	b94033e0 	ldr	w0, [sp, #48]
    a0017518:	b9004fe0 	str	w0, [sp, #76]
	write_daif(key);
    a001751c:	b9404fe0 	ldr	w0, [sp, #76]
    a0017520:	f90023e0 	str	x0, [sp, #64]
MAKE_REG_HELPER(daif)
    a0017524:	f94023e0 	ldr	x0, [sp, #64]
    a0017528:	d51b4220 	msr	daif, x0
    a001752c:	d503201f 	nop
}
    a0017530:	d503201f 	nop
}
    a0017534:	14000009 	b	a0017558 <z_impl_k_thread_resume+0xb8>
		k_spin_unlock(&sched_spinlock, key);
		return;
	}

	z_mark_thread_as_not_suspended(thread);
    a0017538:	f9400fe0 	ldr	x0, [sp, #24]
    a001753c:	97fffb4f 	bl	a0016278 <z_mark_thread_as_not_suspended>
	ready_thread(thread);
    a0017540:	f9400fe0 	ldr	x0, [sp, #24]
    a0017544:	97fffe93 	bl	a0016f90 <ready_thread>

	z_reschedule(&sched_spinlock, key);
    a0017548:	b9403be1 	ldr	w1, [sp, #56]
    a001754c:	b0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0017550:	910a4000 	add	x0, x0, #0x290
    a0017554:	940002f2 	bl	a001811c <z_reschedule>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_thread, resume, thread);
}
    a0017558:	a8c77bfd 	ldp	x29, x30, [sp], #112
    a001755c:	d65f03c0 	ret

00000000a0017560 <z_vrfy_k_thread_resume>:

#ifdef CONFIG_USERSPACE
static inline void z_vrfy_k_thread_resume(struct k_thread *thread)
{
    a0017560:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a0017564:	910003fd 	mov	x29, sp
    a0017568:	f9000fe0 	str	x0, [sp, #24]
	Z_OOPS(Z_SYSCALL_OBJ(thread, K_OBJ_THREAD));
    a001756c:	f9400fe0 	ldr	x0, [sp, #24]
    a0017570:	9400152e 	bl	a001ca28 <z_object_find>
    a0017574:	52800003 	mov	w3, #0x0                   	// #0
    a0017578:	52800122 	mov	w2, #0x9                   	// #9
    a001757c:	f9400fe1 	ldr	x1, [sp, #24]
    a0017580:	97fffcc4 	bl	a0016890 <z_obj_validation_check>
    a0017584:	7100001f 	cmp	w0, #0x0
    a0017588:	1a9f07e0 	cset	w0, ne  // ne = any
    a001758c:	39063fe0 	strb	w0, [sp, #399]
    a0017590:	39463fe0 	ldrb	w0, [sp, #399]
    a0017594:	7100001f 	cmp	w0, #0x0
    a0017598:	39463fe0 	ldrb	w0, [sp, #399]
    a001759c:	7100001f 	cmp	w0, #0x0
    a00175a0:	540000c0 	b.eq	a00175b8 <z_vrfy_k_thread_resume+0x58>  // b.none
    a00175a4:	90000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00175a8:	913f8000 	add	x0, x0, #0xfe0
    a00175ac:	f9400800 	ldr	x0, [x0, #16]
    a00175b0:	f9408400 	ldr	x0, [x0, #264]
    a00175b4:	97ffc6e9 	bl	a0009158 <arch_syscall_oops>
	z_impl_k_thread_resume(thread);
    a00175b8:	f9400fe0 	ldr	x0, [sp, #24]
    a00175bc:	97ffffb9 	bl	a00174a0 <z_impl_k_thread_resume>
}
    a00175c0:	d503201f 	nop
    a00175c4:	a8d97bfd 	ldp	x29, x30, [sp], #400
    a00175c8:	d65f03c0 	ret

00000000a00175cc <z_mrsh_k_thread_resume>:
#include <syscalls/kernel.h>

extern void z_vrfy_k_thread_resume(k_tid_t thread);
uintptr_t z_mrsh_k_thread_resume(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a00175cc:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a00175d0:	910003fd 	mov	x29, sp
    a00175d4:	f90027e0 	str	x0, [sp, #72]
    a00175d8:	f90023e1 	str	x1, [sp, #64]
    a00175dc:	f9001fe2 	str	x2, [sp, #56]
    a00175e0:	f9001be3 	str	x3, [sp, #48]
    a00175e4:	f90017e4 	str	x4, [sp, #40]
    a00175e8:	f90013e5 	str	x5, [sp, #32]
    a00175ec:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a00175f0:	90000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00175f4:	913f8000 	add	x0, x0, #0xfe0
    a00175f8:	f9400800 	ldr	x0, [x0, #16]
    a00175fc:	f9400fe1 	ldr	x1, [sp, #24]
    a0017600:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_thread_resume(*(k_tid_t*)&arg0)
    a0017604:	910123e0 	add	x0, sp, #0x48
    a0017608:	f9400000 	ldr	x0, [x0]
    a001760c:	97ffffd5 	bl	a0017560 <z_vrfy_k_thread_resume>
;
	_current->syscall_frame = NULL;
    a0017610:	90000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0017614:	913f8000 	add	x0, x0, #0xfe0
    a0017618:	f9400800 	ldr	x0, [x0, #16]
    a001761c:	f900841f 	str	xzr, [x0, #264]
	return 0;
    a0017620:	d2800000 	mov	x0, #0x0                   	// #0
}
    a0017624:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a0017628:	d65f03c0 	ret

00000000a001762c <pended_on_thread>:
#include <syscalls/k_thread_resume_mrsh.c>
#endif

static _wait_q_t *pended_on_thread(struct k_thread *thread)
{
    a001762c:	d10043ff 	sub	sp, sp, #0x10
    a0017630:	f90007e0 	str	x0, [sp, #8]
	__ASSERT_NO_MSG(thread->base.pended_on);

	return thread->base.pended_on;
    a0017634:	f94007e0 	ldr	x0, [sp, #8]
    a0017638:	f9400800 	ldr	x0, [x0, #16]
}
    a001763c:	910043ff 	add	sp, sp, #0x10
    a0017640:	d65f03c0 	ret

00000000a0017644 <unready_thread>:

static void unready_thread(struct k_thread *thread)
{
    a0017644:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    a0017648:	910003fd 	mov	x29, sp
    a001764c:	f9000fe0 	str	x0, [sp, #24]
	if (z_is_thread_queued(thread)) {
    a0017650:	f9400fe0 	ldr	x0, [sp, #24]
    a0017654:	97fffaf5 	bl	a0016228 <z_is_thread_queued>
    a0017658:	12001c00 	and	w0, w0, #0xff
    a001765c:	7100001f 	cmp	w0, #0x0
    a0017660:	54000300 	b.eq	a00176c0 <unready_thread+0x7c>  // b.none
    a0017664:	f9400fe0 	ldr	x0, [sp, #24]
    a0017668:	f9001fe0 	str	x0, [sp, #56]
	thread->base.thread_state &= ~_THREAD_QUEUED;
    a001766c:	f9401fe0 	ldr	x0, [sp, #56]
    a0017670:	39406400 	ldrb	w0, [x0, #25]
    a0017674:	12001800 	and	w0, w0, #0x7f
    a0017678:	12001c01 	and	w1, w0, #0xff
    a001767c:	f9401fe0 	ldr	x0, [sp, #56]
    a0017680:	39006401 	strb	w1, [x0, #25]
	if (should_queue_thread(thread)) {
    a0017684:	f9401fe0 	ldr	x0, [sp, #56]
    a0017688:	97fffcb2 	bl	a0016950 <should_queue_thread>
    a001768c:	12001c00 	and	w0, w0, #0xff
    a0017690:	7100001f 	cmp	w0, #0x0
    a0017694:	54000140 	b.eq	a00176bc <unready_thread+0x78>  // b.none
    a0017698:	f9401fe0 	ldr	x0, [sp, #56]
    a001769c:	f9001be0 	str	x0, [sp, #48]
    a00176a0:	f9401be0 	ldr	x0, [sp, #48]
    a00176a4:	f90017e0 	str	x0, [sp, #40]
	return &_kernel.ready_q.runq;
    a00176a8:	b0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a00176ac:	91004000 	add	x0, x0, #0x10
	_priq_run_remove(thread_runq(thread), thread);
    a00176b0:	f9401be1 	ldr	x1, [sp, #48]
    a00176b4:	94000350 	bl	a00183f4 <z_priq_dumb_remove>
}
    a00176b8:	d503201f 	nop
}
    a00176bc:	d503201f 	nop
		dequeue_thread(thread);
	}
	update_cache(thread == _current);
    a00176c0:	90000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00176c4:	913f8000 	add	x0, x0, #0xfe0
    a00176c8:	f9400800 	ldr	x0, [x0, #16]
    a00176cc:	f9400fe1 	ldr	x1, [sp, #24]
    a00176d0:	eb00003f 	cmp	x1, x0
    a00176d4:	1a9f17e0 	cset	w0, eq  // eq = none
    a00176d8:	12001c00 	and	w0, w0, #0xff
    a00176dc:	97fffde0 	bl	a0016e5c <update_cache>
}
    a00176e0:	d503201f 	nop
    a00176e4:	a8c47bfd 	ldp	x29, x30, [sp], #64
    a00176e8:	d65f03c0 	ret

00000000a00176ec <add_to_waitq_locked>:

/* sched_spinlock must be held */
static void add_to_waitq_locked(struct k_thread *thread, _wait_q_t *wait_q)
{
    a00176ec:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    a00176f0:	910003fd 	mov	x29, sp
    a00176f4:	f9000fe0 	str	x0, [sp, #24]
    a00176f8:	f9000be1 	str	x1, [sp, #16]
	unready_thread(thread);
    a00176fc:	f9400fe0 	ldr	x0, [sp, #24]
    a0017700:	97ffffd1 	bl	a0017644 <unready_thread>
	z_mark_thread_as_pending(thread);
    a0017704:	f9400fe0 	ldr	x0, [sp, #24]
    a0017708:	97fffaf2 	bl	a00162d0 <z_mark_thread_as_pending>

	SYS_PORT_TRACING_FUNC(k_thread, sched_pend, thread);

	if (wait_q != NULL) {
    a001770c:	f9400be0 	ldr	x0, [sp, #16]
    a0017710:	f100001f 	cmp	x0, #0x0
    a0017714:	540006a0 	b.eq	a00177e8 <add_to_waitq_locked+0xfc>  // b.none
		thread->base.pended_on = wait_q;
    a0017718:	f9400fe0 	ldr	x0, [sp, #24]
    a001771c:	f9400be1 	ldr	x1, [sp, #16]
    a0017720:	f9000801 	str	x1, [x0, #16]
		z_priq_wait_add(&wait_q->waitq, thread);
    a0017724:	f9400be0 	ldr	x0, [sp, #16]
    a0017728:	f9001fe0 	str	x0, [sp, #56]
    a001772c:	f9400fe0 	ldr	x0, [sp, #24]
    a0017730:	f9001be0 	str	x0, [sp, #48]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    a0017734:	f9401fe0 	ldr	x0, [sp, #56]
    a0017738:	97fff635 	bl	a001500c <sys_dlist_peek_head>
    a001773c:	f100001f 	cmp	x0, #0x0
    a0017740:	54000080 	b.eq	a0017750 <add_to_waitq_locked+0x64>  // b.none
    a0017744:	f9401fe0 	ldr	x0, [sp, #56]
    a0017748:	97fff631 	bl	a001500c <sys_dlist_peek_head>
    a001774c:	14000002 	b	a0017754 <add_to_waitq_locked+0x68>
    a0017750:	d2800000 	mov	x0, #0x0                   	// #0
    a0017754:	f90017e0 	str	x0, [sp, #40]
    a0017758:	1400001d 	b	a00177cc <add_to_waitq_locked+0xe0>
		if (z_sched_prio_cmp(thread, t) > 0) {
    a001775c:	f94017e1 	ldr	x1, [sp, #40]
    a0017760:	f9401be0 	ldr	x0, [sp, #48]
    a0017764:	97fffc67 	bl	a0016900 <z_sched_prio_cmp>
    a0017768:	7100001f 	cmp	w0, #0x0
    a001776c:	540000cd 	b.le	a0017784 <add_to_waitq_locked+0x98>
			sys_dlist_insert(&t->base.qnode_dlist,
    a0017770:	f94017e0 	ldr	x0, [sp, #40]
    a0017774:	f9401be1 	ldr	x1, [sp, #48]
    a0017778:	97fff664 	bl	a0015108 <sys_dlist_insert>
			return;
    a001777c:	d503201f 	nop
	}
}
    a0017780:	1400001a 	b	a00177e8 <add_to_waitq_locked+0xfc>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    a0017784:	f94017e0 	ldr	x0, [sp, #40]
    a0017788:	f100001f 	cmp	x0, #0x0
    a001778c:	540001c0 	b.eq	a00177c4 <add_to_waitq_locked+0xd8>  // b.none
    a0017790:	f94017e0 	ldr	x0, [sp, #40]
    a0017794:	aa0003e1 	mov	x1, x0
    a0017798:	f9401fe0 	ldr	x0, [sp, #56]
    a001779c:	97fff638 	bl	a001507c <sys_dlist_peek_next>
    a00177a0:	f100001f 	cmp	x0, #0x0
    a00177a4:	540000c0 	b.eq	a00177bc <add_to_waitq_locked+0xd0>  // b.none
    a00177a8:	f94017e0 	ldr	x0, [sp, #40]
    a00177ac:	aa0003e1 	mov	x1, x0
    a00177b0:	f9401fe0 	ldr	x0, [sp, #56]
    a00177b4:	97fff632 	bl	a001507c <sys_dlist_peek_next>
    a00177b8:	14000004 	b	a00177c8 <add_to_waitq_locked+0xdc>
    a00177bc:	d2800000 	mov	x0, #0x0                   	// #0
    a00177c0:	14000002 	b	a00177c8 <add_to_waitq_locked+0xdc>
    a00177c4:	d2800000 	mov	x0, #0x0                   	// #0
    a00177c8:	f90017e0 	str	x0, [sp, #40]
    a00177cc:	f94017e0 	ldr	x0, [sp, #40]
    a00177d0:	f100001f 	cmp	x0, #0x0
    a00177d4:	54fffc41 	b.ne	a001775c <add_to_waitq_locked+0x70>  // b.any
	sys_dlist_append(pq, &thread->base.qnode_dlist);
    a00177d8:	f9401be0 	ldr	x0, [sp, #48]
    a00177dc:	aa0003e1 	mov	x1, x0
    a00177e0:	f9401fe0 	ldr	x0, [sp, #56]
    a00177e4:	97fff634 	bl	a00150b4 <sys_dlist_append>
}
    a00177e8:	d503201f 	nop
    a00177ec:	a8c47bfd 	ldp	x29, x30, [sp], #64
    a00177f0:	d65f03c0 	ret

00000000a00177f4 <add_thread_timeout>:

static void add_thread_timeout(struct k_thread *thread, k_timeout_t timeout)
{
    a00177f4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a00177f8:	910003fd 	mov	x29, sp
    a00177fc:	f9000fe0 	str	x0, [sp, #24]
    a0017800:	f9000be1 	str	x1, [sp, #16]
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    a0017804:	f9400be0 	ldr	x0, [sp, #16]
    a0017808:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
    a001780c:	eb01001f 	cmp	x0, x1
    a0017810:	54000080 	b.eq	a0017820 <add_thread_timeout+0x2c>  // b.none
		z_add_thread_timeout(thread, timeout);
    a0017814:	f9400be1 	ldr	x1, [sp, #16]
    a0017818:	f9400fe0 	ldr	x0, [sp, #24]
    a001781c:	97fff9e9 	bl	a0015fc0 <z_add_thread_timeout>
	}
}
    a0017820:	d503201f 	nop
    a0017824:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0017828:	d65f03c0 	ret

00000000a001782c <pend>:

static void pend(struct k_thread *thread, _wait_q_t *wait_q,
		 k_timeout_t timeout)
{
    a001782c:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
    a0017830:	910003fd 	mov	x29, sp
    a0017834:	f90017e0 	str	x0, [sp, #40]
    a0017838:	f90013e1 	str	x1, [sp, #32]
    a001783c:	f9000fe2 	str	x2, [sp, #24]
#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(wait_q == NULL || arch_mem_coherent(wait_q));
#endif

	LOCKED(&sched_spinlock) {
    a0017840:	b9004bff 	str	wzr, [sp, #72]
    a0017844:	b0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0017848:	910a4000 	add	x0, x0, #0x290
    a001784c:	f9003fe0 	str	x0, [sp, #120]
    a0017850:	d53b4220 	mrs	x0, daif
    a0017854:	f9003be0 	str	x0, [sp, #112]
    a0017858:	f9403be0 	ldr	x0, [sp, #112]
    a001785c:	d503201f 	nop
	key = read_daif();
    a0017860:	b9006fe0 	str	w0, [sp, #108]
	__asm__ volatile ("msr DAIFSet, %0"
    a0017864:	d50342df 	msr	daifset, #0x2
}
    a0017868:	d503201f 	nop
	return key;
    a001786c:	b9406fe0 	ldr	w0, [sp, #108]
	k.key = arch_irq_lock();
    a0017870:	b90033e0 	str	w0, [sp, #48]
	return k;
    a0017874:	b94033e0 	ldr	w0, [sp, #48]
    a0017878:	b90043e0 	str	w0, [sp, #64]
    a001787c:	14000014 	b	a00178cc <pend+0xa0>
		add_to_waitq_locked(thread, wait_q);
    a0017880:	f94013e1 	ldr	x1, [sp, #32]
    a0017884:	f94017e0 	ldr	x0, [sp, #40]
    a0017888:	97ffff99 	bl	a00176ec <add_to_waitq_locked>
    a001788c:	b0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0017890:	910a4000 	add	x0, x0, #0x290
    a0017894:	f90033e0 	str	x0, [sp, #96]
    a0017898:	b94043e0 	ldr	w0, [sp, #64]
    a001789c:	b9003be0 	str	w0, [sp, #56]
	arch_irq_unlock(key.key);
    a00178a0:	b9403be0 	ldr	w0, [sp, #56]
    a00178a4:	b9005fe0 	str	w0, [sp, #92]
	write_daif(key);
    a00178a8:	b9405fe0 	ldr	w0, [sp, #92]
    a00178ac:	f9002be0 	str	x0, [sp, #80]
MAKE_REG_HELPER(daif)
    a00178b0:	f9402be0 	ldr	x0, [sp, #80]
    a00178b4:	d51b4220 	msr	daif, x0
    a00178b8:	d503201f 	nop
}
    a00178bc:	d503201f 	nop
}
    a00178c0:	d503201f 	nop
	LOCKED(&sched_spinlock) {
    a00178c4:	52800020 	mov	w0, #0x1                   	// #1
    a00178c8:	b9004be0 	str	w0, [sp, #72]
    a00178cc:	b9404be0 	ldr	w0, [sp, #72]
    a00178d0:	7100001f 	cmp	w0, #0x0
    a00178d4:	54fffd60 	b.eq	a0017880 <pend+0x54>  // b.none
	}

	add_thread_timeout(thread, timeout);
    a00178d8:	f9400fe1 	ldr	x1, [sp, #24]
    a00178dc:	f94017e0 	ldr	x0, [sp, #40]
    a00178e0:	97ffffc5 	bl	a00177f4 <add_thread_timeout>
}
    a00178e4:	d503201f 	nop
    a00178e8:	a8c87bfd 	ldp	x29, x30, [sp], #128
    a00178ec:	d65f03c0 	ret

00000000a00178f0 <unpend_thread_no_timeout>:
	__ASSERT_NO_MSG(thread == _current || is_thread_dummy(thread));
	pend(thread, wait_q, timeout);
}

static inline void unpend_thread_no_timeout(struct k_thread *thread)
{
    a00178f0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a00178f4:	910003fd 	mov	x29, sp
    a00178f8:	f9000fe0 	str	x0, [sp, #24]
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
    a00178fc:	f9400fe0 	ldr	x0, [sp, #24]
    a0017900:	97ffff4b 	bl	a001762c <pended_on_thread>
    a0017904:	f9400fe1 	ldr	x1, [sp, #24]
    a0017908:	940002bb 	bl	a00183f4 <z_priq_dumb_remove>
	z_mark_thread_as_not_pending(thread);
    a001790c:	f9400fe0 	ldr	x0, [sp, #24]
    a0017910:	97fffa7b 	bl	a00162fc <z_mark_thread_as_not_pending>
	thread->base.pended_on = NULL;
    a0017914:	f9400fe0 	ldr	x0, [sp, #24]
    a0017918:	f900081f 	str	xzr, [x0, #16]
}
    a001791c:	d503201f 	nop
    a0017920:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0017924:	d65f03c0 	ret

00000000a0017928 <z_unpend_thread_no_timeout>:

ALWAYS_INLINE void z_unpend_thread_no_timeout(struct k_thread *thread)
{
    a0017928:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    a001792c:	910003fd 	mov	x29, sp
    a0017930:	f9000fe0 	str	x0, [sp, #24]
	LOCKED(&sched_spinlock) {
    a0017934:	b9003bff 	str	wzr, [sp, #56]
    a0017938:	b0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a001793c:	910a4000 	add	x0, x0, #0x290
    a0017940:	f90037e0 	str	x0, [sp, #104]
    a0017944:	d53b4220 	mrs	x0, daif
    a0017948:	f90033e0 	str	x0, [sp, #96]
    a001794c:	f94033e0 	ldr	x0, [sp, #96]
    a0017950:	d503201f 	nop
	key = read_daif();
    a0017954:	b9005fe0 	str	w0, [sp, #92]
	__asm__ volatile ("msr DAIFSet, %0"
    a0017958:	d50342df 	msr	daifset, #0x2
}
    a001795c:	d503201f 	nop
	return key;
    a0017960:	b9405fe0 	ldr	w0, [sp, #92]
	k.key = arch_irq_lock();
    a0017964:	b90023e0 	str	w0, [sp, #32]
	return k;
    a0017968:	b94023e0 	ldr	w0, [sp, #32]
    a001796c:	b90033e0 	str	w0, [sp, #48]
    a0017970:	14000013 	b	a00179bc <z_unpend_thread_no_timeout+0x94>
		unpend_thread_no_timeout(thread);
    a0017974:	f9400fe0 	ldr	x0, [sp, #24]
    a0017978:	97ffffde 	bl	a00178f0 <unpend_thread_no_timeout>
    a001797c:	b0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0017980:	910a4000 	add	x0, x0, #0x290
    a0017984:	f9002be0 	str	x0, [sp, #80]
    a0017988:	b94033e0 	ldr	w0, [sp, #48]
    a001798c:	b9002be0 	str	w0, [sp, #40]
	arch_irq_unlock(key.key);
    a0017990:	b9402be0 	ldr	w0, [sp, #40]
    a0017994:	b9004fe0 	str	w0, [sp, #76]
	write_daif(key);
    a0017998:	b9404fe0 	ldr	w0, [sp, #76]
    a001799c:	f90023e0 	str	x0, [sp, #64]
MAKE_REG_HELPER(daif)
    a00179a0:	f94023e0 	ldr	x0, [sp, #64]
    a00179a4:	d51b4220 	msr	daif, x0
    a00179a8:	d503201f 	nop
}
    a00179ac:	d503201f 	nop
}
    a00179b0:	d503201f 	nop
	LOCKED(&sched_spinlock) {
    a00179b4:	52800020 	mov	w0, #0x1                   	// #1
    a00179b8:	b9003be0 	str	w0, [sp, #56]
    a00179bc:	b9403be0 	ldr	w0, [sp, #56]
    a00179c0:	7100001f 	cmp	w0, #0x0
    a00179c4:	54fffd80 	b.eq	a0017974 <z_unpend_thread_no_timeout+0x4c>  // b.none
	}
}
    a00179c8:	d503201f 	nop
    a00179cc:	d503201f 	nop
    a00179d0:	a8c77bfd 	ldp	x29, x30, [sp], #112
    a00179d4:	d65f03c0 	ret

00000000a00179d8 <z_thread_timeout>:

#ifdef CONFIG_SYS_CLOCK_EXISTS
/* Timeout handler for *_thread_timeout() APIs */
void z_thread_timeout(struct _timeout *timeout)
{
    a00179d8:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
    a00179dc:	910003fd 	mov	x29, sp
    a00179e0:	f9000fe0 	str	x0, [sp, #24]
	struct k_thread *thread = CONTAINER_OF(timeout,
    a00179e4:	f9400fe0 	ldr	x0, [sp, #24]
    a00179e8:	d100a000 	sub	x0, x0, #0x28
    a00179ec:	f9003fe0 	str	x0, [sp, #120]
					       struct k_thread, base.timeout);

	LOCKED(&sched_spinlock) {
    a00179f0:	b9003bff 	str	wzr, [sp, #56]
    a00179f4:	b0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a00179f8:	910a4000 	add	x0, x0, #0x290
    a00179fc:	f90037e0 	str	x0, [sp, #104]
    a0017a00:	d53b4220 	mrs	x0, daif
    a0017a04:	f90033e0 	str	x0, [sp, #96]
    a0017a08:	f94033e0 	ldr	x0, [sp, #96]
    a0017a0c:	d503201f 	nop
	key = read_daif();
    a0017a10:	b9005fe0 	str	w0, [sp, #92]
	__asm__ volatile ("msr DAIFSet, %0"
    a0017a14:	d50342df 	msr	daifset, #0x2
}
    a0017a18:	d503201f 	nop
	return key;
    a0017a1c:	b9405fe0 	ldr	w0, [sp, #92]
	k.key = arch_irq_lock();
    a0017a20:	b90023e0 	str	w0, [sp, #32]
	return k;
    a0017a24:	b94023e0 	ldr	w0, [sp, #32]
    a0017a28:	b90033e0 	str	w0, [sp, #48]
    a0017a2c:	14000035 	b	a0017b00 <z_thread_timeout+0x128>
		bool killed = ((thread->base.thread_state & _THREAD_DEAD) ||
    a0017a30:	f9403fe0 	ldr	x0, [sp, #120]
    a0017a34:	39406400 	ldrb	w0, [x0, #25]
    a0017a38:	92401c00 	and	x0, x0, #0xff
    a0017a3c:	927d0000 	and	x0, x0, #0x8
    a0017a40:	f100001f 	cmp	x0, #0x0
    a0017a44:	540000e1 	b.ne	a0017a60 <z_thread_timeout+0x88>  // b.any
			       (thread->base.thread_state & _THREAD_ABORTING));
    a0017a48:	f9403fe0 	ldr	x0, [sp, #120]
    a0017a4c:	39406400 	ldrb	w0, [x0, #25]
    a0017a50:	92401c00 	and	x0, x0, #0xff
    a0017a54:	927b0000 	and	x0, x0, #0x20
		bool killed = ((thread->base.thread_state & _THREAD_DEAD) ||
    a0017a58:	f100001f 	cmp	x0, #0x0
    a0017a5c:	54000060 	b.eq	a0017a68 <z_thread_timeout+0x90>  // b.none
    a0017a60:	52800020 	mov	w0, #0x1                   	// #1
    a0017a64:	14000002 	b	a0017a6c <z_thread_timeout+0x94>
    a0017a68:	52800000 	mov	w0, #0x0                   	// #0
    a0017a6c:	3901dfe0 	strb	w0, [sp, #119]
    a0017a70:	3941dfe0 	ldrb	w0, [sp, #119]
    a0017a74:	12000000 	and	w0, w0, #0x1
    a0017a78:	3901dfe0 	strb	w0, [sp, #119]

		if (!killed) {
    a0017a7c:	3941dfe0 	ldrb	w0, [sp, #119]
    a0017a80:	52000000 	eor	w0, w0, #0x1
    a0017a84:	12001c00 	and	w0, w0, #0xff
    a0017a88:	7100001f 	cmp	w0, #0x0
    a0017a8c:	540001a0 	b.eq	a0017ac0 <z_thread_timeout+0xe8>  // b.none
			if (thread->base.pended_on != NULL) {
    a0017a90:	f9403fe0 	ldr	x0, [sp, #120]
    a0017a94:	f9400800 	ldr	x0, [x0, #16]
    a0017a98:	f100001f 	cmp	x0, #0x0
    a0017a9c:	54000060 	b.eq	a0017aa8 <z_thread_timeout+0xd0>  // b.none
				unpend_thread_no_timeout(thread);
    a0017aa0:	f9403fe0 	ldr	x0, [sp, #120]
    a0017aa4:	97ffff93 	bl	a00178f0 <unpend_thread_no_timeout>
			}
			z_mark_thread_as_started(thread);
    a0017aa8:	f9403fe0 	ldr	x0, [sp, #120]
    a0017aac:	97fff9fe 	bl	a00162a4 <z_mark_thread_as_started>
			z_mark_thread_as_not_suspended(thread);
    a0017ab0:	f9403fe0 	ldr	x0, [sp, #120]
    a0017ab4:	97fff9f1 	bl	a0016278 <z_mark_thread_as_not_suspended>
			ready_thread(thread);
    a0017ab8:	f9403fe0 	ldr	x0, [sp, #120]
    a0017abc:	97fffd35 	bl	a0016f90 <ready_thread>
    a0017ac0:	b0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0017ac4:	910a4000 	add	x0, x0, #0x290
    a0017ac8:	f9002be0 	str	x0, [sp, #80]
    a0017acc:	b94033e0 	ldr	w0, [sp, #48]
    a0017ad0:	b9002be0 	str	w0, [sp, #40]
	arch_irq_unlock(key.key);
    a0017ad4:	b9402be0 	ldr	w0, [sp, #40]
    a0017ad8:	b9004fe0 	str	w0, [sp, #76]
	write_daif(key);
    a0017adc:	b9404fe0 	ldr	w0, [sp, #76]
    a0017ae0:	f90023e0 	str	x0, [sp, #64]
MAKE_REG_HELPER(daif)
    a0017ae4:	f94023e0 	ldr	x0, [sp, #64]
    a0017ae8:	d51b4220 	msr	daif, x0
    a0017aec:	d503201f 	nop
}
    a0017af0:	d503201f 	nop
}
    a0017af4:	d503201f 	nop
	LOCKED(&sched_spinlock) {
    a0017af8:	52800020 	mov	w0, #0x1                   	// #1
    a0017afc:	b9003be0 	str	w0, [sp, #56]
    a0017b00:	b9403be0 	ldr	w0, [sp, #56]
    a0017b04:	7100001f 	cmp	w0, #0x0
    a0017b08:	54fff940 	b.eq	a0017a30 <z_thread_timeout+0x58>  // b.none
		}
	}
}
    a0017b0c:	d503201f 	nop
    a0017b10:	d503201f 	nop
    a0017b14:	a8c87bfd 	ldp	x29, x30, [sp], #128
    a0017b18:	d65f03c0 	ret

00000000a0017b1c <z_pend_curr>:
#endif
}

int z_pend_curr(struct k_spinlock *lock, k_spinlock_key_t key,
	       _wait_q_t *wait_q, k_timeout_t timeout)
{
    a0017b1c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0017b20:	910003fd 	mov	x29, sp
    a0017b24:	f90017e0 	str	x0, [sp, #40]
    a0017b28:	b90023e1 	str	w1, [sp, #32]
    a0017b2c:	f9000fe2 	str	x2, [sp, #24]
    a0017b30:	f9000be3 	str	x3, [sp, #16]
#if defined(CONFIG_TIMESLICING) && defined(CONFIG_SWAP_NONATOMIC)
	pending_current = _current;
#endif
	pend(_current, wait_q, timeout);
    a0017b34:	90000180 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0017b38:	913f8000 	add	x0, x0, #0xfe0
    a0017b3c:	f9400800 	ldr	x0, [x0, #16]
    a0017b40:	f9400be2 	ldr	x2, [sp, #16]
    a0017b44:	f9400fe1 	ldr	x1, [sp, #24]
    a0017b48:	97ffff39 	bl	a001782c <pend>
	return z_swap(lock, key);
    a0017b4c:	b94023e1 	ldr	w1, [sp, #32]
    a0017b50:	f94017e0 	ldr	x0, [sp, #40]
    a0017b54:	97fffade 	bl	a00166cc <z_swap>
}
    a0017b58:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0017b5c:	d65f03c0 	ret

00000000a0017b60 <z_unpend1_no_timeout>:

struct k_thread *z_unpend1_no_timeout(_wait_q_t *wait_q)
{
    a0017b60:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
    a0017b64:	910003fd 	mov	x29, sp
    a0017b68:	f9000fe0 	str	x0, [sp, #24]
	struct k_thread *thread = NULL;
    a0017b6c:	f9003fff 	str	xzr, [sp, #120]

	LOCKED(&sched_spinlock) {
    a0017b70:	b90043ff 	str	wzr, [sp, #64]
    a0017b74:	b0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0017b78:	910a4000 	add	x0, x0, #0x290
    a0017b7c:	f9003be0 	str	x0, [sp, #112]
    a0017b80:	d53b4220 	mrs	x0, daif
    a0017b84:	f90037e0 	str	x0, [sp, #104]
    a0017b88:	f94037e0 	ldr	x0, [sp, #104]
    a0017b8c:	d503201f 	nop
	key = read_daif();
    a0017b90:	b90067e0 	str	w0, [sp, #100]
	__asm__ volatile ("msr DAIFSet, %0"
    a0017b94:	d50342df 	msr	daifset, #0x2
}
    a0017b98:	d503201f 	nop
	return key;
    a0017b9c:	b94067e0 	ldr	w0, [sp, #100]
	k.key = arch_irq_lock();
    a0017ba0:	b9002be0 	str	w0, [sp, #40]
	return k;
    a0017ba4:	b9402be0 	ldr	w0, [sp, #40]
    a0017ba8:	b9003be0 	str	w0, [sp, #56]
    a0017bac:	14000019 	b	a0017c10 <z_unpend1_no_timeout+0xb0>
		thread = _priq_wait_best(&wait_q->waitq);
    a0017bb0:	f9400fe0 	ldr	x0, [sp, #24]
    a0017bb4:	94000219 	bl	a0018418 <z_priq_dumb_best>
    a0017bb8:	f9003fe0 	str	x0, [sp, #120]

		if (thread != NULL) {
    a0017bbc:	f9403fe0 	ldr	x0, [sp, #120]
    a0017bc0:	f100001f 	cmp	x0, #0x0
    a0017bc4:	54000060 	b.eq	a0017bd0 <z_unpend1_no_timeout+0x70>  // b.none
			unpend_thread_no_timeout(thread);
    a0017bc8:	f9403fe0 	ldr	x0, [sp, #120]
    a0017bcc:	97ffff49 	bl	a00178f0 <unpend_thread_no_timeout>
    a0017bd0:	b0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0017bd4:	910a4000 	add	x0, x0, #0x290
    a0017bd8:	f9002fe0 	str	x0, [sp, #88]
    a0017bdc:	b9403be0 	ldr	w0, [sp, #56]
    a0017be0:	b90033e0 	str	w0, [sp, #48]
	arch_irq_unlock(key.key);
    a0017be4:	b94033e0 	ldr	w0, [sp, #48]
    a0017be8:	b90057e0 	str	w0, [sp, #84]
	write_daif(key);
    a0017bec:	b94057e0 	ldr	w0, [sp, #84]
    a0017bf0:	f90027e0 	str	x0, [sp, #72]
MAKE_REG_HELPER(daif)
    a0017bf4:	f94027e0 	ldr	x0, [sp, #72]
    a0017bf8:	d51b4220 	msr	daif, x0
    a0017bfc:	d503201f 	nop
}
    a0017c00:	d503201f 	nop
}
    a0017c04:	d503201f 	nop
	LOCKED(&sched_spinlock) {
    a0017c08:	52800020 	mov	w0, #0x1                   	// #1
    a0017c0c:	b90043e0 	str	w0, [sp, #64]
    a0017c10:	b94043e0 	ldr	w0, [sp, #64]
    a0017c14:	7100001f 	cmp	w0, #0x0
    a0017c18:	54fffcc0 	b.eq	a0017bb0 <z_unpend1_no_timeout+0x50>  // b.none
		}
	}

	return thread;
    a0017c1c:	f9403fe0 	ldr	x0, [sp, #120]
}
    a0017c20:	a8c87bfd 	ldp	x29, x30, [sp], #128
    a0017c24:	d65f03c0 	ret

00000000a0017c28 <z_unpend_first_thread>:

struct k_thread *z_unpend_first_thread(_wait_q_t *wait_q)
{
    a0017c28:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
    a0017c2c:	910003fd 	mov	x29, sp
    a0017c30:	f9000fe0 	str	x0, [sp, #24]
	struct k_thread *thread = NULL;
    a0017c34:	f9003fff 	str	xzr, [sp, #120]

	LOCKED(&sched_spinlock) {
    a0017c38:	b90043ff 	str	wzr, [sp, #64]
    a0017c3c:	b0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0017c40:	910a4000 	add	x0, x0, #0x290
    a0017c44:	f9003be0 	str	x0, [sp, #112]
    a0017c48:	d53b4220 	mrs	x0, daif
    a0017c4c:	f90037e0 	str	x0, [sp, #104]
    a0017c50:	f94037e0 	ldr	x0, [sp, #104]
    a0017c54:	d503201f 	nop
	key = read_daif();
    a0017c58:	b90067e0 	str	w0, [sp, #100]
	__asm__ volatile ("msr DAIFSet, %0"
    a0017c5c:	d50342df 	msr	daifset, #0x2
}
    a0017c60:	d503201f 	nop
	return key;
    a0017c64:	b94067e0 	ldr	w0, [sp, #100]
	k.key = arch_irq_lock();
    a0017c68:	b9002be0 	str	w0, [sp, #40]
	return k;
    a0017c6c:	b9402be0 	ldr	w0, [sp, #40]
    a0017c70:	b9003be0 	str	w0, [sp, #56]
    a0017c74:	1400001b 	b	a0017ce0 <z_unpend_first_thread+0xb8>
		thread = _priq_wait_best(&wait_q->waitq);
    a0017c78:	f9400fe0 	ldr	x0, [sp, #24]
    a0017c7c:	940001e7 	bl	a0018418 <z_priq_dumb_best>
    a0017c80:	f9003fe0 	str	x0, [sp, #120]

		if (thread != NULL) {
    a0017c84:	f9403fe0 	ldr	x0, [sp, #120]
    a0017c88:	f100001f 	cmp	x0, #0x0
    a0017c8c:	540000a0 	b.eq	a0017ca0 <z_unpend_first_thread+0x78>  // b.none
			unpend_thread_no_timeout(thread);
    a0017c90:	f9403fe0 	ldr	x0, [sp, #120]
    a0017c94:	97ffff17 	bl	a00178f0 <unpend_thread_no_timeout>
			(void)z_abort_thread_timeout(thread);
    a0017c98:	f9403fe0 	ldr	x0, [sp, #120]
    a0017c9c:	97fff8d7 	bl	a0015ff8 <z_abort_thread_timeout>
    a0017ca0:	b0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0017ca4:	910a4000 	add	x0, x0, #0x290
    a0017ca8:	f9002fe0 	str	x0, [sp, #88]
    a0017cac:	b9403be0 	ldr	w0, [sp, #56]
    a0017cb0:	b90033e0 	str	w0, [sp, #48]
	arch_irq_unlock(key.key);
    a0017cb4:	b94033e0 	ldr	w0, [sp, #48]
    a0017cb8:	b90057e0 	str	w0, [sp, #84]
	write_daif(key);
    a0017cbc:	b94057e0 	ldr	w0, [sp, #84]
    a0017cc0:	f90027e0 	str	x0, [sp, #72]
MAKE_REG_HELPER(daif)
    a0017cc4:	f94027e0 	ldr	x0, [sp, #72]
    a0017cc8:	d51b4220 	msr	daif, x0
    a0017ccc:	d503201f 	nop
}
    a0017cd0:	d503201f 	nop
}
    a0017cd4:	d503201f 	nop
	LOCKED(&sched_spinlock) {
    a0017cd8:	52800020 	mov	w0, #0x1                   	// #1
    a0017cdc:	b90043e0 	str	w0, [sp, #64]
    a0017ce0:	b94043e0 	ldr	w0, [sp, #64]
    a0017ce4:	7100001f 	cmp	w0, #0x0
    a0017ce8:	54fffc80 	b.eq	a0017c78 <z_unpend_first_thread+0x50>  // b.none
		}
	}

	return thread;
    a0017cec:	f9403fe0 	ldr	x0, [sp, #120]
}
    a0017cf0:	a8c87bfd 	ldp	x29, x30, [sp], #128
    a0017cf4:	d65f03c0 	ret

00000000a0017cf8 <z_unpend_thread>:

void z_unpend_thread(struct k_thread *thread)
{
    a0017cf8:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
    a0017cfc:	910003fd 	mov	x29, sp
    a0017d00:	f9000fe0 	str	x0, [sp, #24]
    a0017d04:	f9400fe0 	ldr	x0, [sp, #24]
    a0017d08:	f9003fe0 	str	x0, [sp, #120]
	LOCKED(&sched_spinlock) {
    a0017d0c:	b90043ff 	str	wzr, [sp, #64]
    a0017d10:	b0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0017d14:	910a4000 	add	x0, x0, #0x290
    a0017d18:	f9003be0 	str	x0, [sp, #112]
    a0017d1c:	d53b4220 	mrs	x0, daif
    a0017d20:	f90037e0 	str	x0, [sp, #104]
    a0017d24:	f94037e0 	ldr	x0, [sp, #104]
    a0017d28:	d503201f 	nop
	key = read_daif();
    a0017d2c:	b90067e0 	str	w0, [sp, #100]
	__asm__ volatile ("msr DAIFSet, %0"
    a0017d30:	d50342df 	msr	daifset, #0x2
}
    a0017d34:	d503201f 	nop
	return key;
    a0017d38:	b94067e0 	ldr	w0, [sp, #100]
	k.key = arch_irq_lock();
    a0017d3c:	b9002be0 	str	w0, [sp, #40]
	return k;
    a0017d40:	b9402be0 	ldr	w0, [sp, #40]
    a0017d44:	b9003be0 	str	w0, [sp, #56]
    a0017d48:	14000013 	b	a0017d94 <z_unpend_thread+0x9c>
		unpend_thread_no_timeout(thread);
    a0017d4c:	f9403fe0 	ldr	x0, [sp, #120]
    a0017d50:	97fffee8 	bl	a00178f0 <unpend_thread_no_timeout>
    a0017d54:	b0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0017d58:	910a4000 	add	x0, x0, #0x290
    a0017d5c:	f9002fe0 	str	x0, [sp, #88]
    a0017d60:	b9403be0 	ldr	w0, [sp, #56]
    a0017d64:	b90033e0 	str	w0, [sp, #48]
	arch_irq_unlock(key.key);
    a0017d68:	b94033e0 	ldr	w0, [sp, #48]
    a0017d6c:	b90057e0 	str	w0, [sp, #84]
	write_daif(key);
    a0017d70:	b94057e0 	ldr	w0, [sp, #84]
    a0017d74:	f90027e0 	str	x0, [sp, #72]
MAKE_REG_HELPER(daif)
    a0017d78:	f94027e0 	ldr	x0, [sp, #72]
    a0017d7c:	d51b4220 	msr	daif, x0
    a0017d80:	d503201f 	nop
}
    a0017d84:	d503201f 	nop
}
    a0017d88:	d503201f 	nop
	LOCKED(&sched_spinlock) {
    a0017d8c:	52800020 	mov	w0, #0x1                   	// #1
    a0017d90:	b90043e0 	str	w0, [sp, #64]
    a0017d94:	b94043e0 	ldr	w0, [sp, #64]
    a0017d98:	7100001f 	cmp	w0, #0x0
    a0017d9c:	54fffd80 	b.eq	a0017d4c <z_unpend_thread+0x54>  // b.none
}
    a0017da0:	d503201f 	nop
	z_unpend_thread_no_timeout(thread);
	(void)z_abort_thread_timeout(thread);
    a0017da4:	f9400fe0 	ldr	x0, [sp, #24]
    a0017da8:	97fff894 	bl	a0015ff8 <z_abort_thread_timeout>
}
    a0017dac:	d503201f 	nop
    a0017db0:	a8c87bfd 	ldp	x29, x30, [sp], #128
    a0017db4:	d65f03c0 	ret

00000000a0017db8 <z_set_prio>:

/* Priority set utility that does no rescheduling, it just changes the
 * run queue state, returning true if a reschedule is needed later.
 */
bool z_set_prio(struct k_thread *thread, int prio)
{
    a0017db8:	a9b47bfd 	stp	x29, x30, [sp, #-192]!
    a0017dbc:	910003fd 	mov	x29, sp
    a0017dc0:	f9000fe0 	str	x0, [sp, #24]
    a0017dc4:	b90017e1 	str	w1, [sp, #20]
	bool need_sched = 0;
    a0017dc8:	3902ffff 	strb	wzr, [sp, #191]

	LOCKED(&sched_spinlock) {
    a0017dcc:	b9003bff 	str	wzr, [sp, #56]
    a0017dd0:	b0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0017dd4:	910a4000 	add	x0, x0, #0x290
    a0017dd8:	f9005be0 	str	x0, [sp, #176]
    a0017ddc:	d53b4220 	mrs	x0, daif
    a0017de0:	f90057e0 	str	x0, [sp, #168]
    a0017de4:	f94057e0 	ldr	x0, [sp, #168]
    a0017de8:	d503201f 	nop
	key = read_daif();
    a0017dec:	b900a7e0 	str	w0, [sp, #164]
	__asm__ volatile ("msr DAIFSet, %0"
    a0017df0:	d50342df 	msr	daifset, #0x2
}
    a0017df4:	d503201f 	nop
	return key;
    a0017df8:	b940a7e0 	ldr	w0, [sp, #164]
	k.key = arch_irq_lock();
    a0017dfc:	b90023e0 	str	w0, [sp, #32]
	return k;
    a0017e00:	b94023e0 	ldr	w0, [sp, #32]
    a0017e04:	b90033e0 	str	w0, [sp, #48]
    a0017e08:	1400007d 	b	a0017ffc <z_set_prio+0x244>
		need_sched = z_is_thread_ready(thread);
    a0017e0c:	f9400fe0 	ldr	x0, [sp, #24]
    a0017e10:	97fff8d6 	bl	a0016168 <z_is_thread_ready>
    a0017e14:	3902ffe0 	strb	w0, [sp, #191]

		if (need_sched) {
    a0017e18:	3942ffe0 	ldrb	w0, [sp, #191]
    a0017e1c:	7100001f 	cmp	w0, #0x0
    a0017e20:	54000c60 	b.eq	a0017fac <z_set_prio+0x1f4>  // b.none
    a0017e24:	f9400fe0 	ldr	x0, [sp, #24]
    a0017e28:	f90037e0 	str	x0, [sp, #104]
	thread->base.thread_state &= ~_THREAD_QUEUED;
    a0017e2c:	f94037e0 	ldr	x0, [sp, #104]
    a0017e30:	39406400 	ldrb	w0, [x0, #25]
    a0017e34:	12001800 	and	w0, w0, #0x7f
    a0017e38:	12001c01 	and	w1, w0, #0xff
    a0017e3c:	f94037e0 	ldr	x0, [sp, #104]
    a0017e40:	39006401 	strb	w1, [x0, #25]
	if (should_queue_thread(thread)) {
    a0017e44:	f94037e0 	ldr	x0, [sp, #104]
    a0017e48:	97fffac2 	bl	a0016950 <should_queue_thread>
    a0017e4c:	12001c00 	and	w0, w0, #0xff
    a0017e50:	7100001f 	cmp	w0, #0x0
    a0017e54:	54000140 	b.eq	a0017e7c <z_set_prio+0xc4>  // b.none
    a0017e58:	f94037e0 	ldr	x0, [sp, #104]
    a0017e5c:	f90033e0 	str	x0, [sp, #96]
    a0017e60:	f94033e0 	ldr	x0, [sp, #96]
    a0017e64:	f9002fe0 	str	x0, [sp, #88]
	return &_kernel.ready_q.runq;
    a0017e68:	b0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0017e6c:	91004000 	add	x0, x0, #0x10
	_priq_run_remove(thread_runq(thread), thread);
    a0017e70:	f94033e1 	ldr	x1, [sp, #96]
    a0017e74:	94000160 	bl	a00183f4 <z_priq_dumb_remove>
}
    a0017e78:	d503201f 	nop
}
    a0017e7c:	d503201f 	nop
			/* Don't requeue on SMP if it's the running thread */
			if (!IS_ENABLED(CONFIG_SMP) || z_is_thread_queued(thread)) {
				dequeue_thread(thread);
				thread->base.prio = prio;
    a0017e80:	b94017e0 	ldr	w0, [sp, #20]
    a0017e84:	13001c01 	sxtb	w1, w0
    a0017e88:	f9400fe0 	ldr	x0, [sp, #24]
    a0017e8c:	39006801 	strb	w1, [x0, #26]
    a0017e90:	f9400fe0 	ldr	x0, [sp, #24]
    a0017e94:	f9004fe0 	str	x0, [sp, #152]
	thread->base.thread_state |= _THREAD_QUEUED;
    a0017e98:	f9404fe0 	ldr	x0, [sp, #152]
    a0017e9c:	39406400 	ldrb	w0, [x0, #25]
    a0017ea0:	32196000 	orr	w0, w0, #0xffffff80
    a0017ea4:	12001c01 	and	w1, w0, #0xff
    a0017ea8:	f9404fe0 	ldr	x0, [sp, #152]
    a0017eac:	39006401 	strb	w1, [x0, #25]
	if (should_queue_thread(thread)) {
    a0017eb0:	f9404fe0 	ldr	x0, [sp, #152]
    a0017eb4:	97fffaa7 	bl	a0016950 <should_queue_thread>
    a0017eb8:	12001c00 	and	w0, w0, #0xff
    a0017ebc:	7100001f 	cmp	w0, #0x0
    a0017ec0:	540006e0 	b.eq	a0017f9c <z_set_prio+0x1e4>  // b.none
    a0017ec4:	f9404fe0 	ldr	x0, [sp, #152]
    a0017ec8:	f9004be0 	str	x0, [sp, #144]
    a0017ecc:	f9404be0 	ldr	x0, [sp, #144]
    a0017ed0:	f90047e0 	str	x0, [sp, #136]
	return &_kernel.ready_q.runq;
    a0017ed4:	b0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0017ed8:	91004000 	add	x0, x0, #0x10
    a0017edc:	f90043e0 	str	x0, [sp, #128]
    a0017ee0:	f9404be0 	ldr	x0, [sp, #144]
    a0017ee4:	f9003fe0 	str	x0, [sp, #120]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    a0017ee8:	f94043e0 	ldr	x0, [sp, #128]
    a0017eec:	97fff448 	bl	a001500c <sys_dlist_peek_head>
    a0017ef0:	f100001f 	cmp	x0, #0x0
    a0017ef4:	54000080 	b.eq	a0017f04 <z_set_prio+0x14c>  // b.none
    a0017ef8:	f94043e0 	ldr	x0, [sp, #128]
    a0017efc:	97fff444 	bl	a001500c <sys_dlist_peek_head>
    a0017f00:	14000002 	b	a0017f08 <z_set_prio+0x150>
    a0017f04:	d2800000 	mov	x0, #0x0                   	// #0
    a0017f08:	f9003be0 	str	x0, [sp, #112]
    a0017f0c:	1400001c 	b	a0017f7c <z_set_prio+0x1c4>
		if (z_sched_prio_cmp(thread, t) > 0) {
    a0017f10:	f9403be1 	ldr	x1, [sp, #112]
    a0017f14:	f9403fe0 	ldr	x0, [sp, #120]
    a0017f18:	97fffa7a 	bl	a0016900 <z_sched_prio_cmp>
    a0017f1c:	7100001f 	cmp	w0, #0x0
    a0017f20:	540000ad 	b.le	a0017f34 <z_set_prio+0x17c>
			sys_dlist_insert(&t->base.qnode_dlist,
    a0017f24:	f9403be0 	ldr	x0, [sp, #112]
    a0017f28:	f9403fe1 	ldr	x1, [sp, #120]
    a0017f2c:	97fff477 	bl	a0015108 <sys_dlist_insert>
			return;
    a0017f30:	1400001a 	b	a0017f98 <z_set_prio+0x1e0>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    a0017f34:	f9403be0 	ldr	x0, [sp, #112]
    a0017f38:	f100001f 	cmp	x0, #0x0
    a0017f3c:	540001c0 	b.eq	a0017f74 <z_set_prio+0x1bc>  // b.none
    a0017f40:	f9403be0 	ldr	x0, [sp, #112]
    a0017f44:	aa0003e1 	mov	x1, x0
    a0017f48:	f94043e0 	ldr	x0, [sp, #128]
    a0017f4c:	97fff44c 	bl	a001507c <sys_dlist_peek_next>
    a0017f50:	f100001f 	cmp	x0, #0x0
    a0017f54:	540000c0 	b.eq	a0017f6c <z_set_prio+0x1b4>  // b.none
    a0017f58:	f9403be0 	ldr	x0, [sp, #112]
    a0017f5c:	aa0003e1 	mov	x1, x0
    a0017f60:	f94043e0 	ldr	x0, [sp, #128]
    a0017f64:	97fff446 	bl	a001507c <sys_dlist_peek_next>
    a0017f68:	14000004 	b	a0017f78 <z_set_prio+0x1c0>
    a0017f6c:	d2800000 	mov	x0, #0x0                   	// #0
    a0017f70:	14000002 	b	a0017f78 <z_set_prio+0x1c0>
    a0017f74:	d2800000 	mov	x0, #0x0                   	// #0
    a0017f78:	f9003be0 	str	x0, [sp, #112]
    a0017f7c:	f9403be0 	ldr	x0, [sp, #112]
    a0017f80:	f100001f 	cmp	x0, #0x0
    a0017f84:	54fffc61 	b.ne	a0017f10 <z_set_prio+0x158>  // b.any
	sys_dlist_append(pq, &thread->base.qnode_dlist);
    a0017f88:	f9403fe0 	ldr	x0, [sp, #120]
    a0017f8c:	aa0003e1 	mov	x1, x0
    a0017f90:	f94043e0 	ldr	x0, [sp, #128]
    a0017f94:	97fff448 	bl	a00150b4 <sys_dlist_append>
}
    a0017f98:	d503201f 	nop
}
    a0017f9c:	d503201f 	nop
				queue_thread(thread);
			} else {
				thread->base.prio = prio;
			}
			update_cache(1);
    a0017fa0:	52800020 	mov	w0, #0x1                   	// #1
    a0017fa4:	97fffbae 	bl	a0016e5c <update_cache>
    a0017fa8:	14000005 	b	a0017fbc <z_set_prio+0x204>
		} else {
			thread->base.prio = prio;
    a0017fac:	b94017e0 	ldr	w0, [sp, #20]
    a0017fb0:	13001c01 	sxtb	w1, w0
    a0017fb4:	f9400fe0 	ldr	x0, [sp, #24]
    a0017fb8:	39006801 	strb	w1, [x0, #26]
    a0017fbc:	b0000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0017fc0:	910a4000 	add	x0, x0, #0x290
    a0017fc4:	f9002be0 	str	x0, [sp, #80]
    a0017fc8:	b94033e0 	ldr	w0, [sp, #48]
    a0017fcc:	b9002be0 	str	w0, [sp, #40]
	arch_irq_unlock(key.key);
    a0017fd0:	b9402be0 	ldr	w0, [sp, #40]
    a0017fd4:	b9004fe0 	str	w0, [sp, #76]
	write_daif(key);
    a0017fd8:	b9404fe0 	ldr	w0, [sp, #76]
    a0017fdc:	f90023e0 	str	x0, [sp, #64]
MAKE_REG_HELPER(daif)
    a0017fe0:	f94023e0 	ldr	x0, [sp, #64]
    a0017fe4:	d51b4220 	msr	daif, x0
    a0017fe8:	d503201f 	nop
}
    a0017fec:	d503201f 	nop
}
    a0017ff0:	d503201f 	nop
	LOCKED(&sched_spinlock) {
    a0017ff4:	52800020 	mov	w0, #0x1                   	// #1
    a0017ff8:	b9003be0 	str	w0, [sp, #56]
    a0017ffc:	b9403be0 	ldr	w0, [sp, #56]
    a0018000:	7100001f 	cmp	w0, #0x0
    a0018004:	54fff040 	b.eq	a0017e0c <z_set_prio+0x54>  // b.none
		}
	}

	SYS_PORT_TRACING_OBJ_FUNC(k_thread, sched_priority_set, thread, prio);

	return need_sched;
    a0018008:	3942ffe0 	ldrb	w0, [sp, #191]
}
    a001800c:	a8cc7bfd 	ldp	x29, x30, [sp], #192
    a0018010:	d65f03c0 	ret

00000000a0018014 <z_thread_priority_set>:

void z_thread_priority_set(struct k_thread *thread, int prio)
{
    a0018014:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0018018:	910003fd 	mov	x29, sp
    a001801c:	f9000fe0 	str	x0, [sp, #24]
    a0018020:	b90017e1 	str	w1, [sp, #20]
	bool need_sched = z_set_prio(thread, prio);
    a0018024:	b94017e1 	ldr	w1, [sp, #20]
    a0018028:	f9400fe0 	ldr	x0, [sp, #24]
    a001802c:	97ffff63 	bl	a0017db8 <z_set_prio>
    a0018030:	3900bfe0 	strb	w0, [sp, #47]

#if defined(CONFIG_SMP) && defined(CONFIG_SCHED_IPI_SUPPORTED)
	arch_sched_ipi();
#endif

	if (need_sched && _current->base.sched_locked == 0U) {
    a0018034:	3940bfe0 	ldrb	w0, [sp, #47]
    a0018038:	7100001f 	cmp	w0, #0x0
    a001803c:	54000100 	b.eq	a001805c <z_thread_priority_set+0x48>  // b.none
    a0018040:	f0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0018044:	913f8000 	add	x0, x0, #0xfe0
    a0018048:	f9400800 	ldr	x0, [x0, #16]
    a001804c:	39406c00 	ldrb	w0, [x0, #27]
    a0018050:	7100001f 	cmp	w0, #0x0
    a0018054:	54000041 	b.ne	a001805c <z_thread_priority_set+0x48>  // b.any
		z_reschedule_unlocked();
    a0018058:	97fff7f0 	bl	a0016018 <z_reschedule_unlocked>
	}
}
    a001805c:	d503201f 	nop
    a0018060:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0018064:	d65f03c0 	ret

00000000a0018068 <resched>:

static inline bool resched(uint32_t key)
{
    a0018068:	d10083ff 	sub	sp, sp, #0x20
    a001806c:	b9000fe0 	str	w0, [sp, #12]
    a0018070:	b9400fe0 	ldr	w0, [sp, #12]
    a0018074:	b9001fe0 	str	w0, [sp, #28]

static ALWAYS_INLINE bool arch_irq_unlocked(unsigned int key)
{
	/* We only check the (I)RQ bit on the DAIF register */
	return (key & DAIF_IRQ_BIT) == 0;
    a0018078:	b9401fe0 	ldr	w0, [sp, #28]
    a001807c:	92790000 	and	x0, x0, #0x80
    a0018080:	f100001f 	cmp	x0, #0x0
    a0018084:	1a9f17e0 	cset	w0, eq  // eq = none
    a0018088:	12001c00 	and	w0, w0, #0xff
#ifdef CONFIG_SMP
	_current_cpu->swap_ok = 0;
#endif

	return arch_irq_unlocked(key) && !arch_is_in_isr();
    a001808c:	7100001f 	cmp	w0, #0x0
    a0018090:	54000200 	b.eq	a00180d0 <resched+0x68>  // b.none
MAKE_REG_HELPER(tpidrro_el0);
    a0018094:	d53bd060 	mrs	x0, tpidrro_el0
    a0018098:	f9000be0 	str	x0, [sp, #16]
    a001809c:	f9400be0 	ldr	x0, [sp, #16]
    a00180a0:	d503201f 	nop
    a00180a4:	927db000 	and	x0, x0, #0xfffffffffff8
    a00180a8:	b9400000 	ldr	w0, [x0]
    a00180ac:	7100001f 	cmp	w0, #0x0
    a00180b0:	1a9f07e0 	cset	w0, ne  // ne = any
    a00180b4:	12001c00 	and	w0, w0, #0xff
    a00180b8:	52000000 	eor	w0, w0, #0x1
    a00180bc:	12001c00 	and	w0, w0, #0xff
    a00180c0:	7100001f 	cmp	w0, #0x0
    a00180c4:	54000060 	b.eq	a00180d0 <resched+0x68>  // b.none
    a00180c8:	52800020 	mov	w0, #0x1                   	// #1
    a00180cc:	14000002 	b	a00180d4 <resched+0x6c>
    a00180d0:	52800000 	mov	w0, #0x0                   	// #0
    a00180d4:	12000000 	and	w0, w0, #0x1
    a00180d8:	12001c00 	and	w0, w0, #0xff
}
    a00180dc:	910083ff 	add	sp, sp, #0x20
    a00180e0:	d65f03c0 	ret

00000000a00180e4 <need_swap>:
/*
 * Check if the next ready thread is the same as the current thread
 * and save the trip if true.
 */
static inline bool need_swap(void)
{
    a00180e4:	d10043ff 	sub	sp, sp, #0x10
	return true;
#else
	struct k_thread *new_thread;

	/* Check if the next ready thread is the same as the current thread */
	new_thread = _kernel.ready_q.cache;
    a00180e8:	f0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00180ec:	913f8000 	add	x0, x0, #0xfe0
    a00180f0:	f9401400 	ldr	x0, [x0, #40]
    a00180f4:	f90007e0 	str	x0, [sp, #8]
	return new_thread != _current;
    a00180f8:	f0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00180fc:	913f8000 	add	x0, x0, #0xfe0
    a0018100:	f9400800 	ldr	x0, [x0, #16]
    a0018104:	f94007e1 	ldr	x1, [sp, #8]
    a0018108:	eb00003f 	cmp	x1, x0
    a001810c:	1a9f07e0 	cset	w0, ne  // ne = any
    a0018110:	12001c00 	and	w0, w0, #0xff
#endif
}
    a0018114:	910043ff 	add	sp, sp, #0x10
    a0018118:	d65f03c0 	ret

00000000a001811c <z_reschedule>:

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
    a001811c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    a0018120:	910003fd 	mov	x29, sp
    a0018124:	f9000fe0 	str	x0, [sp, #24]
    a0018128:	b90013e1 	str	w1, [sp, #16]
	if (resched(key.key) && need_swap()) {
    a001812c:	b94013e0 	ldr	w0, [sp, #16]
    a0018130:	97ffffce 	bl	a0018068 <resched>
    a0018134:	12001c00 	and	w0, w0, #0xff
    a0018138:	7100001f 	cmp	w0, #0x0
    a001813c:	54000120 	b.eq	a0018160 <z_reschedule+0x44>  // b.none
    a0018140:	97ffffe9 	bl	a00180e4 <need_swap>
    a0018144:	12001c00 	and	w0, w0, #0xff
    a0018148:	7100001f 	cmp	w0, #0x0
    a001814c:	540000a0 	b.eq	a0018160 <z_reschedule+0x44>  // b.none
		z_swap(lock, key);
    a0018150:	b94013e1 	ldr	w1, [sp, #16]
    a0018154:	f9400fe0 	ldr	x0, [sp, #24]
    a0018158:	97fff95d 	bl	a00166cc <z_swap>
    a001815c:	1400000e 	b	a0018194 <z_reschedule+0x78>
    a0018160:	f9400fe0 	ldr	x0, [sp, #24]
    a0018164:	f9001fe0 	str	x0, [sp, #56]
    a0018168:	b94013e0 	ldr	w0, [sp, #16]
    a001816c:	b90023e0 	str	w0, [sp, #32]
	arch_irq_unlock(key.key);
    a0018170:	b94023e0 	ldr	w0, [sp, #32]
    a0018174:	b90037e0 	str	w0, [sp, #52]
	write_daif(key);
    a0018178:	b94037e0 	ldr	w0, [sp, #52]
    a001817c:	f90017e0 	str	x0, [sp, #40]
MAKE_REG_HELPER(daif)
    a0018180:	f94017e0 	ldr	x0, [sp, #40]
    a0018184:	d51b4220 	msr	daif, x0
    a0018188:	d503201f 	nop
}
    a001818c:	d503201f 	nop
}
    a0018190:	d503201f 	nop
	} else {
		k_spin_unlock(lock, key);
	}
}
    a0018194:	d503201f 	nop
    a0018198:	a8c47bfd 	ldp	x29, x30, [sp], #64
    a001819c:	d65f03c0 	ret

00000000a00181a0 <z_reschedule_irqlock>:

void z_reschedule_irqlock(uint32_t key)
{
    a00181a0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a00181a4:	910003fd 	mov	x29, sp
    a00181a8:	b9001fe0 	str	w0, [sp, #28]
	if (resched(key)) {
    a00181ac:	b9401fe0 	ldr	w0, [sp, #28]
    a00181b0:	97ffffae 	bl	a0018068 <resched>
    a00181b4:	12001c00 	and	w0, w0, #0xff
    a00181b8:	7100001f 	cmp	w0, #0x0
    a00181bc:	54000080 	b.eq	a00181cc <z_reschedule_irqlock+0x2c>  // b.none
		z_swap_irqlock(key);
    a00181c0:	b9401fe0 	ldr	w0, [sp, #28]
    a00181c4:	97fff8d4 	bl	a0016514 <z_swap_irqlock>
	} else {
		irq_unlock(key);
	}
}
    a00181c8:	14000009 	b	a00181ec <z_reschedule_irqlock+0x4c>
    a00181cc:	b9401fe0 	ldr	w0, [sp, #28]
    a00181d0:	b9002fe0 	str	w0, [sp, #44]
	write_daif(key);
    a00181d4:	b9402fe0 	ldr	w0, [sp, #44]
    a00181d8:	f90013e0 	str	x0, [sp, #32]
    a00181dc:	f94013e0 	ldr	x0, [sp, #32]
    a00181e0:	d51b4220 	msr	daif, x0
    a00181e4:	d503201f 	nop
}
    a00181e8:	d503201f 	nop
    a00181ec:	d503201f 	nop
    a00181f0:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a00181f4:	d65f03c0 	ret

00000000a00181f8 <k_sched_lock>:

void k_sched_lock(void)
{
    a00181f8:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a00181fc:	910003fd 	mov	x29, sp
	LOCKED(&sched_spinlock) {
    a0018200:	b9002bff 	str	wzr, [sp, #40]
    a0018204:	90000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0018208:	910a4000 	add	x0, x0, #0x290
    a001820c:	f9002fe0 	str	x0, [sp, #88]
    a0018210:	d53b4220 	mrs	x0, daif
    a0018214:	f9002be0 	str	x0, [sp, #80]
    a0018218:	f9402be0 	ldr	x0, [sp, #80]
    a001821c:	d503201f 	nop
	key = read_daif();
    a0018220:	b9004fe0 	str	w0, [sp, #76]
	__asm__ volatile ("msr DAIFSet, %0"
    a0018224:	d50342df 	msr	daifset, #0x2
}
    a0018228:	d503201f 	nop
	return key;
    a001822c:	b9404fe0 	ldr	w0, [sp, #76]
	k.key = arch_irq_lock();
    a0018230:	b90013e0 	str	w0, [sp, #16]
	return k;
    a0018234:	b94013e0 	ldr	w0, [sp, #16]
    a0018238:	b90023e0 	str	w0, [sp, #32]
    a001823c:	14000012 	b	a0018284 <k_sched_lock+0x8c>
		SYS_PORT_TRACING_FUNC(k_thread, sched_lock);

		z_sched_lock();
    a0018240:	97fff89b 	bl	a00164ac <z_sched_lock>
    a0018244:	90000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0018248:	910a4000 	add	x0, x0, #0x290
    a001824c:	f90023e0 	str	x0, [sp, #64]
    a0018250:	b94023e0 	ldr	w0, [sp, #32]
    a0018254:	b9001be0 	str	w0, [sp, #24]
	arch_irq_unlock(key.key);
    a0018258:	b9401be0 	ldr	w0, [sp, #24]
    a001825c:	b9003fe0 	str	w0, [sp, #60]
	write_daif(key);
    a0018260:	b9403fe0 	ldr	w0, [sp, #60]
    a0018264:	f9001be0 	str	x0, [sp, #48]
MAKE_REG_HELPER(daif)
    a0018268:	f9401be0 	ldr	x0, [sp, #48]
    a001826c:	d51b4220 	msr	daif, x0
    a0018270:	d503201f 	nop
}
    a0018274:	d503201f 	nop
}
    a0018278:	d503201f 	nop
	LOCKED(&sched_spinlock) {
    a001827c:	52800020 	mov	w0, #0x1                   	// #1
    a0018280:	b9002be0 	str	w0, [sp, #40]
    a0018284:	b9402be0 	ldr	w0, [sp, #40]
    a0018288:	7100001f 	cmp	w0, #0x0
    a001828c:	54fffda0 	b.eq	a0018240 <k_sched_lock+0x48>  // b.none
	}
}
    a0018290:	d503201f 	nop
    a0018294:	d503201f 	nop
    a0018298:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a001829c:	d65f03c0 	ret

00000000a00182a0 <k_sched_unlock>:

void k_sched_unlock(void)
{
    a00182a0:	a9a27bfd 	stp	x29, x30, [sp, #-480]!
    a00182a4:	910003fd 	mov	x29, sp
	LOCKED(&sched_spinlock) {
    a00182a8:	b901abff 	str	wzr, [sp, #424]
    a00182ac:	90000180 	adrp	x0, a0048000 <_kernel+0x20>
    a00182b0:	910a4000 	add	x0, x0, #0x290
    a00182b4:	f900dbe0 	str	x0, [sp, #432]
    a00182b8:	d53b4220 	mrs	x0, daif
    a00182bc:	f900dfe0 	str	x0, [sp, #440]
    a00182c0:	f940dfe0 	ldr	x0, [sp, #440]
    a00182c4:	d503201f 	nop
	key = read_daif();
    a00182c8:	b901c7e0 	str	w0, [sp, #452]
	__asm__ volatile ("msr DAIFSet, %0"
    a00182cc:	d50342df 	msr	daifset, #0x2
}
    a00182d0:	d503201f 	nop
	return key;
    a00182d4:	b941c7e0 	ldr	w0, [sp, #452]
	k.key = arch_irq_lock();
    a00182d8:	b90193e0 	str	w0, [sp, #400]
	return k;
    a00182dc:	b94193e0 	ldr	w0, [sp, #400]
    a00182e0:	b901a3e0 	str	w0, [sp, #416]
    a00182e4:	1400001a 	b	a001834c <k_sched_unlock+0xac>
		__ASSERT(_current->base.sched_locked != 0U, "");
		__ASSERT(!arch_is_in_isr(), "");

		++_current->base.sched_locked;
    a00182e8:	f0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00182ec:	913f8000 	add	x0, x0, #0xfe0
    a00182f0:	f9400800 	ldr	x0, [x0, #16]
    a00182f4:	39406c01 	ldrb	w1, [x0, #27]
    a00182f8:	11000421 	add	w1, w1, #0x1
    a00182fc:	12001c21 	and	w1, w1, #0xff
    a0018300:	39006c01 	strb	w1, [x0, #27]
		update_cache(0);
    a0018304:	52800000 	mov	w0, #0x0                   	// #0
    a0018308:	97fffad5 	bl	a0016e5c <update_cache>
    a001830c:	90000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0018310:	910a4000 	add	x0, x0, #0x290
    a0018314:	f900e7e0 	str	x0, [sp, #456]
    a0018318:	b941a3e0 	ldr	w0, [sp, #416]
    a001831c:	b9019be0 	str	w0, [sp, #408]
	arch_irq_unlock(key.key);
    a0018320:	b9419be0 	ldr	w0, [sp, #408]
    a0018324:	b901dfe0 	str	w0, [sp, #476]
	write_daif(key);
    a0018328:	b941dfe0 	ldr	w0, [sp, #476]
    a001832c:	f900ebe0 	str	x0, [sp, #464]
MAKE_REG_HELPER(daif)
    a0018330:	f940ebe0 	ldr	x0, [sp, #464]
    a0018334:	d51b4220 	msr	daif, x0
    a0018338:	d503201f 	nop
}
    a001833c:	d503201f 	nop
}
    a0018340:	d503201f 	nop
	LOCKED(&sched_spinlock) {
    a0018344:	52800020 	mov	w0, #0x1                   	// #1
    a0018348:	b901abe0 	str	w0, [sp, #424]
    a001834c:	b941abe0 	ldr	w0, [sp, #424]
    a0018350:	7100001f 	cmp	w0, #0x0
    a0018354:	54fffca0 	b.eq	a00182e8 <k_sched_unlock+0x48>  // b.none
	LOG_DBG("scheduler unlocked (%p:%d)",
		_current, _current->base.sched_locked);

	SYS_PORT_TRACING_FUNC(k_thread, sched_unlock);

	z_reschedule_unlocked();
    a0018358:	97fff730 	bl	a0016018 <z_reschedule_unlocked>
}
    a001835c:	d503201f 	nop
    a0018360:	a8de7bfd 	ldp	x29, x30, [sp], #480
    a0018364:	d65f03c0 	ret

00000000a0018368 <z_swap_next_thread>:
struct k_thread *z_swap_next_thread(void)
{
#ifdef CONFIG_SMP
	return next_up();
#else
	return _kernel.ready_q.cache;
    a0018368:	f0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001836c:	913f8000 	add	x0, x0, #0xfe0
    a0018370:	f9401400 	ldr	x0, [x0, #40]
#endif
}
    a0018374:	d65f03c0 	ret

00000000a0018378 <set_current>:

#ifdef CONFIG_USE_SWITCH
/* Just a wrapper around _current = xxx with tracing */
static inline void set_current(struct k_thread *new_thread)
{
    a0018378:	d10043ff 	sub	sp, sp, #0x10
    a001837c:	f90007e0 	str	x0, [sp, #8]
	z_thread_mark_switched_out();
	_current_cpu->current = new_thread;
    a0018380:	f0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0018384:	913f8000 	add	x0, x0, #0xfe0
    a0018388:	f94007e1 	ldr	x1, [sp, #8]
    a001838c:	f9000801 	str	x1, [x0, #16]
}
    a0018390:	d503201f 	nop
    a0018394:	910043ff 	add	sp, sp, #0x10
    a0018398:	d65f03c0 	ret

00000000a001839c <z_get_next_switch_handle>:

void *z_get_next_switch_handle(void *interrupted)
{
    a001839c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a00183a0:	910003fd 	mov	x29, sp
    a00183a4:	f9000fe0 	str	x0, [sp, #24]
			new_thread->switch_handle = NULL;
		}
	}
	return ret;
#else
	z_sched_usage_switch(_kernel.ready_q.cache);
    a00183a8:	f0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00183ac:	913f8000 	add	x0, x0, #0xfe0
    a00183b0:	f9401400 	ldr	x0, [x0, #40]
    a00183b4:	97fff847 	bl	a00164d0 <z_sched_usage_switch>
	_current->switch_handle = interrupted;
    a00183b8:	f0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00183bc:	913f8000 	add	x0, x0, #0xfe0
    a00183c0:	f9400800 	ldr	x0, [x0, #16]
    a00183c4:	f9400fe1 	ldr	x1, [sp, #24]
    a00183c8:	f9008c01 	str	x1, [x0, #280]
	set_current(_kernel.ready_q.cache);
    a00183cc:	f0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00183d0:	913f8000 	add	x0, x0, #0xfe0
    a00183d4:	f9401400 	ldr	x0, [x0, #40]
    a00183d8:	97ffffe8 	bl	a0018378 <set_current>
	return _current->switch_handle;
    a00183dc:	f0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00183e0:	913f8000 	add	x0, x0, #0xfe0
    a00183e4:	f9400800 	ldr	x0, [x0, #16]
    a00183e8:	f9408c00 	ldr	x0, [x0, #280]
#endif
}
    a00183ec:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a00183f0:	d65f03c0 	ret

00000000a00183f4 <z_priq_dumb_remove>:
#endif

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
    a00183f4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a00183f8:	910003fd 	mov	x29, sp
    a00183fc:	f9000fe0 	str	x0, [sp, #24]
    a0018400:	f9000be1 	str	x1, [sp, #16]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
    a0018404:	f9400be0 	ldr	x0, [sp, #16]
    a0018408:	97fff355 	bl	a001515c <sys_dlist_remove>
}
    a001840c:	d503201f 	nop
    a0018410:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0018414:	d65f03c0 	ret

00000000a0018418 <z_priq_dumb_best>:

struct k_thread *z_priq_dumb_best(sys_dlist_t *pq)
{
    a0018418:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a001841c:	910003fd 	mov	x29, sp
    a0018420:	f9000fe0 	str	x0, [sp, #24]
	struct k_thread *thread = NULL;
    a0018424:	f90017ff 	str	xzr, [sp, #40]
	sys_dnode_t *n = sys_dlist_peek_head(pq);
    a0018428:	f9400fe0 	ldr	x0, [sp, #24]
    a001842c:	97fff2f8 	bl	a001500c <sys_dlist_peek_head>
    a0018430:	f90013e0 	str	x0, [sp, #32]

	if (n != NULL) {
    a0018434:	f94013e0 	ldr	x0, [sp, #32]
    a0018438:	f100001f 	cmp	x0, #0x0
    a001843c:	54000060 	b.eq	a0018448 <z_priq_dumb_best+0x30>  // b.none
		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
    a0018440:	f94013e0 	ldr	x0, [sp, #32]
    a0018444:	f90017e0 	str	x0, [sp, #40]
	}
	return thread;
    a0018448:	f94017e0 	ldr	x0, [sp, #40]
}
    a001844c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0018450:	d65f03c0 	ret

00000000a0018454 <z_unpend_all>:
	}
	return thread;
}

int z_unpend_all(_wait_q_t *wait_q)
{
    a0018454:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0018458:	910003fd 	mov	x29, sp
    a001845c:	f9000fe0 	str	x0, [sp, #24]
	int need_sched = 0;
    a0018460:	b9002fff 	str	wzr, [sp, #44]
	struct k_thread *thread;

	while ((thread = z_waitq_head(wait_q)) != NULL) {
    a0018464:	14000007 	b	a0018480 <z_unpend_all+0x2c>
		z_unpend_thread(thread);
    a0018468:	f94013e0 	ldr	x0, [sp, #32]
    a001846c:	97fffe23 	bl	a0017cf8 <z_unpend_thread>
		z_ready_thread(thread);
    a0018470:	f94013e0 	ldr	x0, [sp, #32]
    a0018474:	97fffb1f 	bl	a00170f0 <z_ready_thread>
		need_sched = 1;
    a0018478:	52800020 	mov	w0, #0x1                   	// #1
    a001847c:	b9002fe0 	str	w0, [sp, #44]
	while ((thread = z_waitq_head(wait_q)) != NULL) {
    a0018480:	f9400fe0 	ldr	x0, [sp, #24]
    a0018484:	97fff818 	bl	a00164e4 <z_waitq_head>
    a0018488:	f90013e0 	str	x0, [sp, #32]
    a001848c:	f94013e0 	ldr	x0, [sp, #32]
    a0018490:	f100001f 	cmp	x0, #0x0
    a0018494:	54fffea1 	b.ne	a0018468 <z_unpend_all+0x14>  // b.any
	}

	return need_sched;
    a0018498:	b9402fe0 	ldr	w0, [sp, #44]
}
    a001849c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a00184a0:	d65f03c0 	ret

00000000a00184a4 <init_ready_q>:

void init_ready_q(struct _ready_q *rq)
{
    a00184a4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a00184a8:	910003fd 	mov	x29, sp
    a00184ac:	f9000fe0 	str	x0, [sp, #24]
#elif defined(CONFIG_SCHED_MULTIQ)
	for (int i = 0; i < ARRAY_SIZE(_kernel.ready_q.runq.queues); i++) {
		sys_dlist_init(&rq->runq.queues[i]);
	}
#else
	sys_dlist_init(&rq->runq);
    a00184b0:	f9400fe0 	ldr	x0, [sp, #24]
    a00184b4:	91002000 	add	x0, x0, #0x8
    a00184b8:	97fff2ae 	bl	a0014f70 <sys_dlist_init>
#endif
}
    a00184bc:	d503201f 	nop
    a00184c0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a00184c4:	d65f03c0 	ret

00000000a00184c8 <z_sched_init>:

void z_sched_init(void)
{
    a00184c8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    a00184cc:	910003fd 	mov	x29, sp
#ifdef CONFIG_SCHED_CPU_MASK_PIN_ONLY
	for (int i = 0; i < CONFIG_MP_NUM_CPUS; i++) {
		init_ready_q(&_kernel.cpus[i].ready_q);
	}
#else
	init_ready_q(&_kernel.ready_q);
    a00184d0:	90000180 	adrp	x0, a0048000 <_kernel+0x20>
    a00184d4:	91002000 	add	x0, x0, #0x8
    a00184d8:	97fffff3 	bl	a00184a4 <init_ready_q>
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
    a00184dc:	52800001 	mov	w1, #0x0                   	// #0
    a00184e0:	52800000 	mov	w0, #0x0                   	// #0
    a00184e4:	97fff9a7 	bl	a0016b80 <k_sched_time_slice_set>
		CONFIG_TIMESLICE_PRIORITY);
#endif
}
    a00184e8:	d503201f 	nop
    a00184ec:	a8c17bfd 	ldp	x29, x30, [sp], #16
    a00184f0:	d65f03c0 	ret

00000000a00184f4 <z_impl_k_thread_priority_get>:

int z_impl_k_thread_priority_get(k_tid_t thread)
{
    a00184f4:	d10043ff 	sub	sp, sp, #0x10
    a00184f8:	f90007e0 	str	x0, [sp, #8]
	return thread->base.prio;
    a00184fc:	f94007e0 	ldr	x0, [sp, #8]
    a0018500:	39c06800 	ldrsb	w0, [x0, #26]
}
    a0018504:	910043ff 	add	sp, sp, #0x10
    a0018508:	d65f03c0 	ret

00000000a001850c <z_vrfy_k_thread_priority_get>:

#ifdef CONFIG_USERSPACE
static inline int z_vrfy_k_thread_priority_get(k_tid_t thread)
{
    a001850c:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a0018510:	910003fd 	mov	x29, sp
    a0018514:	f9000fe0 	str	x0, [sp, #24]
	Z_OOPS(Z_SYSCALL_OBJ(thread, K_OBJ_THREAD));
    a0018518:	f9400fe0 	ldr	x0, [sp, #24]
    a001851c:	94001143 	bl	a001ca28 <z_object_find>
    a0018520:	52800003 	mov	w3, #0x0                   	// #0
    a0018524:	52800122 	mov	w2, #0x9                   	// #9
    a0018528:	f9400fe1 	ldr	x1, [sp, #24]
    a001852c:	97fff8d9 	bl	a0016890 <z_obj_validation_check>
    a0018530:	7100001f 	cmp	w0, #0x0
    a0018534:	1a9f07e0 	cset	w0, ne  // ne = any
    a0018538:	39063fe0 	strb	w0, [sp, #399]
    a001853c:	39463fe0 	ldrb	w0, [sp, #399]
    a0018540:	7100001f 	cmp	w0, #0x0
    a0018544:	39463fe0 	ldrb	w0, [sp, #399]
    a0018548:	7100001f 	cmp	w0, #0x0
    a001854c:	540000c0 	b.eq	a0018564 <z_vrfy_k_thread_priority_get+0x58>  // b.none
    a0018550:	f0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0018554:	913f8000 	add	x0, x0, #0xfe0
    a0018558:	f9400800 	ldr	x0, [x0, #16]
    a001855c:	f9408400 	ldr	x0, [x0, #264]
    a0018560:	97ffc2fe 	bl	a0009158 <arch_syscall_oops>
	return z_impl_k_thread_priority_get(thread);
    a0018564:	f9400fe0 	ldr	x0, [sp, #24]
    a0018568:	97ffffe3 	bl	a00184f4 <z_impl_k_thread_priority_get>
}
    a001856c:	a8d97bfd 	ldp	x29, x30, [sp], #400
    a0018570:	d65f03c0 	ret

00000000a0018574 <z_mrsh_k_thread_priority_get>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_thread_priority_get(k_tid_t thread);
uintptr_t z_mrsh_k_thread_priority_get(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a0018574:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a0018578:	910003fd 	mov	x29, sp
    a001857c:	f90027e0 	str	x0, [sp, #72]
    a0018580:	f90023e1 	str	x1, [sp, #64]
    a0018584:	f9001fe2 	str	x2, [sp, #56]
    a0018588:	f9001be3 	str	x3, [sp, #48]
    a001858c:	f90017e4 	str	x4, [sp, #40]
    a0018590:	f90013e5 	str	x5, [sp, #32]
    a0018594:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a0018598:	f0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001859c:	913f8000 	add	x0, x0, #0xfe0
    a00185a0:	f9400800 	ldr	x0, [x0, #16]
    a00185a4:	f9400fe1 	ldr	x1, [sp, #24]
    a00185a8:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_thread_priority_get(*(k_tid_t*)&arg0)
    a00185ac:	910123e0 	add	x0, sp, #0x48
    a00185b0:	f9400000 	ldr	x0, [x0]
    a00185b4:	97ffffd6 	bl	a001850c <z_vrfy_k_thread_priority_get>
    a00185b8:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a00185bc:	f0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00185c0:	913f8000 	add	x0, x0, #0xfe0
    a00185c4:	f9400800 	ldr	x0, [x0, #16]
    a00185c8:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a00185cc:	b9805fe0 	ldrsw	x0, [sp, #92]
}
    a00185d0:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a00185d4:	d65f03c0 	ret

00000000a00185d8 <z_impl_k_thread_priority_set>:
#include <syscalls/k_thread_priority_get_mrsh.c>
#endif

void z_impl_k_thread_priority_set(k_tid_t thread, int prio)
{
    a00185d8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a00185dc:	910003fd 	mov	x29, sp
    a00185e0:	f9000fe0 	str	x0, [sp, #24]
    a00185e4:	b90017e1 	str	w1, [sp, #20]
	 * keep track of it) and idle cannot change its priority.
	 */
	Z_ASSERT_VALID_PRIO(prio, NULL);
	__ASSERT(!arch_is_in_isr(), "");

	struct k_thread *th = (struct k_thread *)thread;
    a00185e8:	f9400fe0 	ldr	x0, [sp, #24]
    a00185ec:	f90017e0 	str	x0, [sp, #40]

	z_thread_priority_set(th, prio);
    a00185f0:	b94017e1 	ldr	w1, [sp, #20]
    a00185f4:	f94017e0 	ldr	x0, [sp, #40]
    a00185f8:	97fffe87 	bl	a0018014 <z_thread_priority_set>
}
    a00185fc:	d503201f 	nop
    a0018600:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0018604:	d65f03c0 	ret

00000000a0018608 <z_vrfy_k_thread_priority_set>:

#ifdef CONFIG_USERSPACE
static inline void z_vrfy_k_thread_priority_set(k_tid_t thread, int prio)
{
    a0018608:	d10ac3ff 	sub	sp, sp, #0x2b0
    a001860c:	a9007bfd 	stp	x29, x30, [sp]
    a0018610:	910003fd 	mov	x29, sp
    a0018614:	f9000fe0 	str	x0, [sp, #24]
    a0018618:	b90017e1 	str	w1, [sp, #20]
	Z_OOPS(Z_SYSCALL_OBJ(thread, K_OBJ_THREAD));
    a001861c:	f9400fe0 	ldr	x0, [sp, #24]
    a0018620:	94001102 	bl	a001ca28 <z_object_find>
    a0018624:	52800003 	mov	w3, #0x0                   	// #0
    a0018628:	52800122 	mov	w2, #0x9                   	// #9
    a001862c:	f9400fe1 	ldr	x1, [sp, #24]
    a0018630:	97fff898 	bl	a0016890 <z_obj_validation_check>
    a0018634:	7100001f 	cmp	w0, #0x0
    a0018638:	1a9f07e0 	cset	w0, ne  // ne = any
    a001863c:	390ab7e0 	strb	w0, [sp, #685]
    a0018640:	394ab7e0 	ldrb	w0, [sp, #685]
    a0018644:	7100001f 	cmp	w0, #0x0
    a0018648:	394ab7e0 	ldrb	w0, [sp, #685]
    a001864c:	7100001f 	cmp	w0, #0x0
    a0018650:	540000c0 	b.eq	a0018668 <z_vrfy_k_thread_priority_set+0x60>  // b.none
    a0018654:	f0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0018658:	913f8000 	add	x0, x0, #0xfe0
    a001865c:	f9400800 	ldr	x0, [x0, #16]
    a0018660:	f9408400 	ldr	x0, [x0, #264]
    a0018664:	97ffc2bd 	bl	a0009158 <arch_syscall_oops>
	Z_OOPS(Z_SYSCALL_VERIFY_MSG(_is_valid_prio(prio, NULL),
    a0018668:	d2800001 	mov	x1, #0x0                   	// #0
    a001866c:	b94017e0 	ldr	w0, [sp, #20]
    a0018670:	97fff76a 	bl	a0016418 <_is_valid_prio>
    a0018674:	12001c00 	and	w0, w0, #0xff
    a0018678:	7100001f 	cmp	w0, #0x0
    a001867c:	1a9f07e0 	cset	w0, ne  // ne = any
    a0018680:	12001c00 	and	w0, w0, #0xff
    a0018684:	52000000 	eor	w0, w0, #0x1
    a0018688:	12001c00 	and	w0, w0, #0xff
    a001868c:	390abbe0 	strb	w0, [sp, #686]
    a0018690:	394abbe0 	ldrb	w0, [sp, #686]
    a0018694:	12000000 	and	w0, w0, #0x1
    a0018698:	390abbe0 	strb	w0, [sp, #686]
    a001869c:	394abbe0 	ldrb	w0, [sp, #686]
    a00186a0:	7100001f 	cmp	w0, #0x0
    a00186a4:	394abbe0 	ldrb	w0, [sp, #686]
    a00186a8:	7100001f 	cmp	w0, #0x0
    a00186ac:	540000c0 	b.eq	a00186c4 <z_vrfy_k_thread_priority_set+0xbc>  // b.none
    a00186b0:	f0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00186b4:	913f8000 	add	x0, x0, #0xfe0
    a00186b8:	f9400800 	ldr	x0, [x0, #16]
    a00186bc:	f9408400 	ldr	x0, [x0, #264]
    a00186c0:	97ffc2a6 	bl	a0009158 <arch_syscall_oops>
				    "invalid thread priority %d", prio));
	Z_OOPS(Z_SYSCALL_VERIFY_MSG((int8_t)prio >= thread->base.prio,
    a00186c4:	b94017e0 	ldr	w0, [sp, #20]
    a00186c8:	13001c01 	sxtb	w1, w0
    a00186cc:	f9400fe0 	ldr	x0, [sp, #24]
    a00186d0:	39c06800 	ldrsb	w0, [x0, #26]
    a00186d4:	6b00003f 	cmp	w1, w0
    a00186d8:	1a9fa7e0 	cset	w0, lt  // lt = tstop
    a00186dc:	390abfe0 	strb	w0, [sp, #687]
    a00186e0:	394abfe0 	ldrb	w0, [sp, #687]
    a00186e4:	7100001f 	cmp	w0, #0x0
    a00186e8:	394abfe0 	ldrb	w0, [sp, #687]
    a00186ec:	7100001f 	cmp	w0, #0x0
    a00186f0:	540000c0 	b.eq	a0018708 <z_vrfy_k_thread_priority_set+0x100>  // b.none
    a00186f4:	f0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00186f8:	913f8000 	add	x0, x0, #0xfe0
    a00186fc:	f9400800 	ldr	x0, [x0, #16]
    a0018700:	f9408400 	ldr	x0, [x0, #264]
    a0018704:	97ffc295 	bl	a0009158 <arch_syscall_oops>
				    "thread priority may only be downgraded (%d < %d)",
				    prio, thread->base.prio));

	z_impl_k_thread_priority_set(thread, prio);
    a0018708:	b94017e1 	ldr	w1, [sp, #20]
    a001870c:	f9400fe0 	ldr	x0, [sp, #24]
    a0018710:	97ffffb2 	bl	a00185d8 <z_impl_k_thread_priority_set>
}
    a0018714:	d503201f 	nop
    a0018718:	a9407bfd 	ldp	x29, x30, [sp]
    a001871c:	910ac3ff 	add	sp, sp, #0x2b0
    a0018720:	d65f03c0 	ret

00000000a0018724 <z_mrsh_k_thread_priority_set>:
#include <syscalls/kernel.h>

extern void z_vrfy_k_thread_priority_set(k_tid_t thread, int prio);
uintptr_t z_mrsh_k_thread_priority_set(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a0018724:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a0018728:	910003fd 	mov	x29, sp
    a001872c:	f90027e0 	str	x0, [sp, #72]
    a0018730:	f90023e1 	str	x1, [sp, #64]
    a0018734:	f9001fe2 	str	x2, [sp, #56]
    a0018738:	f9001be3 	str	x3, [sp, #48]
    a001873c:	f90017e4 	str	x4, [sp, #40]
    a0018740:	f90013e5 	str	x5, [sp, #32]
    a0018744:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a0018748:	f0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001874c:	913f8000 	add	x0, x0, #0xfe0
    a0018750:	f9400800 	ldr	x0, [x0, #16]
    a0018754:	f9400fe1 	ldr	x1, [sp, #24]
    a0018758:	f9008401 	str	x1, [x0, #264]
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_thread_priority_set(*(k_tid_t*)&arg0, *(int*)&arg1)
    a001875c:	910123e0 	add	x0, sp, #0x48
    a0018760:	f9400002 	ldr	x2, [x0]
    a0018764:	910103e0 	add	x0, sp, #0x40
    a0018768:	b9400000 	ldr	w0, [x0]
    a001876c:	2a0003e1 	mov	w1, w0
    a0018770:	aa0203e0 	mov	x0, x2
    a0018774:	97ffffa5 	bl	a0018608 <z_vrfy_k_thread_priority_set>
;
	_current->syscall_frame = NULL;
    a0018778:	f0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001877c:	913f8000 	add	x0, x0, #0xfe0
    a0018780:	f9400800 	ldr	x0, [x0, #16]
    a0018784:	f900841f 	str	xzr, [x0, #264]
	return 0;
    a0018788:	d2800000 	mov	x0, #0x0                   	// #0
}
    a001878c:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a0018790:	d65f03c0 	ret

00000000a0018794 <z_impl_k_yield>:
#include <syscalls/k_thread_deadline_set_mrsh.c>
#endif
#endif

void z_impl_k_yield(void)
{
    a0018794:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
    a0018798:	910003fd 	mov	x29, sp
    a001879c:	90000180 	adrp	x0, a0048000 <_kernel+0x20>
    a00187a0:	910a4000 	add	x0, x0, #0x290
    a00187a4:	f9003fe0 	str	x0, [sp, #120]
    a00187a8:	d53b4220 	mrs	x0, daif
    a00187ac:	f9003be0 	str	x0, [sp, #112]
    a00187b0:	f9403be0 	ldr	x0, [sp, #112]
    a00187b4:	d503201f 	nop
	key = read_daif();
    a00187b8:	b9006fe0 	str	w0, [sp, #108]
	__asm__ volatile ("msr DAIFSet, %0"
    a00187bc:	d50342df 	msr	daifset, #0x2
}
    a00187c0:	d503201f 	nop
	return key;
    a00187c4:	b9406fe0 	ldr	w0, [sp, #108]
	k.key = arch_irq_lock();
    a00187c8:	b90013e0 	str	w0, [sp, #16]
	return k;
    a00187cc:	b94013e0 	ldr	w0, [sp, #16]
    a00187d0:	b9001be0 	str	w0, [sp, #24]

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if (!IS_ENABLED(CONFIG_SMP) ||
	    z_is_thread_queued(_current)) {
		dequeue_thread(_current);
    a00187d4:	f0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00187d8:	913f8000 	add	x0, x0, #0xfe0
    a00187dc:	f9400800 	ldr	x0, [x0, #16]
    a00187e0:	f9001be0 	str	x0, [sp, #48]
	thread->base.thread_state &= ~_THREAD_QUEUED;
    a00187e4:	f9401be0 	ldr	x0, [sp, #48]
    a00187e8:	39406400 	ldrb	w0, [x0, #25]
    a00187ec:	12001800 	and	w0, w0, #0x7f
    a00187f0:	12001c01 	and	w1, w0, #0xff
    a00187f4:	f9401be0 	ldr	x0, [sp, #48]
    a00187f8:	39006401 	strb	w1, [x0, #25]
	if (should_queue_thread(thread)) {
    a00187fc:	f9401be0 	ldr	x0, [sp, #48]
    a0018800:	97fff854 	bl	a0016950 <should_queue_thread>
    a0018804:	12001c00 	and	w0, w0, #0xff
    a0018808:	7100001f 	cmp	w0, #0x0
    a001880c:	54000140 	b.eq	a0018834 <z_impl_k_yield+0xa0>  // b.none
    a0018810:	f9401be0 	ldr	x0, [sp, #48]
    a0018814:	f90017e0 	str	x0, [sp, #40]
    a0018818:	f94017e0 	ldr	x0, [sp, #40]
    a001881c:	f90013e0 	str	x0, [sp, #32]
	return &_kernel.ready_q.runq;
    a0018820:	90000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0018824:	91004000 	add	x0, x0, #0x10
	_priq_run_remove(thread_runq(thread), thread);
    a0018828:	f94017e1 	ldr	x1, [sp, #40]
    a001882c:	97fffef2 	bl	a00183f4 <z_priq_dumb_remove>
}
    a0018830:	d503201f 	nop
}
    a0018834:	d503201f 	nop
	}
	queue_thread(_current);
    a0018838:	f0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001883c:	913f8000 	add	x0, x0, #0xfe0
    a0018840:	f9400800 	ldr	x0, [x0, #16]
    a0018844:	f90033e0 	str	x0, [sp, #96]
	thread->base.thread_state |= _THREAD_QUEUED;
    a0018848:	f94033e0 	ldr	x0, [sp, #96]
    a001884c:	39406400 	ldrb	w0, [x0, #25]
    a0018850:	32196000 	orr	w0, w0, #0xffffff80
    a0018854:	12001c01 	and	w1, w0, #0xff
    a0018858:	f94033e0 	ldr	x0, [sp, #96]
    a001885c:	39006401 	strb	w1, [x0, #25]
	if (should_queue_thread(thread)) {
    a0018860:	f94033e0 	ldr	x0, [sp, #96]
    a0018864:	97fff83b 	bl	a0016950 <should_queue_thread>
    a0018868:	12001c00 	and	w0, w0, #0xff
    a001886c:	7100001f 	cmp	w0, #0x0
    a0018870:	540006e0 	b.eq	a001894c <z_impl_k_yield+0x1b8>  // b.none
    a0018874:	f94033e0 	ldr	x0, [sp, #96]
    a0018878:	f9002fe0 	str	x0, [sp, #88]
    a001887c:	f9402fe0 	ldr	x0, [sp, #88]
    a0018880:	f9002be0 	str	x0, [sp, #80]
	return &_kernel.ready_q.runq;
    a0018884:	90000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0018888:	91004000 	add	x0, x0, #0x10
    a001888c:	f90027e0 	str	x0, [sp, #72]
    a0018890:	f9402fe0 	ldr	x0, [sp, #88]
    a0018894:	f90023e0 	str	x0, [sp, #64]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    a0018898:	f94027e0 	ldr	x0, [sp, #72]
    a001889c:	97fff1dc 	bl	a001500c <sys_dlist_peek_head>
    a00188a0:	f100001f 	cmp	x0, #0x0
    a00188a4:	54000080 	b.eq	a00188b4 <z_impl_k_yield+0x120>  // b.none
    a00188a8:	f94027e0 	ldr	x0, [sp, #72]
    a00188ac:	97fff1d8 	bl	a001500c <sys_dlist_peek_head>
    a00188b0:	14000002 	b	a00188b8 <z_impl_k_yield+0x124>
    a00188b4:	d2800000 	mov	x0, #0x0                   	// #0
    a00188b8:	f9001fe0 	str	x0, [sp, #56]
    a00188bc:	1400001c 	b	a001892c <z_impl_k_yield+0x198>
		if (z_sched_prio_cmp(thread, t) > 0) {
    a00188c0:	f9401fe1 	ldr	x1, [sp, #56]
    a00188c4:	f94023e0 	ldr	x0, [sp, #64]
    a00188c8:	97fff80e 	bl	a0016900 <z_sched_prio_cmp>
    a00188cc:	7100001f 	cmp	w0, #0x0
    a00188d0:	540000ad 	b.le	a00188e4 <z_impl_k_yield+0x150>
			sys_dlist_insert(&t->base.qnode_dlist,
    a00188d4:	f9401fe0 	ldr	x0, [sp, #56]
    a00188d8:	f94023e1 	ldr	x1, [sp, #64]
    a00188dc:	97fff20b 	bl	a0015108 <sys_dlist_insert>
			return;
    a00188e0:	1400001a 	b	a0018948 <z_impl_k_yield+0x1b4>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    a00188e4:	f9401fe0 	ldr	x0, [sp, #56]
    a00188e8:	f100001f 	cmp	x0, #0x0
    a00188ec:	540001c0 	b.eq	a0018924 <z_impl_k_yield+0x190>  // b.none
    a00188f0:	f9401fe0 	ldr	x0, [sp, #56]
    a00188f4:	aa0003e1 	mov	x1, x0
    a00188f8:	f94027e0 	ldr	x0, [sp, #72]
    a00188fc:	97fff1e0 	bl	a001507c <sys_dlist_peek_next>
    a0018900:	f100001f 	cmp	x0, #0x0
    a0018904:	540000c0 	b.eq	a001891c <z_impl_k_yield+0x188>  // b.none
    a0018908:	f9401fe0 	ldr	x0, [sp, #56]
    a001890c:	aa0003e1 	mov	x1, x0
    a0018910:	f94027e0 	ldr	x0, [sp, #72]
    a0018914:	97fff1da 	bl	a001507c <sys_dlist_peek_next>
    a0018918:	14000004 	b	a0018928 <z_impl_k_yield+0x194>
    a001891c:	d2800000 	mov	x0, #0x0                   	// #0
    a0018920:	14000002 	b	a0018928 <z_impl_k_yield+0x194>
    a0018924:	d2800000 	mov	x0, #0x0                   	// #0
    a0018928:	f9001fe0 	str	x0, [sp, #56]
    a001892c:	f9401fe0 	ldr	x0, [sp, #56]
    a0018930:	f100001f 	cmp	x0, #0x0
    a0018934:	54fffc61 	b.ne	a00188c0 <z_impl_k_yield+0x12c>  // b.any
	sys_dlist_append(pq, &thread->base.qnode_dlist);
    a0018938:	f94023e0 	ldr	x0, [sp, #64]
    a001893c:	aa0003e1 	mov	x1, x0
    a0018940:	f94027e0 	ldr	x0, [sp, #72]
    a0018944:	97fff1dc 	bl	a00150b4 <sys_dlist_append>
}
    a0018948:	d503201f 	nop
}
    a001894c:	d503201f 	nop
	update_cache(1);
    a0018950:	52800020 	mov	w0, #0x1                   	// #1
    a0018954:	97fff942 	bl	a0016e5c <update_cache>
	z_swap(&sched_spinlock, key);
    a0018958:	b9401be1 	ldr	w1, [sp, #24]
    a001895c:	90000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0018960:	910a4000 	add	x0, x0, #0x290
    a0018964:	97fff75a 	bl	a00166cc <z_swap>
}
    a0018968:	d503201f 	nop
    a001896c:	a8c87bfd 	ldp	x29, x30, [sp], #128
    a0018970:	d65f03c0 	ret

00000000a0018974 <z_vrfy_k_yield>:

#ifdef CONFIG_USERSPACE
static inline void z_vrfy_k_yield(void)
{
    a0018974:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    a0018978:	910003fd 	mov	x29, sp
	z_impl_k_yield();
    a001897c:	97ffff86 	bl	a0018794 <z_impl_k_yield>
}
    a0018980:	d503201f 	nop
    a0018984:	a8c17bfd 	ldp	x29, x30, [sp], #16
    a0018988:	d65f03c0 	ret

00000000a001898c <z_mrsh_k_yield>:
#include <syscalls/kernel.h>

extern void z_vrfy_k_yield();
uintptr_t z_mrsh_k_yield(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a001898c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a0018990:	910003fd 	mov	x29, sp
    a0018994:	f90027e0 	str	x0, [sp, #72]
    a0018998:	f90023e1 	str	x1, [sp, #64]
    a001899c:	f9001fe2 	str	x2, [sp, #56]
    a00189a0:	f9001be3 	str	x3, [sp, #48]
    a00189a4:	f90017e4 	str	x4, [sp, #40]
    a00189a8:	f90013e5 	str	x5, [sp, #32]
    a00189ac:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a00189b0:	f0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00189b4:	913f8000 	add	x0, x0, #0xfe0
    a00189b8:	f9400800 	ldr	x0, [x0, #16]
    a00189bc:	f9400fe1 	ldr	x1, [sp, #24]
    a00189c0:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_yield()
    a00189c4:	97ffffec 	bl	a0018974 <z_vrfy_k_yield>
;
	_current->syscall_frame = NULL;
    a00189c8:	f0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00189cc:	913f8000 	add	x0, x0, #0xfe0
    a00189d0:	f9400800 	ldr	x0, [x0, #16]
    a00189d4:	f900841f 	str	xzr, [x0, #264]
	return 0;
    a00189d8:	d2800000 	mov	x0, #0x0                   	// #0
}
    a00189dc:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a00189e0:	d65f03c0 	ret

00000000a00189e4 <z_tick_sleep>:
#include <syscalls/k_yield_mrsh.c>
#endif

static int32_t z_tick_sleep(k_ticks_t ticks)
{
    a00189e4:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    a00189e8:	910003fd 	mov	x29, sp
    a00189ec:	f9000bf3 	str	x19, [sp, #16]
    a00189f0:	f90017e0 	str	x0, [sp, #40]
	 */
	LOG_DBG("thread %p for %u ticks", _current, ticks);
#endif

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
    a00189f4:	f94017e0 	ldr	x0, [sp, #40]
    a00189f8:	f100001f 	cmp	x0, #0x0
    a00189fc:	54000081 	b.ne	a0018a0c <z_tick_sleep+0x28>  // b.any
		k_yield();
    a0018a00:	97fff539 	bl	a0015ee4 <k_yield>
		return 0;
    a0018a04:	52800000 	mov	w0, #0x0                   	// #0
    a0018a08:	1400003c 	b	a0018af8 <z_tick_sleep+0x114>
	}

	k_timeout_t timeout = Z_TIMEOUT_TICKS(ticks);
    a0018a0c:	f94017e0 	ldr	x0, [sp, #40]
    a0018a10:	f90027e0 	str	x0, [sp, #72]
	if (Z_TICK_ABS(ticks) <= 0) {
    a0018a14:	92800021 	mov	x1, #0xfffffffffffffffe    	// #-2
    a0018a18:	f94017e0 	ldr	x0, [sp, #40]
    a0018a1c:	cb000020 	sub	x0, x1, x0
    a0018a20:	f100001f 	cmp	x0, #0x0
    a0018a24:	540000cc 	b.gt	a0018a3c <z_tick_sleep+0x58>
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
    a0018a28:	9400062e 	bl	a001a2e0 <sys_clock_tick_get_32>
    a0018a2c:	f94017e1 	ldr	x1, [sp, #40]
    a0018a30:	0b010000 	add	w0, w0, w1
    a0018a34:	b9006fe0 	str	w0, [sp, #108]
    a0018a38:	14000006 	b	a0018a50 <z_tick_sleep+0x6c>
	} else {
		expected_wakeup_ticks = Z_TICK_ABS(ticks);
    a0018a3c:	f94017e0 	ldr	x0, [sp, #40]
    a0018a40:	2a0003e1 	mov	w1, w0
    a0018a44:	12800020 	mov	w0, #0xfffffffe            	// #-2
    a0018a48:	4b010000 	sub	w0, w0, w1
    a0018a4c:	b9006fe0 	str	w0, [sp, #108]
    a0018a50:	90000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0018a54:	910a4000 	add	x0, x0, #0x290
    a0018a58:	f90033e0 	str	x0, [sp, #96]
MAKE_REG_HELPER(daif)
    a0018a5c:	d53b4220 	mrs	x0, daif
    a0018a60:	f9002fe0 	str	x0, [sp, #88]
    a0018a64:	f9402fe0 	ldr	x0, [sp, #88]
    a0018a68:	d503201f 	nop
	key = read_daif();
    a0018a6c:	b90057e0 	str	w0, [sp, #84]
	__asm__ volatile ("msr DAIFSet, %0"
    a0018a70:	d50342df 	msr	daifset, #0x2
}
    a0018a74:	d503201f 	nop
	return key;
    a0018a78:	b94057e0 	ldr	w0, [sp, #84]
	k.key = arch_irq_lock();
    a0018a7c:	b9003be0 	str	w0, [sp, #56]
	return k;
    a0018a80:	b9403be0 	ldr	w0, [sp, #56]
    a0018a84:	b90043e0 	str	w0, [sp, #64]
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

#if defined(CONFIG_TIMESLICING) && defined(CONFIG_SWAP_NONATOMIC)
	pending_current = _current;
#endif
	unready_thread(_current);
    a0018a88:	f0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0018a8c:	913f8000 	add	x0, x0, #0xfe0
    a0018a90:	f9400800 	ldr	x0, [x0, #16]
    a0018a94:	97fffaec 	bl	a0017644 <unready_thread>
	z_add_thread_timeout(_current, timeout);
    a0018a98:	f0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0018a9c:	913f8000 	add	x0, x0, #0xfe0
    a0018aa0:	f9400800 	ldr	x0, [x0, #16]
    a0018aa4:	f94027e1 	ldr	x1, [sp, #72]
    a0018aa8:	97fff546 	bl	a0015fc0 <z_add_thread_timeout>
	z_mark_thread_as_suspended(_current);
    a0018aac:	f0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0018ab0:	913f8000 	add	x0, x0, #0xfe0
    a0018ab4:	f9400800 	ldr	x0, [x0, #16]
    a0018ab8:	97fff5e5 	bl	a001624c <z_mark_thread_as_suspended>

	(void)z_swap(&sched_spinlock, key);
    a0018abc:	b94043e1 	ldr	w1, [sp, #64]
    a0018ac0:	90000180 	adrp	x0, a0048000 <_kernel+0x20>
    a0018ac4:	910a4000 	add	x0, x0, #0x290
    a0018ac8:	97fff701 	bl	a00166cc <z_swap>

	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");

	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
    a0018acc:	b9406ff3 	ldr	w19, [sp, #108]
    a0018ad0:	94000604 	bl	a001a2e0 <sys_clock_tick_get_32>
    a0018ad4:	2a0003e0 	mov	w0, w0
    a0018ad8:	cb000260 	sub	x0, x19, x0
    a0018adc:	f90017e0 	str	x0, [sp, #40]
	if (ticks > 0) {
    a0018ae0:	f94017e0 	ldr	x0, [sp, #40]
    a0018ae4:	f100001f 	cmp	x0, #0x0
    a0018ae8:	5400006d 	b.le	a0018af4 <z_tick_sleep+0x110>
		return ticks;
    a0018aec:	f94017e0 	ldr	x0, [sp, #40]
    a0018af0:	14000002 	b	a0018af8 <z_tick_sleep+0x114>
	}
#endif

	return 0;
    a0018af4:	52800000 	mov	w0, #0x0                   	// #0
}
    a0018af8:	f9400bf3 	ldr	x19, [sp, #16]
    a0018afc:	a8c77bfd 	ldp	x29, x30, [sp], #112
    a0018b00:	d65f03c0 	ret

00000000a0018b04 <z_impl_k_sleep>:

int32_t z_impl_k_sleep(k_timeout_t timeout)
{
    a0018b04:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0018b08:	910003fd 	mov	x29, sp
    a0018b0c:	f9000fe0 	str	x0, [sp, #24]
	__ASSERT(!arch_is_in_isr(), "");

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, sleep, timeout);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    a0018b10:	f9400fe0 	ldr	x0, [sp, #24]
    a0018b14:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
    a0018b18:	eb01001f 	cmp	x0, x1
    a0018b1c:	540000e1 	b.ne	a0018b38 <z_impl_k_sleep+0x34>  // b.any
		k_thread_suspend(_current);
    a0018b20:	f0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0018b24:	913f8000 	add	x0, x0, #0xfe0
    a0018b28:	f9400800 	ldr	x0, [x0, #16]
    a0018b2c:	97fff4fb 	bl	a0015f18 <k_thread_suspend>

		SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, (int32_t) K_TICKS_FOREVER);

		return (int32_t) K_TICKS_FOREVER;
    a0018b30:	12800000 	mov	w0, #0xffffffff            	// #-1
    a0018b34:	1400000b 	b	a0018b60 <z_impl_k_sleep+0x5c>
	}

	ticks = timeout.ticks;
    a0018b38:	f9400fe0 	ldr	x0, [sp, #24]
    a0018b3c:	f90017e0 	str	x0, [sp, #40]

	ticks = z_tick_sleep(ticks);
    a0018b40:	f94017e0 	ldr	x0, [sp, #40]
    a0018b44:	97ffffa8 	bl	a00189e4 <z_tick_sleep>
    a0018b48:	93407c00 	sxtw	x0, w0
    a0018b4c:	f90017e0 	str	x0, [sp, #40]

	int32_t ret = k_ticks_to_ms_floor64(ticks);
    a0018b50:	f94017e0 	ldr	x0, [sp, #40]
    a0018b54:	97fff349 	bl	a0015878 <k_ticks_to_ms_floor64>
    a0018b58:	b90027e0 	str	w0, [sp, #36]

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, ret);

	return ret;
    a0018b5c:	b94027e0 	ldr	w0, [sp, #36]
}
    a0018b60:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0018b64:	d65f03c0 	ret

00000000a0018b68 <z_vrfy_k_sleep>:

#ifdef CONFIG_USERSPACE
static inline int32_t z_vrfy_k_sleep(k_timeout_t timeout)
{
    a0018b68:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0018b6c:	910003fd 	mov	x29, sp
    a0018b70:	f9000fe0 	str	x0, [sp, #24]
	return z_impl_k_sleep(timeout);
    a0018b74:	f9400fe0 	ldr	x0, [sp, #24]
    a0018b78:	97ffffe3 	bl	a0018b04 <z_impl_k_sleep>
}
    a0018b7c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0018b80:	d65f03c0 	ret

00000000a0018b84 <z_mrsh_k_sleep>:
#include <syscalls/kernel.h>

extern int32_t z_vrfy_k_sleep(k_timeout_t timeout);
uintptr_t z_mrsh_k_sleep(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a0018b84:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a0018b88:	910003fd 	mov	x29, sp
    a0018b8c:	f90027e0 	str	x0, [sp, #72]
    a0018b90:	f90023e1 	str	x1, [sp, #64]
    a0018b94:	f9001fe2 	str	x2, [sp, #56]
    a0018b98:	f9001be3 	str	x3, [sp, #48]
    a0018b9c:	f90017e4 	str	x4, [sp, #40]
    a0018ba0:	f90013e5 	str	x5, [sp, #32]
    a0018ba4:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a0018ba8:	f0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0018bac:	913f8000 	add	x0, x0, #0xfe0
    a0018bb0:	f9400800 	ldr	x0, [x0, #16]
    a0018bb4:	f9400fe1 	ldr	x1, [sp, #24]
    a0018bb8:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int32_t ret = z_vrfy_k_sleep(*(k_timeout_t*)&arg0)
    a0018bbc:	910123e0 	add	x0, sp, #0x48
    a0018bc0:	f9400000 	ldr	x0, [x0]
    a0018bc4:	97ffffe9 	bl	a0018b68 <z_vrfy_k_sleep>
    a0018bc8:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a0018bcc:	f0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0018bd0:	913f8000 	add	x0, x0, #0xfe0
    a0018bd4:	f9400800 	ldr	x0, [x0, #16]
    a0018bd8:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a0018bdc:	b9805fe0 	ldrsw	x0, [sp, #92]
}
    a0018be0:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a0018be4:	d65f03c0 	ret

00000000a0018be8 <z_impl_k_usleep>:
#include <syscalls/k_sleep_mrsh.c>
#endif

int32_t z_impl_k_usleep(int us)
{
    a0018be8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0018bec:	910003fd 	mov	x29, sp
    a0018bf0:	b9001fe0 	str	w0, [sp, #28]
	int32_t ticks;

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, usleep, us);

	ticks = k_us_to_ticks_ceil64(us);
    a0018bf4:	b9801fe0 	ldrsw	x0, [sp, #28]
    a0018bf8:	97fff251 	bl	a001553c <k_us_to_ticks_ceil64>
    a0018bfc:	b9002fe0 	str	w0, [sp, #44]
	ticks = z_tick_sleep(ticks);
    a0018c00:	b9802fe0 	ldrsw	x0, [sp, #44]
    a0018c04:	97ffff78 	bl	a00189e4 <z_tick_sleep>
    a0018c08:	b9002fe0 	str	w0, [sp, #44]

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, usleep, us, k_ticks_to_us_floor64(ticks));

	return k_ticks_to_us_floor64(ticks);
    a0018c0c:	b9802fe0 	ldrsw	x0, [sp, #44]
    a0018c10:	97fff3e7 	bl	a0015bac <k_ticks_to_us_floor64>
}
    a0018c14:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0018c18:	d65f03c0 	ret

00000000a0018c1c <z_vrfy_k_usleep>:

#ifdef CONFIG_USERSPACE
static inline int32_t z_vrfy_k_usleep(int us)
{
    a0018c1c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0018c20:	910003fd 	mov	x29, sp
    a0018c24:	b9001fe0 	str	w0, [sp, #28]
	return z_impl_k_usleep(us);
    a0018c28:	b9401fe0 	ldr	w0, [sp, #28]
    a0018c2c:	97ffffef 	bl	a0018be8 <z_impl_k_usleep>
}
    a0018c30:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0018c34:	d65f03c0 	ret

00000000a0018c38 <z_mrsh_k_usleep>:
#include <syscalls/kernel.h>

extern int32_t z_vrfy_k_usleep(int32_t us);
uintptr_t z_mrsh_k_usleep(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a0018c38:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a0018c3c:	910003fd 	mov	x29, sp
    a0018c40:	f90027e0 	str	x0, [sp, #72]
    a0018c44:	f90023e1 	str	x1, [sp, #64]
    a0018c48:	f9001fe2 	str	x2, [sp, #56]
    a0018c4c:	f9001be3 	str	x3, [sp, #48]
    a0018c50:	f90017e4 	str	x4, [sp, #40]
    a0018c54:	f90013e5 	str	x5, [sp, #32]
    a0018c58:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a0018c5c:	f0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0018c60:	913f8000 	add	x0, x0, #0xfe0
    a0018c64:	f9400800 	ldr	x0, [x0, #16]
    a0018c68:	f9400fe1 	ldr	x1, [sp, #24]
    a0018c6c:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int32_t ret = z_vrfy_k_usleep(*(int32_t*)&arg0)
    a0018c70:	910123e0 	add	x0, sp, #0x48
    a0018c74:	b9400000 	ldr	w0, [x0]
    a0018c78:	97ffffe9 	bl	a0018c1c <z_vrfy_k_usleep>
    a0018c7c:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a0018c80:	f0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0018c84:	913f8000 	add	x0, x0, #0xfe0
    a0018c88:	f9400800 	ldr	x0, [x0, #16]
    a0018c8c:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a0018c90:	b9805fe0 	ldrsw	x0, [sp, #92]
}
    a0018c94:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a0018c98:	d65f03c0 	ret

00000000a0018c9c <z_impl_k_wakeup>:
#include <syscalls/k_usleep_mrsh.c>
#endif

void z_impl_k_wakeup(k_tid_t thread)
{
    a0018c9c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0018ca0:	910003fd 	mov	x29, sp
    a0018ca4:	f9000fe0 	str	x0, [sp, #24]
	SYS_PORT_TRACING_OBJ_FUNC(k_thread, wakeup, thread);

	if (z_is_thread_pending(thread)) {
    a0018ca8:	f9400fe0 	ldr	x0, [sp, #24]
    a0018cac:	97fff508 	bl	a00160cc <z_is_thread_pending>
    a0018cb0:	12001c00 	and	w0, w0, #0xff
    a0018cb4:	7100001f 	cmp	w0, #0x0
    a0018cb8:	54000381 	b.ne	a0018d28 <z_impl_k_wakeup+0x8c>  // b.any
		return;
	}

	if (z_abort_thread_timeout(thread) < 0) {
    a0018cbc:	f9400fe0 	ldr	x0, [sp, #24]
    a0018cc0:	97fff4ce 	bl	a0015ff8 <z_abort_thread_timeout>
    a0018cc4:	7100001f 	cmp	w0, #0x0
    a0018cc8:	540000aa 	b.ge	a0018cdc <z_impl_k_wakeup+0x40>  // b.tcont
		/* Might have just been sleeping forever */
		if (thread->base.thread_state != _THREAD_SUSPENDED) {
    a0018ccc:	f9400fe0 	ldr	x0, [sp, #24]
    a0018cd0:	39406400 	ldrb	w0, [x0, #25]
    a0018cd4:	7100401f 	cmp	w0, #0x10
    a0018cd8:	540002c1 	b.ne	a0018d30 <z_impl_k_wakeup+0x94>  // b.any
			return;
		}
	}

	z_mark_thread_as_not_suspended(thread);
    a0018cdc:	f9400fe0 	ldr	x0, [sp, #24]
    a0018ce0:	97fff566 	bl	a0016278 <z_mark_thread_as_not_suspended>
	z_ready_thread(thread);
    a0018ce4:	f9400fe0 	ldr	x0, [sp, #24]
    a0018ce8:	97fff902 	bl	a00170f0 <z_ready_thread>
MAKE_REG_HELPER(tpidrro_el0);
    a0018cec:	d53bd060 	mrs	x0, tpidrro_el0
    a0018cf0:	f90017e0 	str	x0, [sp, #40]
    a0018cf4:	f94017e0 	ldr	x0, [sp, #40]
    a0018cf8:	d503201f 	nop
    a0018cfc:	927db000 	and	x0, x0, #0xfffffffffff8
    a0018d00:	b9400000 	ldr	w0, [x0]
    a0018d04:	7100001f 	cmp	w0, #0x0
    a0018d08:	1a9f07e0 	cset	w0, ne  // ne = any
    a0018d0c:	12001c00 	and	w0, w0, #0xff

#if defined(CONFIG_SMP) && defined(CONFIG_SCHED_IPI_SUPPORTED)
	arch_sched_ipi();
#endif

	if (!arch_is_in_isr()) {
    a0018d10:	52000000 	eor	w0, w0, #0x1
    a0018d14:	12001c00 	and	w0, w0, #0xff
    a0018d18:	7100001f 	cmp	w0, #0x0
    a0018d1c:	540000c0 	b.eq	a0018d34 <z_impl_k_wakeup+0x98>  // b.none
		z_reschedule_unlocked();
    a0018d20:	97fff4be 	bl	a0016018 <z_reschedule_unlocked>
    a0018d24:	14000004 	b	a0018d34 <z_impl_k_wakeup+0x98>
		return;
    a0018d28:	d503201f 	nop
    a0018d2c:	14000002 	b	a0018d34 <z_impl_k_wakeup+0x98>
			return;
    a0018d30:	d503201f 	nop
	}
}
    a0018d34:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0018d38:	d65f03c0 	ret

00000000a0018d3c <z_vrfy_k_wakeup>:
}
#endif

#ifdef CONFIG_USERSPACE
static inline void z_vrfy_k_wakeup(k_tid_t thread)
{
    a0018d3c:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a0018d40:	910003fd 	mov	x29, sp
    a0018d44:	f9000fe0 	str	x0, [sp, #24]
	Z_OOPS(Z_SYSCALL_OBJ(thread, K_OBJ_THREAD));
    a0018d48:	f9400fe0 	ldr	x0, [sp, #24]
    a0018d4c:	94000f37 	bl	a001ca28 <z_object_find>
    a0018d50:	52800003 	mov	w3, #0x0                   	// #0
    a0018d54:	52800122 	mov	w2, #0x9                   	// #9
    a0018d58:	f9400fe1 	ldr	x1, [sp, #24]
    a0018d5c:	97fff6cd 	bl	a0016890 <z_obj_validation_check>
    a0018d60:	7100001f 	cmp	w0, #0x0
    a0018d64:	1a9f07e0 	cset	w0, ne  // ne = any
    a0018d68:	39063fe0 	strb	w0, [sp, #399]
    a0018d6c:	39463fe0 	ldrb	w0, [sp, #399]
    a0018d70:	7100001f 	cmp	w0, #0x0
    a0018d74:	39463fe0 	ldrb	w0, [sp, #399]
    a0018d78:	7100001f 	cmp	w0, #0x0
    a0018d7c:	540000c0 	b.eq	a0018d94 <z_vrfy_k_wakeup+0x58>  // b.none
    a0018d80:	f0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0018d84:	913f8000 	add	x0, x0, #0xfe0
    a0018d88:	f9400800 	ldr	x0, [x0, #16]
    a0018d8c:	f9408400 	ldr	x0, [x0, #264]
    a0018d90:	97ffc0f2 	bl	a0009158 <arch_syscall_oops>
	z_impl_k_wakeup(thread);
    a0018d94:	f9400fe0 	ldr	x0, [sp, #24]
    a0018d98:	97ffffc1 	bl	a0018c9c <z_impl_k_wakeup>
}
    a0018d9c:	d503201f 	nop
    a0018da0:	a8d97bfd 	ldp	x29, x30, [sp], #400
    a0018da4:	d65f03c0 	ret

00000000a0018da8 <z_mrsh_k_wakeup>:
#include <syscalls/kernel.h>

extern void z_vrfy_k_wakeup(k_tid_t thread);
uintptr_t z_mrsh_k_wakeup(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a0018da8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a0018dac:	910003fd 	mov	x29, sp
    a0018db0:	f90027e0 	str	x0, [sp, #72]
    a0018db4:	f90023e1 	str	x1, [sp, #64]
    a0018db8:	f9001fe2 	str	x2, [sp, #56]
    a0018dbc:	f9001be3 	str	x3, [sp, #48]
    a0018dc0:	f90017e4 	str	x4, [sp, #40]
    a0018dc4:	f90013e5 	str	x5, [sp, #32]
    a0018dc8:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a0018dcc:	f0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0018dd0:	913f8000 	add	x0, x0, #0xfe0
    a0018dd4:	f9400800 	ldr	x0, [x0, #16]
    a0018dd8:	f9400fe1 	ldr	x1, [sp, #24]
    a0018ddc:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_wakeup(*(k_tid_t*)&arg0)
    a0018de0:	910123e0 	add	x0, sp, #0x48
    a0018de4:	f9400000 	ldr	x0, [x0]
    a0018de8:	97ffffd5 	bl	a0018d3c <z_vrfy_k_wakeup>
;
	_current->syscall_frame = NULL;
    a0018dec:	f0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0018df0:	913f8000 	add	x0, x0, #0xfe0
    a0018df4:	f9400800 	ldr	x0, [x0, #16]
    a0018df8:	f900841f 	str	xzr, [x0, #264]
	return 0;
    a0018dfc:	d2800000 	mov	x0, #0x0                   	// #0
}
    a0018e00:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a0018e04:	d65f03c0 	ret

00000000a0018e08 <z_impl_z_current_get>:
#include <syscalls/k_wakeup_mrsh.c>
#endif

k_tid_t z_impl_z_current_get(void)
{
    a0018e08:	d10043ff 	sub	sp, sp, #0x10
	 * local interrupts when reading it.
	 */
	unsigned int k = arch_irq_lock();
#endif

	k_tid_t ret = _current_cpu->current;
    a0018e0c:	f0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0018e10:	913f8000 	add	x0, x0, #0xfe0
    a0018e14:	f9400800 	ldr	x0, [x0, #16]
    a0018e18:	f90007e0 	str	x0, [sp, #8]

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
    a0018e1c:	f94007e0 	ldr	x0, [sp, #8]
}
    a0018e20:	910043ff 	add	sp, sp, #0x10
    a0018e24:	d65f03c0 	ret

00000000a0018e28 <z_vrfy_z_current_get>:

#ifdef CONFIG_USERSPACE
static inline k_tid_t z_vrfy_z_current_get(void)
{
    a0018e28:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    a0018e2c:	910003fd 	mov	x29, sp
	return z_impl_z_current_get();
    a0018e30:	97fffff6 	bl	a0018e08 <z_impl_z_current_get>
}
    a0018e34:	a8c17bfd 	ldp	x29, x30, [sp], #16
    a0018e38:	d65f03c0 	ret

00000000a0018e3c <z_mrsh_z_current_get>:
#include <syscalls/kernel.h>

extern k_tid_t z_vrfy_z_current_get();
uintptr_t z_mrsh_z_current_get(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a0018e3c:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a0018e40:	910003fd 	mov	x29, sp
    a0018e44:	f90027e0 	str	x0, [sp, #72]
    a0018e48:	f90023e1 	str	x1, [sp, #64]
    a0018e4c:	f9001fe2 	str	x2, [sp, #56]
    a0018e50:	f9001be3 	str	x3, [sp, #48]
    a0018e54:	f90017e4 	str	x4, [sp, #40]
    a0018e58:	f90013e5 	str	x5, [sp, #32]
    a0018e5c:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a0018e60:	f0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0018e64:	913f8000 	add	x0, x0, #0xfe0
    a0018e68:	f9400800 	ldr	x0, [x0, #16]
    a0018e6c:	f9400fe1 	ldr	x1, [sp, #24]
    a0018e70:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	k_tid_t ret = z_vrfy_z_current_get()
    a0018e74:	97ffffed 	bl	a0018e28 <z_vrfy_z_current_get>
    a0018e78:	f9002fe0 	str	x0, [sp, #88]
;
	_current->syscall_frame = NULL;
    a0018e7c:	f0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0018e80:	913f8000 	add	x0, x0, #0xfe0
    a0018e84:	f9400800 	ldr	x0, [x0, #16]
    a0018e88:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a0018e8c:	f9402fe0 	ldr	x0, [sp, #88]
}
    a0018e90:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a0018e94:	d65f03c0 	ret

00000000a0018e98 <z_impl_k_is_preempt_thread>:
#include <syscalls/z_current_get_mrsh.c>
#endif

int z_impl_k_is_preempt_thread(void)
{
    a0018e98:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0018e9c:	910003fd 	mov	x29, sp
    a0018ea0:	d53bd060 	mrs	x0, tpidrro_el0
    a0018ea4:	f9000fe0 	str	x0, [sp, #24]
    a0018ea8:	f9400fe0 	ldr	x0, [sp, #24]
    a0018eac:	d503201f 	nop
    a0018eb0:	927db000 	and	x0, x0, #0xfffffffffff8
    a0018eb4:	b9400000 	ldr	w0, [x0]
    a0018eb8:	7100001f 	cmp	w0, #0x0
    a0018ebc:	1a9f07e0 	cset	w0, ne  // ne = any
    a0018ec0:	12001c00 	and	w0, w0, #0xff
	return !arch_is_in_isr() && is_preempt(_current);
    a0018ec4:	52000000 	eor	w0, w0, #0x1
    a0018ec8:	12001c00 	and	w0, w0, #0xff
    a0018ecc:	7100001f 	cmp	w0, #0x0
    a0018ed0:	54000120 	b.eq	a0018ef4 <z_impl_k_is_preempt_thread+0x5c>  // b.none
    a0018ed4:	f0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0018ed8:	913f8000 	add	x0, x0, #0xfe0
    a0018edc:	f9400800 	ldr	x0, [x0, #16]
    a0018ee0:	97fff67a 	bl	a00168c8 <is_preempt>
    a0018ee4:	7100001f 	cmp	w0, #0x0
    a0018ee8:	54000060 	b.eq	a0018ef4 <z_impl_k_is_preempt_thread+0x5c>  // b.none
    a0018eec:	52800020 	mov	w0, #0x1                   	// #1
    a0018ef0:	14000002 	b	a0018ef8 <z_impl_k_is_preempt_thread+0x60>
    a0018ef4:	52800000 	mov	w0, #0x0                   	// #0
}
    a0018ef8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0018efc:	d65f03c0 	ret

00000000a0018f00 <z_vrfy_k_is_preempt_thread>:

#ifdef CONFIG_USERSPACE
static inline int z_vrfy_k_is_preempt_thread(void)
{
    a0018f00:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    a0018f04:	910003fd 	mov	x29, sp
	return z_impl_k_is_preempt_thread();
    a0018f08:	97ffffe4 	bl	a0018e98 <z_impl_k_is_preempt_thread>
}
    a0018f0c:	a8c17bfd 	ldp	x29, x30, [sp], #16
    a0018f10:	d65f03c0 	ret

00000000a0018f14 <z_mrsh_k_is_preempt_thread>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_is_preempt_thread();
uintptr_t z_mrsh_k_is_preempt_thread(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a0018f14:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a0018f18:	910003fd 	mov	x29, sp
    a0018f1c:	f90027e0 	str	x0, [sp, #72]
    a0018f20:	f90023e1 	str	x1, [sp, #64]
    a0018f24:	f9001fe2 	str	x2, [sp, #56]
    a0018f28:	f9001be3 	str	x3, [sp, #48]
    a0018f2c:	f90017e4 	str	x4, [sp, #40]
    a0018f30:	f90013e5 	str	x5, [sp, #32]
    a0018f34:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a0018f38:	f0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0018f3c:	913f8000 	add	x0, x0, #0xfe0
    a0018f40:	f9400800 	ldr	x0, [x0, #16]
    a0018f44:	f9400fe1 	ldr	x1, [sp, #24]
    a0018f48:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_is_preempt_thread()
    a0018f4c:	97ffffed 	bl	a0018f00 <z_vrfy_k_is_preempt_thread>
    a0018f50:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a0018f54:	f0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0018f58:	913f8000 	add	x0, x0, #0xfe0
    a0018f5c:	f9400800 	ldr	x0, [x0, #16]
    a0018f60:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a0018f64:	b9805fe0 	ldrsw	x0, [sp, #92]
}
    a0018f68:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a0018f6c:	d65f03c0 	ret

00000000a0018f70 <unpend_all>:
}

#endif /* CONFIG_SCHED_CPU_MASK */

static inline void unpend_all(_wait_q_t *wait_q)
{
    a0018f70:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    a0018f74:	910003fd 	mov	x29, sp
    a0018f78:	f9000fe0 	str	x0, [sp, #24]
	struct k_thread *thread;

	while ((thread = z_waitq_head(wait_q)) != NULL) {
    a0018f7c:	1400000e 	b	a0018fb4 <unpend_all+0x44>
		unpend_thread_no_timeout(thread);
    a0018f80:	f9401fe0 	ldr	x0, [sp, #56]
    a0018f84:	97fffa5b 	bl	a00178f0 <unpend_thread_no_timeout>
		(void)z_abort_thread_timeout(thread);
    a0018f88:	f9401fe0 	ldr	x0, [sp, #56]
    a0018f8c:	97fff41b 	bl	a0015ff8 <z_abort_thread_timeout>
    a0018f90:	f9401fe0 	ldr	x0, [sp, #56]
    a0018f94:	f9001be0 	str	x0, [sp, #48]
    a0018f98:	b9002fff 	str	wzr, [sp, #44]
	thread->swap_retval = value;
    a0018f9c:	b9402fe1 	ldr	w1, [sp, #44]
    a0018fa0:	f9401be0 	ldr	x0, [sp, #48]
    a0018fa4:	b9011001 	str	w1, [x0, #272]
}
    a0018fa8:	d503201f 	nop
		arch_thread_return_value_set(thread, 0);
		ready_thread(thread);
    a0018fac:	f9401fe0 	ldr	x0, [sp, #56]
    a0018fb0:	97fff7f8 	bl	a0016f90 <ready_thread>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
    a0018fb4:	f9400fe0 	ldr	x0, [sp, #24]
    a0018fb8:	97fff54b 	bl	a00164e4 <z_waitq_head>
    a0018fbc:	f9001fe0 	str	x0, [sp, #56]
    a0018fc0:	f9401fe0 	ldr	x0, [sp, #56]
    a0018fc4:	f100001f 	cmp	x0, #0x0
    a0018fc8:	54fffdc1 	b.ne	a0018f80 <unpend_all+0x10>  // b.any
	}
}
    a0018fcc:	d503201f 	nop
    a0018fd0:	d503201f 	nop
    a0018fd4:	a8c47bfd 	ldp	x29, x30, [sp], #64
    a0018fd8:	d65f03c0 	ret

00000000a0018fdc <end_thread>:
#ifdef CONFIG_CMSIS_RTOS_V1
extern void z_thread_cmsis_status_mask_clear(struct k_thread *thread);
#endif

static void end_thread(struct k_thread *thread)
{
    a0018fdc:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    a0018fe0:	910003fd 	mov	x29, sp
    a0018fe4:	f9000fe0 	str	x0, [sp, #24]
	/* We hold the lock, and the thread is known not to be running
	 * anywhere.
	 */
	if ((thread->base.thread_state & _THREAD_DEAD) == 0U) {
    a0018fe8:	f9400fe0 	ldr	x0, [sp, #24]
    a0018fec:	39406400 	ldrb	w0, [x0, #25]
    a0018ff0:	92401c00 	and	x0, x0, #0xff
    a0018ff4:	927d0000 	and	x0, x0, #0x8
    a0018ff8:	f100001f 	cmp	x0, #0x0
    a0018ffc:	540007e1 	b.ne	a00190f8 <end_thread+0x11c>  // b.any
		thread->base.thread_state |= _THREAD_DEAD;
    a0019000:	f9400fe0 	ldr	x0, [sp, #24]
    a0019004:	39406400 	ldrb	w0, [x0, #25]
    a0019008:	321d0000 	orr	w0, w0, #0x8
    a001900c:	12001c01 	and	w1, w0, #0xff
    a0019010:	f9400fe0 	ldr	x0, [sp, #24]
    a0019014:	39006401 	strb	w1, [x0, #25]
		thread->base.thread_state &= ~_THREAD_ABORTING;
    a0019018:	f9400fe0 	ldr	x0, [sp, #24]
    a001901c:	39406400 	ldrb	w0, [x0, #25]
    a0019020:	121a7800 	and	w0, w0, #0xffffffdf
    a0019024:	12001c01 	and	w1, w0, #0xff
    a0019028:	f9400fe0 	ldr	x0, [sp, #24]
    a001902c:	39006401 	strb	w1, [x0, #25]
		if (z_is_thread_queued(thread)) {
    a0019030:	f9400fe0 	ldr	x0, [sp, #24]
    a0019034:	97fff47d 	bl	a0016228 <z_is_thread_queued>
    a0019038:	12001c00 	and	w0, w0, #0xff
    a001903c:	7100001f 	cmp	w0, #0x0
    a0019040:	54000300 	b.eq	a00190a0 <end_thread+0xc4>  // b.none
    a0019044:	f9400fe0 	ldr	x0, [sp, #24]
    a0019048:	f9001fe0 	str	x0, [sp, #56]
	thread->base.thread_state &= ~_THREAD_QUEUED;
    a001904c:	f9401fe0 	ldr	x0, [sp, #56]
    a0019050:	39406400 	ldrb	w0, [x0, #25]
    a0019054:	12001800 	and	w0, w0, #0x7f
    a0019058:	12001c01 	and	w1, w0, #0xff
    a001905c:	f9401fe0 	ldr	x0, [sp, #56]
    a0019060:	39006401 	strb	w1, [x0, #25]
	if (should_queue_thread(thread)) {
    a0019064:	f9401fe0 	ldr	x0, [sp, #56]
    a0019068:	97fff63a 	bl	a0016950 <should_queue_thread>
    a001906c:	12001c00 	and	w0, w0, #0xff
    a0019070:	7100001f 	cmp	w0, #0x0
    a0019074:	54000140 	b.eq	a001909c <end_thread+0xc0>  // b.none
    a0019078:	f9401fe0 	ldr	x0, [sp, #56]
    a001907c:	f9001be0 	str	x0, [sp, #48]
    a0019080:	f9401be0 	ldr	x0, [sp, #48]
    a0019084:	f90017e0 	str	x0, [sp, #40]
	return &_kernel.ready_q.runq;
    a0019088:	f0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a001908c:	91004000 	add	x0, x0, #0x10
	_priq_run_remove(thread_runq(thread), thread);
    a0019090:	f9401be1 	ldr	x1, [sp, #48]
    a0019094:	97fffcd8 	bl	a00183f4 <z_priq_dumb_remove>
}
    a0019098:	d503201f 	nop
}
    a001909c:	d503201f 	nop
			dequeue_thread(thread);
		}
		if (thread->base.pended_on != NULL) {
    a00190a0:	f9400fe0 	ldr	x0, [sp, #24]
    a00190a4:	f9400800 	ldr	x0, [x0, #16]
    a00190a8:	f100001f 	cmp	x0, #0x0
    a00190ac:	54000060 	b.eq	a00190b8 <end_thread+0xdc>  // b.none
			unpend_thread_no_timeout(thread);
    a00190b0:	f9400fe0 	ldr	x0, [sp, #24]
    a00190b4:	97fffa0f 	bl	a00178f0 <unpend_thread_no_timeout>
		}
		(void)z_abort_thread_timeout(thread);
    a00190b8:	f9400fe0 	ldr	x0, [sp, #24]
    a00190bc:	97fff3cf 	bl	a0015ff8 <z_abort_thread_timeout>
		unpend_all(&thread->join_queue);
    a00190c0:	f9400fe0 	ldr	x0, [sp, #24]
    a00190c4:	9102e000 	add	x0, x0, #0xb8
    a00190c8:	97ffffaa 	bl	a0018f70 <unpend_all>
		update_cache(1);
    a00190cc:	52800020 	mov	w0, #0x1                   	// #1
    a00190d0:	97fff763 	bl	a0016e5c <update_cache>
#ifdef CONFIG_CMSIS_RTOS_V1
		z_thread_cmsis_status_mask_clear(thread);
#endif

#ifdef CONFIG_USERSPACE
		z_mem_domain_exit_thread(thread);
    a00190d4:	f9400fe0 	ldr	x0, [sp, #24]
    a00190d8:	94000bf1 	bl	a001c09c <z_mem_domain_exit_thread>
		z_thread_perms_all_clear(thread);
    a00190dc:	f9400fe0 	ldr	x0, [sp, #24]
    a00190e0:	94001026 	bl	a001d178 <z_thread_perms_all_clear>
		z_object_uninit(thread->stack_obj);
    a00190e4:	f9400fe0 	ldr	x0, [sp, #24]
    a00190e8:	f9408000 	ldr	x0, [x0, #256]
    a00190ec:	940010dc 	bl	a001d45c <z_object_uninit>
		z_object_uninit(thread);
    a00190f0:	f9400fe0 	ldr	x0, [sp, #24]
    a00190f4:	940010da 	bl	a001d45c <z_object_uninit>
#endif
	}
}
    a00190f8:	d503201f 	nop
    a00190fc:	a8c47bfd 	ldp	x29, x30, [sp], #64
    a0019100:	d65f03c0 	ret

00000000a0019104 <z_thread_abort>:

void z_thread_abort(struct k_thread *thread)
{
    a0019104:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
    a0019108:	910003fd 	mov	x29, sp
    a001910c:	f9000fe0 	str	x0, [sp, #24]
    a0019110:	f0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a0019114:	910a4000 	add	x0, x0, #0x290
    a0019118:	f90047e0 	str	x0, [sp, #136]
MAKE_REG_HELPER(daif)
    a001911c:	d53b4220 	mrs	x0, daif
    a0019120:	f90043e0 	str	x0, [sp, #128]
    a0019124:	f94043e0 	ldr	x0, [sp, #128]
    a0019128:	d503201f 	nop
	key = read_daif();
    a001912c:	b9007fe0 	str	w0, [sp, #124]
	__asm__ volatile ("msr DAIFSet, %0"
    a0019130:	d50342df 	msr	daifset, #0x2
}
    a0019134:	d503201f 	nop
	return key;
    a0019138:	b9407fe0 	ldr	w0, [sp, #124]
	k.key = arch_irq_lock();
    a001913c:	b90023e0 	str	w0, [sp, #32]
	return k;
    a0019140:	b94023e0 	ldr	w0, [sp, #32]
    a0019144:	b9003be0 	str	w0, [sp, #56]
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
    a0019148:	f9400fe0 	ldr	x0, [sp, #24]
    a001914c:	39406400 	ldrb	w0, [x0, #25]
    a0019150:	92401c00 	and	x0, x0, #0xff
    a0019154:	927d0000 	and	x0, x0, #0x8
    a0019158:	f100001f 	cmp	x0, #0x0
    a001915c:	540001e0 	b.eq	a0019198 <z_thread_abort+0x94>  // b.none
    a0019160:	f0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a0019164:	910a4000 	add	x0, x0, #0x290
    a0019168:	f9003be0 	str	x0, [sp, #112]
    a001916c:	b9403be0 	ldr	w0, [sp, #56]
    a0019170:	b9002be0 	str	w0, [sp, #40]
	arch_irq_unlock(key.key);
    a0019174:	b9402be0 	ldr	w0, [sp, #40]
    a0019178:	b9006fe0 	str	w0, [sp, #108]
	write_daif(key);
    a001917c:	b9406fe0 	ldr	w0, [sp, #108]
    a0019180:	f90033e0 	str	x0, [sp, #96]
MAKE_REG_HELPER(daif)
    a0019184:	f94033e0 	ldr	x0, [sp, #96]
    a0019188:	d51b4220 	msr	daif, x0
    a001918c:	d503201f 	nop
}
    a0019190:	d503201f 	nop
}
    a0019194:	14000028 	b	a0019234 <z_thread_abort+0x130>
			z_swap(&sched_spinlock, key);
		}
		return; /* lock has been released */
	}
#endif
	end_thread(thread);
    a0019198:	f9400fe0 	ldr	x0, [sp, #24]
    a001919c:	97ffff90 	bl	a0018fdc <end_thread>
	if (thread == _current && !arch_is_in_isr()) {
    a00191a0:	d0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00191a4:	913f8000 	add	x0, x0, #0xfe0
    a00191a8:	f9400800 	ldr	x0, [x0, #16]
    a00191ac:	f9400fe1 	ldr	x1, [sp, #24]
    a00191b0:	eb00003f 	cmp	x1, x0
    a00191b4:	54000241 	b.ne	a00191fc <z_thread_abort+0xf8>  // b.any
MAKE_REG_HELPER(tpidrro_el0);
    a00191b8:	d53bd060 	mrs	x0, tpidrro_el0
    a00191bc:	f9002fe0 	str	x0, [sp, #88]
    a00191c0:	f9402fe0 	ldr	x0, [sp, #88]
    a00191c4:	d503201f 	nop
    a00191c8:	927db000 	and	x0, x0, #0xfffffffffff8
    a00191cc:	b9400000 	ldr	w0, [x0]
    a00191d0:	7100001f 	cmp	w0, #0x0
    a00191d4:	1a9f07e0 	cset	w0, ne  // ne = any
    a00191d8:	12001c00 	and	w0, w0, #0xff
    a00191dc:	52000000 	eor	w0, w0, #0x1
    a00191e0:	12001c00 	and	w0, w0, #0xff
    a00191e4:	7100001f 	cmp	w0, #0x0
    a00191e8:	540000a0 	b.eq	a00191fc <z_thread_abort+0xf8>  // b.none
		z_swap(&sched_spinlock, key);
    a00191ec:	b9403be1 	ldr	w1, [sp, #56]
    a00191f0:	f0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a00191f4:	910a4000 	add	x0, x0, #0x290
    a00191f8:	97fff535 	bl	a00166cc <z_swap>
    a00191fc:	f0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a0019200:	910a4000 	add	x0, x0, #0x290
    a0019204:	f9002be0 	str	x0, [sp, #80]
    a0019208:	b9403be0 	ldr	w0, [sp, #56]
    a001920c:	b90033e0 	str	w0, [sp, #48]
	arch_irq_unlock(key.key);
    a0019210:	b94033e0 	ldr	w0, [sp, #48]
    a0019214:	b9004fe0 	str	w0, [sp, #76]
	write_daif(key);
    a0019218:	b9404fe0 	ldr	w0, [sp, #76]
    a001921c:	f90023e0 	str	x0, [sp, #64]
MAKE_REG_HELPER(daif)
    a0019220:	f94023e0 	ldr	x0, [sp, #64]
    a0019224:	d51b4220 	msr	daif, x0
    a0019228:	d503201f 	nop
}
    a001922c:	d503201f 	nop
}
    a0019230:	d503201f 	nop
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
    a0019234:	a8c97bfd 	ldp	x29, x30, [sp], #144
    a0019238:	d65f03c0 	ret

00000000a001923c <z_impl_k_thread_abort>:

#if !defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void z_impl_k_thread_abort(struct k_thread *thread)
{
    a001923c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0019240:	910003fd 	mov	x29, sp
    a0019244:	f9000fe0 	str	x0, [sp, #24]
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_thread, abort, thread);

	z_thread_abort(thread);
    a0019248:	f9400fe0 	ldr	x0, [sp, #24]
    a001924c:	97ffffae 	bl	a0019104 <z_thread_abort>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_thread, abort, thread);
}
    a0019250:	d503201f 	nop
    a0019254:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0019258:	d65f03c0 	ret

00000000a001925c <z_impl_k_thread_join>:
#endif

int z_impl_k_thread_join(struct k_thread *thread, k_timeout_t timeout)
{
    a001925c:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    a0019260:	910003fd 	mov	x29, sp
    a0019264:	f9000fe0 	str	x0, [sp, #24]
    a0019268:	f9000be1 	str	x1, [sp, #16]
    a001926c:	f0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a0019270:	910a4000 	add	x0, x0, #0x290
    a0019274:	f90033e0 	str	x0, [sp, #96]
    a0019278:	d53b4220 	mrs	x0, daif
    a001927c:	f9002fe0 	str	x0, [sp, #88]
    a0019280:	f9402fe0 	ldr	x0, [sp, #88]
    a0019284:	d503201f 	nop
	key = read_daif();
    a0019288:	b90057e0 	str	w0, [sp, #84]
	__asm__ volatile ("msr DAIFSet, %0"
    a001928c:	d50342df 	msr	daifset, #0x2
}
    a0019290:	d503201f 	nop
	return key;
    a0019294:	b94057e0 	ldr	w0, [sp, #84]
	k.key = arch_irq_lock();
    a0019298:	b90023e0 	str	w0, [sp, #32]
	return k;
    a001929c:	b94023e0 	ldr	w0, [sp, #32]
    a00192a0:	b90033e0 	str	w0, [sp, #48]
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);
	int ret = 0;
    a00192a4:	b9006fff 	str	wzr, [sp, #108]

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_thread, join, thread, timeout);

	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
    a00192a8:	f9400fe0 	ldr	x0, [sp, #24]
    a00192ac:	39406400 	ldrb	w0, [x0, #25]
    a00192b0:	92401c00 	and	x0, x0, #0xff
    a00192b4:	927d0000 	and	x0, x0, #0x8
    a00192b8:	f100001f 	cmp	x0, #0x0
    a00192bc:	54000060 	b.eq	a00192c8 <z_impl_k_thread_join+0x6c>  // b.none
		ret = 0;
    a00192c0:	b9006fff 	str	wzr, [sp, #108]
    a00192c4:	1400002d 	b	a0019378 <z_impl_k_thread_join+0x11c>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    a00192c8:	f9400be0 	ldr	x0, [sp, #16]
    a00192cc:	d2800001 	mov	x1, #0x0                   	// #0
    a00192d0:	eb01001f 	cmp	x0, x1
    a00192d4:	54000081 	b.ne	a00192e4 <z_impl_k_thread_join+0x88>  // b.any
		ret = -EBUSY;
    a00192d8:	128001e0 	mov	w0, #0xfffffff0            	// #-16
    a00192dc:	b9006fe0 	str	w0, [sp, #108]
    a00192e0:	14000026 	b	a0019378 <z_impl_k_thread_join+0x11c>
	} else if ((thread == _current) ||
    a00192e4:	d0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00192e8:	913f8000 	add	x0, x0, #0xfe0
    a00192ec:	f9400800 	ldr	x0, [x0, #16]
    a00192f0:	f9400fe1 	ldr	x1, [sp, #24]
    a00192f4:	eb00003f 	cmp	x1, x0
    a00192f8:	54000120 	b.eq	a001931c <z_impl_k_thread_join+0xc0>  // b.none
		   (thread->base.pended_on == &_current->join_queue)) {
    a00192fc:	f9400fe0 	ldr	x0, [sp, #24]
    a0019300:	f9400801 	ldr	x1, [x0, #16]
    a0019304:	d0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0019308:	913f8000 	add	x0, x0, #0xfe0
    a001930c:	f9400800 	ldr	x0, [x0, #16]
    a0019310:	9102e000 	add	x0, x0, #0xb8
	} else if ((thread == _current) ||
    a0019314:	eb00003f 	cmp	x1, x0
    a0019318:	54000081 	b.ne	a0019328 <z_impl_k_thread_join+0xcc>  // b.any
		ret = -EDEADLK;
    a001931c:	12800580 	mov	w0, #0xffffffd3            	// #-45
    a0019320:	b9006fe0 	str	w0, [sp, #108]
    a0019324:	14000015 	b	a0019378 <z_impl_k_thread_join+0x11c>
	} else {
		__ASSERT(!arch_is_in_isr(), "cannot join in ISR");
		add_to_waitq_locked(_current, &thread->join_queue);
    a0019328:	d0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001932c:	913f8000 	add	x0, x0, #0xfe0
    a0019330:	f9400802 	ldr	x2, [x0, #16]
    a0019334:	f9400fe0 	ldr	x0, [sp, #24]
    a0019338:	9102e000 	add	x0, x0, #0xb8
    a001933c:	aa0003e1 	mov	x1, x0
    a0019340:	aa0203e0 	mov	x0, x2
    a0019344:	97fff8ea 	bl	a00176ec <add_to_waitq_locked>
		add_thread_timeout(_current, timeout);
    a0019348:	d0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001934c:	913f8000 	add	x0, x0, #0xfe0
    a0019350:	f9400800 	ldr	x0, [x0, #16]
    a0019354:	f9400be1 	ldr	x1, [sp, #16]
    a0019358:	97fff927 	bl	a00177f4 <add_thread_timeout>

		SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_thread, join, thread, timeout);
		ret = z_swap(&sched_spinlock, key);
    a001935c:	b94033e1 	ldr	w1, [sp, #48]
    a0019360:	f0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a0019364:	910a4000 	add	x0, x0, #0x290
    a0019368:	97fff4d9 	bl	a00166cc <z_swap>
    a001936c:	b9006fe0 	str	w0, [sp, #108]
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_thread, join, thread, timeout, ret);

		return ret;
    a0019370:	b9406fe0 	ldr	w0, [sp, #108]
    a0019374:	14000010 	b	a00193b4 <z_impl_k_thread_join+0x158>
    a0019378:	f0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a001937c:	910a4000 	add	x0, x0, #0x290
    a0019380:	f90027e0 	str	x0, [sp, #72]
    a0019384:	b94033e0 	ldr	w0, [sp, #48]
    a0019388:	b9002be0 	str	w0, [sp, #40]
	arch_irq_unlock(key.key);
    a001938c:	b9402be0 	ldr	w0, [sp, #40]
    a0019390:	b90047e0 	str	w0, [sp, #68]
	write_daif(key);
    a0019394:	b94047e0 	ldr	w0, [sp, #68]
    a0019398:	f9001fe0 	str	x0, [sp, #56]
MAKE_REG_HELPER(daif)
    a001939c:	f9401fe0 	ldr	x0, [sp, #56]
    a00193a0:	d51b4220 	msr	daif, x0
    a00193a4:	d503201f 	nop
}
    a00193a8:	d503201f 	nop
}
    a00193ac:	d503201f 	nop
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_thread, join, thread, timeout, ret);

	k_spin_unlock(&sched_spinlock, key);
	return ret;
    a00193b0:	b9406fe0 	ldr	w0, [sp, #108]
}
    a00193b4:	a8c77bfd 	ldp	x29, x30, [sp], #112
    a00193b8:	d65f03c0 	ret

00000000a00193bc <thread_obj_validate>:
 *
 * Return true in this case indicating we should just do nothing and return
 * success to the caller.
 */
static bool thread_obj_validate(struct k_thread *thread)
{
    a00193bc:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a00193c0:	910003fd 	mov	x29, sp
    a00193c4:	f9000fe0 	str	x0, [sp, #24]
	struct z_object *ko = z_object_find(thread);
    a00193c8:	f9400fe0 	ldr	x0, [sp, #24]
    a00193cc:	94000d97 	bl	a001ca28 <z_object_find>
    a00193d0:	f900c3e0 	str	x0, [sp, #384]
	int ret = z_object_validate(ko, K_OBJ_THREAD, _OBJ_INIT_TRUE);
    a00193d4:	52800002 	mov	w2, #0x0                   	// #0
    a00193d8:	52800121 	mov	w1, #0x9                   	// #9
    a00193dc:	f940c3e0 	ldr	x0, [sp, #384]
    a00193e0:	94000fb9 	bl	a001d2c4 <z_object_validate>
    a00193e4:	b9018be0 	str	w0, [sp, #392]

	switch (ret) {
    a00193e8:	b9418be0 	ldr	w0, [sp, #392]
    a00193ec:	3100581f 	cmn	w0, #0x16
    a00193f0:	540000c0 	b.eq	a0019408 <thread_obj_validate+0x4c>  // b.none
    a00193f4:	b9418be0 	ldr	w0, [sp, #392]
    a00193f8:	7100001f 	cmp	w0, #0x0
    a00193fc:	540000a1 	b.ne	a0019410 <thread_obj_validate+0x54>  // b.any
	case 0:
		return false;
    a0019400:	52800000 	mov	w0, #0x0                   	// #0
    a0019404:	14000011 	b	a0019448 <thread_obj_validate+0x8c>
	case -EINVAL:
		return true;
    a0019408:	52800020 	mov	w0, #0x1                   	// #1
    a001940c:	1400000f 	b	a0019448 <thread_obj_validate+0x8c>
	default:
#ifdef CONFIG_LOG
		z_dump_object_error(ret, thread, ko, K_OBJ_THREAD);
#endif
		Z_OOPS(Z_SYSCALL_VERIFY_MSG(ret, "access denied"));
    a0019410:	b9418be0 	ldr	w0, [sp, #392]
    a0019414:	7100001f 	cmp	w0, #0x0
    a0019418:	1a9f17e0 	cset	w0, eq  // eq = none
    a001941c:	39063fe0 	strb	w0, [sp, #399]
    a0019420:	39463fe0 	ldrb	w0, [sp, #399]
    a0019424:	7100001f 	cmp	w0, #0x0
    a0019428:	39463fe0 	ldrb	w0, [sp, #399]
    a001942c:	7100001f 	cmp	w0, #0x0
    a0019430:	540000c0 	b.eq	a0019448 <thread_obj_validate+0x8c>  // b.none
    a0019434:	d0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0019438:	913f8000 	add	x0, x0, #0xfe0
    a001943c:	f9400800 	ldr	x0, [x0, #16]
    a0019440:	f9408400 	ldr	x0, [x0, #264]
    a0019444:	97ffbf45 	bl	a0009158 <arch_syscall_oops>
	}
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
}
    a0019448:	a8d97bfd 	ldp	x29, x30, [sp], #400
    a001944c:	d65f03c0 	ret

00000000a0019450 <z_vrfy_k_thread_join>:

static inline int z_vrfy_k_thread_join(struct k_thread *thread,
				       k_timeout_t timeout)
{
    a0019450:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0019454:	910003fd 	mov	x29, sp
    a0019458:	f9000fe0 	str	x0, [sp, #24]
    a001945c:	f9000be1 	str	x1, [sp, #16]
	if (thread_obj_validate(thread)) {
    a0019460:	f9400fe0 	ldr	x0, [sp, #24]
    a0019464:	97ffffd6 	bl	a00193bc <thread_obj_validate>
    a0019468:	12001c00 	and	w0, w0, #0xff
    a001946c:	7100001f 	cmp	w0, #0x0
    a0019470:	54000060 	b.eq	a001947c <z_vrfy_k_thread_join+0x2c>  // b.none
		return 0;
    a0019474:	52800000 	mov	w0, #0x0                   	// #0
    a0019478:	14000004 	b	a0019488 <z_vrfy_k_thread_join+0x38>
	}

	return z_impl_k_thread_join(thread, timeout);
    a001947c:	f9400be1 	ldr	x1, [sp, #16]
    a0019480:	f9400fe0 	ldr	x0, [sp, #24]
    a0019484:	97ffff76 	bl	a001925c <z_impl_k_thread_join>
}
    a0019488:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a001948c:	d65f03c0 	ret

00000000a0019490 <z_mrsh_k_thread_join>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_thread_join(struct k_thread * thread, k_timeout_t timeout);
uintptr_t z_mrsh_k_thread_join(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a0019490:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a0019494:	910003fd 	mov	x29, sp
    a0019498:	f90027e0 	str	x0, [sp, #72]
    a001949c:	f90023e1 	str	x1, [sp, #64]
    a00194a0:	f9001fe2 	str	x2, [sp, #56]
    a00194a4:	f9001be3 	str	x3, [sp, #48]
    a00194a8:	f90017e4 	str	x4, [sp, #40]
    a00194ac:	f90013e5 	str	x5, [sp, #32]
    a00194b0:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a00194b4:	d0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00194b8:	913f8000 	add	x0, x0, #0xfe0
    a00194bc:	f9400800 	ldr	x0, [x0, #16]
    a00194c0:	f9400fe1 	ldr	x1, [sp, #24]
    a00194c4:	f9008401 	str	x1, [x0, #264]
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_thread_join(*(struct k_thread **)&arg0, *(k_timeout_t*)&arg1)
    a00194c8:	910123e0 	add	x0, sp, #0x48
    a00194cc:	f9400002 	ldr	x2, [x0]
    a00194d0:	910103e0 	add	x0, sp, #0x40
    a00194d4:	f9400001 	ldr	x1, [x0]
    a00194d8:	aa0203e0 	mov	x0, x2
    a00194dc:	97ffffdd 	bl	a0019450 <z_vrfy_k_thread_join>
    a00194e0:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a00194e4:	d0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00194e8:	913f8000 	add	x0, x0, #0xfe0
    a00194ec:	f9400800 	ldr	x0, [x0, #16]
    a00194f0:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a00194f4:	b9805fe0 	ldrsw	x0, [sp, #92]
}
    a00194f8:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a00194fc:	d65f03c0 	ret

00000000a0019500 <z_vrfy_k_thread_abort>:
#include <syscalls/k_thread_join_mrsh.c>

static inline void z_vrfy_k_thread_abort(k_tid_t thread)
{
    a0019500:	a9a57bfd 	stp	x29, x30, [sp, #-432]!
    a0019504:	910003fd 	mov	x29, sp
    a0019508:	f9000fe0 	str	x0, [sp, #24]
	if (thread_obj_validate(thread)) {
    a001950c:	f9400fe0 	ldr	x0, [sp, #24]
    a0019510:	97ffffab 	bl	a00193bc <thread_obj_validate>
    a0019514:	12001c00 	and	w0, w0, #0xff
    a0019518:	7100001f 	cmp	w0, #0x0
    a001951c:	540002a1 	b.ne	a0019570 <z_vrfy_k_thread_abort+0x70>  // b.any
		return;
	}

	Z_OOPS(Z_SYSCALL_VERIFY_MSG(!(thread->base.user_options & K_ESSENTIAL),
    a0019520:	f9400fe0 	ldr	x0, [sp, #24]
    a0019524:	39406000 	ldrb	w0, [x0, #24]
    a0019528:	92401c00 	and	x0, x0, #0xff
    a001952c:	92400000 	and	x0, x0, #0x1
    a0019530:	f100001f 	cmp	x0, #0x0
    a0019534:	1a9f07e0 	cset	w0, ne  // ne = any
    a0019538:	3906bfe0 	strb	w0, [sp, #431]
    a001953c:	3946bfe0 	ldrb	w0, [sp, #431]
    a0019540:	7100001f 	cmp	w0, #0x0
    a0019544:	3946bfe0 	ldrb	w0, [sp, #431]
    a0019548:	7100001f 	cmp	w0, #0x0
    a001954c:	540000c0 	b.eq	a0019564 <z_vrfy_k_thread_abort+0x64>  // b.none
    a0019550:	d0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0019554:	913f8000 	add	x0, x0, #0xfe0
    a0019558:	f9400800 	ldr	x0, [x0, #16]
    a001955c:	f9408400 	ldr	x0, [x0, #264]
    a0019560:	97ffbefe 	bl	a0009158 <arch_syscall_oops>
				    "aborting essential thread %p", thread));

	z_impl_k_thread_abort((struct k_thread *)thread);
    a0019564:	f9400fe0 	ldr	x0, [sp, #24]
    a0019568:	97ffff35 	bl	a001923c <z_impl_k_thread_abort>
    a001956c:	14000002 	b	a0019574 <z_vrfy_k_thread_abort+0x74>
		return;
    a0019570:	d503201f 	nop
}
    a0019574:	a8db7bfd 	ldp	x29, x30, [sp], #432
    a0019578:	d65f03c0 	ret

00000000a001957c <z_mrsh_k_thread_abort>:
#include <syscalls/kernel.h>

extern void z_vrfy_k_thread_abort(k_tid_t thread);
uintptr_t z_mrsh_k_thread_abort(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a001957c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a0019580:	910003fd 	mov	x29, sp
    a0019584:	f90027e0 	str	x0, [sp, #72]
    a0019588:	f90023e1 	str	x1, [sp, #64]
    a001958c:	f9001fe2 	str	x2, [sp, #56]
    a0019590:	f9001be3 	str	x3, [sp, #48]
    a0019594:	f90017e4 	str	x4, [sp, #40]
    a0019598:	f90013e5 	str	x5, [sp, #32]
    a001959c:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a00195a0:	d0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00195a4:	913f8000 	add	x0, x0, #0xfe0
    a00195a8:	f9400800 	ldr	x0, [x0, #16]
    a00195ac:	f9400fe1 	ldr	x1, [sp, #24]
    a00195b0:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_thread_abort(*(k_tid_t*)&arg0)
    a00195b4:	910123e0 	add	x0, sp, #0x48
    a00195b8:	f9400000 	ldr	x0, [x0]
    a00195bc:	97ffffd1 	bl	a0019500 <z_vrfy_k_thread_abort>
;
	_current->syscall_frame = NULL;
    a00195c0:	d0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00195c4:	913f8000 	add	x0, x0, #0xfe0
    a00195c8:	f9400800 	ldr	x0, [x0, #16]
    a00195cc:	f900841f 	str	xzr, [x0, #264]
	return 0;
    a00195d0:	d2800000 	mov	x0, #0x0                   	// #0
}
    a00195d4:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a00195d8:	d65f03c0 	ret

00000000a00195dc <sys_dnode_init>:
{
    a00195dc:	d10043ff 	sub	sp, sp, #0x10
    a00195e0:	f90007e0 	str	x0, [sp, #8]
	node->next = NULL;
    a00195e4:	f94007e0 	ldr	x0, [sp, #8]
    a00195e8:	f900001f 	str	xzr, [x0]
	node->prev = NULL;
    a00195ec:	f94007e0 	ldr	x0, [sp, #8]
    a00195f0:	f900041f 	str	xzr, [x0, #8]
}
    a00195f4:	d503201f 	nop
    a00195f8:	910043ff 	add	sp, sp, #0x10
    a00195fc:	d65f03c0 	ret

00000000a0019600 <sys_dnode_is_linked>:
{
    a0019600:	d10043ff 	sub	sp, sp, #0x10
    a0019604:	f90007e0 	str	x0, [sp, #8]
	return node->next != NULL;
    a0019608:	f94007e0 	ldr	x0, [sp, #8]
    a001960c:	f9400000 	ldr	x0, [x0]
    a0019610:	f100001f 	cmp	x0, #0x0
    a0019614:	1a9f07e0 	cset	w0, ne  // ne = any
    a0019618:	12001c00 	and	w0, w0, #0xff
}
    a001961c:	910043ff 	add	sp, sp, #0x10
    a0019620:	d65f03c0 	ret

00000000a0019624 <sys_dlist_is_empty>:
{
    a0019624:	d10043ff 	sub	sp, sp, #0x10
    a0019628:	f90007e0 	str	x0, [sp, #8]
	return list->head == list;
    a001962c:	f94007e0 	ldr	x0, [sp, #8]
    a0019630:	f9400000 	ldr	x0, [x0]
    a0019634:	f94007e1 	ldr	x1, [sp, #8]
    a0019638:	eb00003f 	cmp	x1, x0
    a001963c:	1a9f17e0 	cset	w0, eq  // eq = none
    a0019640:	12001c00 	and	w0, w0, #0xff
}
    a0019644:	910043ff 	add	sp, sp, #0x10
    a0019648:	d65f03c0 	ret

00000000a001964c <sys_dlist_peek_head>:
{
    a001964c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0019650:	910003fd 	mov	x29, sp
    a0019654:	f9000fe0 	str	x0, [sp, #24]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    a0019658:	f9400fe0 	ldr	x0, [sp, #24]
    a001965c:	97fffff2 	bl	a0019624 <sys_dlist_is_empty>
    a0019660:	12001c00 	and	w0, w0, #0xff
    a0019664:	7100001f 	cmp	w0, #0x0
    a0019668:	54000081 	b.ne	a0019678 <sys_dlist_peek_head+0x2c>  // b.any
    a001966c:	f9400fe0 	ldr	x0, [sp, #24]
    a0019670:	f9400000 	ldr	x0, [x0]
    a0019674:	14000002 	b	a001967c <sys_dlist_peek_head+0x30>
    a0019678:	d2800000 	mov	x0, #0x0                   	// #0
}
    a001967c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0019680:	d65f03c0 	ret

00000000a0019684 <sys_dlist_peek_next_no_check>:
{
    a0019684:	d10043ff 	sub	sp, sp, #0x10
    a0019688:	f90007e0 	str	x0, [sp, #8]
    a001968c:	f90003e1 	str	x1, [sp]
	return (node == list->tail) ? NULL : node->next;
    a0019690:	f94007e0 	ldr	x0, [sp, #8]
    a0019694:	f9400400 	ldr	x0, [x0, #8]
    a0019698:	f94003e1 	ldr	x1, [sp]
    a001969c:	eb00003f 	cmp	x1, x0
    a00196a0:	54000080 	b.eq	a00196b0 <sys_dlist_peek_next_no_check+0x2c>  // b.none
    a00196a4:	f94003e0 	ldr	x0, [sp]
    a00196a8:	f9400000 	ldr	x0, [x0]
    a00196ac:	14000002 	b	a00196b4 <sys_dlist_peek_next_no_check+0x30>
    a00196b0:	d2800000 	mov	x0, #0x0                   	// #0
}
    a00196b4:	910043ff 	add	sp, sp, #0x10
    a00196b8:	d65f03c0 	ret

00000000a00196bc <sys_dlist_peek_next>:
{
    a00196bc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a00196c0:	910003fd 	mov	x29, sp
    a00196c4:	f9000fe0 	str	x0, [sp, #24]
    a00196c8:	f9000be1 	str	x1, [sp, #16]
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    a00196cc:	f9400be0 	ldr	x0, [sp, #16]
    a00196d0:	f100001f 	cmp	x0, #0x0
    a00196d4:	540000a0 	b.eq	a00196e8 <sys_dlist_peek_next+0x2c>  // b.none
    a00196d8:	f9400be1 	ldr	x1, [sp, #16]
    a00196dc:	f9400fe0 	ldr	x0, [sp, #24]
    a00196e0:	97ffffe9 	bl	a0019684 <sys_dlist_peek_next_no_check>
    a00196e4:	14000002 	b	a00196ec <sys_dlist_peek_next+0x30>
    a00196e8:	d2800000 	mov	x0, #0x0                   	// #0
}
    a00196ec:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a00196f0:	d65f03c0 	ret

00000000a00196f4 <sys_dlist_append>:
{
    a00196f4:	d10083ff 	sub	sp, sp, #0x20
    a00196f8:	f90007e0 	str	x0, [sp, #8]
    a00196fc:	f90003e1 	str	x1, [sp]
	sys_dnode_t *const tail = list->tail;
    a0019700:	f94007e0 	ldr	x0, [sp, #8]
    a0019704:	f9400400 	ldr	x0, [x0, #8]
    a0019708:	f9000fe0 	str	x0, [sp, #24]
	node->next = list;
    a001970c:	f94003e0 	ldr	x0, [sp]
    a0019710:	f94007e1 	ldr	x1, [sp, #8]
    a0019714:	f9000001 	str	x1, [x0]
	node->prev = tail;
    a0019718:	f94003e0 	ldr	x0, [sp]
    a001971c:	f9400fe1 	ldr	x1, [sp, #24]
    a0019720:	f9000401 	str	x1, [x0, #8]
	tail->next = node;
    a0019724:	f9400fe0 	ldr	x0, [sp, #24]
    a0019728:	f94003e1 	ldr	x1, [sp]
    a001972c:	f9000001 	str	x1, [x0]
	list->tail = node;
    a0019730:	f94007e0 	ldr	x0, [sp, #8]
    a0019734:	f94003e1 	ldr	x1, [sp]
    a0019738:	f9000401 	str	x1, [x0, #8]
}
    a001973c:	d503201f 	nop
    a0019740:	910083ff 	add	sp, sp, #0x20
    a0019744:	d65f03c0 	ret

00000000a0019748 <sys_dlist_insert>:
{
    a0019748:	d10083ff 	sub	sp, sp, #0x20
    a001974c:	f90007e0 	str	x0, [sp, #8]
    a0019750:	f90003e1 	str	x1, [sp]
	sys_dnode_t *const prev = successor->prev;
    a0019754:	f94007e0 	ldr	x0, [sp, #8]
    a0019758:	f9400400 	ldr	x0, [x0, #8]
    a001975c:	f9000fe0 	str	x0, [sp, #24]
	node->prev = prev;
    a0019760:	f94003e0 	ldr	x0, [sp]
    a0019764:	f9400fe1 	ldr	x1, [sp, #24]
    a0019768:	f9000401 	str	x1, [x0, #8]
	node->next = successor;
    a001976c:	f94003e0 	ldr	x0, [sp]
    a0019770:	f94007e1 	ldr	x1, [sp, #8]
    a0019774:	f9000001 	str	x1, [x0]
	prev->next = node;
    a0019778:	f9400fe0 	ldr	x0, [sp, #24]
    a001977c:	f94003e1 	ldr	x1, [sp]
    a0019780:	f9000001 	str	x1, [x0]
	successor->prev = node;
    a0019784:	f94007e0 	ldr	x0, [sp, #8]
    a0019788:	f94003e1 	ldr	x1, [sp]
    a001978c:	f9000401 	str	x1, [x0, #8]
}
    a0019790:	d503201f 	nop
    a0019794:	910083ff 	add	sp, sp, #0x20
    a0019798:	d65f03c0 	ret

00000000a001979c <sys_dlist_remove>:
{
    a001979c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a00197a0:	910003fd 	mov	x29, sp
    a00197a4:	f9000fe0 	str	x0, [sp, #24]
	sys_dnode_t *const prev = node->prev;
    a00197a8:	f9400fe0 	ldr	x0, [sp, #24]
    a00197ac:	f9400400 	ldr	x0, [x0, #8]
    a00197b0:	f90017e0 	str	x0, [sp, #40]
	sys_dnode_t *const next = node->next;
    a00197b4:	f9400fe0 	ldr	x0, [sp, #24]
    a00197b8:	f9400000 	ldr	x0, [x0]
    a00197bc:	f90013e0 	str	x0, [sp, #32]
	prev->next = next;
    a00197c0:	f94017e0 	ldr	x0, [sp, #40]
    a00197c4:	f94013e1 	ldr	x1, [sp, #32]
    a00197c8:	f9000001 	str	x1, [x0]
	next->prev = prev;
    a00197cc:	f94013e0 	ldr	x0, [sp, #32]
    a00197d0:	f94017e1 	ldr	x1, [sp, #40]
    a00197d4:	f9000401 	str	x1, [x0, #8]
	sys_dnode_init(node);
    a00197d8:	f9400fe0 	ldr	x0, [sp, #24]
    a00197dc:	97ffff80 	bl	a00195dc <sys_dnode_init>
}
    a00197e0:	d503201f 	nop
    a00197e4:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a00197e8:	d65f03c0 	ret

00000000a00197ec <z_is_inactive_timeout>:
{
    a00197ec:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a00197f0:	910003fd 	mov	x29, sp
    a00197f4:	f9000fe0 	str	x0, [sp, #24]
	return !sys_dnode_is_linked(&to->node);
    a00197f8:	f9400fe0 	ldr	x0, [sp, #24]
    a00197fc:	97ffff81 	bl	a0019600 <sys_dnode_is_linked>
    a0019800:	12001c00 	and	w0, w0, #0xff
    a0019804:	7100001f 	cmp	w0, #0x0
    a0019808:	1a9f07e0 	cset	w0, ne  // ne = any
    a001980c:	12001c00 	and	w0, w0, #0xff
    a0019810:	52000000 	eor	w0, w0, #0x1
    a0019814:	12001c00 	and	w0, w0, #0xff
    a0019818:	12000000 	and	w0, w0, #0x1
    a001981c:	12001c00 	and	w0, w0, #0xff
}
    a0019820:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0019824:	d65f03c0 	ret

00000000a0019828 <first>:
#include <syscalls/sys_clock_hw_cycles_per_sec_runtime_get_mrsh.c>
#endif /* CONFIG_USERSPACE */
#endif /* CONFIG_TIMER_READS_ITS_FREQUENCY_AT_RUNTIME */

static struct _timeout *first(void)
{
    a0019828:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a001982c:	910003fd 	mov	x29, sp
	sys_dnode_t *t = sys_dlist_peek_head(&timeout_list);
    a0019830:	d0000400 	adrp	x0, a009b000 <twom1000.10>
    a0019834:	9101c000 	add	x0, x0, #0x70
    a0019838:	97ffff85 	bl	a001964c <sys_dlist_peek_head>
    a001983c:	f9000fe0 	str	x0, [sp, #24]

	return t == NULL ? NULL : CONTAINER_OF(t, struct _timeout, node);
    a0019840:	f9400fe0 	ldr	x0, [sp, #24]
}
    a0019844:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0019848:	d65f03c0 	ret

00000000a001984c <next>:

static struct _timeout *next(struct _timeout *t)
{
    a001984c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0019850:	910003fd 	mov	x29, sp
    a0019854:	f9000fe0 	str	x0, [sp, #24]
	sys_dnode_t *n = sys_dlist_peek_next(&timeout_list, &t->node);
    a0019858:	f9400fe0 	ldr	x0, [sp, #24]
    a001985c:	aa0003e1 	mov	x1, x0
    a0019860:	d0000400 	adrp	x0, a009b000 <twom1000.10>
    a0019864:	9101c000 	add	x0, x0, #0x70
    a0019868:	97ffff95 	bl	a00196bc <sys_dlist_peek_next>
    a001986c:	f90017e0 	str	x0, [sp, #40]

	return n == NULL ? NULL : CONTAINER_OF(n, struct _timeout, node);
    a0019870:	f94017e0 	ldr	x0, [sp, #40]
}
    a0019874:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0019878:	d65f03c0 	ret

00000000a001987c <remove_timeout>:

static void remove_timeout(struct _timeout *t)
{
    a001987c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0019880:	910003fd 	mov	x29, sp
    a0019884:	f9000fe0 	str	x0, [sp, #24]
	if (next(t) != NULL) {
    a0019888:	f9400fe0 	ldr	x0, [sp, #24]
    a001988c:	97fffff0 	bl	a001984c <next>
    a0019890:	f100001f 	cmp	x0, #0x0
    a0019894:	54000100 	b.eq	a00198b4 <remove_timeout+0x38>  // b.none
		next(t)->dticks += t->dticks;
    a0019898:	f9400fe0 	ldr	x0, [sp, #24]
    a001989c:	97ffffec 	bl	a001984c <next>
    a00198a0:	f9400c02 	ldr	x2, [x0, #24]
    a00198a4:	f9400fe1 	ldr	x1, [sp, #24]
    a00198a8:	f9400c21 	ldr	x1, [x1, #24]
    a00198ac:	8b010041 	add	x1, x2, x1
    a00198b0:	f9000c01 	str	x1, [x0, #24]
	}

	sys_dlist_remove(&t->node);
    a00198b4:	f9400fe0 	ldr	x0, [sp, #24]
    a00198b8:	97ffffb9 	bl	a001979c <sys_dlist_remove>
}
    a00198bc:	d503201f 	nop
    a00198c0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a00198c4:	d65f03c0 	ret

00000000a00198c8 <elapsed>:

static int32_t elapsed(void)
{
    a00198c8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    a00198cc:	910003fd 	mov	x29, sp
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
    a00198d0:	f00003a0 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a00198d4:	9111b000 	add	x0, x0, #0x46c
    a00198d8:	b9400000 	ldr	w0, [x0]
    a00198dc:	7100001f 	cmp	w0, #0x0
    a00198e0:	54000061 	b.ne	a00198ec <elapsed+0x24>  // b.any
    a00198e4:	97ffdb40 	bl	a00105e4 <sys_clock_elapsed>
    a00198e8:	14000002 	b	a00198f0 <elapsed+0x28>
    a00198ec:	52800000 	mov	w0, #0x0                   	// #0
}
    a00198f0:	a8c17bfd 	ldp	x29, x30, [sp], #16
    a00198f4:	d65f03c0 	ret

00000000a00198f8 <next_timeout>:

static int32_t next_timeout(void)
{
    a00198f8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a00198fc:	910003fd 	mov	x29, sp
	struct _timeout *to = first();
    a0019900:	97ffffca 	bl	a0019828 <first>
    a0019904:	f90013e0 	str	x0, [sp, #32]
	int32_t ticks_elapsed = elapsed();
    a0019908:	97fffff0 	bl	a00198c8 <elapsed>
    a001990c:	b9001fe0 	str	w0, [sp, #28]
	int32_t ret = to == NULL ? MAX_WAIT
    a0019910:	f94013e0 	ldr	x0, [sp, #32]
    a0019914:	f100001f 	cmp	x0, #0x0
    a0019918:	54000240 	b.eq	a0019960 <next_timeout+0x68>  // b.none
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
    a001991c:	f94013e0 	ldr	x0, [sp, #32]
    a0019920:	f9400c01 	ldr	x1, [x0, #24]
    a0019924:	b9801fe0 	ldrsw	x0, [sp, #28]
    a0019928:	cb000020 	sub	x0, x1, x0
	int32_t ret = to == NULL ? MAX_WAIT
    a001992c:	f100001f 	cmp	x0, #0x0
    a0019930:	5400014d 	b.le	a0019958 <next_timeout+0x60>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
    a0019934:	f94013e0 	ldr	x0, [sp, #32]
    a0019938:	f9400c01 	ldr	x1, [x0, #24]
    a001993c:	b9801fe0 	ldrsw	x0, [sp, #28]
    a0019940:	cb000020 	sub	x0, x1, x0
    a0019944:	b2407be2 	mov	x2, #0x7fffffff            	// #2147483647
    a0019948:	b2407be1 	mov	x1, #0x7fffffff            	// #2147483647
    a001994c:	eb02001f 	cmp	x0, x2
    a0019950:	9a81d000 	csel	x0, x0, x1, le
    a0019954:	14000004 	b	a0019964 <next_timeout+0x6c>
	int32_t ret = to == NULL ? MAX_WAIT
    a0019958:	52800000 	mov	w0, #0x0                   	// #0
    a001995c:	14000002 	b	a0019964 <next_timeout+0x6c>
    a0019960:	12b00000 	mov	w0, #0x7fffffff            	// #2147483647
    a0019964:	b9002fe0 	str	w0, [sp, #44]

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
    a0019968:	d0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001996c:	913f8000 	add	x0, x0, #0xfe0
    a0019970:	b9402000 	ldr	w0, [x0, #32]
    a0019974:	7100001f 	cmp	w0, #0x0
    a0019978:	54000160 	b.eq	a00199a4 <next_timeout+0xac>  // b.none
    a001997c:	d0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0019980:	913f8000 	add	x0, x0, #0xfe0
    a0019984:	b9402000 	ldr	w0, [x0, #32]
    a0019988:	b9402fe1 	ldr	w1, [sp, #44]
    a001998c:	6b00003f 	cmp	w1, w0
    a0019990:	540000ad 	b.le	a00199a4 <next_timeout+0xac>
		ret = _current_cpu->slice_ticks;
    a0019994:	d0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0019998:	913f8000 	add	x0, x0, #0xfe0
    a001999c:	b9402000 	ldr	w0, [x0, #32]
    a00199a0:	b9002fe0 	str	w0, [sp, #44]
	}
#endif
	return ret;
    a00199a4:	b9402fe0 	ldr	w0, [sp, #44]
}
    a00199a8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a00199ac:	d65f03c0 	ret

00000000a00199b0 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
    a00199b0:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
    a00199b4:	910003fd 	mov	x29, sp
    a00199b8:	f9000bf3 	str	x19, [sp, #16]
    a00199bc:	f9001fe0 	str	x0, [sp, #56]
    a00199c0:	f9001be1 	str	x1, [sp, #48]
    a00199c4:	f90017e2 	str	x2, [sp, #40]
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    a00199c8:	f94017e0 	ldr	x0, [sp, #40]
    a00199cc:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
    a00199d0:	eb01001f 	cmp	x0, x1
    a00199d4:	54001020 	b.eq	a0019bd8 <z_add_timeout+0x228>  // b.none
#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
    a00199d8:	f9401fe0 	ldr	x0, [sp, #56]
    a00199dc:	f9401be1 	ldr	x1, [sp, #48]
    a00199e0:	f9000801 	str	x1, [x0, #16]

	LOCKED(&timeout_lock) {
    a00199e4:	b90063ff 	str	wzr, [sp, #96]
    a00199e8:	f0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a00199ec:	910a6000 	add	x0, x0, #0x298
    a00199f0:	f9004be0 	str	x0, [sp, #144]
    a00199f4:	d53b4220 	mrs	x0, daif
    a00199f8:	f90047e0 	str	x0, [sp, #136]
    a00199fc:	f94047e0 	ldr	x0, [sp, #136]
    a0019a00:	d503201f 	nop
	key = read_daif();
    a0019a04:	b90087e0 	str	w0, [sp, #132]
	__asm__ volatile ("msr DAIFSet, %0"
    a0019a08:	d50342df 	msr	daifset, #0x2
}
    a0019a0c:	d503201f 	nop
	return key;
    a0019a10:	b94087e0 	ldr	w0, [sp, #132]
	k.key = arch_irq_lock();
    a0019a14:	b9004be0 	str	w0, [sp, #72]
	return k;
    a0019a18:	b9404be0 	ldr	w0, [sp, #72]
    a0019a1c:	b9005be0 	str	w0, [sp, #88]
    a0019a20:	1400006a 	b	a0019bc8 <z_add_timeout+0x218>
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
		    Z_TICK_ABS(timeout.ticks) >= 0) {
    a0019a24:	f94017e0 	ldr	x0, [sp, #40]
    a0019a28:	92800021 	mov	x1, #0xfffffffffffffffe    	// #-2
    a0019a2c:	cb000020 	sub	x0, x1, x0
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
    a0019a30:	f100001f 	cmp	x0, #0x0
    a0019a34:	5400024b 	b.lt	a0019a7c <z_add_timeout+0xcc>  // b.tstop
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
    a0019a38:	f94017e0 	ldr	x0, [sp, #40]
    a0019a3c:	aa0003e1 	mov	x1, x0
    a0019a40:	f0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a0019a44:	910a4000 	add	x0, x0, #0x290
    a0019a48:	f9400000 	ldr	x0, [x0]
    a0019a4c:	8b000020 	add	x0, x1, x0
    a0019a50:	92800021 	mov	x1, #0xfffffffffffffffe    	// #-2
    a0019a54:	cb000020 	sub	x0, x1, x0
    a0019a58:	f90053e0 	str	x0, [sp, #160]

			to->dticks = MAX(1, ticks);
    a0019a5c:	f94053e2 	ldr	x2, [sp, #160]
    a0019a60:	f94053e1 	ldr	x1, [sp, #160]
    a0019a64:	d2800020 	mov	x0, #0x1                   	// #1
    a0019a68:	f100005f 	cmp	x2, #0x0
    a0019a6c:	9a80c021 	csel	x1, x1, x0, gt
    a0019a70:	f9401fe0 	ldr	x0, [sp, #56]
    a0019a74:	f9000c01 	str	x1, [x0, #24]
    a0019a78:	14000008 	b	a0019a98 <z_add_timeout+0xe8>
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
    a0019a7c:	f94017e0 	ldr	x0, [sp, #40]
    a0019a80:	91000413 	add	x19, x0, #0x1
    a0019a84:	97ffff91 	bl	a00198c8 <elapsed>
    a0019a88:	93407c00 	sxtw	x0, w0
    a0019a8c:	8b000261 	add	x1, x19, x0
    a0019a90:	f9401fe0 	ldr	x0, [sp, #56]
    a0019a94:	f9000c01 	str	x1, [x0, #24]
		}

		for (t = first(); t != NULL; t = next(t)) {
    a0019a98:	97ffff64 	bl	a0019828 <first>
    a0019a9c:	f90057e0 	str	x0, [sp, #168]
    a0019aa0:	1400001c 	b	a0019b10 <z_add_timeout+0x160>
			if (t->dticks > to->dticks) {
    a0019aa4:	f94057e0 	ldr	x0, [sp, #168]
    a0019aa8:	f9400c01 	ldr	x1, [x0, #24]
    a0019aac:	f9401fe0 	ldr	x0, [sp, #56]
    a0019ab0:	f9400c00 	ldr	x0, [x0, #24]
    a0019ab4:	eb00003f 	cmp	x1, x0
    a0019ab8:	5400018d 	b.le	a0019ae8 <z_add_timeout+0x138>
				t->dticks -= to->dticks;
    a0019abc:	f94057e0 	ldr	x0, [sp, #168]
    a0019ac0:	f9400c01 	ldr	x1, [x0, #24]
    a0019ac4:	f9401fe0 	ldr	x0, [sp, #56]
    a0019ac8:	f9400c00 	ldr	x0, [x0, #24]
    a0019acc:	cb000021 	sub	x1, x1, x0
    a0019ad0:	f94057e0 	ldr	x0, [sp, #168]
    a0019ad4:	f9000c01 	str	x1, [x0, #24]
				sys_dlist_insert(&t->node, &to->node);
    a0019ad8:	f94057e0 	ldr	x0, [sp, #168]
    a0019adc:	f9401fe1 	ldr	x1, [sp, #56]
    a0019ae0:	97ffff1a 	bl	a0019748 <sys_dlist_insert>
				break;
    a0019ae4:	1400000e 	b	a0019b1c <z_add_timeout+0x16c>
			}
			to->dticks -= t->dticks;
    a0019ae8:	f9401fe0 	ldr	x0, [sp, #56]
    a0019aec:	f9400c01 	ldr	x1, [x0, #24]
    a0019af0:	f94057e0 	ldr	x0, [sp, #168]
    a0019af4:	f9400c00 	ldr	x0, [x0, #24]
    a0019af8:	cb000021 	sub	x1, x1, x0
    a0019afc:	f9401fe0 	ldr	x0, [sp, #56]
    a0019b00:	f9000c01 	str	x1, [x0, #24]
		for (t = first(); t != NULL; t = next(t)) {
    a0019b04:	f94057e0 	ldr	x0, [sp, #168]
    a0019b08:	97ffff51 	bl	a001984c <next>
    a0019b0c:	f90057e0 	str	x0, [sp, #168]
    a0019b10:	f94057e0 	ldr	x0, [sp, #168]
    a0019b14:	f100001f 	cmp	x0, #0x0
    a0019b18:	54fffc61 	b.ne	a0019aa4 <z_add_timeout+0xf4>  // b.any
		}

		if (t == NULL) {
    a0019b1c:	f94057e0 	ldr	x0, [sp, #168]
    a0019b20:	f100001f 	cmp	x0, #0x0
    a0019b24:	540000c1 	b.ne	a0019b3c <z_add_timeout+0x18c>  // b.any
			sys_dlist_append(&timeout_list, &to->node);
    a0019b28:	f9401fe0 	ldr	x0, [sp, #56]
    a0019b2c:	aa0003e1 	mov	x1, x0
    a0019b30:	d0000400 	adrp	x0, a009b000 <twom1000.10>
    a0019b34:	9101c000 	add	x0, x0, #0x70
    a0019b38:	97fffeef 	bl	a00196f4 <sys_dlist_append>
		}

		if (to == first()) {
    a0019b3c:	97ffff3b 	bl	a0019828 <first>
    a0019b40:	aa0003e1 	mov	x1, x0
    a0019b44:	f9401fe0 	ldr	x0, [sp, #56]
    a0019b48:	eb01001f 	cmp	x0, x1
    a0019b4c:	540001e1 	b.ne	a0019b88 <z_add_timeout+0x1d8>  // b.any
			 * last announcement, and slice_ticks is based
			 * on that. It means that the time remaining for
			 * the next announcement can be less than
			 * slice_ticks.
			 */
			int32_t next_time = next_timeout();
    a0019b50:	97ffff6a 	bl	a00198f8 <next_timeout>
    a0019b54:	b9009fe0 	str	w0, [sp, #156]

			if (next_time == 0 ||
    a0019b58:	b9409fe0 	ldr	w0, [sp, #156]
    a0019b5c:	7100001f 	cmp	w0, #0x0
    a0019b60:	540000e0 	b.eq	a0019b7c <z_add_timeout+0x1cc>  // b.none
			    _current_cpu->slice_ticks != next_time) {
    a0019b64:	d0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0019b68:	913f8000 	add	x0, x0, #0xfe0
    a0019b6c:	b9402000 	ldr	w0, [x0, #32]
			if (next_time == 0 ||
    a0019b70:	b9409fe1 	ldr	w1, [sp, #156]
    a0019b74:	6b00003f 	cmp	w1, w0
    a0019b78:	54000080 	b.eq	a0019b88 <z_add_timeout+0x1d8>  // b.none
				sys_clock_set_timeout(next_time, false);
    a0019b7c:	52800001 	mov	w1, #0x0                   	// #0
    a0019b80:	b9409fe0 	ldr	w0, [sp, #156]
    a0019b84:	97ffd9ef 	bl	a0010340 <sys_clock_set_timeout>
    a0019b88:	f0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a0019b8c:	910a6000 	add	x0, x0, #0x298
    a0019b90:	f9003fe0 	str	x0, [sp, #120]
    a0019b94:	b9405be0 	ldr	w0, [sp, #88]
    a0019b98:	b90053e0 	str	w0, [sp, #80]
	arch_irq_unlock(key.key);
    a0019b9c:	b94053e0 	ldr	w0, [sp, #80]
    a0019ba0:	b90077e0 	str	w0, [sp, #116]
	write_daif(key);
    a0019ba4:	b94077e0 	ldr	w0, [sp, #116]
    a0019ba8:	f90037e0 	str	x0, [sp, #104]
MAKE_REG_HELPER(daif)
    a0019bac:	f94037e0 	ldr	x0, [sp, #104]
    a0019bb0:	d51b4220 	msr	daif, x0
    a0019bb4:	d503201f 	nop
}
    a0019bb8:	d503201f 	nop
}
    a0019bbc:	d503201f 	nop
	LOCKED(&timeout_lock) {
    a0019bc0:	52800020 	mov	w0, #0x1                   	// #1
    a0019bc4:	b90063e0 	str	w0, [sp, #96]
    a0019bc8:	b94063e0 	ldr	w0, [sp, #96]
    a0019bcc:	7100001f 	cmp	w0, #0x0
    a0019bd0:	54fff2a0 	b.eq	a0019a24 <z_add_timeout+0x74>  // b.none
    a0019bd4:	14000002 	b	a0019bdc <z_add_timeout+0x22c>
		return;
    a0019bd8:	d503201f 	nop
#else
			sys_clock_set_timeout(next_timeout(), false);
#endif	/* CONFIG_TIMESLICING */
		}
	}
}
    a0019bdc:	f9400bf3 	ldr	x19, [sp, #16]
    a0019be0:	a8cb7bfd 	ldp	x29, x30, [sp], #176
    a0019be4:	d65f03c0 	ret

00000000a0019be8 <z_abort_timeout>:

int z_abort_timeout(struct _timeout *to)
{
    a0019be8:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
    a0019bec:	910003fd 	mov	x29, sp
    a0019bf0:	f9000fe0 	str	x0, [sp, #24]
	int ret = -EINVAL;
    a0019bf4:	128002a0 	mov	w0, #0xffffffea            	// #-22
    a0019bf8:	b9007fe0 	str	w0, [sp, #124]

	LOCKED(&timeout_lock) {
    a0019bfc:	b90043ff 	str	wzr, [sp, #64]
    a0019c00:	f0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a0019c04:	910a6000 	add	x0, x0, #0x298
    a0019c08:	f9003be0 	str	x0, [sp, #112]
    a0019c0c:	d53b4220 	mrs	x0, daif
    a0019c10:	f90037e0 	str	x0, [sp, #104]
    a0019c14:	f94037e0 	ldr	x0, [sp, #104]
    a0019c18:	d503201f 	nop
	key = read_daif();
    a0019c1c:	b90067e0 	str	w0, [sp, #100]
	__asm__ volatile ("msr DAIFSet, %0"
    a0019c20:	d50342df 	msr	daifset, #0x2
}
    a0019c24:	d503201f 	nop
	return key;
    a0019c28:	b94067e0 	ldr	w0, [sp, #100]
	k.key = arch_irq_lock();
    a0019c2c:	b9002be0 	str	w0, [sp, #40]
	return k;
    a0019c30:	b9402be0 	ldr	w0, [sp, #40]
    a0019c34:	b9003be0 	str	w0, [sp, #56]
    a0019c38:	14000019 	b	a0019c9c <z_abort_timeout+0xb4>
		if (sys_dnode_is_linked(&to->node)) {
    a0019c3c:	f9400fe0 	ldr	x0, [sp, #24]
    a0019c40:	97fffe70 	bl	a0019600 <sys_dnode_is_linked>
    a0019c44:	12001c00 	and	w0, w0, #0xff
    a0019c48:	7100001f 	cmp	w0, #0x0
    a0019c4c:	54000080 	b.eq	a0019c5c <z_abort_timeout+0x74>  // b.none
			remove_timeout(to);
    a0019c50:	f9400fe0 	ldr	x0, [sp, #24]
    a0019c54:	97ffff0a 	bl	a001987c <remove_timeout>
			ret = 0;
    a0019c58:	b9007fff 	str	wzr, [sp, #124]
    a0019c5c:	f0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a0019c60:	910a6000 	add	x0, x0, #0x298
    a0019c64:	f9002fe0 	str	x0, [sp, #88]
    a0019c68:	b9403be0 	ldr	w0, [sp, #56]
    a0019c6c:	b90033e0 	str	w0, [sp, #48]
	arch_irq_unlock(key.key);
    a0019c70:	b94033e0 	ldr	w0, [sp, #48]
    a0019c74:	b90057e0 	str	w0, [sp, #84]
	write_daif(key);
    a0019c78:	b94057e0 	ldr	w0, [sp, #84]
    a0019c7c:	f90027e0 	str	x0, [sp, #72]
MAKE_REG_HELPER(daif)
    a0019c80:	f94027e0 	ldr	x0, [sp, #72]
    a0019c84:	d51b4220 	msr	daif, x0
    a0019c88:	d503201f 	nop
}
    a0019c8c:	d503201f 	nop
}
    a0019c90:	d503201f 	nop
	LOCKED(&timeout_lock) {
    a0019c94:	52800020 	mov	w0, #0x1                   	// #1
    a0019c98:	b90043e0 	str	w0, [sp, #64]
    a0019c9c:	b94043e0 	ldr	w0, [sp, #64]
    a0019ca0:	7100001f 	cmp	w0, #0x0
    a0019ca4:	54fffcc0 	b.eq	a0019c3c <z_abort_timeout+0x54>  // b.none
		}
	}

	return ret;
    a0019ca8:	b9407fe0 	ldr	w0, [sp, #124]
}
    a0019cac:	a8c87bfd 	ldp	x29, x30, [sp], #128
    a0019cb0:	d65f03c0 	ret

00000000a0019cb4 <timeout_rem>:

/* must be locked */
static k_ticks_t timeout_rem(const struct _timeout *timeout)
{
    a0019cb4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0019cb8:	910003fd 	mov	x29, sp
    a0019cbc:	f9000fe0 	str	x0, [sp, #24]
	k_ticks_t ticks = 0;
    a0019cc0:	f90017ff 	str	xzr, [sp, #40]

	if (z_is_inactive_timeout(timeout)) {
    a0019cc4:	f9400fe0 	ldr	x0, [sp, #24]
    a0019cc8:	97fffec9 	bl	a00197ec <z_is_inactive_timeout>
    a0019ccc:	12001c00 	and	w0, w0, #0xff
    a0019cd0:	7100001f 	cmp	w0, #0x0
    a0019cd4:	54000060 	b.eq	a0019ce0 <timeout_rem+0x2c>  // b.none
		return 0;
    a0019cd8:	d2800000 	mov	x0, #0x0                   	// #0
    a0019cdc:	14000019 	b	a0019d40 <timeout_rem+0x8c>
	}

	for (struct _timeout *t = first(); t != NULL; t = next(t)) {
    a0019ce0:	97fffed2 	bl	a0019828 <first>
    a0019ce4:	f90013e0 	str	x0, [sp, #32]
    a0019ce8:	1400000d 	b	a0019d1c <timeout_rem+0x68>
		ticks += t->dticks;
    a0019cec:	f94013e0 	ldr	x0, [sp, #32]
    a0019cf0:	f9400c00 	ldr	x0, [x0, #24]
    a0019cf4:	f94017e1 	ldr	x1, [sp, #40]
    a0019cf8:	8b000020 	add	x0, x1, x0
    a0019cfc:	f90017e0 	str	x0, [sp, #40]
		if (timeout == t) {
    a0019d00:	f9400fe1 	ldr	x1, [sp, #24]
    a0019d04:	f94013e0 	ldr	x0, [sp, #32]
    a0019d08:	eb00003f 	cmp	x1, x0
    a0019d0c:	54000100 	b.eq	a0019d2c <timeout_rem+0x78>  // b.none
	for (struct _timeout *t = first(); t != NULL; t = next(t)) {
    a0019d10:	f94013e0 	ldr	x0, [sp, #32]
    a0019d14:	97fffece 	bl	a001984c <next>
    a0019d18:	f90013e0 	str	x0, [sp, #32]
    a0019d1c:	f94013e0 	ldr	x0, [sp, #32]
    a0019d20:	f100001f 	cmp	x0, #0x0
    a0019d24:	54fffe41 	b.ne	a0019cec <timeout_rem+0x38>  // b.any
    a0019d28:	14000002 	b	a0019d30 <timeout_rem+0x7c>
			break;
    a0019d2c:	d503201f 	nop
		}
	}

	return ticks - elapsed();
    a0019d30:	97fffee6 	bl	a00198c8 <elapsed>
    a0019d34:	93407c00 	sxtw	x0, w0
    a0019d38:	f94017e1 	ldr	x1, [sp, #40]
    a0019d3c:	cb000020 	sub	x0, x1, x0
}
    a0019d40:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0019d44:	d65f03c0 	ret

00000000a0019d48 <z_timeout_remaining>:

k_ticks_t z_timeout_remaining(const struct _timeout *timeout)
{
    a0019d48:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
    a0019d4c:	910003fd 	mov	x29, sp
    a0019d50:	f9000fe0 	str	x0, [sp, #24]
	k_ticks_t ticks = 0;
    a0019d54:	f9003fff 	str	xzr, [sp, #120]

	LOCKED(&timeout_lock) {
    a0019d58:	b90043ff 	str	wzr, [sp, #64]
    a0019d5c:	f0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a0019d60:	910a6000 	add	x0, x0, #0x298
    a0019d64:	f9003be0 	str	x0, [sp, #112]
    a0019d68:	d53b4220 	mrs	x0, daif
    a0019d6c:	f90037e0 	str	x0, [sp, #104]
    a0019d70:	f94037e0 	ldr	x0, [sp, #104]
    a0019d74:	d503201f 	nop
	key = read_daif();
    a0019d78:	b90067e0 	str	w0, [sp, #100]
	__asm__ volatile ("msr DAIFSet, %0"
    a0019d7c:	d50342df 	msr	daifset, #0x2
}
    a0019d80:	d503201f 	nop
	return key;
    a0019d84:	b94067e0 	ldr	w0, [sp, #100]
	k.key = arch_irq_lock();
    a0019d88:	b9002be0 	str	w0, [sp, #40]
	return k;
    a0019d8c:	b9402be0 	ldr	w0, [sp, #40]
    a0019d90:	b9003be0 	str	w0, [sp, #56]
    a0019d94:	14000014 	b	a0019de4 <z_timeout_remaining+0x9c>
		ticks = timeout_rem(timeout);
    a0019d98:	f9400fe0 	ldr	x0, [sp, #24]
    a0019d9c:	97ffffc6 	bl	a0019cb4 <timeout_rem>
    a0019da0:	f9003fe0 	str	x0, [sp, #120]
    a0019da4:	f0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a0019da8:	910a6000 	add	x0, x0, #0x298
    a0019dac:	f9002fe0 	str	x0, [sp, #88]
    a0019db0:	b9403be0 	ldr	w0, [sp, #56]
    a0019db4:	b90033e0 	str	w0, [sp, #48]
	arch_irq_unlock(key.key);
    a0019db8:	b94033e0 	ldr	w0, [sp, #48]
    a0019dbc:	b90057e0 	str	w0, [sp, #84]
	write_daif(key);
    a0019dc0:	b94057e0 	ldr	w0, [sp, #84]
    a0019dc4:	f90027e0 	str	x0, [sp, #72]
MAKE_REG_HELPER(daif)
    a0019dc8:	f94027e0 	ldr	x0, [sp, #72]
    a0019dcc:	d51b4220 	msr	daif, x0
    a0019dd0:	d503201f 	nop
}
    a0019dd4:	d503201f 	nop
}
    a0019dd8:	d503201f 	nop
	LOCKED(&timeout_lock) {
    a0019ddc:	52800020 	mov	w0, #0x1                   	// #1
    a0019de0:	b90043e0 	str	w0, [sp, #64]
    a0019de4:	b94043e0 	ldr	w0, [sp, #64]
    a0019de8:	7100001f 	cmp	w0, #0x0
    a0019dec:	54fffd60 	b.eq	a0019d98 <z_timeout_remaining+0x50>  // b.none
	}

	return ticks;
    a0019df0:	f9403fe0 	ldr	x0, [sp, #120]
}
    a0019df4:	a8c87bfd 	ldp	x29, x30, [sp], #128
    a0019df8:	d65f03c0 	ret

00000000a0019dfc <z_timeout_expires>:

k_ticks_t z_timeout_expires(const struct _timeout *timeout)
{
    a0019dfc:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
    a0019e00:	910003fd 	mov	x29, sp
    a0019e04:	f9000fe0 	str	x0, [sp, #24]
	k_ticks_t ticks = 0;
    a0019e08:	f9003fff 	str	xzr, [sp, #120]

	LOCKED(&timeout_lock) {
    a0019e0c:	b90043ff 	str	wzr, [sp, #64]
    a0019e10:	f0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a0019e14:	910a6000 	add	x0, x0, #0x298
    a0019e18:	f9003be0 	str	x0, [sp, #112]
    a0019e1c:	d53b4220 	mrs	x0, daif
    a0019e20:	f90037e0 	str	x0, [sp, #104]
    a0019e24:	f94037e0 	ldr	x0, [sp, #104]
    a0019e28:	d503201f 	nop
	key = read_daif();
    a0019e2c:	b90067e0 	str	w0, [sp, #100]
	__asm__ volatile ("msr DAIFSet, %0"
    a0019e30:	d50342df 	msr	daifset, #0x2
}
    a0019e34:	d503201f 	nop
	return key;
    a0019e38:	b94067e0 	ldr	w0, [sp, #100]
	k.key = arch_irq_lock();
    a0019e3c:	b9002be0 	str	w0, [sp, #40]
	return k;
    a0019e40:	b9402be0 	ldr	w0, [sp, #40]
    a0019e44:	b9003be0 	str	w0, [sp, #56]
    a0019e48:	14000019 	b	a0019eac <z_timeout_expires+0xb0>
		ticks = curr_tick + timeout_rem(timeout);
    a0019e4c:	f9400fe0 	ldr	x0, [sp, #24]
    a0019e50:	97ffff99 	bl	a0019cb4 <timeout_rem>
    a0019e54:	aa0003e1 	mov	x1, x0
    a0019e58:	f0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a0019e5c:	910a4000 	add	x0, x0, #0x290
    a0019e60:	f9400000 	ldr	x0, [x0]
    a0019e64:	8b000020 	add	x0, x1, x0
    a0019e68:	f9003fe0 	str	x0, [sp, #120]
    a0019e6c:	f0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a0019e70:	910a6000 	add	x0, x0, #0x298
    a0019e74:	f9002fe0 	str	x0, [sp, #88]
    a0019e78:	b9403be0 	ldr	w0, [sp, #56]
    a0019e7c:	b90033e0 	str	w0, [sp, #48]
	arch_irq_unlock(key.key);
    a0019e80:	b94033e0 	ldr	w0, [sp, #48]
    a0019e84:	b90057e0 	str	w0, [sp, #84]
	write_daif(key);
    a0019e88:	b94057e0 	ldr	w0, [sp, #84]
    a0019e8c:	f90027e0 	str	x0, [sp, #72]
MAKE_REG_HELPER(daif)
    a0019e90:	f94027e0 	ldr	x0, [sp, #72]
    a0019e94:	d51b4220 	msr	daif, x0
    a0019e98:	d503201f 	nop
}
    a0019e9c:	d503201f 	nop
}
    a0019ea0:	d503201f 	nop
	LOCKED(&timeout_lock) {
    a0019ea4:	52800020 	mov	w0, #0x1                   	// #1
    a0019ea8:	b90043e0 	str	w0, [sp, #64]
    a0019eac:	b94043e0 	ldr	w0, [sp, #64]
    a0019eb0:	7100001f 	cmp	w0, #0x0
    a0019eb4:	54fffcc0 	b.eq	a0019e4c <z_timeout_expires+0x50>  // b.none
	}

	return ticks;
    a0019eb8:	f9403fe0 	ldr	x0, [sp, #120]
}
    a0019ebc:	a8c87bfd 	ldp	x29, x30, [sp], #128
    a0019ec0:	d65f03c0 	ret

00000000a0019ec4 <z_set_timeout_expiry>:
	}
	return ret;
}

void z_set_timeout_expiry(int32_t ticks, bool is_idle)
{
    a0019ec4:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
    a0019ec8:	910003fd 	mov	x29, sp
    a0019ecc:	b9001fe0 	str	w0, [sp, #28]
    a0019ed0:	39006fe1 	strb	w1, [sp, #27]
	LOCKED(&timeout_lock) {
    a0019ed4:	b90043ff 	str	wzr, [sp, #64]
    a0019ed8:	f0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a0019edc:	910a6000 	add	x0, x0, #0x298
    a0019ee0:	f9003be0 	str	x0, [sp, #112]
    a0019ee4:	d53b4220 	mrs	x0, daif
    a0019ee8:	f90037e0 	str	x0, [sp, #104]
    a0019eec:	f94037e0 	ldr	x0, [sp, #104]
    a0019ef0:	d503201f 	nop
	key = read_daif();
    a0019ef4:	b90067e0 	str	w0, [sp, #100]
	__asm__ volatile ("msr DAIFSet, %0"
    a0019ef8:	d50342df 	msr	daifset, #0x2
}
    a0019efc:	d503201f 	nop
	return key;
    a0019f00:	b94067e0 	ldr	w0, [sp, #100]
	k.key = arch_irq_lock();
    a0019f04:	b9002be0 	str	w0, [sp, #40]
	return k;
    a0019f08:	b9402be0 	ldr	w0, [sp, #40]
    a0019f0c:	b9003be0 	str	w0, [sp, #56]
    a0019f10:	14000034 	b	a0019fe0 <z_set_timeout_expiry+0x11c>
		int next_to = next_timeout();
    a0019f14:	97fffe79 	bl	a00198f8 <next_timeout>
    a0019f18:	b9007fe0 	str	w0, [sp, #124]
		bool sooner = (next_to == K_TICKS_FOREVER)
			      || (ticks <= next_to);
    a0019f1c:	b9407fe0 	ldr	w0, [sp, #124]
    a0019f20:	3100041f 	cmn	w0, #0x1
    a0019f24:	540000a0 	b.eq	a0019f38 <z_set_timeout_expiry+0x74>  // b.none
    a0019f28:	b9401fe1 	ldr	w1, [sp, #28]
    a0019f2c:	b9407fe0 	ldr	w0, [sp, #124]
    a0019f30:	6b00003f 	cmp	w1, w0
    a0019f34:	5400006c 	b.gt	a0019f40 <z_set_timeout_expiry+0x7c>
    a0019f38:	52800020 	mov	w0, #0x1                   	// #1
    a0019f3c:	14000002 	b	a0019f44 <z_set_timeout_expiry+0x80>
    a0019f40:	52800000 	mov	w0, #0x0                   	// #0
		bool sooner = (next_to == K_TICKS_FOREVER)
    a0019f44:	3901efe0 	strb	w0, [sp, #123]
    a0019f48:	3941efe0 	ldrb	w0, [sp, #123]
    a0019f4c:	12000000 	and	w0, w0, #0x1
    a0019f50:	3901efe0 	strb	w0, [sp, #123]
		bool imminent = next_to <= 1;
    a0019f54:	b9407fe0 	ldr	w0, [sp, #124]
    a0019f58:	7100041f 	cmp	w0, #0x1
    a0019f5c:	1a9fc7e0 	cset	w0, le
    a0019f60:	3901ebe0 	strb	w0, [sp, #122]
		 * SMP can't use this optimization though: we don't
		 * know when context switches happen until interrupt
		 * exit and so can't get the timeslicing clamp folded
		 * in.
		 */
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
    a0019f64:	3941ebe0 	ldrb	w0, [sp, #122]
    a0019f68:	52000000 	eor	w0, w0, #0x1
    a0019f6c:	12001c00 	and	w0, w0, #0xff
    a0019f70:	7100001f 	cmp	w0, #0x0
    a0019f74:	54000160 	b.eq	a0019fa0 <z_set_timeout_expiry+0xdc>  // b.none
    a0019f78:	3941efe0 	ldrb	w0, [sp, #123]
    a0019f7c:	7100001f 	cmp	w0, #0x0
    a0019f80:	54000100 	b.eq	a0019fa0 <z_set_timeout_expiry+0xdc>  // b.none
			sys_clock_set_timeout(MIN(ticks, next_to), is_idle);
    a0019f84:	b9401fe0 	ldr	w0, [sp, #28]
    a0019f88:	b9407fe2 	ldr	w2, [sp, #124]
    a0019f8c:	b9407fe1 	ldr	w1, [sp, #124]
    a0019f90:	6b00005f 	cmp	w2, w0
    a0019f94:	1a80d020 	csel	w0, w1, w0, le
    a0019f98:	39406fe1 	ldrb	w1, [sp, #27]
    a0019f9c:	97ffd8e9 	bl	a0010340 <sys_clock_set_timeout>
    a0019fa0:	f0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a0019fa4:	910a6000 	add	x0, x0, #0x298
    a0019fa8:	f9002fe0 	str	x0, [sp, #88]
    a0019fac:	b9403be0 	ldr	w0, [sp, #56]
    a0019fb0:	b90033e0 	str	w0, [sp, #48]
	arch_irq_unlock(key.key);
    a0019fb4:	b94033e0 	ldr	w0, [sp, #48]
    a0019fb8:	b90057e0 	str	w0, [sp, #84]
	write_daif(key);
    a0019fbc:	b94057e0 	ldr	w0, [sp, #84]
    a0019fc0:	f90027e0 	str	x0, [sp, #72]
MAKE_REG_HELPER(daif)
    a0019fc4:	f94027e0 	ldr	x0, [sp, #72]
    a0019fc8:	d51b4220 	msr	daif, x0
    a0019fcc:	d503201f 	nop
}
    a0019fd0:	d503201f 	nop
}
    a0019fd4:	d503201f 	nop
	LOCKED(&timeout_lock) {
    a0019fd8:	52800020 	mov	w0, #0x1                   	// #1
    a0019fdc:	b90043e0 	str	w0, [sp, #64]
    a0019fe0:	b94043e0 	ldr	w0, [sp, #64]
    a0019fe4:	7100001f 	cmp	w0, #0x0
    a0019fe8:	54fff960 	b.eq	a0019f14 <z_set_timeout_expiry+0x50>  // b.none
		}
	}
}
    a0019fec:	d503201f 	nop
    a0019ff0:	d503201f 	nop
    a0019ff4:	a8c87bfd 	ldp	x29, x30, [sp], #128
    a0019ff8:	d65f03c0 	ret

00000000a0019ffc <sys_clock_announce>:

void sys_clock_announce(int32_t ticks)
{
    a0019ffc:	a9b47bfd 	stp	x29, x30, [sp, #-192]!
    a001a000:	910003fd 	mov	x29, sp
    a001a004:	b9001fe0 	str	w0, [sp, #28]
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
    a001a008:	b9401fe0 	ldr	w0, [sp, #28]
    a001a00c:	97fff34a 	bl	a0016d34 <z_time_slice>
    a001a010:	d0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a001a014:	910a6000 	add	x0, x0, #0x298
    a001a018:	f90057e0 	str	x0, [sp, #168]
    a001a01c:	d53b4220 	mrs	x0, daif
    a001a020:	f90053e0 	str	x0, [sp, #160]
    a001a024:	f94053e0 	ldr	x0, [sp, #160]
    a001a028:	d503201f 	nop
	key = read_daif();
    a001a02c:	b9009fe0 	str	w0, [sp, #156]
	__asm__ volatile ("msr DAIFSet, %0"
    a001a030:	d50342df 	msr	daifset, #0x2
}
    a001a034:	d503201f 	nop
	return key;
    a001a038:	b9409fe0 	ldr	w0, [sp, #156]
	k.key = arch_irq_lock();
    a001a03c:	b9003be0 	str	w0, [sp, #56]
	return k;
    a001a040:	b9403be0 	ldr	w0, [sp, #56]
    a001a044:	b9004be0 	str	w0, [sp, #72]
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
    a001a048:	d00003a0 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a001a04c:	9111b000 	add	x0, x0, #0x46c
    a001a050:	b9401fe1 	ldr	w1, [sp, #28]
    a001a054:	b9000001 	str	w1, [x0]

	while (first() != NULL && first()->dticks <= announce_remaining) {
    a001a058:	1400003a 	b	a001a140 <sys_clock_announce+0x144>
		struct _timeout *t = first();
    a001a05c:	97fffdf3 	bl	a0019828 <first>
    a001a060:	f9005fe0 	str	x0, [sp, #184]
		int dt = t->dticks;
    a001a064:	f9405fe0 	ldr	x0, [sp, #184]
    a001a068:	f9400c00 	ldr	x0, [x0, #24]
    a001a06c:	b900b7e0 	str	w0, [sp, #180]

		curr_tick += dt;
    a001a070:	b980b7e1 	ldrsw	x1, [sp, #180]
    a001a074:	d0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a001a078:	910a4000 	add	x0, x0, #0x290
    a001a07c:	f9400000 	ldr	x0, [x0]
    a001a080:	8b000021 	add	x1, x1, x0
    a001a084:	d0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a001a088:	910a4000 	add	x0, x0, #0x290
    a001a08c:	f9000001 	str	x1, [x0]
		announce_remaining -= dt;
    a001a090:	d00003a0 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a001a094:	9111b000 	add	x0, x0, #0x46c
    a001a098:	b9400001 	ldr	w1, [x0]
    a001a09c:	b940b7e0 	ldr	w0, [sp, #180]
    a001a0a0:	4b000021 	sub	w1, w1, w0
    a001a0a4:	d00003a0 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a001a0a8:	9111b000 	add	x0, x0, #0x46c
    a001a0ac:	b9000001 	str	w1, [x0]
		t->dticks = 0;
    a001a0b0:	f9405fe0 	ldr	x0, [sp, #184]
    a001a0b4:	f9000c1f 	str	xzr, [x0, #24]
		remove_timeout(t);
    a001a0b8:	f9405fe0 	ldr	x0, [sp, #184]
    a001a0bc:	97fffdf0 	bl	a001987c <remove_timeout>
    a001a0c0:	d0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a001a0c4:	910a6000 	add	x0, x0, #0x298
    a001a0c8:	f9003fe0 	str	x0, [sp, #120]
    a001a0cc:	b9404be0 	ldr	w0, [sp, #72]
    a001a0d0:	b90033e0 	str	w0, [sp, #48]
	arch_irq_unlock(key.key);
    a001a0d4:	b94033e0 	ldr	w0, [sp, #48]
    a001a0d8:	b90077e0 	str	w0, [sp, #116]
	write_daif(key);
    a001a0dc:	b94077e0 	ldr	w0, [sp, #116]
    a001a0e0:	f90037e0 	str	x0, [sp, #104]
MAKE_REG_HELPER(daif)
    a001a0e4:	f94037e0 	ldr	x0, [sp, #104]
    a001a0e8:	d51b4220 	msr	daif, x0
    a001a0ec:	d503201f 	nop
}
    a001a0f0:	d503201f 	nop
}
    a001a0f4:	d503201f 	nop

		k_spin_unlock(&timeout_lock, key);
		t->fn(t);
    a001a0f8:	f9405fe0 	ldr	x0, [sp, #184]
    a001a0fc:	f9400801 	ldr	x1, [x0, #16]
    a001a100:	f9405fe0 	ldr	x0, [sp, #184]
    a001a104:	d63f0020 	blr	x1
    a001a108:	d0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a001a10c:	910a6000 	add	x0, x0, #0x298
    a001a110:	f9004be0 	str	x0, [sp, #144]
    a001a114:	d53b4220 	mrs	x0, daif
    a001a118:	f90047e0 	str	x0, [sp, #136]
    a001a11c:	f94047e0 	ldr	x0, [sp, #136]
    a001a120:	d503201f 	nop
	key = read_daif();
    a001a124:	b90087e0 	str	w0, [sp, #132]
	__asm__ volatile ("msr DAIFSet, %0"
    a001a128:	d50342df 	msr	daifset, #0x2
}
    a001a12c:	d503201f 	nop
	return key;
    a001a130:	b94087e0 	ldr	w0, [sp, #132]
	k.key = arch_irq_lock();
    a001a134:	b9002be0 	str	w0, [sp, #40]
	return k;
    a001a138:	b9402be0 	ldr	w0, [sp, #40]
    a001a13c:	b9004be0 	str	w0, [sp, #72]
	while (first() != NULL && first()->dticks <= announce_remaining) {
    a001a140:	97fffdba 	bl	a0019828 <first>
    a001a144:	f100001f 	cmp	x0, #0x0
    a001a148:	54000120 	b.eq	a001a16c <sys_clock_announce+0x170>  // b.none
    a001a14c:	97fffdb7 	bl	a0019828 <first>
    a001a150:	f9400c01 	ldr	x1, [x0, #24]
    a001a154:	d00003a0 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a001a158:	9111b000 	add	x0, x0, #0x46c
    a001a15c:	b9400000 	ldr	w0, [x0]
    a001a160:	93407c00 	sxtw	x0, w0
    a001a164:	eb00003f 	cmp	x1, x0
    a001a168:	54fff7ad 	b.le	a001a05c <sys_clock_announce+0x60>
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
    a001a16c:	97fffdaf 	bl	a0019828 <first>
    a001a170:	f100001f 	cmp	x0, #0x0
    a001a174:	54000120 	b.eq	a001a198 <sys_clock_announce+0x19c>  // b.none
		first()->dticks -= announce_remaining;
    a001a178:	97fffdac 	bl	a0019828 <first>
    a001a17c:	f9400c02 	ldr	x2, [x0, #24]
    a001a180:	d00003a1 	adrp	x1, a0090000 <z_page_frames+0x47d68>
    a001a184:	9111b021 	add	x1, x1, #0x46c
    a001a188:	b9400021 	ldr	w1, [x1]
    a001a18c:	93407c21 	sxtw	x1, w1
    a001a190:	cb010041 	sub	x1, x2, x1
    a001a194:	f9000c01 	str	x1, [x0, #24]
	}

	curr_tick += announce_remaining;
    a001a198:	d00003a0 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a001a19c:	9111b000 	add	x0, x0, #0x46c
    a001a1a0:	b9400000 	ldr	w0, [x0]
    a001a1a4:	93407c01 	sxtw	x1, w0
    a001a1a8:	d0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a001a1ac:	910a4000 	add	x0, x0, #0x290
    a001a1b0:	f9400000 	ldr	x0, [x0]
    a001a1b4:	8b000021 	add	x1, x1, x0
    a001a1b8:	d0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a001a1bc:	910a4000 	add	x0, x0, #0x290
    a001a1c0:	f9000001 	str	x1, [x0]
	announce_remaining = 0;
    a001a1c4:	d00003a0 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a001a1c8:	9111b000 	add	x0, x0, #0x46c
    a001a1cc:	b900001f 	str	wzr, [x0]

	sys_clock_set_timeout(next_timeout(), false);
    a001a1d0:	97fffdca 	bl	a00198f8 <next_timeout>
    a001a1d4:	52800001 	mov	w1, #0x0                   	// #0
    a001a1d8:	97ffd85a 	bl	a0010340 <sys_clock_set_timeout>
    a001a1dc:	d0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a001a1e0:	910a6000 	add	x0, x0, #0x298
    a001a1e4:	f90033e0 	str	x0, [sp, #96]
    a001a1e8:	b9404be0 	ldr	w0, [sp, #72]
    a001a1ec:	b90043e0 	str	w0, [sp, #64]
	arch_irq_unlock(key.key);
    a001a1f0:	b94043e0 	ldr	w0, [sp, #64]
    a001a1f4:	b9005fe0 	str	w0, [sp, #92]
	write_daif(key);
    a001a1f8:	b9405fe0 	ldr	w0, [sp, #92]
    a001a1fc:	f9002be0 	str	x0, [sp, #80]
MAKE_REG_HELPER(daif)
    a001a200:	f9402be0 	ldr	x0, [sp, #80]
    a001a204:	d51b4220 	msr	daif, x0
    a001a208:	d503201f 	nop
}
    a001a20c:	d503201f 	nop
}
    a001a210:	d503201f 	nop

	k_spin_unlock(&timeout_lock, key);
}
    a001a214:	d503201f 	nop
    a001a218:	a8cc7bfd 	ldp	x29, x30, [sp], #192
    a001a21c:	d65f03c0 	ret

00000000a001a220 <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
    a001a220:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    a001a224:	910003fd 	mov	x29, sp
	uint64_t t = 0U;
    a001a228:	f90037ff 	str	xzr, [sp, #104]

	LOCKED(&timeout_lock) {
    a001a22c:	b90033ff 	str	wzr, [sp, #48]
    a001a230:	d0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a001a234:	910a6000 	add	x0, x0, #0x298
    a001a238:	f90033e0 	str	x0, [sp, #96]
    a001a23c:	d53b4220 	mrs	x0, daif
    a001a240:	f9002fe0 	str	x0, [sp, #88]
    a001a244:	f9402fe0 	ldr	x0, [sp, #88]
    a001a248:	d503201f 	nop
	key = read_daif();
    a001a24c:	b90057e0 	str	w0, [sp, #84]
	__asm__ volatile ("msr DAIFSet, %0"
    a001a250:	d50342df 	msr	daifset, #0x2
}
    a001a254:	d503201f 	nop
	return key;
    a001a258:	b94057e0 	ldr	w0, [sp, #84]
	k.key = arch_irq_lock();
    a001a25c:	b9001be0 	str	w0, [sp, #24]
	return k;
    a001a260:	b9401be0 	ldr	w0, [sp, #24]
    a001a264:	b9002be0 	str	w0, [sp, #40]
    a001a268:	14000018 	b	a001a2c8 <sys_clock_tick_get+0xa8>
		t = curr_tick + sys_clock_elapsed();
    a001a26c:	97ffd8de 	bl	a00105e4 <sys_clock_elapsed>
    a001a270:	2a0003e1 	mov	w1, w0
    a001a274:	d0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a001a278:	910a4000 	add	x0, x0, #0x290
    a001a27c:	f9400000 	ldr	x0, [x0]
    a001a280:	8b000020 	add	x0, x1, x0
    a001a284:	f90037e0 	str	x0, [sp, #104]
    a001a288:	d0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a001a28c:	910a6000 	add	x0, x0, #0x298
    a001a290:	f90027e0 	str	x0, [sp, #72]
    a001a294:	b9402be0 	ldr	w0, [sp, #40]
    a001a298:	b90023e0 	str	w0, [sp, #32]
	arch_irq_unlock(key.key);
    a001a29c:	b94023e0 	ldr	w0, [sp, #32]
    a001a2a0:	b90047e0 	str	w0, [sp, #68]
	write_daif(key);
    a001a2a4:	b94047e0 	ldr	w0, [sp, #68]
    a001a2a8:	f9001fe0 	str	x0, [sp, #56]
MAKE_REG_HELPER(daif)
    a001a2ac:	f9401fe0 	ldr	x0, [sp, #56]
    a001a2b0:	d51b4220 	msr	daif, x0
    a001a2b4:	d503201f 	nop
}
    a001a2b8:	d503201f 	nop
}
    a001a2bc:	d503201f 	nop
	LOCKED(&timeout_lock) {
    a001a2c0:	52800020 	mov	w0, #0x1                   	// #1
    a001a2c4:	b90033e0 	str	w0, [sp, #48]
    a001a2c8:	b94033e0 	ldr	w0, [sp, #48]
    a001a2cc:	7100001f 	cmp	w0, #0x0
    a001a2d0:	54fffce0 	b.eq	a001a26c <sys_clock_tick_get+0x4c>  // b.none
	}
	return t;
    a001a2d4:	f94037e0 	ldr	x0, [sp, #104]
}
    a001a2d8:	a8c77bfd 	ldp	x29, x30, [sp], #112
    a001a2dc:	d65f03c0 	ret

00000000a001a2e0 <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
    a001a2e0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    a001a2e4:	910003fd 	mov	x29, sp
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
    a001a2e8:	97ffffce 	bl	a001a220 <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
    a001a2ec:	a8c17bfd 	ldp	x29, x30, [sp], #16
    a001a2f0:	d65f03c0 	ret

00000000a001a2f4 <z_impl_k_uptime_ticks>:

int64_t z_impl_k_uptime_ticks(void)
{
    a001a2f4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    a001a2f8:	910003fd 	mov	x29, sp
	return sys_clock_tick_get();
    a001a2fc:	97ffffc9 	bl	a001a220 <sys_clock_tick_get>
}
    a001a300:	a8c17bfd 	ldp	x29, x30, [sp], #16
    a001a304:	d65f03c0 	ret

00000000a001a308 <z_vrfy_k_uptime_ticks>:

#ifdef CONFIG_USERSPACE
static inline int64_t z_vrfy_k_uptime_ticks(void)
{
    a001a308:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    a001a30c:	910003fd 	mov	x29, sp
	return z_impl_k_uptime_ticks();
    a001a310:	97fffff9 	bl	a001a2f4 <z_impl_k_uptime_ticks>
}
    a001a314:	a8c17bfd 	ldp	x29, x30, [sp], #16
    a001a318:	d65f03c0 	ret

00000000a001a31c <z_mrsh_k_uptime_ticks>:
#include <syscalls/kernel.h>

extern int64_t z_vrfy_k_uptime_ticks();
uintptr_t z_mrsh_k_uptime_ticks(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a001a31c:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a001a320:	910003fd 	mov	x29, sp
    a001a324:	f90027e0 	str	x0, [sp, #72]
    a001a328:	f90023e1 	str	x1, [sp, #64]
    a001a32c:	f9001fe2 	str	x2, [sp, #56]
    a001a330:	f9001be3 	str	x3, [sp, #48]
    a001a334:	f90017e4 	str	x4, [sp, #40]
    a001a338:	f90013e5 	str	x5, [sp, #32]
    a001a33c:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a001a340:	b0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001a344:	913f8000 	add	x0, x0, #0xfe0
    a001a348:	f9400800 	ldr	x0, [x0, #16]
    a001a34c:	f9400fe1 	ldr	x1, [sp, #24]
    a001a350:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int64_t ret = z_vrfy_k_uptime_ticks()
    a001a354:	97ffffed 	bl	a001a308 <z_vrfy_k_uptime_ticks>
    a001a358:	f9002fe0 	str	x0, [sp, #88]
;
	_current->syscall_frame = NULL;
    a001a35c:	b0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001a360:	913f8000 	add	x0, x0, #0xfe0
    a001a364:	f9400800 	ldr	x0, [x0, #16]
    a001a368:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a001a36c:	f9402fe0 	ldr	x0, [sp, #88]
}
    a001a370:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a001a374:	d65f03c0 	ret

00000000a001a378 <z_impl_k_busy_wait>:
#include <syscalls/k_uptime_ticks_mrsh.c>
#endif

void z_impl_k_busy_wait(uint32_t usec_to_wait)
{
    a001a378:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a001a37c:	910003fd 	mov	x29, sp
    a001a380:	b9001fe0 	str	w0, [sp, #28]
	SYS_PORT_TRACING_FUNC_ENTER(k_thread, busy_wait, usec_to_wait);
	if (usec_to_wait == 0U) {
    a001a384:	b9401fe0 	ldr	w0, [sp, #28]
    a001a388:	7100001f 	cmp	w0, #0x0
    a001a38c:	54000080 	b.eq	a001a39c <z_impl_k_busy_wait+0x24>  // b.none
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
			break;
		}
	}
#else
	arch_busy_wait(usec_to_wait);
    a001a390:	b9401fe0 	ldr	w0, [sp, #28]
    a001a394:	97ffd8cb 	bl	a00106c0 <arch_busy_wait>
    a001a398:	14000002 	b	a001a3a0 <z_impl_k_busy_wait+0x28>
		return;
    a001a39c:	d503201f 	nop
#endif /* CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT */
	SYS_PORT_TRACING_FUNC_EXIT(k_thread, busy_wait, usec_to_wait);
}
    a001a3a0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a001a3a4:	d65f03c0 	ret

00000000a001a3a8 <z_vrfy_k_busy_wait>:

#ifdef CONFIG_USERSPACE
static inline void z_vrfy_k_busy_wait(uint32_t usec_to_wait)
{
    a001a3a8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a001a3ac:	910003fd 	mov	x29, sp
    a001a3b0:	b9001fe0 	str	w0, [sp, #28]
	z_impl_k_busy_wait(usec_to_wait);
    a001a3b4:	b9401fe0 	ldr	w0, [sp, #28]
    a001a3b8:	97fffff0 	bl	a001a378 <z_impl_k_busy_wait>
}
    a001a3bc:	d503201f 	nop
    a001a3c0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a001a3c4:	d65f03c0 	ret

00000000a001a3c8 <z_mrsh_k_busy_wait>:
#include <syscalls/kernel.h>

extern void z_vrfy_k_busy_wait(uint32_t usec_to_wait);
uintptr_t z_mrsh_k_busy_wait(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a001a3c8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a001a3cc:	910003fd 	mov	x29, sp
    a001a3d0:	f90027e0 	str	x0, [sp, #72]
    a001a3d4:	f90023e1 	str	x1, [sp, #64]
    a001a3d8:	f9001fe2 	str	x2, [sp, #56]
    a001a3dc:	f9001be3 	str	x3, [sp, #48]
    a001a3e0:	f90017e4 	str	x4, [sp, #40]
    a001a3e4:	f90013e5 	str	x5, [sp, #32]
    a001a3e8:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a001a3ec:	b0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001a3f0:	913f8000 	add	x0, x0, #0xfe0
    a001a3f4:	f9400800 	ldr	x0, [x0, #16]
    a001a3f8:	f9400fe1 	ldr	x1, [sp, #24]
    a001a3fc:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_busy_wait(*(uint32_t*)&arg0)
    a001a400:	910123e0 	add	x0, sp, #0x48
    a001a404:	b9400000 	ldr	w0, [x0]
    a001a408:	97ffffe8 	bl	a001a3a8 <z_vrfy_k_busy_wait>
;
	_current->syscall_frame = NULL;
    a001a40c:	b0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001a410:	913f8000 	add	x0, x0, #0xfe0
    a001a414:	f9400800 	ldr	x0, [x0, #16]
    a001a418:	f900841f 	str	xzr, [x0, #264]
	return 0;
    a001a41c:	d2800000 	mov	x0, #0x0                   	// #0
}
    a001a420:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a001a424:	d65f03c0 	ret

00000000a001a428 <sys_clock_timeout_end_calc>:
 * timeout object.  When used correctly, this should be called once,
 * synchronously with the user passing a new timeout value.  It should
 * not be used iteratively to adjust a timeout.
 */
uint64_t sys_clock_timeout_end_calc(k_timeout_t timeout)
{
    a001a428:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a001a42c:	910003fd 	mov	x29, sp
    a001a430:	f9000fe0 	str	x0, [sp, #24]
	k_ticks_t dt;

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    a001a434:	f9400fe0 	ldr	x0, [sp, #24]
    a001a438:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
    a001a43c:	eb01001f 	cmp	x0, x1
    a001a440:	54000061 	b.ne	a001a44c <sys_clock_timeout_end_calc+0x24>  // b.any
		return UINT64_MAX;
    a001a444:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    a001a448:	1400001a 	b	a001a4b0 <sys_clock_timeout_end_calc+0x88>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    a001a44c:	f9400fe0 	ldr	x0, [sp, #24]
    a001a450:	d2800001 	mov	x1, #0x0                   	// #0
    a001a454:	eb01001f 	cmp	x0, x1
    a001a458:	54000061 	b.ne	a001a464 <sys_clock_timeout_end_calc+0x3c>  // b.any
		return sys_clock_tick_get();
    a001a45c:	97ffff71 	bl	a001a220 <sys_clock_tick_get>
    a001a460:	14000014 	b	a001a4b0 <sys_clock_timeout_end_calc+0x88>
	} else {

		dt = timeout.ticks;
    a001a464:	f9400fe0 	ldr	x0, [sp, #24]
    a001a468:	f90017e0 	str	x0, [sp, #40]

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
    a001a46c:	92800021 	mov	x1, #0xfffffffffffffffe    	// #-2
    a001a470:	f94017e0 	ldr	x0, [sp, #40]
    a001a474:	cb000020 	sub	x0, x1, x0
    a001a478:	f100001f 	cmp	x0, #0x0
    a001a47c:	540000ab 	b.lt	a001a490 <sys_clock_timeout_end_calc+0x68>  // b.tstop
			return Z_TICK_ABS(dt);
    a001a480:	92800021 	mov	x1, #0xfffffffffffffffe    	// #-2
    a001a484:	f94017e0 	ldr	x0, [sp, #40]
    a001a488:	cb000020 	sub	x0, x1, x0
    a001a48c:	14000009 	b	a001a4b0 <sys_clock_timeout_end_calc+0x88>
		}
		return sys_clock_tick_get() + MAX(1, dt);
    a001a490:	97ffff64 	bl	a001a220 <sys_clock_tick_get>
    a001a494:	aa0003e3 	mov	x3, x0
    a001a498:	f94017e2 	ldr	x2, [sp, #40]
    a001a49c:	f94017e1 	ldr	x1, [sp, #40]
    a001a4a0:	d2800020 	mov	x0, #0x1                   	// #1
    a001a4a4:	f100005f 	cmp	x2, #0x0
    a001a4a8:	9a80c020 	csel	x0, x1, x0, gt
    a001a4ac:	8b000060 	add	x0, x3, x0
	}
}
    a001a4b0:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a001a4b4:	d65f03c0 	ret

00000000a001a4b8 <sys_dnode_is_linked>:
{
    a001a4b8:	d10043ff 	sub	sp, sp, #0x10
    a001a4bc:	f90007e0 	str	x0, [sp, #8]
	return node->next != NULL;
    a001a4c0:	f94007e0 	ldr	x0, [sp, #8]
    a001a4c4:	f9400000 	ldr	x0, [x0]
    a001a4c8:	f100001f 	cmp	x0, #0x0
    a001a4cc:	1a9f07e0 	cset	w0, ne  // ne = any
    a001a4d0:	12001c00 	and	w0, w0, #0xff
}
    a001a4d4:	910043ff 	add	sp, sp, #0x10
    a001a4d8:	d65f03c0 	ret

00000000a001a4dc <sys_dlist_is_empty>:
{
    a001a4dc:	d10043ff 	sub	sp, sp, #0x10
    a001a4e0:	f90007e0 	str	x0, [sp, #8]
	return list->head == list;
    a001a4e4:	f94007e0 	ldr	x0, [sp, #8]
    a001a4e8:	f9400000 	ldr	x0, [x0]
    a001a4ec:	f94007e1 	ldr	x1, [sp, #8]
    a001a4f0:	eb00003f 	cmp	x1, x0
    a001a4f4:	1a9f17e0 	cset	w0, eq  // eq = none
    a001a4f8:	12001c00 	and	w0, w0, #0xff
}
    a001a4fc:	910043ff 	add	sp, sp, #0x10
    a001a500:	d65f03c0 	ret

00000000a001a504 <sys_dlist_peek_head>:
{
    a001a504:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a001a508:	910003fd 	mov	x29, sp
    a001a50c:	f9000fe0 	str	x0, [sp, #24]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    a001a510:	f9400fe0 	ldr	x0, [sp, #24]
    a001a514:	97fffff2 	bl	a001a4dc <sys_dlist_is_empty>
    a001a518:	12001c00 	and	w0, w0, #0xff
    a001a51c:	7100001f 	cmp	w0, #0x0
    a001a520:	54000081 	b.ne	a001a530 <sys_dlist_peek_head+0x2c>  // b.any
    a001a524:	f9400fe0 	ldr	x0, [sp, #24]
    a001a528:	f9400000 	ldr	x0, [x0]
    a001a52c:	14000002 	b	a001a534 <sys_dlist_peek_head+0x30>
    a001a530:	d2800000 	mov	x0, #0x0                   	// #0
}
    a001a534:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a001a538:	d65f03c0 	ret

00000000a001a53c <z_impl_k_timer_expires_ticks>:
{
    a001a53c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a001a540:	910003fd 	mov	x29, sp
    a001a544:	f9000fe0 	str	x0, [sp, #24]
	return z_timeout_expires(&timer->timeout);
    a001a548:	f9400fe0 	ldr	x0, [sp, #24]
    a001a54c:	97fffe2c 	bl	a0019dfc <z_timeout_expires>
}
    a001a550:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a001a554:	d65f03c0 	ret

00000000a001a558 <z_impl_k_timer_remaining_ticks>:
{
    a001a558:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a001a55c:	910003fd 	mov	x29, sp
    a001a560:	f9000fe0 	str	x0, [sp, #24]
	return z_timeout_remaining(&timer->timeout);
    a001a564:	f9400fe0 	ldr	x0, [sp, #24]
    a001a568:	97fffdf8 	bl	a0019d48 <z_timeout_remaining>
}
    a001a56c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a001a570:	d65f03c0 	ret

00000000a001a574 <z_impl_k_timer_user_data_set>:
{
    a001a574:	d10043ff 	sub	sp, sp, #0x10
    a001a578:	f90007e0 	str	x0, [sp, #8]
    a001a57c:	f90003e1 	str	x1, [sp]
	timer->user_data = user_data;
    a001a580:	f94007e0 	ldr	x0, [sp, #8]
    a001a584:	f94003e1 	ldr	x1, [sp]
    a001a588:	f9002801 	str	x1, [x0, #80]
}
    a001a58c:	d503201f 	nop
    a001a590:	910043ff 	add	sp, sp, #0x10
    a001a594:	d65f03c0 	ret

00000000a001a598 <z_impl_k_timer_user_data_get>:
{
    a001a598:	d10043ff 	sub	sp, sp, #0x10
    a001a59c:	f90007e0 	str	x0, [sp, #8]
	return timer->user_data;
    a001a5a0:	f94007e0 	ldr	x0, [sp, #8]
    a001a5a4:	f9402800 	ldr	x0, [x0, #80]
}
    a001a5a8:	910043ff 	add	sp, sp, #0x10
    a001a5ac:	d65f03c0 	ret

00000000a001a5b0 <z_is_inactive_timeout>:
{
    a001a5b0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a001a5b4:	910003fd 	mov	x29, sp
    a001a5b8:	f9000fe0 	str	x0, [sp, #24]
	return !sys_dnode_is_linked(&to->node);
    a001a5bc:	f9400fe0 	ldr	x0, [sp, #24]
    a001a5c0:	97ffffbe 	bl	a001a4b8 <sys_dnode_is_linked>
    a001a5c4:	12001c00 	and	w0, w0, #0xff
    a001a5c8:	7100001f 	cmp	w0, #0x0
    a001a5cc:	1a9f07e0 	cset	w0, ne  // ne = any
    a001a5d0:	12001c00 	and	w0, w0, #0xff
    a001a5d4:	52000000 	eor	w0, w0, #0x1
    a001a5d8:	12001c00 	and	w0, w0, #0xff
    a001a5dc:	12000000 	and	w0, w0, #0x1
    a001a5e0:	12001c00 	and	w0, w0, #0xff
}
    a001a5e4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a001a5e8:	d65f03c0 	ret

00000000a001a5ec <z_reschedule_unlocked>:
{
    a001a5ec:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a001a5f0:	910003fd 	mov	x29, sp
    a001a5f4:	d53b4220 	mrs	x0, daif
    a001a5f8:	f9000fe0 	str	x0, [sp, #24]
    a001a5fc:	f9400fe0 	ldr	x0, [sp, #24]
    a001a600:	d503201f 	nop
	key = read_daif();
    a001a604:	b90017e0 	str	w0, [sp, #20]
	__asm__ volatile ("msr DAIFSet, %0"
    a001a608:	d50342df 	msr	daifset, #0x2
}
    a001a60c:	d503201f 	nop
	return key;
    a001a610:	b94017e0 	ldr	w0, [sp, #20]
	(void) z_reschedule_irqlock(arch_irq_lock());
    a001a614:	97fff6e3 	bl	a00181a0 <z_reschedule_irqlock>
}
    a001a618:	d503201f 	nop
    a001a61c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a001a620:	d65f03c0 	ret

00000000a001a624 <z_waitq_head>:
{
    a001a624:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a001a628:	910003fd 	mov	x29, sp
    a001a62c:	f9000fe0 	str	x0, [sp, #24]
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
    a001a630:	f9400fe0 	ldr	x0, [sp, #24]
    a001a634:	97ffffb4 	bl	a001a504 <sys_dlist_peek_head>
}
    a001a638:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a001a63c:	d65f03c0 	ret

00000000a001a640 <z_obj_validation_check>:
{
    a001a640:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    a001a644:	910003fd 	mov	x29, sp
    a001a648:	f90017e0 	str	x0, [sp, #40]
    a001a64c:	f90013e1 	str	x1, [sp, #32]
    a001a650:	b9001fe2 	str	w2, [sp, #28]
    a001a654:	b9001be3 	str	w3, [sp, #24]
	ret = z_object_validate(ko, otype, init);
    a001a658:	b9401be2 	ldr	w2, [sp, #24]
    a001a65c:	b9401fe1 	ldr	w1, [sp, #28]
    a001a660:	f94017e0 	ldr	x0, [sp, #40]
    a001a664:	94000b18 	bl	a001d2c4 <z_object_validate>
    a001a668:	b9003fe0 	str	w0, [sp, #60]
	return ret;
    a001a66c:	b9403fe0 	ldr	w0, [sp, #60]
}
    a001a670:	a8c47bfd 	ldp	x29, x30, [sp], #64
    a001a674:	d65f03c0 	ret

00000000a001a678 <z_timer_expiration_handler>:
 * @brief Handle expiration of a kernel timer object.
 *
 * @param t  Timeout used by the timer.
 */
void z_timer_expiration_handler(struct _timeout *t)
{
    a001a678:	a9b27bfd 	stp	x29, x30, [sp, #-224]!
    a001a67c:	910003fd 	mov	x29, sp
    a001a680:	f9000fe0 	str	x0, [sp, #24]
	struct k_timer *timer = CONTAINER_OF(t, struct k_timer, timeout);
    a001a684:	f9400fe0 	ldr	x0, [sp, #24]
    a001a688:	f9006fe0 	str	x0, [sp, #216]
    a001a68c:	d0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a001a690:	910a6000 	add	x0, x0, #0x298
    a001a694:	f90067e0 	str	x0, [sp, #200]
MAKE_REG_HELPER(daif)
    a001a698:	d53b4220 	mrs	x0, daif
    a001a69c:	f90063e0 	str	x0, [sp, #192]
    a001a6a0:	f94063e0 	ldr	x0, [sp, #192]
    a001a6a4:	d503201f 	nop
	key = read_daif();
    a001a6a8:	b900bfe0 	str	w0, [sp, #188]
	__asm__ volatile ("msr DAIFSet, %0"
    a001a6ac:	d50342df 	msr	daifset, #0x2
}
    a001a6b0:	d503201f 	nop
	return key;
    a001a6b4:	b940bfe0 	ldr	w0, [sp, #188]
	k.key = arch_irq_lock();
    a001a6b8:	b90023e0 	str	w0, [sp, #32]
	return k;
    a001a6bc:	b94023e0 	ldr	w0, [sp, #32]
    a001a6c0:	b9004be0 	str	w0, [sp, #72]

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
    a001a6c4:	f9406fe0 	ldr	x0, [sp, #216]
    a001a6c8:	f9402000 	ldr	x0, [x0, #64]
    a001a6cc:	d2800001 	mov	x1, #0x0                   	// #0
    a001a6d0:	eb01001f 	cmp	x0, x1
    a001a6d4:	540001a0 	b.eq	a001a708 <z_timer_expiration_handler+0x90>  // b.none
	    !K_TIMEOUT_EQ(timer->period, K_FOREVER)) {
    a001a6d8:	f9406fe0 	ldr	x0, [sp, #216]
    a001a6dc:	f9402000 	ldr	x0, [x0, #64]
    a001a6e0:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
    a001a6e4:	eb01001f 	cmp	x0, x1
    a001a6e8:	54000100 	b.eq	a001a708 <z_timer_expiration_handler+0x90>  // b.none
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
    a001a6ec:	f9406fe3 	ldr	x3, [sp, #216]
    a001a6f0:	f9406fe0 	ldr	x0, [sp, #216]
    a001a6f4:	f9402002 	ldr	x2, [x0, #64]
    a001a6f8:	90000000 	adrp	x0, a001a000 <sys_clock_announce+0x4>
    a001a6fc:	9119e001 	add	x1, x0, #0x678
    a001a700:	aa0303e0 	mov	x0, x3
    a001a704:	97fffcab 	bl	a00199b0 <z_add_timeout>
			     timer->period);
	}

	/* update timer's status */
	timer->status += 1U;
    a001a708:	f9406fe0 	ldr	x0, [sp, #216]
    a001a70c:	b9404800 	ldr	w0, [x0, #72]
    a001a710:	11000401 	add	w1, w0, #0x1
    a001a714:	f9406fe0 	ldr	x0, [sp, #216]
    a001a718:	b9004801 	str	w1, [x0, #72]

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
    a001a71c:	f9406fe0 	ldr	x0, [sp, #216]
    a001a720:	f9401800 	ldr	x0, [x0, #48]
    a001a724:	f100001f 	cmp	x0, #0x0
    a001a728:	54000420 	b.eq	a001a7ac <z_timer_expiration_handler+0x134>  // b.none
    a001a72c:	d0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a001a730:	910a6000 	add	x0, x0, #0x298
    a001a734:	f9004fe0 	str	x0, [sp, #152]
    a001a738:	b9404be0 	ldr	w0, [sp, #72]
    a001a73c:	b90033e0 	str	w0, [sp, #48]
	arch_irq_unlock(key.key);
    a001a740:	b94033e0 	ldr	w0, [sp, #48]
    a001a744:	b90097e0 	str	w0, [sp, #148]
	write_daif(key);
    a001a748:	b94097e0 	ldr	w0, [sp, #148]
    a001a74c:	f90047e0 	str	x0, [sp, #136]
MAKE_REG_HELPER(daif)
    a001a750:	f94047e0 	ldr	x0, [sp, #136]
    a001a754:	d51b4220 	msr	daif, x0
    a001a758:	d503201f 	nop
}
    a001a75c:	d503201f 	nop
}
    a001a760:	d503201f 	nop
		/* Unlock for user handler. */
		k_spin_unlock(&lock, key);
		timer->expiry_fn(timer);
    a001a764:	f9406fe0 	ldr	x0, [sp, #216]
    a001a768:	f9401801 	ldr	x1, [x0, #48]
    a001a76c:	f9406fe0 	ldr	x0, [sp, #216]
    a001a770:	d63f0020 	blr	x1
    a001a774:	d0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a001a778:	910a6000 	add	x0, x0, #0x298
    a001a77c:	f9005be0 	str	x0, [sp, #176]
    a001a780:	d53b4220 	mrs	x0, daif
    a001a784:	f90057e0 	str	x0, [sp, #168]
    a001a788:	f94057e0 	ldr	x0, [sp, #168]
    a001a78c:	d503201f 	nop
	key = read_daif();
    a001a790:	b900a7e0 	str	w0, [sp, #164]
	__asm__ volatile ("msr DAIFSet, %0"
    a001a794:	d50342df 	msr	daifset, #0x2
}
    a001a798:	d503201f 	nop
	return key;
    a001a79c:	b940a7e0 	ldr	w0, [sp, #164]
	k.key = arch_irq_lock();
    a001a7a0:	b9002be0 	str	w0, [sp, #40]
	return k;
    a001a7a4:	b9402be0 	ldr	w0, [sp, #40]
    a001a7a8:	b9004be0 	str	w0, [sp, #72]
	if (!IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_spin_unlock(&lock, key);
		return;
	}

	thread = z_waitq_head(&timer->wait_q);
    a001a7ac:	f9406fe0 	ldr	x0, [sp, #216]
    a001a7b0:	91008000 	add	x0, x0, #0x20
    a001a7b4:	97ffff9c 	bl	a001a624 <z_waitq_head>
    a001a7b8:	f9006be0 	str	x0, [sp, #208]

	if (thread == NULL) {
    a001a7bc:	f9406be0 	ldr	x0, [sp, #208]
    a001a7c0:	f100001f 	cmp	x0, #0x0
    a001a7c4:	540001e1 	b.ne	a001a800 <z_timer_expiration_handler+0x188>  // b.any
    a001a7c8:	d0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a001a7cc:	910a6000 	add	x0, x0, #0x298
    a001a7d0:	f90043e0 	str	x0, [sp, #128]
    a001a7d4:	b9404be0 	ldr	w0, [sp, #72]
    a001a7d8:	b9003be0 	str	w0, [sp, #56]
	arch_irq_unlock(key.key);
    a001a7dc:	b9403be0 	ldr	w0, [sp, #56]
    a001a7e0:	b9007fe0 	str	w0, [sp, #124]
	write_daif(key);
    a001a7e4:	b9407fe0 	ldr	w0, [sp, #124]
    a001a7e8:	f9003be0 	str	x0, [sp, #112]
MAKE_REG_HELPER(daif)
    a001a7ec:	f9403be0 	ldr	x0, [sp, #112]
    a001a7f0:	d51b4220 	msr	daif, x0
    a001a7f4:	d503201f 	nop
}
    a001a7f8:	d503201f 	nop
}
    a001a7fc:	1400001a 	b	a001a864 <z_timer_expiration_handler+0x1ec>
		k_spin_unlock(&lock, key);
		return;
	}

	z_unpend_thread_no_timeout(thread);
    a001a800:	f9406be0 	ldr	x0, [sp, #208]
    a001a804:	97fff449 	bl	a0017928 <z_unpend_thread_no_timeout>
    a001a808:	f9406be0 	ldr	x0, [sp, #208]
    a001a80c:	f9002be0 	str	x0, [sp, #80]
    a001a810:	b9004fff 	str	wzr, [sp, #76]
	thread->swap_retval = value;
    a001a814:	b9404fe1 	ldr	w1, [sp, #76]
    a001a818:	f9402be0 	ldr	x0, [sp, #80]
    a001a81c:	b9011001 	str	w1, [x0, #272]
}
    a001a820:	d503201f 	nop
    a001a824:	d0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a001a828:	910a6000 	add	x0, x0, #0x298
    a001a82c:	f90037e0 	str	x0, [sp, #104]
    a001a830:	b9404be0 	ldr	w0, [sp, #72]
    a001a834:	b90043e0 	str	w0, [sp, #64]
	arch_irq_unlock(key.key);
    a001a838:	b94043e0 	ldr	w0, [sp, #64]
    a001a83c:	b90067e0 	str	w0, [sp, #100]
	write_daif(key);
    a001a840:	b94067e0 	ldr	w0, [sp, #100]
    a001a844:	f9002fe0 	str	x0, [sp, #88]
    a001a848:	f9402fe0 	ldr	x0, [sp, #88]
    a001a84c:	d51b4220 	msr	daif, x0
    a001a850:	d503201f 	nop
}
    a001a854:	d503201f 	nop
}
    a001a858:	d503201f 	nop

	arch_thread_return_value_set(thread, 0);

	k_spin_unlock(&lock, key);

	z_ready_thread(thread);
    a001a85c:	f9406be0 	ldr	x0, [sp, #208]
    a001a860:	97fff224 	bl	a00170f0 <z_ready_thread>
}
    a001a864:	a8ce7bfd 	ldp	x29, x30, [sp], #224
    a001a868:	d65f03c0 	ret

00000000a001a86c <z_impl_k_timer_start>:
}


void z_impl_k_timer_start(struct k_timer *timer, k_timeout_t duration,
			  k_timeout_t period)
{
    a001a86c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a001a870:	910003fd 	mov	x29, sp
    a001a874:	f90017e0 	str	x0, [sp, #40]
    a001a878:	f90013e1 	str	x1, [sp, #32]
    a001a87c:	f9000fe2 	str	x2, [sp, #24]
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, start, timer);

	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
    a001a880:	f94013e0 	ldr	x0, [sp, #32]
    a001a884:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
    a001a888:	eb01001f 	cmp	x0, x1
    a001a88c:	54000580 	b.eq	a001a93c <z_impl_k_timer_start+0xd0>  // b.none
	 * for backwards compatibility.  This is unfortunate
	 * (i.e. k_timer_start() doesn't treat its initial sleep
	 * argument the same way k_sleep() does), but historical.  The
	 * timer_api test relies on this behavior.
	 */
	if (!K_TIMEOUT_EQ(period, K_FOREVER) && period.ticks != 0 &&
    a001a890:	f9400fe0 	ldr	x0, [sp, #24]
    a001a894:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
    a001a898:	eb01001f 	cmp	x0, x1
    a001a89c:	540001e0 	b.eq	a001a8d8 <z_impl_k_timer_start+0x6c>  // b.none
    a001a8a0:	f9400fe0 	ldr	x0, [sp, #24]
    a001a8a4:	f100001f 	cmp	x0, #0x0
    a001a8a8:	54000180 	b.eq	a001a8d8 <z_impl_k_timer_start+0x6c>  // b.none
	    Z_TICK_ABS(period.ticks) < 0) {
    a001a8ac:	f9400fe0 	ldr	x0, [sp, #24]
    a001a8b0:	92800021 	mov	x1, #0xfffffffffffffffe    	// #-2
    a001a8b4:	cb000020 	sub	x0, x1, x0
	if (!K_TIMEOUT_EQ(period, K_FOREVER) && period.ticks != 0 &&
    a001a8b8:	f100001f 	cmp	x0, #0x0
    a001a8bc:	540000ea 	b.ge	a001a8d8 <z_impl_k_timer_start+0x6c>  // b.tcont
		period.ticks = MAX(period.ticks - 1, 1);
    a001a8c0:	f9400fe0 	ldr	x0, [sp, #24]
    a001a8c4:	d2800041 	mov	x1, #0x2                   	// #2
    a001a8c8:	f100081f 	cmp	x0, #0x2
    a001a8cc:	9a81a000 	csel	x0, x0, x1, ge  // ge = tcont
    a001a8d0:	d1000400 	sub	x0, x0, #0x1
    a001a8d4:	f9000fe0 	str	x0, [sp, #24]
	}
	if (Z_TICK_ABS(duration.ticks) < 0) {
    a001a8d8:	f94013e0 	ldr	x0, [sp, #32]
    a001a8dc:	92800021 	mov	x1, #0xfffffffffffffffe    	// #-2
    a001a8e0:	cb000020 	sub	x0, x1, x0
    a001a8e4:	f100001f 	cmp	x0, #0x0
    a001a8e8:	540000ea 	b.ge	a001a904 <z_impl_k_timer_start+0x98>  // b.tcont
		duration.ticks = MAX(duration.ticks - 1, 0);
    a001a8ec:	f94013e0 	ldr	x0, [sp, #32]
    a001a8f0:	d2800021 	mov	x1, #0x1                   	// #1
    a001a8f4:	f100001f 	cmp	x0, #0x0
    a001a8f8:	9a81c000 	csel	x0, x0, x1, gt
    a001a8fc:	d1000400 	sub	x0, x0, #0x1
    a001a900:	f90013e0 	str	x0, [sp, #32]
	}

	(void)z_abort_timeout(&timer->timeout);
    a001a904:	f94017e0 	ldr	x0, [sp, #40]
    a001a908:	97fffcb8 	bl	a0019be8 <z_abort_timeout>
	timer->period = period;
    a001a90c:	f94017e0 	ldr	x0, [sp, #40]
    a001a910:	f9400fe1 	ldr	x1, [sp, #24]
    a001a914:	f9002001 	str	x1, [x0, #64]
	timer->status = 0U;
    a001a918:	f94017e0 	ldr	x0, [sp, #40]
    a001a91c:	b900481f 	str	wzr, [x0, #72]

	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
    a001a920:	f94017e3 	ldr	x3, [sp, #40]
    a001a924:	f94013e2 	ldr	x2, [sp, #32]
    a001a928:	90000000 	adrp	x0, a001a000 <sys_clock_announce+0x4>
    a001a92c:	9119e001 	add	x1, x0, #0x678
    a001a930:	aa0303e0 	mov	x0, x3
    a001a934:	97fffc1f 	bl	a00199b0 <z_add_timeout>
    a001a938:	14000002 	b	a001a940 <z_impl_k_timer_start+0xd4>
		return;
    a001a93c:	d503201f 	nop
		     duration);
}
    a001a940:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a001a944:	d65f03c0 	ret

00000000a001a948 <z_vrfy_k_timer_start>:

#ifdef CONFIG_USERSPACE
static inline void z_vrfy_k_timer_start(struct k_timer *timer,
					k_timeout_t duration,
					k_timeout_t period)
{
    a001a948:	a9a67bfd 	stp	x29, x30, [sp, #-416]!
    a001a94c:	910003fd 	mov	x29, sp
    a001a950:	f90017e0 	str	x0, [sp, #40]
    a001a954:	f90013e1 	str	x1, [sp, #32]
    a001a958:	f9000fe2 	str	x2, [sp, #24]
	Z_OOPS(Z_SYSCALL_OBJ(timer, K_OBJ_TIMER));
    a001a95c:	f94017e0 	ldr	x0, [sp, #40]
    a001a960:	94000832 	bl	a001ca28 <z_object_find>
    a001a964:	52800003 	mov	w3, #0x0                   	// #0
    a001a968:	52800142 	mov	w2, #0xa                   	// #10
    a001a96c:	f94017e1 	ldr	x1, [sp, #40]
    a001a970:	97ffff34 	bl	a001a640 <z_obj_validation_check>
    a001a974:	7100001f 	cmp	w0, #0x0
    a001a978:	1a9f07e0 	cset	w0, ne  // ne = any
    a001a97c:	39067fe0 	strb	w0, [sp, #415]
    a001a980:	39467fe0 	ldrb	w0, [sp, #415]
    a001a984:	7100001f 	cmp	w0, #0x0
    a001a988:	39467fe0 	ldrb	w0, [sp, #415]
    a001a98c:	7100001f 	cmp	w0, #0x0
    a001a990:	540000c0 	b.eq	a001a9a8 <z_vrfy_k_timer_start+0x60>  // b.none
    a001a994:	b0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001a998:	913f8000 	add	x0, x0, #0xfe0
    a001a99c:	f9400800 	ldr	x0, [x0, #16]
    a001a9a0:	f9408400 	ldr	x0, [x0, #264]
    a001a9a4:	97ffb9ed 	bl	a0009158 <arch_syscall_oops>
	z_impl_k_timer_start(timer, duration, period);
    a001a9a8:	f9400fe2 	ldr	x2, [sp, #24]
    a001a9ac:	f94013e1 	ldr	x1, [sp, #32]
    a001a9b0:	f94017e0 	ldr	x0, [sp, #40]
    a001a9b4:	97ffffae 	bl	a001a86c <z_impl_k_timer_start>
}
    a001a9b8:	d503201f 	nop
    a001a9bc:	a8da7bfd 	ldp	x29, x30, [sp], #416
    a001a9c0:	d65f03c0 	ret

00000000a001a9c4 <z_mrsh_k_timer_start>:
#include <syscalls/kernel.h>

extern void z_vrfy_k_timer_start(struct k_timer * timer, k_timeout_t duration, k_timeout_t period);
uintptr_t z_mrsh_k_timer_start(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a001a9c4:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a001a9c8:	910003fd 	mov	x29, sp
    a001a9cc:	f90027e0 	str	x0, [sp, #72]
    a001a9d0:	f90023e1 	str	x1, [sp, #64]
    a001a9d4:	f9001fe2 	str	x2, [sp, #56]
    a001a9d8:	f9001be3 	str	x3, [sp, #48]
    a001a9dc:	f90017e4 	str	x4, [sp, #40]
    a001a9e0:	f90013e5 	str	x5, [sp, #32]
    a001a9e4:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a001a9e8:	b0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001a9ec:	913f8000 	add	x0, x0, #0xfe0
    a001a9f0:	f9400800 	ldr	x0, [x0, #16]
    a001a9f4:	f9400fe1 	ldr	x1, [sp, #24]
    a001a9f8:	f9008401 	str	x1, [x0, #264]
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_timer_start(*(struct k_timer **)&arg0, *(k_timeout_t*)&arg1, *(k_timeout_t*)&arg2)
    a001a9fc:	910123e0 	add	x0, sp, #0x48
    a001aa00:	f9400003 	ldr	x3, [x0]
    a001aa04:	910103e0 	add	x0, sp, #0x40
    a001aa08:	9100e3e1 	add	x1, sp, #0x38
    a001aa0c:	f9400022 	ldr	x2, [x1]
    a001aa10:	f9400001 	ldr	x1, [x0]
    a001aa14:	aa0303e0 	mov	x0, x3
    a001aa18:	97ffffcc 	bl	a001a948 <z_vrfy_k_timer_start>
;
	_current->syscall_frame = NULL;
    a001aa1c:	b0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001aa20:	913f8000 	add	x0, x0, #0xfe0
    a001aa24:	f9400800 	ldr	x0, [x0, #16]
    a001aa28:	f900841f 	str	xzr, [x0, #264]
	return 0;
    a001aa2c:	d2800000 	mov	x0, #0x0                   	// #0
}
    a001aa30:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a001aa34:	d65f03c0 	ret

00000000a001aa38 <z_impl_k_timer_stop>:
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
    a001aa38:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a001aa3c:	910003fd 	mov	x29, sp
    a001aa40:	f9000fe0 	str	x0, [sp, #24]
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, stop, timer);

	int inactive = z_abort_timeout(&timer->timeout) != 0;
    a001aa44:	f9400fe0 	ldr	x0, [sp, #24]
    a001aa48:	97fffc68 	bl	a0019be8 <z_abort_timeout>
    a001aa4c:	7100001f 	cmp	w0, #0x0
    a001aa50:	1a9f07e0 	cset	w0, ne  // ne = any
    a001aa54:	12001c00 	and	w0, w0, #0xff
    a001aa58:	b9002fe0 	str	w0, [sp, #44]

	if (inactive) {
    a001aa5c:	b9402fe0 	ldr	w0, [sp, #44]
    a001aa60:	7100001f 	cmp	w0, #0x0
    a001aa64:	54000281 	b.ne	a001aab4 <z_impl_k_timer_stop+0x7c>  // b.any
		return;
	}

	if (timer->stop_fn != NULL) {
    a001aa68:	f9400fe0 	ldr	x0, [sp, #24]
    a001aa6c:	f9401c00 	ldr	x0, [x0, #56]
    a001aa70:	f100001f 	cmp	x0, #0x0
    a001aa74:	540000a0 	b.eq	a001aa88 <z_impl_k_timer_stop+0x50>  // b.none
		timer->stop_fn(timer);
    a001aa78:	f9400fe0 	ldr	x0, [sp, #24]
    a001aa7c:	f9401c01 	ldr	x1, [x0, #56]
    a001aa80:	f9400fe0 	ldr	x0, [sp, #24]
    a001aa84:	d63f0020 	blr	x1
	}

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		struct k_thread *pending_thread = z_unpend1_no_timeout(&timer->wait_q);
    a001aa88:	f9400fe0 	ldr	x0, [sp, #24]
    a001aa8c:	91008000 	add	x0, x0, #0x20
    a001aa90:	97fff434 	bl	a0017b60 <z_unpend1_no_timeout>
    a001aa94:	f90013e0 	str	x0, [sp, #32]

		if (pending_thread != NULL) {
    a001aa98:	f94013e0 	ldr	x0, [sp, #32]
    a001aa9c:	f100001f 	cmp	x0, #0x0
    a001aaa0:	540000c0 	b.eq	a001aab8 <z_impl_k_timer_stop+0x80>  // b.none
			z_ready_thread(pending_thread);
    a001aaa4:	f94013e0 	ldr	x0, [sp, #32]
    a001aaa8:	97fff192 	bl	a00170f0 <z_ready_thread>
			z_reschedule_unlocked();
    a001aaac:	97fffed0 	bl	a001a5ec <z_reschedule_unlocked>
    a001aab0:	14000002 	b	a001aab8 <z_impl_k_timer_stop+0x80>
		return;
    a001aab4:	d503201f 	nop
		}
	}
}
    a001aab8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a001aabc:	d65f03c0 	ret

00000000a001aac0 <z_vrfy_k_timer_stop>:

#ifdef CONFIG_USERSPACE
static inline void z_vrfy_k_timer_stop(struct k_timer *timer)
{
    a001aac0:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a001aac4:	910003fd 	mov	x29, sp
    a001aac8:	f9000fe0 	str	x0, [sp, #24]
	Z_OOPS(Z_SYSCALL_OBJ(timer, K_OBJ_TIMER));
    a001aacc:	f9400fe0 	ldr	x0, [sp, #24]
    a001aad0:	940007d6 	bl	a001ca28 <z_object_find>
    a001aad4:	52800003 	mov	w3, #0x0                   	// #0
    a001aad8:	52800142 	mov	w2, #0xa                   	// #10
    a001aadc:	f9400fe1 	ldr	x1, [sp, #24]
    a001aae0:	97fffed8 	bl	a001a640 <z_obj_validation_check>
    a001aae4:	7100001f 	cmp	w0, #0x0
    a001aae8:	1a9f07e0 	cset	w0, ne  // ne = any
    a001aaec:	39063fe0 	strb	w0, [sp, #399]
    a001aaf0:	39463fe0 	ldrb	w0, [sp, #399]
    a001aaf4:	7100001f 	cmp	w0, #0x0
    a001aaf8:	39463fe0 	ldrb	w0, [sp, #399]
    a001aafc:	7100001f 	cmp	w0, #0x0
    a001ab00:	540000c0 	b.eq	a001ab18 <z_vrfy_k_timer_stop+0x58>  // b.none
    a001ab04:	b0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001ab08:	913f8000 	add	x0, x0, #0xfe0
    a001ab0c:	f9400800 	ldr	x0, [x0, #16]
    a001ab10:	f9408400 	ldr	x0, [x0, #264]
    a001ab14:	97ffb991 	bl	a0009158 <arch_syscall_oops>
	z_impl_k_timer_stop(timer);
    a001ab18:	f9400fe0 	ldr	x0, [sp, #24]
    a001ab1c:	97ffffc7 	bl	a001aa38 <z_impl_k_timer_stop>
}
    a001ab20:	d503201f 	nop
    a001ab24:	a8d97bfd 	ldp	x29, x30, [sp], #400
    a001ab28:	d65f03c0 	ret

00000000a001ab2c <z_mrsh_k_timer_stop>:
#include <syscalls/kernel.h>

extern void z_vrfy_k_timer_stop(struct k_timer * timer);
uintptr_t z_mrsh_k_timer_stop(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a001ab2c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a001ab30:	910003fd 	mov	x29, sp
    a001ab34:	f90027e0 	str	x0, [sp, #72]
    a001ab38:	f90023e1 	str	x1, [sp, #64]
    a001ab3c:	f9001fe2 	str	x2, [sp, #56]
    a001ab40:	f9001be3 	str	x3, [sp, #48]
    a001ab44:	f90017e4 	str	x4, [sp, #40]
    a001ab48:	f90013e5 	str	x5, [sp, #32]
    a001ab4c:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a001ab50:	b0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001ab54:	913f8000 	add	x0, x0, #0xfe0
    a001ab58:	f9400800 	ldr	x0, [x0, #16]
    a001ab5c:	f9400fe1 	ldr	x1, [sp, #24]
    a001ab60:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_timer_stop(*(struct k_timer **)&arg0)
    a001ab64:	910123e0 	add	x0, sp, #0x48
    a001ab68:	f9400000 	ldr	x0, [x0]
    a001ab6c:	97ffffd5 	bl	a001aac0 <z_vrfy_k_timer_stop>
;
	_current->syscall_frame = NULL;
    a001ab70:	b0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001ab74:	913f8000 	add	x0, x0, #0xfe0
    a001ab78:	f9400800 	ldr	x0, [x0, #16]
    a001ab7c:	f900841f 	str	xzr, [x0, #264]
	return 0;
    a001ab80:	d2800000 	mov	x0, #0x0                   	// #0
}
    a001ab84:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a001ab88:	d65f03c0 	ret

00000000a001ab8c <z_impl_k_timer_status_get>:
#include <syscalls/k_timer_stop_mrsh.c>
#endif

uint32_t z_impl_k_timer_status_get(struct k_timer *timer)
{
    a001ab8c:	d10183ff 	sub	sp, sp, #0x60
    a001ab90:	f90007e0 	str	x0, [sp, #8]
    a001ab94:	d0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a001ab98:	910a6000 	add	x0, x0, #0x298
    a001ab9c:	f9001fe0 	str	x0, [sp, #56]
    a001aba0:	d53b4220 	mrs	x0, daif
    a001aba4:	f9001be0 	str	x0, [sp, #48]
    a001aba8:	f9401be0 	ldr	x0, [sp, #48]
    a001abac:	d503201f 	nop
	key = read_daif();
    a001abb0:	b9002fe0 	str	w0, [sp, #44]
	__asm__ volatile ("msr DAIFSet, %0"
    a001abb4:	d50342df 	msr	daifset, #0x2
}
    a001abb8:	d503201f 	nop
	return key;
    a001abbc:	b9402fe0 	ldr	w0, [sp, #44]
	k.key = arch_irq_lock();
    a001abc0:	b90023e0 	str	w0, [sp, #32]
	return k;
    a001abc4:	b94023e0 	ldr	w0, [sp, #32]
    a001abc8:	b9002be0 	str	w0, [sp, #40]
	k_spinlock_key_t key = k_spin_lock(&lock);
	uint32_t result = timer->status;
    a001abcc:	f94007e0 	ldr	x0, [sp, #8]
    a001abd0:	b9404800 	ldr	w0, [x0, #72]
    a001abd4:	b9005fe0 	str	w0, [sp, #92]

	timer->status = 0U;
    a001abd8:	f94007e0 	ldr	x0, [sp, #8]
    a001abdc:	b900481f 	str	wzr, [x0, #72]
    a001abe0:	d0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a001abe4:	910a6000 	add	x0, x0, #0x298
    a001abe8:	f9002be0 	str	x0, [sp, #80]
    a001abec:	b9402be0 	ldr	w0, [sp, #40]
    a001abf0:	b9001be0 	str	w0, [sp, #24]
	arch_irq_unlock(key.key);
    a001abf4:	b9401be0 	ldr	w0, [sp, #24]
    a001abf8:	b9004fe0 	str	w0, [sp, #76]
	write_daif(key);
    a001abfc:	b9404fe0 	ldr	w0, [sp, #76]
    a001ac00:	f90023e0 	str	x0, [sp, #64]
MAKE_REG_HELPER(daif)
    a001ac04:	f94023e0 	ldr	x0, [sp, #64]
    a001ac08:	d51b4220 	msr	daif, x0
    a001ac0c:	d503201f 	nop
}
    a001ac10:	d503201f 	nop
}
    a001ac14:	d503201f 	nop
	k_spin_unlock(&lock, key);

	return result;
    a001ac18:	b9405fe0 	ldr	w0, [sp, #92]
}
    a001ac1c:	910183ff 	add	sp, sp, #0x60
    a001ac20:	d65f03c0 	ret

00000000a001ac24 <z_vrfy_k_timer_status_get>:

#ifdef CONFIG_USERSPACE
static inline uint32_t z_vrfy_k_timer_status_get(struct k_timer *timer)
{
    a001ac24:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a001ac28:	910003fd 	mov	x29, sp
    a001ac2c:	f9000fe0 	str	x0, [sp, #24]
	Z_OOPS(Z_SYSCALL_OBJ(timer, K_OBJ_TIMER));
    a001ac30:	f9400fe0 	ldr	x0, [sp, #24]
    a001ac34:	9400077d 	bl	a001ca28 <z_object_find>
    a001ac38:	52800003 	mov	w3, #0x0                   	// #0
    a001ac3c:	52800142 	mov	w2, #0xa                   	// #10
    a001ac40:	f9400fe1 	ldr	x1, [sp, #24]
    a001ac44:	97fffe7f 	bl	a001a640 <z_obj_validation_check>
    a001ac48:	7100001f 	cmp	w0, #0x0
    a001ac4c:	1a9f07e0 	cset	w0, ne  // ne = any
    a001ac50:	39063fe0 	strb	w0, [sp, #399]
    a001ac54:	39463fe0 	ldrb	w0, [sp, #399]
    a001ac58:	7100001f 	cmp	w0, #0x0
    a001ac5c:	39463fe0 	ldrb	w0, [sp, #399]
    a001ac60:	7100001f 	cmp	w0, #0x0
    a001ac64:	540000c0 	b.eq	a001ac7c <z_vrfy_k_timer_status_get+0x58>  // b.none
    a001ac68:	b0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001ac6c:	913f8000 	add	x0, x0, #0xfe0
    a001ac70:	f9400800 	ldr	x0, [x0, #16]
    a001ac74:	f9408400 	ldr	x0, [x0, #264]
    a001ac78:	97ffb938 	bl	a0009158 <arch_syscall_oops>
	return z_impl_k_timer_status_get(timer);
    a001ac7c:	f9400fe0 	ldr	x0, [sp, #24]
    a001ac80:	97ffffc3 	bl	a001ab8c <z_impl_k_timer_status_get>
}
    a001ac84:	a8d97bfd 	ldp	x29, x30, [sp], #400
    a001ac88:	d65f03c0 	ret

00000000a001ac8c <z_mrsh_k_timer_status_get>:
#include <syscalls/kernel.h>

extern uint32_t z_vrfy_k_timer_status_get(struct k_timer * timer);
uintptr_t z_mrsh_k_timer_status_get(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a001ac8c:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a001ac90:	910003fd 	mov	x29, sp
    a001ac94:	f90027e0 	str	x0, [sp, #72]
    a001ac98:	f90023e1 	str	x1, [sp, #64]
    a001ac9c:	f9001fe2 	str	x2, [sp, #56]
    a001aca0:	f9001be3 	str	x3, [sp, #48]
    a001aca4:	f90017e4 	str	x4, [sp, #40]
    a001aca8:	f90013e5 	str	x5, [sp, #32]
    a001acac:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a001acb0:	b0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001acb4:	913f8000 	add	x0, x0, #0xfe0
    a001acb8:	f9400800 	ldr	x0, [x0, #16]
    a001acbc:	f9400fe1 	ldr	x1, [sp, #24]
    a001acc0:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	uint32_t ret = z_vrfy_k_timer_status_get(*(struct k_timer **)&arg0)
    a001acc4:	910123e0 	add	x0, sp, #0x48
    a001acc8:	f9400000 	ldr	x0, [x0]
    a001accc:	97ffffd6 	bl	a001ac24 <z_vrfy_k_timer_status_get>
    a001acd0:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a001acd4:	b0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001acd8:	913f8000 	add	x0, x0, #0xfe0
    a001acdc:	f9400800 	ldr	x0, [x0, #16]
    a001ace0:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a001ace4:	b9405fe0 	ldr	w0, [sp, #92]
}
    a001ace8:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a001acec:	d65f03c0 	ret

00000000a001acf0 <z_impl_k_timer_status_sync>:
#include <syscalls/k_timer_status_get_mrsh.c>
#endif

uint32_t z_impl_k_timer_status_sync(struct k_timer *timer)
{
    a001acf0:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
    a001acf4:	910003fd 	mov	x29, sp
    a001acf8:	f9000fe0 	str	x0, [sp, #24]
    a001acfc:	d0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a001ad00:	910a6000 	add	x0, x0, #0x298
    a001ad04:	f9004be0 	str	x0, [sp, #144]
    a001ad08:	d53b4220 	mrs	x0, daif
    a001ad0c:	f90047e0 	str	x0, [sp, #136]
    a001ad10:	f94047e0 	ldr	x0, [sp, #136]
    a001ad14:	d503201f 	nop
	key = read_daif();
    a001ad18:	b90087e0 	str	w0, [sp, #132]
	__asm__ volatile ("msr DAIFSet, %0"
    a001ad1c:	d50342df 	msr	daifset, #0x2
}
    a001ad20:	d503201f 	nop
	return key;
    a001ad24:	b94087e0 	ldr	w0, [sp, #132]
	k.key = arch_irq_lock();
    a001ad28:	b9003be0 	str	w0, [sp, #56]
	return k;
    a001ad2c:	b9403be0 	ldr	w0, [sp, #56]
    a001ad30:	b9004be0 	str	w0, [sp, #72]

		return result;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	uint32_t result = timer->status;
    a001ad34:	f9400fe0 	ldr	x0, [sp, #24]
    a001ad38:	b9404800 	ldr	w0, [x0, #72]
    a001ad3c:	b9009fe0 	str	w0, [sp, #156]

	if (result == 0U) {
    a001ad40:	b9409fe0 	ldr	w0, [sp, #156]
    a001ad44:	7100001f 	cmp	w0, #0x0
    a001ad48:	54000441 	b.ne	a001add0 <z_impl_k_timer_status_sync+0xe0>  // b.any
		if (!z_is_inactive_timeout(&timer->timeout)) {
    a001ad4c:	f9400fe0 	ldr	x0, [sp, #24]
    a001ad50:	97fffe18 	bl	a001a5b0 <z_is_inactive_timeout>
    a001ad54:	12001c00 	and	w0, w0, #0xff
    a001ad58:	52000000 	eor	w0, w0, #0x1
    a001ad5c:	12001c00 	and	w0, w0, #0xff
    a001ad60:	7100001f 	cmp	w0, #0x0
    a001ad64:	54000360 	b.eq	a001add0 <z_impl_k_timer_status_sync+0xe0>  // b.none
			SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_timer, status_sync, timer, K_FOREVER);

			/* wait for timer to expire or stop */
			(void)z_pend_curr(&lock, key, &timer->wait_q, K_FOREVER);
    a001ad68:	f9400fe0 	ldr	x0, [sp, #24]
    a001ad6c:	91008000 	add	x0, x0, #0x20
    a001ad70:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
    a001ad74:	aa0103e3 	mov	x3, x1
    a001ad78:	aa0003e2 	mov	x2, x0
    a001ad7c:	b9404be1 	ldr	w1, [sp, #72]
    a001ad80:	d0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a001ad84:	910a6000 	add	x0, x0, #0x298
    a001ad88:	97fff365 	bl	a0017b1c <z_pend_curr>
    a001ad8c:	d0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a001ad90:	910a6000 	add	x0, x0, #0x298
    a001ad94:	f9003fe0 	str	x0, [sp, #120]
MAKE_REG_HELPER(daif)
    a001ad98:	d53b4220 	mrs	x0, daif
    a001ad9c:	f9003be0 	str	x0, [sp, #112]
    a001ada0:	f9403be0 	ldr	x0, [sp, #112]
    a001ada4:	d503201f 	nop
	key = read_daif();
    a001ada8:	b9006fe0 	str	w0, [sp, #108]
	__asm__ volatile ("msr DAIFSet, %0"
    a001adac:	d50342df 	msr	daifset, #0x2
}
    a001adb0:	d503201f 	nop
	return key;
    a001adb4:	b9406fe0 	ldr	w0, [sp, #108]
	k.key = arch_irq_lock();
    a001adb8:	b9002be0 	str	w0, [sp, #40]
	return k;
    a001adbc:	b9402be0 	ldr	w0, [sp, #40]
    a001adc0:	b9004be0 	str	w0, [sp, #72]

			/* get updated timer status */
			key = k_spin_lock(&lock);
			result = timer->status;
    a001adc4:	f9400fe0 	ldr	x0, [sp, #24]
    a001adc8:	b9404800 	ldr	w0, [x0, #72]
    a001adcc:	b9009fe0 	str	w0, [sp, #156]
		}
	} else {
		/* timer has already expired at least once */
	}

	timer->status = 0U;
    a001add0:	f9400fe0 	ldr	x0, [sp, #24]
    a001add4:	b900481f 	str	wzr, [x0, #72]
    a001add8:	d0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a001addc:	910a6000 	add	x0, x0, #0x298
    a001ade0:	f90033e0 	str	x0, [sp, #96]
    a001ade4:	b9404be0 	ldr	w0, [sp, #72]
    a001ade8:	b90043e0 	str	w0, [sp, #64]
	arch_irq_unlock(key.key);
    a001adec:	b94043e0 	ldr	w0, [sp, #64]
    a001adf0:	b9005fe0 	str	w0, [sp, #92]
	write_daif(key);
    a001adf4:	b9405fe0 	ldr	w0, [sp, #92]
    a001adf8:	f9002be0 	str	x0, [sp, #80]
MAKE_REG_HELPER(daif)
    a001adfc:	f9402be0 	ldr	x0, [sp, #80]
    a001ae00:	d51b4220 	msr	daif, x0
    a001ae04:	d503201f 	nop
}
    a001ae08:	d503201f 	nop
}
    a001ae0c:	d503201f 	nop
	/**
	 * @note	New tracing hook
	 */
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_timer, status_sync, timer, result);

	return result;
    a001ae10:	b9409fe0 	ldr	w0, [sp, #156]
}
    a001ae14:	a8ca7bfd 	ldp	x29, x30, [sp], #160
    a001ae18:	d65f03c0 	ret

00000000a001ae1c <z_vrfy_k_timer_status_sync>:

#ifdef CONFIG_USERSPACE
static inline uint32_t z_vrfy_k_timer_status_sync(struct k_timer *timer)
{
    a001ae1c:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a001ae20:	910003fd 	mov	x29, sp
    a001ae24:	f9000fe0 	str	x0, [sp, #24]
	Z_OOPS(Z_SYSCALL_OBJ(timer, K_OBJ_TIMER));
    a001ae28:	f9400fe0 	ldr	x0, [sp, #24]
    a001ae2c:	940006ff 	bl	a001ca28 <z_object_find>
    a001ae30:	52800003 	mov	w3, #0x0                   	// #0
    a001ae34:	52800142 	mov	w2, #0xa                   	// #10
    a001ae38:	f9400fe1 	ldr	x1, [sp, #24]
    a001ae3c:	97fffe01 	bl	a001a640 <z_obj_validation_check>
    a001ae40:	7100001f 	cmp	w0, #0x0
    a001ae44:	1a9f07e0 	cset	w0, ne  // ne = any
    a001ae48:	39063fe0 	strb	w0, [sp, #399]
    a001ae4c:	39463fe0 	ldrb	w0, [sp, #399]
    a001ae50:	7100001f 	cmp	w0, #0x0
    a001ae54:	39463fe0 	ldrb	w0, [sp, #399]
    a001ae58:	7100001f 	cmp	w0, #0x0
    a001ae5c:	540000c0 	b.eq	a001ae74 <z_vrfy_k_timer_status_sync+0x58>  // b.none
    a001ae60:	b0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001ae64:	913f8000 	add	x0, x0, #0xfe0
    a001ae68:	f9400800 	ldr	x0, [x0, #16]
    a001ae6c:	f9408400 	ldr	x0, [x0, #264]
    a001ae70:	97ffb8ba 	bl	a0009158 <arch_syscall_oops>
	return z_impl_k_timer_status_sync(timer);
    a001ae74:	f9400fe0 	ldr	x0, [sp, #24]
    a001ae78:	97ffff9e 	bl	a001acf0 <z_impl_k_timer_status_sync>
}
    a001ae7c:	a8d97bfd 	ldp	x29, x30, [sp], #400
    a001ae80:	d65f03c0 	ret

00000000a001ae84 <z_mrsh_k_timer_status_sync>:
#include <syscalls/kernel.h>

extern uint32_t z_vrfy_k_timer_status_sync(struct k_timer * timer);
uintptr_t z_mrsh_k_timer_status_sync(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a001ae84:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a001ae88:	910003fd 	mov	x29, sp
    a001ae8c:	f90027e0 	str	x0, [sp, #72]
    a001ae90:	f90023e1 	str	x1, [sp, #64]
    a001ae94:	f9001fe2 	str	x2, [sp, #56]
    a001ae98:	f9001be3 	str	x3, [sp, #48]
    a001ae9c:	f90017e4 	str	x4, [sp, #40]
    a001aea0:	f90013e5 	str	x5, [sp, #32]
    a001aea4:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a001aea8:	b0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001aeac:	913f8000 	add	x0, x0, #0xfe0
    a001aeb0:	f9400800 	ldr	x0, [x0, #16]
    a001aeb4:	f9400fe1 	ldr	x1, [sp, #24]
    a001aeb8:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	uint32_t ret = z_vrfy_k_timer_status_sync(*(struct k_timer **)&arg0)
    a001aebc:	910123e0 	add	x0, sp, #0x48
    a001aec0:	f9400000 	ldr	x0, [x0]
    a001aec4:	97ffffd6 	bl	a001ae1c <z_vrfy_k_timer_status_sync>
    a001aec8:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a001aecc:	b0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001aed0:	913f8000 	add	x0, x0, #0xfe0
    a001aed4:	f9400800 	ldr	x0, [x0, #16]
    a001aed8:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a001aedc:	b9405fe0 	ldr	w0, [sp, #92]
}
    a001aee0:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a001aee4:	d65f03c0 	ret

00000000a001aee8 <z_vrfy_k_timer_remaining_ticks>:
#include <syscalls/k_timer_status_sync_mrsh.c>

static inline k_ticks_t z_vrfy_k_timer_remaining_ticks(
						const struct k_timer *timer)
{
    a001aee8:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a001aeec:	910003fd 	mov	x29, sp
    a001aef0:	f9000fe0 	str	x0, [sp, #24]
	Z_OOPS(Z_SYSCALL_OBJ(timer, K_OBJ_TIMER));
    a001aef4:	f9400fe0 	ldr	x0, [sp, #24]
    a001aef8:	940006cc 	bl	a001ca28 <z_object_find>
    a001aefc:	52800003 	mov	w3, #0x0                   	// #0
    a001af00:	52800142 	mov	w2, #0xa                   	// #10
    a001af04:	f9400fe1 	ldr	x1, [sp, #24]
    a001af08:	97fffdce 	bl	a001a640 <z_obj_validation_check>
    a001af0c:	7100001f 	cmp	w0, #0x0
    a001af10:	1a9f07e0 	cset	w0, ne  // ne = any
    a001af14:	39063fe0 	strb	w0, [sp, #399]
    a001af18:	39463fe0 	ldrb	w0, [sp, #399]
    a001af1c:	7100001f 	cmp	w0, #0x0
    a001af20:	39463fe0 	ldrb	w0, [sp, #399]
    a001af24:	7100001f 	cmp	w0, #0x0
    a001af28:	540000c0 	b.eq	a001af40 <z_vrfy_k_timer_remaining_ticks+0x58>  // b.none
    a001af2c:	b0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001af30:	913f8000 	add	x0, x0, #0xfe0
    a001af34:	f9400800 	ldr	x0, [x0, #16]
    a001af38:	f9408400 	ldr	x0, [x0, #264]
    a001af3c:	97ffb887 	bl	a0009158 <arch_syscall_oops>
	return z_impl_k_timer_remaining_ticks(timer);
    a001af40:	f9400fe0 	ldr	x0, [sp, #24]
    a001af44:	97fffd85 	bl	a001a558 <z_impl_k_timer_remaining_ticks>
}
    a001af48:	a8d97bfd 	ldp	x29, x30, [sp], #400
    a001af4c:	d65f03c0 	ret

00000000a001af50 <z_mrsh_k_timer_remaining_ticks>:
#include <syscalls/kernel.h>

extern k_ticks_t z_vrfy_k_timer_remaining_ticks(const struct k_timer * timer);
uintptr_t z_mrsh_k_timer_remaining_ticks(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a001af50:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a001af54:	910003fd 	mov	x29, sp
    a001af58:	f90027e0 	str	x0, [sp, #72]
    a001af5c:	f90023e1 	str	x1, [sp, #64]
    a001af60:	f9001fe2 	str	x2, [sp, #56]
    a001af64:	f9001be3 	str	x3, [sp, #48]
    a001af68:	f90017e4 	str	x4, [sp, #40]
    a001af6c:	f90013e5 	str	x5, [sp, #32]
    a001af70:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a001af74:	b0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001af78:	913f8000 	add	x0, x0, #0xfe0
    a001af7c:	f9400800 	ldr	x0, [x0, #16]
    a001af80:	f9400fe1 	ldr	x1, [sp, #24]
    a001af84:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	k_ticks_t ret = z_vrfy_k_timer_remaining_ticks(*(const struct k_timer **)&arg0)
    a001af88:	910123e0 	add	x0, sp, #0x48
    a001af8c:	f9400000 	ldr	x0, [x0]
    a001af90:	97ffffd6 	bl	a001aee8 <z_vrfy_k_timer_remaining_ticks>
    a001af94:	f9002fe0 	str	x0, [sp, #88]
;
	_current->syscall_frame = NULL;
    a001af98:	b0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001af9c:	913f8000 	add	x0, x0, #0xfe0
    a001afa0:	f9400800 	ldr	x0, [x0, #16]
    a001afa4:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a001afa8:	f9402fe0 	ldr	x0, [sp, #88]
}
    a001afac:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a001afb0:	d65f03c0 	ret

00000000a001afb4 <z_vrfy_k_timer_expires_ticks>:
#include <syscalls/k_timer_remaining_ticks_mrsh.c>

static inline k_ticks_t z_vrfy_k_timer_expires_ticks(
						const struct k_timer *timer)
{
    a001afb4:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a001afb8:	910003fd 	mov	x29, sp
    a001afbc:	f9000fe0 	str	x0, [sp, #24]
	Z_OOPS(Z_SYSCALL_OBJ(timer, K_OBJ_TIMER));
    a001afc0:	f9400fe0 	ldr	x0, [sp, #24]
    a001afc4:	94000699 	bl	a001ca28 <z_object_find>
    a001afc8:	52800003 	mov	w3, #0x0                   	// #0
    a001afcc:	52800142 	mov	w2, #0xa                   	// #10
    a001afd0:	f9400fe1 	ldr	x1, [sp, #24]
    a001afd4:	97fffd9b 	bl	a001a640 <z_obj_validation_check>
    a001afd8:	7100001f 	cmp	w0, #0x0
    a001afdc:	1a9f07e0 	cset	w0, ne  // ne = any
    a001afe0:	39063fe0 	strb	w0, [sp, #399]
    a001afe4:	39463fe0 	ldrb	w0, [sp, #399]
    a001afe8:	7100001f 	cmp	w0, #0x0
    a001afec:	39463fe0 	ldrb	w0, [sp, #399]
    a001aff0:	7100001f 	cmp	w0, #0x0
    a001aff4:	540000c0 	b.eq	a001b00c <z_vrfy_k_timer_expires_ticks+0x58>  // b.none
    a001aff8:	b0000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001affc:	913f8000 	add	x0, x0, #0xfe0
    a001b000:	f9400800 	ldr	x0, [x0, #16]
    a001b004:	f9408400 	ldr	x0, [x0, #264]
    a001b008:	97ffb854 	bl	a0009158 <arch_syscall_oops>
	return z_impl_k_timer_expires_ticks(timer);
    a001b00c:	f9400fe0 	ldr	x0, [sp, #24]
    a001b010:	97fffd4b 	bl	a001a53c <z_impl_k_timer_expires_ticks>
}
    a001b014:	a8d97bfd 	ldp	x29, x30, [sp], #400
    a001b018:	d65f03c0 	ret

00000000a001b01c <z_mrsh_k_timer_expires_ticks>:
#include <syscalls/kernel.h>

extern k_ticks_t z_vrfy_k_timer_expires_ticks(const struct k_timer * timer);
uintptr_t z_mrsh_k_timer_expires_ticks(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a001b01c:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a001b020:	910003fd 	mov	x29, sp
    a001b024:	f90027e0 	str	x0, [sp, #72]
    a001b028:	f90023e1 	str	x1, [sp, #64]
    a001b02c:	f9001fe2 	str	x2, [sp, #56]
    a001b030:	f9001be3 	str	x3, [sp, #48]
    a001b034:	f90017e4 	str	x4, [sp, #40]
    a001b038:	f90013e5 	str	x5, [sp, #32]
    a001b03c:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a001b040:	90000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001b044:	913f8000 	add	x0, x0, #0xfe0
    a001b048:	f9400800 	ldr	x0, [x0, #16]
    a001b04c:	f9400fe1 	ldr	x1, [sp, #24]
    a001b050:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	k_ticks_t ret = z_vrfy_k_timer_expires_ticks(*(const struct k_timer **)&arg0)
    a001b054:	910123e0 	add	x0, sp, #0x48
    a001b058:	f9400000 	ldr	x0, [x0]
    a001b05c:	97ffffd6 	bl	a001afb4 <z_vrfy_k_timer_expires_ticks>
    a001b060:	f9002fe0 	str	x0, [sp, #88]
;
	_current->syscall_frame = NULL;
    a001b064:	90000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001b068:	913f8000 	add	x0, x0, #0xfe0
    a001b06c:	f9400800 	ldr	x0, [x0, #16]
    a001b070:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a001b074:	f9402fe0 	ldr	x0, [sp, #88]
}
    a001b078:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a001b07c:	d65f03c0 	ret

00000000a001b080 <z_vrfy_k_timer_user_data_get>:
#include <syscalls/k_timer_expires_ticks_mrsh.c>

static inline void *z_vrfy_k_timer_user_data_get(const struct k_timer *timer)
{
    a001b080:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a001b084:	910003fd 	mov	x29, sp
    a001b088:	f9000fe0 	str	x0, [sp, #24]
	Z_OOPS(Z_SYSCALL_OBJ(timer, K_OBJ_TIMER));
    a001b08c:	f9400fe0 	ldr	x0, [sp, #24]
    a001b090:	94000666 	bl	a001ca28 <z_object_find>
    a001b094:	52800003 	mov	w3, #0x0                   	// #0
    a001b098:	52800142 	mov	w2, #0xa                   	// #10
    a001b09c:	f9400fe1 	ldr	x1, [sp, #24]
    a001b0a0:	97fffd68 	bl	a001a640 <z_obj_validation_check>
    a001b0a4:	7100001f 	cmp	w0, #0x0
    a001b0a8:	1a9f07e0 	cset	w0, ne  // ne = any
    a001b0ac:	39063fe0 	strb	w0, [sp, #399]
    a001b0b0:	39463fe0 	ldrb	w0, [sp, #399]
    a001b0b4:	7100001f 	cmp	w0, #0x0
    a001b0b8:	39463fe0 	ldrb	w0, [sp, #399]
    a001b0bc:	7100001f 	cmp	w0, #0x0
    a001b0c0:	540000c0 	b.eq	a001b0d8 <z_vrfy_k_timer_user_data_get+0x58>  // b.none
    a001b0c4:	90000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001b0c8:	913f8000 	add	x0, x0, #0xfe0
    a001b0cc:	f9400800 	ldr	x0, [x0, #16]
    a001b0d0:	f9408400 	ldr	x0, [x0, #264]
    a001b0d4:	97ffb821 	bl	a0009158 <arch_syscall_oops>
	return z_impl_k_timer_user_data_get(timer);
    a001b0d8:	f9400fe0 	ldr	x0, [sp, #24]
    a001b0dc:	97fffd2f 	bl	a001a598 <z_impl_k_timer_user_data_get>
}
    a001b0e0:	a8d97bfd 	ldp	x29, x30, [sp], #400
    a001b0e4:	d65f03c0 	ret

00000000a001b0e8 <z_mrsh_k_timer_user_data_get>:
#include <syscalls/kernel.h>

extern void * z_vrfy_k_timer_user_data_get(const struct k_timer * timer);
uintptr_t z_mrsh_k_timer_user_data_get(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a001b0e8:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a001b0ec:	910003fd 	mov	x29, sp
    a001b0f0:	f90027e0 	str	x0, [sp, #72]
    a001b0f4:	f90023e1 	str	x1, [sp, #64]
    a001b0f8:	f9001fe2 	str	x2, [sp, #56]
    a001b0fc:	f9001be3 	str	x3, [sp, #48]
    a001b100:	f90017e4 	str	x4, [sp, #40]
    a001b104:	f90013e5 	str	x5, [sp, #32]
    a001b108:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a001b10c:	90000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001b110:	913f8000 	add	x0, x0, #0xfe0
    a001b114:	f9400800 	ldr	x0, [x0, #16]
    a001b118:	f9400fe1 	ldr	x1, [sp, #24]
    a001b11c:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	void * ret = z_vrfy_k_timer_user_data_get(*(const struct k_timer **)&arg0)
    a001b120:	910123e0 	add	x0, sp, #0x48
    a001b124:	f9400000 	ldr	x0, [x0]
    a001b128:	97ffffd6 	bl	a001b080 <z_vrfy_k_timer_user_data_get>
    a001b12c:	f9002fe0 	str	x0, [sp, #88]
;
	_current->syscall_frame = NULL;
    a001b130:	90000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001b134:	913f8000 	add	x0, x0, #0xfe0
    a001b138:	f9400800 	ldr	x0, [x0, #16]
    a001b13c:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a001b140:	f9402fe0 	ldr	x0, [sp, #88]
}
    a001b144:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a001b148:	d65f03c0 	ret

00000000a001b14c <z_vrfy_k_timer_user_data_set>:
#include <syscalls/k_timer_user_data_get_mrsh.c>

static inline void z_vrfy_k_timer_user_data_set(struct k_timer *timer,
						void *user_data)
{
    a001b14c:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a001b150:	910003fd 	mov	x29, sp
    a001b154:	f9000fe0 	str	x0, [sp, #24]
    a001b158:	f9000be1 	str	x1, [sp, #16]
	Z_OOPS(Z_SYSCALL_OBJ(timer, K_OBJ_TIMER));
    a001b15c:	f9400fe0 	ldr	x0, [sp, #24]
    a001b160:	94000632 	bl	a001ca28 <z_object_find>
    a001b164:	52800003 	mov	w3, #0x0                   	// #0
    a001b168:	52800142 	mov	w2, #0xa                   	// #10
    a001b16c:	f9400fe1 	ldr	x1, [sp, #24]
    a001b170:	97fffd34 	bl	a001a640 <z_obj_validation_check>
    a001b174:	7100001f 	cmp	w0, #0x0
    a001b178:	1a9f07e0 	cset	w0, ne  // ne = any
    a001b17c:	39063fe0 	strb	w0, [sp, #399]
    a001b180:	39463fe0 	ldrb	w0, [sp, #399]
    a001b184:	7100001f 	cmp	w0, #0x0
    a001b188:	39463fe0 	ldrb	w0, [sp, #399]
    a001b18c:	7100001f 	cmp	w0, #0x0
    a001b190:	540000c0 	b.eq	a001b1a8 <z_vrfy_k_timer_user_data_set+0x5c>  // b.none
    a001b194:	90000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001b198:	913f8000 	add	x0, x0, #0xfe0
    a001b19c:	f9400800 	ldr	x0, [x0, #16]
    a001b1a0:	f9408400 	ldr	x0, [x0, #264]
    a001b1a4:	97ffb7ed 	bl	a0009158 <arch_syscall_oops>
	z_impl_k_timer_user_data_set(timer, user_data);
    a001b1a8:	f9400be1 	ldr	x1, [sp, #16]
    a001b1ac:	f9400fe0 	ldr	x0, [sp, #24]
    a001b1b0:	97fffcf1 	bl	a001a574 <z_impl_k_timer_user_data_set>
}
    a001b1b4:	d503201f 	nop
    a001b1b8:	a8d97bfd 	ldp	x29, x30, [sp], #400
    a001b1bc:	d65f03c0 	ret

00000000a001b1c0 <z_mrsh_k_timer_user_data_set>:
#include <syscalls/kernel.h>

extern void z_vrfy_k_timer_user_data_set(struct k_timer * timer, void * user_data);
uintptr_t z_mrsh_k_timer_user_data_set(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a001b1c0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a001b1c4:	910003fd 	mov	x29, sp
    a001b1c8:	f90027e0 	str	x0, [sp, #72]
    a001b1cc:	f90023e1 	str	x1, [sp, #64]
    a001b1d0:	f9001fe2 	str	x2, [sp, #56]
    a001b1d4:	f9001be3 	str	x3, [sp, #48]
    a001b1d8:	f90017e4 	str	x4, [sp, #40]
    a001b1dc:	f90013e5 	str	x5, [sp, #32]
    a001b1e0:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a001b1e4:	90000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001b1e8:	913f8000 	add	x0, x0, #0xfe0
    a001b1ec:	f9400800 	ldr	x0, [x0, #16]
    a001b1f0:	f9400fe1 	ldr	x1, [sp, #24]
    a001b1f4:	f9008401 	str	x1, [x0, #264]
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_timer_user_data_set(*(struct k_timer **)&arg0, *(void **)&arg1)
    a001b1f8:	910123e0 	add	x0, sp, #0x48
    a001b1fc:	f9400002 	ldr	x2, [x0]
    a001b200:	910103e0 	add	x0, sp, #0x40
    a001b204:	f9400000 	ldr	x0, [x0]
    a001b208:	aa0003e1 	mov	x1, x0
    a001b20c:	aa0203e0 	mov	x0, x2
    a001b210:	97ffffcf 	bl	a001b14c <z_vrfy_k_timer_user_data_set>
;
	_current->syscall_frame = NULL;
    a001b214:	90000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001b218:	913f8000 	add	x0, x0, #0xfe0
    a001b21c:	f9400800 	ldr	x0, [x0, #16]
    a001b220:	f900841f 	str	xzr, [x0, #264]
	return 0;
    a001b224:	d2800000 	mov	x0, #0x0                   	// #0
}
    a001b228:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a001b22c:	d65f03c0 	ret

00000000a001b230 <sys_slist_init>:
{
    a001b230:	d10043ff 	sub	sp, sp, #0x10
    a001b234:	f90007e0 	str	x0, [sp, #8]
	list->head = NULL;
    a001b238:	f94007e0 	ldr	x0, [sp, #8]
    a001b23c:	f900001f 	str	xzr, [x0]
	list->tail = NULL;
    a001b240:	f94007e0 	ldr	x0, [sp, #8]
    a001b244:	f900041f 	str	xzr, [x0, #8]
}
    a001b248:	d503201f 	nop
    a001b24c:	910043ff 	add	sp, sp, #0x10
    a001b250:	d65f03c0 	ret

00000000a001b254 <z_snode_next_set>:
{
    a001b254:	d10043ff 	sub	sp, sp, #0x10
    a001b258:	f90007e0 	str	x0, [sp, #8]
    a001b25c:	f90003e1 	str	x1, [sp]
	parent->next = child;
    a001b260:	f94007e0 	ldr	x0, [sp, #8]
    a001b264:	f94003e1 	ldr	x1, [sp]
    a001b268:	f9000001 	str	x1, [x0]
}
    a001b26c:	d503201f 	nop
    a001b270:	910043ff 	add	sp, sp, #0x10
    a001b274:	d65f03c0 	ret

00000000a001b278 <z_slist_head_set>:
{
    a001b278:	d10043ff 	sub	sp, sp, #0x10
    a001b27c:	f90007e0 	str	x0, [sp, #8]
    a001b280:	f90003e1 	str	x1, [sp]
	list->head = node;
    a001b284:	f94007e0 	ldr	x0, [sp, #8]
    a001b288:	f94003e1 	ldr	x1, [sp]
    a001b28c:	f9000001 	str	x1, [x0]
}
    a001b290:	d503201f 	nop
    a001b294:	910043ff 	add	sp, sp, #0x10
    a001b298:	d65f03c0 	ret

00000000a001b29c <z_slist_tail_set>:
{
    a001b29c:	d10043ff 	sub	sp, sp, #0x10
    a001b2a0:	f90007e0 	str	x0, [sp, #8]
    a001b2a4:	f90003e1 	str	x1, [sp]
	list->tail = node;
    a001b2a8:	f94007e0 	ldr	x0, [sp, #8]
    a001b2ac:	f94003e1 	ldr	x1, [sp]
    a001b2b0:	f9000401 	str	x1, [x0, #8]
}
    a001b2b4:	d503201f 	nop
    a001b2b8:	910043ff 	add	sp, sp, #0x10
    a001b2bc:	d65f03c0 	ret

00000000a001b2c0 <sys_slist_peek_tail>:
{
    a001b2c0:	d10043ff 	sub	sp, sp, #0x10
    a001b2c4:	f90007e0 	str	x0, [sp, #8]
	return list->tail;
    a001b2c8:	f94007e0 	ldr	x0, [sp, #8]
    a001b2cc:	f9400400 	ldr	x0, [x0, #8]
}
    a001b2d0:	910043ff 	add	sp, sp, #0x10
    a001b2d4:	d65f03c0 	ret

00000000a001b2d8 <sys_slist_append>:
Z_GENLIST_APPEND(slist, snode)
    a001b2d8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a001b2dc:	910003fd 	mov	x29, sp
    a001b2e0:	f9000fe0 	str	x0, [sp, #24]
    a001b2e4:	f9000be1 	str	x1, [sp, #16]
    a001b2e8:	d2800001 	mov	x1, #0x0                   	// #0
    a001b2ec:	f9400be0 	ldr	x0, [sp, #16]
    a001b2f0:	97ffffd9 	bl	a001b254 <z_snode_next_set>
    a001b2f4:	f9400fe0 	ldr	x0, [sp, #24]
    a001b2f8:	97fffff2 	bl	a001b2c0 <sys_slist_peek_tail>
    a001b2fc:	f100001f 	cmp	x0, #0x0
    a001b300:	54000101 	b.ne	a001b320 <sys_slist_append+0x48>  // b.any
    a001b304:	f9400be1 	ldr	x1, [sp, #16]
    a001b308:	f9400fe0 	ldr	x0, [sp, #24]
    a001b30c:	97ffffe4 	bl	a001b29c <z_slist_tail_set>
    a001b310:	f9400be1 	ldr	x1, [sp, #16]
    a001b314:	f9400fe0 	ldr	x0, [sp, #24]
    a001b318:	97ffffd8 	bl	a001b278 <z_slist_head_set>
    a001b31c:	14000008 	b	a001b33c <sys_slist_append+0x64>
    a001b320:	f9400fe0 	ldr	x0, [sp, #24]
    a001b324:	97ffffe7 	bl	a001b2c0 <sys_slist_peek_tail>
    a001b328:	f9400be1 	ldr	x1, [sp, #16]
    a001b32c:	97ffffca 	bl	a001b254 <z_snode_next_set>
    a001b330:	f9400be1 	ldr	x1, [sp, #16]
    a001b334:	f9400fe0 	ldr	x0, [sp, #24]
    a001b338:	97ffffd9 	bl	a001b29c <z_slist_tail_set>
    a001b33c:	d503201f 	nop
    a001b340:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a001b344:	d65f03c0 	ret

00000000a001b348 <z_page_frame_is_available>:

/* If true, page is not being used for anything, is not reserved, is a member
 * of some free pages list, isn't busy, and may be mapped in memory
 */
static inline bool z_page_frame_is_available(struct z_page_frame *page)
{
    a001b348:	d10043ff 	sub	sp, sp, #0x10
    a001b34c:	f90007e0 	str	x0, [sp, #8]
	return page->flags == 0U;
    a001b350:	f94007e0 	ldr	x0, [sp, #8]
    a001b354:	39402000 	ldrb	w0, [x0, #8]
    a001b358:	7100001f 	cmp	w0, #0x0
    a001b35c:	1a9f17e0 	cset	w0, eq  // eq = none
    a001b360:	12001c00 	and	w0, w0, #0xff
}
    a001b364:	910043ff 	add	sp, sp, #0x10
    a001b368:	d65f03c0 	ret

00000000a001b36c <z_phys_to_page_frame>:
	z_assert_phys_aligned(phys);
	return (phys >= Z_PHYS_RAM_START) && (phys < Z_PHYS_RAM_END);
}

static inline struct z_page_frame *z_phys_to_page_frame(uintptr_t phys)
{
    a001b36c:	d10043ff 	sub	sp, sp, #0x10
    a001b370:	f90007e0 	str	x0, [sp, #8]
	__ASSERT(z_is_page_frame(phys),
		 "0x%lx not an SRAM physical address", phys);

	return &z_page_frames[(phys - Z_PHYS_RAM_START) /
    a001b374:	f94007e1 	ldr	x1, [sp, #8]
    a001b378:	929fffe0 	mov	x0, #0xffffffffffff0000    	// #-65536
    a001b37c:	f2ac0000 	movk	x0, #0x6000, lsl #16
    a001b380:	8b000020 	add	x0, x1, x0
    a001b384:	d34cfc01 	lsr	x1, x0, #12
    a001b388:	aa0103e0 	mov	x0, x1
    a001b38c:	d37df000 	lsl	x0, x0, #3
    a001b390:	8b010000 	add	x0, x0, x1
    a001b394:	b0000161 	adrp	x1, a0048000 <_kernel+0x20>
    a001b398:	910a6021 	add	x1, x1, #0x298
    a001b39c:	8b010000 	add	x0, x0, x1
			      CONFIG_MMU_PAGE_SIZE];
}
    a001b3a0:	910043ff 	add	sp, sp, #0x10
    a001b3a4:	d65f03c0 	ret

00000000a001b3a8 <free_page_frame_list_put>:
	return pf;
}

/* Release a page frame back into the list of free pages */
static void free_page_frame_list_put(struct z_page_frame *pf)
{
    a001b3a8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a001b3ac:	910003fd 	mov	x29, sp
    a001b3b0:	f9000fe0 	str	x0, [sp, #24]
	PF_ASSERT(pf, z_page_frame_is_available(pf),
		 "unavailable page put on free list");
	/* The structure is packed, which ensures that this is true */
	void *node = pf;
    a001b3b4:	f9400fe0 	ldr	x0, [sp, #24]
    a001b3b8:	f90017e0 	str	x0, [sp, #40]

	sys_slist_append(&free_page_frame_list, node);
    a001b3bc:	f94017e1 	ldr	x1, [sp, #40]
    a001b3c0:	b00003a0 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a001b3c4:	910a6000 	add	x0, x0, #0x298
    a001b3c8:	97ffffc4 	bl	a001b2d8 <sys_slist_append>
	z_free_page_count++;
    a001b3cc:	b00003a0 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a001b3d0:	910aa000 	add	x0, x0, #0x2a8
    a001b3d4:	f9400000 	ldr	x0, [x0]
    a001b3d8:	91000401 	add	x1, x0, #0x1
    a001b3dc:	b00003a0 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a001b3e0:	910aa000 	add	x0, x0, #0x2a8
    a001b3e4:	f9000001 	str	x1, [x0]
}
    a001b3e8:	d503201f 	nop
    a001b3ec:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a001b3f0:	d65f03c0 	ret

00000000a001b3f4 <free_page_frame_list_init>:

static void free_page_frame_list_init(void)
{
    a001b3f4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    a001b3f8:	910003fd 	mov	x29, sp
	sys_slist_init(&free_page_frame_list);
    a001b3fc:	b00003a0 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a001b400:	910a6000 	add	x0, x0, #0x298
    a001b404:	97ffff8b 	bl	a001b230 <sys_slist_init>
}
    a001b408:	d503201f 	nop
    a001b40c:	a8c17bfd 	ldp	x29, x30, [sp], #16
    a001b410:	d65f03c0 	ret

00000000a001b414 <frame_mapped_set>:

/* Called after the frame is mapped in the arch layer, to update our
 * local ontology (and do some assertions while we're at it)
 */
static void frame_mapped_set(struct z_page_frame *pf, void *addr)
{
    a001b414:	d10043ff 	sub	sp, sp, #0x10
    a001b418:	f90007e0 	str	x0, [sp, #8]
    a001b41c:	f90003e1 	str	x1, [sp]
	 * Zephyr equivalent of VSDOs
	 */
	PF_ASSERT(pf, !z_page_frame_is_mapped(pf) || z_page_frame_is_pinned(pf),
		 "non-pinned and already mapped to %p", pf->addr);

	pf->flags |= Z_PAGE_FRAME_MAPPED;
    a001b420:	f94007e0 	ldr	x0, [sp, #8]
    a001b424:	39402000 	ldrb	w0, [x0, #8]
    a001b428:	321e0000 	orr	w0, w0, #0x4
    a001b42c:	12001c01 	and	w1, w0, #0xff
    a001b430:	f94007e0 	ldr	x0, [sp, #8]
    a001b434:	39002001 	strb	w1, [x0, #8]
	pf->addr = addr;
    a001b438:	f94007e0 	ldr	x0, [sp, #8]
    a001b43c:	f94003e1 	ldr	x1, [sp]
    a001b440:	f9000001 	str	x1, [x0]
}
    a001b444:	d503201f 	nop
    a001b448:	910043ff 	add	sp, sp, #0x10
    a001b44c:	d65f03c0 	ret

00000000a001b450 <z_mem_manage_init>:
	}
}
#endif /* CONFIG_LINKER_USE_BOOT_SECTION) || CONFIG_LINKER_USE_PINNED_SECTION */

void z_mem_manage_init(void)
{
    a001b450:	a9a37bfd 	stp	x29, x30, [sp, #-464]!
    a001b454:	910003fd 	mov	x29, sp
    a001b458:	b0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a001b45c:	910a6000 	add	x0, x0, #0x298
    a001b460:	f900cfe0 	str	x0, [sp, #408]
    a001b464:	d53b4220 	mrs	x0, daif
    a001b468:	f900d7e0 	str	x0, [sp, #424]
    a001b46c:	f940d7e0 	ldr	x0, [sp, #424]
    a001b470:	d503201f 	nop
	key = read_daif();
    a001b474:	b901b7e0 	str	w0, [sp, #436]
	__asm__ volatile ("msr DAIFSet, %0"
    a001b478:	d50342df 	msr	daifset, #0x2
}
    a001b47c:	d503201f 	nop
	return key;
    a001b480:	b941b7e0 	ldr	w0, [sp, #436]
	k.key = arch_irq_lock();
    a001b484:	b90173e0 	str	w0, [sp, #368]
	return k;
    a001b488:	b94173e0 	ldr	w0, [sp, #368]
    a001b48c:	b90183e0 	str	w0, [sp, #384]
	uintptr_t phys;
	uint8_t *addr;
	struct z_page_frame *pf;
	k_spinlock_key_t key = k_spin_lock(&z_mm_lock);

	free_page_frame_list_init();
    a001b490:	97ffffd9 	bl	a001b3f4 <free_page_frame_list_init>

#ifdef CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT
	/* All pages composing the Zephyr image are mapped at boot in a
	 * predictable way. This can change at runtime.
	 */
	VIRT_FOREACH(Z_KERNEL_VIRT_START, Z_KERNEL_VIRT_SIZE, addr)
    a001b494:	b0ffff20 	adrp	x0, a0000000 <__text_region_start>
    a001b498:	91000000 	add	x0, x0, #0x0
    a001b49c:	f900d3e0 	str	x0, [sp, #416]
    a001b4a0:	14000010 	b	a001b4e0 <z_mem_manage_init+0x90>
	{
		pf = z_phys_to_page_frame(Z_BOOT_VIRT_TO_PHYS(addr));
    a001b4a4:	f940d3e0 	ldr	x0, [sp, #416]
    a001b4a8:	97ffffb1 	bl	a001b36c <z_phys_to_page_frame>
    a001b4ac:	f900cbe0 	str	x0, [sp, #400]
		frame_mapped_set(pf, addr);
    a001b4b0:	f940d3e1 	ldr	x1, [sp, #416]
    a001b4b4:	f940cbe0 	ldr	x0, [sp, #400]
    a001b4b8:	97ffffd7 	bl	a001b414 <frame_mapped_set>
		 * code/data pages which are pinned in memory and
		 * may not be evicted. This will contain critical CPU data
		 * structures, and any code used to perform page fault
		 * handling, page-ins, etc.
		 */
		pf->flags |= Z_PAGE_FRAME_PINNED;
    a001b4bc:	f940cbe0 	ldr	x0, [sp, #400]
    a001b4c0:	39402000 	ldrb	w0, [x0, #8]
    a001b4c4:	32000000 	orr	w0, w0, #0x1
    a001b4c8:	12001c01 	and	w1, w0, #0xff
    a001b4cc:	f940cbe0 	ldr	x0, [sp, #400]
    a001b4d0:	39002001 	strb	w1, [x0, #8]
	VIRT_FOREACH(Z_KERNEL_VIRT_START, Z_KERNEL_VIRT_SIZE, addr)
    a001b4d4:	f940d3e0 	ldr	x0, [sp, #416]
    a001b4d8:	91400400 	add	x0, x0, #0x1, lsl #12
    a001b4dc:	f900d3e0 	str	x0, [sp, #416]
    a001b4e0:	f940d3e1 	ldr	x1, [sp, #416]
    a001b4e4:	b0000400 	adrp	x0, a009c000 <_end>
    a001b4e8:	91000000 	add	x0, x0, #0x0
    a001b4ec:	eb00003f 	cmp	x1, x0
    a001b4f0:	54fffda3 	b.cc	a001b4a4 <z_mem_manage_init+0x54>  // b.lo, b.ul, b.last
#endif

	/* Any remaining pages that aren't mapped, reserved, or pinned get
	 * added to the free pages list
	 */
	Z_PAGE_FRAME_FOREACH(phys, pf) {
    a001b4f4:	d2b40000 	mov	x0, #0xa0000000            	// #2684354560
    a001b4f8:	f900c7e0 	str	x0, [sp, #392]
    a001b4fc:	b0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a001b500:	910a6000 	add	x0, x0, #0x298
    a001b504:	f900cbe0 	str	x0, [sp, #400]
    a001b508:	1400000e 	b	a001b540 <z_mem_manage_init+0xf0>
		if (z_page_frame_is_available(pf)) {
    a001b50c:	f940cbe0 	ldr	x0, [sp, #400]
    a001b510:	97ffff8e 	bl	a001b348 <z_page_frame_is_available>
    a001b514:	12001c00 	and	w0, w0, #0xff
    a001b518:	7100001f 	cmp	w0, #0x0
    a001b51c:	54000060 	b.eq	a001b528 <z_mem_manage_init+0xd8>  // b.none
			free_page_frame_list_put(pf);
    a001b520:	f940cbe0 	ldr	x0, [sp, #400]
    a001b524:	97ffffa1 	bl	a001b3a8 <free_page_frame_list_put>
	Z_PAGE_FRAME_FOREACH(phys, pf) {
    a001b528:	f940c7e0 	ldr	x0, [sp, #392]
    a001b52c:	91400400 	add	x0, x0, #0x1, lsl #12
    a001b530:	f900c7e0 	str	x0, [sp, #392]
    a001b534:	f940cbe0 	ldr	x0, [sp, #400]
    a001b538:	91002400 	add	x0, x0, #0x9
    a001b53c:	f900cbe0 	str	x0, [sp, #400]
    a001b540:	f940c7e1 	ldr	x1, [sp, #392]
    a001b544:	12ab0000 	mov	w0, #0xa7ffffff            	// #-1476395009
    a001b548:	eb00003f 	cmp	x1, x0
    a001b54c:	54fffe09 	b.ls	a001b50c <z_mem_manage_init+0xbc>  // b.plast
    a001b550:	b0000160 	adrp	x0, a0048000 <_kernel+0x20>
    a001b554:	910a6000 	add	x0, x0, #0x298
    a001b558:	f900dfe0 	str	x0, [sp, #440]
    a001b55c:	b94183e0 	ldr	w0, [sp, #384]
    a001b560:	b9017be0 	str	w0, [sp, #376]
	arch_irq_unlock(key.key);
    a001b564:	b9417be0 	ldr	w0, [sp, #376]
    a001b568:	b901c7e0 	str	w0, [sp, #452]
	write_daif(key);
    a001b56c:	b941c7e0 	ldr	w0, [sp, #452]
    a001b570:	f900e7e0 	str	x0, [sp, #456]
MAKE_REG_HELPER(daif)
    a001b574:	f940e7e0 	ldr	x0, [sp, #456]
    a001b578:	d51b4220 	msr	daif, x0
    a001b57c:	d503201f 	nop
}
    a001b580:	d503201f 	nop
}
    a001b584:	d503201f 	nop
	 * and the BSS pages can be brought into physical
	 * memory to be cleared.
	 */
	z_bss_zero();
#endif
}
    a001b588:	d503201f 	nop
    a001b58c:	a8dd7bfd 	ldp	x29, x30, [sp], #464
    a001b590:	d65f03c0 	ret

00000000a001b594 <z_mem_manage_boot_finish>:
	/* At the end of boot process, unpin the boot sections
	 * as they don't need to be in memory all the time anymore.
	 */
	mark_linker_section_pinned(lnkr_boot_start, lnkr_boot_end, false);
#endif
}
    a001b594:	d503201f 	nop
    a001b598:	d65f03c0 	ret

00000000a001b59c <size_add_overflow>:
{
    a001b59c:	d10083ff 	sub	sp, sp, #0x20
    a001b5a0:	f9000fe0 	str	x0, [sp, #24]
    a001b5a4:	f9000be1 	str	x1, [sp, #16]
    a001b5a8:	f90007e2 	str	x2, [sp, #8]
	return __builtin_add_overflow(a, b, result);
    a001b5ac:	d2800002 	mov	x2, #0x0                   	// #0
    a001b5b0:	f9400fe0 	ldr	x0, [sp, #24]
    a001b5b4:	f9400be1 	ldr	x1, [sp, #16]
    a001b5b8:	ab010000 	adds	x0, x0, x1
    a001b5bc:	54000043 	b.cc	a001b5c4 <size_add_overflow+0x28>  // b.lo, b.ul, b.last
    a001b5c0:	d2800022 	mov	x2, #0x1                   	// #1
    a001b5c4:	aa0003e1 	mov	x1, x0
    a001b5c8:	f94007e0 	ldr	x0, [sp, #8]
    a001b5cc:	f9000001 	str	x1, [x0]
    a001b5d0:	aa0203e0 	mov	x0, x2
    a001b5d4:	12000000 	and	w0, w0, #0x1
    a001b5d8:	12001c00 	and	w0, w0, #0xff
}
    a001b5dc:	910083ff 	add	sp, sp, #0x20
    a001b5e0:	d65f03c0 	ret

00000000a001b5e4 <z_heap_aligned_alloc>:
#include <string.h>
#include <sys/math_extras.h>
#include <sys/util.h>

static void *z_heap_aligned_alloc(struct k_heap *heap, size_t align, size_t size)
{
    a001b5e4:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a001b5e8:	910003fd 	mov	x29, sp
    a001b5ec:	f90017e0 	str	x0, [sp, #40]
    a001b5f0:	f90013e1 	str	x1, [sp, #32]
    a001b5f4:	f9000fe2 	str	x2, [sp, #24]
	 * Adjust the size to make room for our heap reference.
	 * Merge a rewind bit with align value (see sys_heap_aligned_alloc()).
	 * This allows for storing the heap pointer right below the aligned
	 * boundary without wasting any memory.
	 */
	if (size_add_overflow(size, sizeof(heap_ref), &size)) {
    a001b5f8:	f9400fe0 	ldr	x0, [sp, #24]
    a001b5fc:	910063e1 	add	x1, sp, #0x18
    a001b600:	aa0103e2 	mov	x2, x1
    a001b604:	d2800101 	mov	x1, #0x8                   	// #8
    a001b608:	97ffffe5 	bl	a001b59c <size_add_overflow>
    a001b60c:	12001c00 	and	w0, w0, #0xff
    a001b610:	7100001f 	cmp	w0, #0x0
    a001b614:	54000060 	b.eq	a001b620 <z_heap_aligned_alloc+0x3c>  // b.none
		return NULL;
    a001b618:	d2800000 	mov	x0, #0x0                   	// #0
    a001b61c:	1400001c 	b	a001b68c <z_heap_aligned_alloc+0xa8>
	}
	__align = align | sizeof(heap_ref);
    a001b620:	f94013e0 	ldr	x0, [sp, #32]
    a001b624:	b27d0000 	orr	x0, x0, #0x8
    a001b628:	f90027e0 	str	x0, [sp, #72]

	mem = k_heap_aligned_alloc(heap, __align, size, K_NO_WAIT);
    a001b62c:	f9400fe0 	ldr	x0, [sp, #24]
    a001b630:	d2800001 	mov	x1, #0x0                   	// #0
    a001b634:	aa0103e3 	mov	x3, x1
    a001b638:	aa0003e2 	mov	x2, x0
    a001b63c:	f94027e1 	ldr	x1, [sp, #72]
    a001b640:	f94017e0 	ldr	x0, [sp, #40]
    a001b644:	940008b1 	bl	a001d908 <k_heap_aligned_alloc>
    a001b648:	f90023e0 	str	x0, [sp, #64]
	if (mem == NULL) {
    a001b64c:	f94023e0 	ldr	x0, [sp, #64]
    a001b650:	f100001f 	cmp	x0, #0x0
    a001b654:	54000061 	b.ne	a001b660 <z_heap_aligned_alloc+0x7c>  // b.any
		return NULL;
    a001b658:	d2800000 	mov	x0, #0x0                   	// #0
    a001b65c:	1400000c 	b	a001b68c <z_heap_aligned_alloc+0xa8>
	}

	heap_ref = mem;
    a001b660:	f94023e0 	ldr	x0, [sp, #64]
    a001b664:	f9001fe0 	str	x0, [sp, #56]
	*heap_ref = heap;
    a001b668:	f9401fe0 	ldr	x0, [sp, #56]
    a001b66c:	f94017e1 	ldr	x1, [sp, #40]
    a001b670:	f9000001 	str	x1, [x0]
	mem = ++heap_ref;
    a001b674:	f9401fe0 	ldr	x0, [sp, #56]
    a001b678:	91002000 	add	x0, x0, #0x8
    a001b67c:	f9001fe0 	str	x0, [sp, #56]
    a001b680:	f9401fe0 	ldr	x0, [sp, #56]
    a001b684:	f90023e0 	str	x0, [sp, #64]
	__ASSERT(align == 0 || ((uintptr_t)mem & (align - 1)) == 0,
		 "misaligned memory at %p (align = %zu)", mem, align);

	return mem;
    a001b688:	f94023e0 	ldr	x0, [sp, #64]
}
    a001b68c:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a001b690:	d65f03c0 	ret

00000000a001b694 <k_free>:

void k_free(void *ptr)
{
    a001b694:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a001b698:	910003fd 	mov	x29, sp
    a001b69c:	f9000fe0 	str	x0, [sp, #24]
	struct k_heap **heap_ref;

	if (ptr != NULL) {
    a001b6a0:	f9400fe0 	ldr	x0, [sp, #24]
    a001b6a4:	f100001f 	cmp	x0, #0x0
    a001b6a8:	54000180 	b.eq	a001b6d8 <k_free+0x44>  // b.none
		heap_ref = ptr;
    a001b6ac:	f9400fe0 	ldr	x0, [sp, #24]
    a001b6b0:	f90017e0 	str	x0, [sp, #40]
		ptr = --heap_ref;
    a001b6b4:	f94017e0 	ldr	x0, [sp, #40]
    a001b6b8:	d1002000 	sub	x0, x0, #0x8
    a001b6bc:	f90017e0 	str	x0, [sp, #40]
    a001b6c0:	f94017e0 	ldr	x0, [sp, #40]
    a001b6c4:	f9000fe0 	str	x0, [sp, #24]

		SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap_sys, k_free, *heap_ref, heap_ref);

		k_heap_free(*heap_ref, ptr);
    a001b6c8:	f94017e0 	ldr	x0, [sp, #40]
    a001b6cc:	f9400000 	ldr	x0, [x0]
    a001b6d0:	f9400fe1 	ldr	x1, [sp, #24]
    a001b6d4:	940008ea 	bl	a001da7c <k_heap_free>

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap_sys, k_free, *heap_ref, heap_ref);
	}
}
    a001b6d8:	d503201f 	nop
    a001b6dc:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a001b6e0:	d65f03c0 	ret

00000000a001b6e4 <z_thread_aligned_alloc>:
#else
#define _SYSTEM_HEAP	NULL
#endif

void *z_thread_aligned_alloc(size_t align, size_t size)
{
    a001b6e4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a001b6e8:	910003fd 	mov	x29, sp
    a001b6ec:	f9000fe0 	str	x0, [sp, #24]
    a001b6f0:	f9000be1 	str	x1, [sp, #16]
	void *ret;
	struct k_heap *heap;

	if (k_is_in_isr()) {
    a001b6f4:	97ffd99e 	bl	a0011d6c <k_is_in_isr>
    a001b6f8:	12001c00 	and	w0, w0, #0xff
    a001b6fc:	7100001f 	cmp	w0, #0x0
    a001b700:	54000060 	b.eq	a001b70c <z_thread_aligned_alloc+0x28>  // b.none
		heap = _SYSTEM_HEAP;
    a001b704:	f90013ff 	str	xzr, [sp, #32]
    a001b708:	14000006 	b	a001b720 <z_thread_aligned_alloc+0x3c>
	} else {
		heap = _current->resource_pool;
    a001b70c:	90000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001b710:	913f8000 	add	x0, x0, #0xfe0
    a001b714:	f9400800 	ldr	x0, [x0, #16]
    a001b718:	f9409000 	ldr	x0, [x0, #288]
    a001b71c:	f90013e0 	str	x0, [sp, #32]
	}

	if (heap != NULL) {
    a001b720:	f94013e0 	ldr	x0, [sp, #32]
    a001b724:	f100001f 	cmp	x0, #0x0
    a001b728:	540000e0 	b.eq	a001b744 <z_thread_aligned_alloc+0x60>  // b.none
		ret = z_heap_aligned_alloc(heap, align, size);
    a001b72c:	f9400be2 	ldr	x2, [sp, #16]
    a001b730:	f9400fe1 	ldr	x1, [sp, #24]
    a001b734:	f94013e0 	ldr	x0, [sp, #32]
    a001b738:	97ffffab 	bl	a001b5e4 <z_heap_aligned_alloc>
    a001b73c:	f90017e0 	str	x0, [sp, #40]
    a001b740:	14000002 	b	a001b748 <z_thread_aligned_alloc+0x64>
	} else {
		ret = NULL;
    a001b744:	f90017ff 	str	xzr, [sp, #40]
	}

	return ret;
    a001b748:	f94017e0 	ldr	x0, [sp, #40]
}
    a001b74c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a001b750:	d65f03c0 	ret

00000000a001b754 <atomic_get>:
 * @param target Address of atomic variable.
 *
 * @return Value of @a target.
 */
static inline atomic_val_t atomic_get(const atomic_t *target)
{
    a001b754:	d10043ff 	sub	sp, sp, #0x10
    a001b758:	f90007e0 	str	x0, [sp, #8]
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    a001b75c:	f94007e0 	ldr	x0, [sp, #8]
    a001b760:	c8dffc00 	ldar	x0, [x0]
}
    a001b764:	910043ff 	add	sp, sp, #0x10
    a001b768:	d65f03c0 	ret

00000000a001b76c <k_futex_find_data>:
#include <syscall_handler.h>
#include <init.h>
#include <ksched.h>

static struct z_futex_data *k_futex_find_data(struct k_futex *futex)
{
    a001b76c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a001b770:	910003fd 	mov	x29, sp
    a001b774:	f9000fe0 	str	x0, [sp, #24]
	struct z_object *obj;

	obj = z_object_find(futex);
    a001b778:	f9400fe0 	ldr	x0, [sp, #24]
    a001b77c:	940004ab 	bl	a001ca28 <z_object_find>
    a001b780:	f90017e0 	str	x0, [sp, #40]
	if (obj == NULL || obj->type != K_OBJ_FUTEX) {
    a001b784:	f94017e0 	ldr	x0, [sp, #40]
    a001b788:	f100001f 	cmp	x0, #0x0
    a001b78c:	540000a0 	b.eq	a001b7a0 <k_futex_find_data+0x34>  // b.none
    a001b790:	f94017e0 	ldr	x0, [sp, #40]
    a001b794:	39402800 	ldrb	w0, [x0, #10]
    a001b798:	71003c1f 	cmp	w0, #0xf
    a001b79c:	54000060 	b.eq	a001b7a8 <k_futex_find_data+0x3c>  // b.none
		return NULL;
    a001b7a0:	d2800000 	mov	x0, #0x0                   	// #0
    a001b7a4:	14000003 	b	a001b7b0 <k_futex_find_data+0x44>
	}

	return obj->data.futex_data;
    a001b7a8:	f94017e0 	ldr	x0, [sp, #40]
    a001b7ac:	f840c000 	ldur	x0, [x0, #12]
}
    a001b7b0:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a001b7b4:	d65f03c0 	ret

00000000a001b7b8 <z_impl_k_futex_wake>:

int z_impl_k_futex_wake(struct k_futex *futex, bool wake_all)
{
    a001b7b8:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    a001b7bc:	910003fd 	mov	x29, sp
    a001b7c0:	f9000fe0 	str	x0, [sp, #24]
    a001b7c4:	39005fe1 	strb	w1, [sp, #23]
	k_spinlock_key_t key;
	unsigned int woken = 0U;
    a001b7c8:	b9006fff 	str	wzr, [sp, #108]
	struct k_thread *thread;
	struct z_futex_data *futex_data;

	futex_data = k_futex_find_data(futex);
    a001b7cc:	f9400fe0 	ldr	x0, [sp, #24]
    a001b7d0:	97ffffe7 	bl	a001b76c <k_futex_find_data>
    a001b7d4:	f90033e0 	str	x0, [sp, #96]
	if (futex_data == NULL) {
    a001b7d8:	f94033e0 	ldr	x0, [sp, #96]
    a001b7dc:	f100001f 	cmp	x0, #0x0
    a001b7e0:	54000061 	b.ne	a001b7ec <z_impl_k_futex_wake+0x34>  // b.any
		return -EINVAL;
    a001b7e4:	128002a0 	mov	w0, #0xffffffea            	// #-22
    a001b7e8:	1400002c 	b	a001b898 <z_impl_k_futex_wake+0xe0>
	}

	key = k_spin_lock(&futex_data->lock);
    a001b7ec:	f94033e0 	ldr	x0, [sp, #96]
    a001b7f0:	91004000 	add	x0, x0, #0x10
    a001b7f4:	f9002be0 	str	x0, [sp, #80]
    a001b7f8:	d53b4220 	mrs	x0, daif
    a001b7fc:	f90027e0 	str	x0, [sp, #72]
    a001b800:	f94027e0 	ldr	x0, [sp, #72]
    a001b804:	d503201f 	nop
	key = read_daif();
    a001b808:	b90047e0 	str	w0, [sp, #68]
	__asm__ volatile ("msr DAIFSet, %0"
    a001b80c:	d50342df 	msr	daifset, #0x2
}
    a001b810:	d503201f 	nop
	return key;
    a001b814:	b94047e0 	ldr	w0, [sp, #68]
	k.key = arch_irq_lock();
    a001b818:	b9002be0 	str	w0, [sp, #40]
	return k;
    a001b81c:	b9402be0 	ldr	w0, [sp, #40]
    a001b820:	b90033e0 	str	w0, [sp, #48]

	do {
		thread = z_unpend_first_thread(&futex_data->wait_q);
    a001b824:	f94033e0 	ldr	x0, [sp, #96]
    a001b828:	97fff100 	bl	a0017c28 <z_unpend_first_thread>
    a001b82c:	f9002fe0 	str	x0, [sp, #88]
		if (thread != NULL) {
    a001b830:	f9402fe0 	ldr	x0, [sp, #88]
    a001b834:	f100001f 	cmp	x0, #0x0
    a001b838:	540001a0 	b.eq	a001b86c <z_impl_k_futex_wake+0xb4>  // b.none
			woken++;
    a001b83c:	b9406fe0 	ldr	w0, [sp, #108]
    a001b840:	11000400 	add	w0, w0, #0x1
    a001b844:	b9006fe0 	str	w0, [sp, #108]
    a001b848:	f9402fe0 	ldr	x0, [sp, #88]
    a001b84c:	f9001fe0 	str	x0, [sp, #56]
    a001b850:	b90037ff 	str	wzr, [sp, #52]
	thread->swap_retval = value;
    a001b854:	b94037e1 	ldr	w1, [sp, #52]
    a001b858:	f9401fe0 	ldr	x0, [sp, #56]
    a001b85c:	b9011001 	str	w1, [x0, #272]
}
    a001b860:	d503201f 	nop
			arch_thread_return_value_set(thread, 0);
			z_ready_thread(thread);
    a001b864:	f9402fe0 	ldr	x0, [sp, #88]
    a001b868:	97ffee22 	bl	a00170f0 <z_ready_thread>
		}
	} while (thread && wake_all);
    a001b86c:	f9402fe0 	ldr	x0, [sp, #88]
    a001b870:	f100001f 	cmp	x0, #0x0
    a001b874:	54000080 	b.eq	a001b884 <z_impl_k_futex_wake+0xcc>  // b.none
    a001b878:	39405fe0 	ldrb	w0, [sp, #23]
    a001b87c:	7100001f 	cmp	w0, #0x0
    a001b880:	54fffd21 	b.ne	a001b824 <z_impl_k_futex_wake+0x6c>  // b.any

	z_reschedule(&futex_data->lock, key);
    a001b884:	f94033e0 	ldr	x0, [sp, #96]
    a001b888:	91004000 	add	x0, x0, #0x10
    a001b88c:	b94033e1 	ldr	w1, [sp, #48]
    a001b890:	97fff223 	bl	a001811c <z_reschedule>

	return woken;
    a001b894:	b9406fe0 	ldr	w0, [sp, #108]
}
    a001b898:	a8c77bfd 	ldp	x29, x30, [sp], #112
    a001b89c:	d65f03c0 	ret

00000000a001b8a0 <z_vrfy_k_futex_wake>:

static inline int z_vrfy_k_futex_wake(struct k_futex *futex, bool wake_all)
{
    a001b8a0:	a9a17bfd 	stp	x29, x30, [sp, #-496]!
    a001b8a4:	910003fd 	mov	x29, sp
    a001b8a8:	f9000fe0 	str	x0, [sp, #24]
    a001b8ac:	39005fe1 	strb	w1, [sp, #23]
	if (Z_SYSCALL_MEMORY_WRITE(futex, sizeof(struct k_futex)) != 0) {
    a001b8b0:	52800022 	mov	w2, #0x1                   	// #1
    a001b8b4:	d2800101 	mov	x1, #0x8                   	// #8
    a001b8b8:	f9400fe0 	ldr	x0, [sp, #24]
    a001b8bc:	97ffbfec 	bl	a000b86c <arch_buffer_validate>
    a001b8c0:	7100001f 	cmp	w0, #0x0
    a001b8c4:	1a9f07e0 	cset	w0, ne  // ne = any
    a001b8c8:	3907bfe0 	strb	w0, [sp, #495]
    a001b8cc:	3947bfe0 	ldrb	w0, [sp, #495]
    a001b8d0:	7100001f 	cmp	w0, #0x0
    a001b8d4:	3947bfe0 	ldrb	w0, [sp, #495]
    a001b8d8:	7100001f 	cmp	w0, #0x0
    a001b8dc:	54000060 	b.eq	a001b8e8 <z_vrfy_k_futex_wake+0x48>  // b.none
		return -EACCES;
    a001b8e0:	12800180 	mov	w0, #0xfffffff3            	// #-13
    a001b8e4:	14000004 	b	a001b8f4 <z_vrfy_k_futex_wake+0x54>
	}

	return z_impl_k_futex_wake(futex, wake_all);
    a001b8e8:	39405fe1 	ldrb	w1, [sp, #23]
    a001b8ec:	f9400fe0 	ldr	x0, [sp, #24]
    a001b8f0:	97ffffb2 	bl	a001b7b8 <z_impl_k_futex_wake>
}
    a001b8f4:	a8df7bfd 	ldp	x29, x30, [sp], #496
    a001b8f8:	d65f03c0 	ret

00000000a001b8fc <z_mrsh_k_futex_wake>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_futex_wake(struct k_futex * futex, bool wake_all);
uintptr_t z_mrsh_k_futex_wake(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a001b8fc:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a001b900:	910003fd 	mov	x29, sp
    a001b904:	f90027e0 	str	x0, [sp, #72]
    a001b908:	f90023e1 	str	x1, [sp, #64]
    a001b90c:	f9001fe2 	str	x2, [sp, #56]
    a001b910:	f9001be3 	str	x3, [sp, #48]
    a001b914:	f90017e4 	str	x4, [sp, #40]
    a001b918:	f90013e5 	str	x5, [sp, #32]
    a001b91c:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a001b920:	90000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001b924:	913f8000 	add	x0, x0, #0xfe0
    a001b928:	f9400800 	ldr	x0, [x0, #16]
    a001b92c:	f9400fe1 	ldr	x1, [sp, #24]
    a001b930:	f9008401 	str	x1, [x0, #264]
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_futex_wake(*(struct k_futex **)&arg0, *(bool*)&arg1)
    a001b934:	910123e0 	add	x0, sp, #0x48
    a001b938:	f9400002 	ldr	x2, [x0]
    a001b93c:	910103e0 	add	x0, sp, #0x40
    a001b940:	39400000 	ldrb	w0, [x0]
    a001b944:	2a0003e1 	mov	w1, w0
    a001b948:	aa0203e0 	mov	x0, x2
    a001b94c:	97ffffd5 	bl	a001b8a0 <z_vrfy_k_futex_wake>
    a001b950:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a001b954:	90000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001b958:	913f8000 	add	x0, x0, #0xfe0
    a001b95c:	f9400800 	ldr	x0, [x0, #16]
    a001b960:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a001b964:	b9805fe0 	ldrsw	x0, [sp, #92]
}
    a001b968:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a001b96c:	d65f03c0 	ret

00000000a001b970 <z_impl_k_futex_wait>:
#include <syscalls/k_futex_wake_mrsh.c>

int z_impl_k_futex_wait(struct k_futex *futex, int expected,
			k_timeout_t timeout)
{
    a001b970:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a001b974:	910003fd 	mov	x29, sp
    a001b978:	f90017e0 	str	x0, [sp, #40]
    a001b97c:	b90027e1 	str	w1, [sp, #36]
    a001b980:	f9000fe2 	str	x2, [sp, #24]
	int ret;
	k_spinlock_key_t key;
	struct z_futex_data *futex_data;

	futex_data = k_futex_find_data(futex);
    a001b984:	f94017e0 	ldr	x0, [sp, #40]
    a001b988:	97ffff79 	bl	a001b76c <k_futex_find_data>
    a001b98c:	f9002be0 	str	x0, [sp, #80]
	if (futex_data == NULL) {
    a001b990:	f9402be0 	ldr	x0, [sp, #80]
    a001b994:	f100001f 	cmp	x0, #0x0
    a001b998:	54000061 	b.ne	a001b9a4 <z_impl_k_futex_wait+0x34>  // b.any
		return -EINVAL;
    a001b99c:	128002a0 	mov	w0, #0xffffffea            	// #-22
    a001b9a0:	14000025 	b	a001ba34 <z_impl_k_futex_wait+0xc4>
	}

	if (atomic_get(&futex->val) != (atomic_val_t)expected) {
    a001b9a4:	f94017e0 	ldr	x0, [sp, #40]
    a001b9a8:	97ffff6b 	bl	a001b754 <atomic_get>
    a001b9ac:	aa0003e1 	mov	x1, x0
    a001b9b0:	b98027e0 	ldrsw	x0, [sp, #36]
    a001b9b4:	eb00003f 	cmp	x1, x0
    a001b9b8:	54000060 	b.eq	a001b9c4 <z_impl_k_futex_wait+0x54>  // b.none
		return -EAGAIN;
    a001b9bc:	12800140 	mov	w0, #0xfffffff5            	// #-11
    a001b9c0:	1400001d 	b	a001ba34 <z_impl_k_futex_wait+0xc4>
	}

	key = k_spin_lock(&futex_data->lock);
    a001b9c4:	f9402be0 	ldr	x0, [sp, #80]
    a001b9c8:	91004000 	add	x0, x0, #0x10
    a001b9cc:	f90027e0 	str	x0, [sp, #72]
MAKE_REG_HELPER(daif)
    a001b9d0:	d53b4220 	mrs	x0, daif
    a001b9d4:	f90023e0 	str	x0, [sp, #64]
    a001b9d8:	f94023e0 	ldr	x0, [sp, #64]
    a001b9dc:	d503201f 	nop
	key = read_daif();
    a001b9e0:	b9003fe0 	str	w0, [sp, #60]
	__asm__ volatile ("msr DAIFSet, %0"
    a001b9e4:	d50342df 	msr	daifset, #0x2
}
    a001b9e8:	d503201f 	nop
	return key;
    a001b9ec:	b9403fe0 	ldr	w0, [sp, #60]
	k.key = arch_irq_lock();
    a001b9f0:	b90033e0 	str	w0, [sp, #48]
	return k;
    a001b9f4:	b94033e0 	ldr	w0, [sp, #48]
    a001b9f8:	b9003be0 	str	w0, [sp, #56]

	ret = z_pend_curr(&futex_data->lock,
    a001b9fc:	f9402be0 	ldr	x0, [sp, #80]
    a001ba00:	91004000 	add	x0, x0, #0x10
    a001ba04:	f9402be1 	ldr	x1, [sp, #80]
    a001ba08:	f9400fe3 	ldr	x3, [sp, #24]
    a001ba0c:	aa0103e2 	mov	x2, x1
    a001ba10:	b9403be1 	ldr	w1, [sp, #56]
    a001ba14:	97fff042 	bl	a0017b1c <z_pend_curr>
    a001ba18:	b9005fe0 	str	w0, [sp, #92]
			key, &futex_data->wait_q, timeout);
	if (ret == -EAGAIN) {
    a001ba1c:	b9405fe0 	ldr	w0, [sp, #92]
    a001ba20:	31002c1f 	cmn	w0, #0xb
    a001ba24:	54000061 	b.ne	a001ba30 <z_impl_k_futex_wait+0xc0>  // b.any
		ret = -ETIMEDOUT;
    a001ba28:	12800e60 	mov	w0, #0xffffff8c            	// #-116
    a001ba2c:	b9005fe0 	str	w0, [sp, #92]
	}

	return ret;
    a001ba30:	b9405fe0 	ldr	w0, [sp, #92]
}
    a001ba34:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a001ba38:	d65f03c0 	ret

00000000a001ba3c <z_vrfy_k_futex_wait>:

static inline int z_vrfy_k_futex_wait(struct k_futex *futex, int expected,
				      k_timeout_t timeout)
{
    a001ba3c:	d10803ff 	sub	sp, sp, #0x200
    a001ba40:	a9007bfd 	stp	x29, x30, [sp]
    a001ba44:	910003fd 	mov	x29, sp
    a001ba48:	f90017e0 	str	x0, [sp, #40]
    a001ba4c:	b90027e1 	str	w1, [sp, #36]
    a001ba50:	f9000fe2 	str	x2, [sp, #24]
	if (Z_SYSCALL_MEMORY_WRITE(futex, sizeof(struct k_futex)) != 0) {
    a001ba54:	52800022 	mov	w2, #0x1                   	// #1
    a001ba58:	d2800101 	mov	x1, #0x8                   	// #8
    a001ba5c:	f94017e0 	ldr	x0, [sp, #40]
    a001ba60:	97ffbf83 	bl	a000b86c <arch_buffer_validate>
    a001ba64:	7100001f 	cmp	w0, #0x0
    a001ba68:	1a9f07e0 	cset	w0, ne  // ne = any
    a001ba6c:	3907ffe0 	strb	w0, [sp, #511]
    a001ba70:	3947ffe0 	ldrb	w0, [sp, #511]
    a001ba74:	7100001f 	cmp	w0, #0x0
    a001ba78:	3947ffe0 	ldrb	w0, [sp, #511]
    a001ba7c:	7100001f 	cmp	w0, #0x0
    a001ba80:	54000060 	b.eq	a001ba8c <z_vrfy_k_futex_wait+0x50>  // b.none
		return -EACCES;
    a001ba84:	12800180 	mov	w0, #0xfffffff3            	// #-13
    a001ba88:	14000005 	b	a001ba9c <z_vrfy_k_futex_wait+0x60>
	}

	return z_impl_k_futex_wait(futex, expected, timeout);
    a001ba8c:	f9400fe2 	ldr	x2, [sp, #24]
    a001ba90:	b94027e1 	ldr	w1, [sp, #36]
    a001ba94:	f94017e0 	ldr	x0, [sp, #40]
    a001ba98:	97ffffb6 	bl	a001b970 <z_impl_k_futex_wait>
}
    a001ba9c:	a9407bfd 	ldp	x29, x30, [sp]
    a001baa0:	910803ff 	add	sp, sp, #0x200
    a001baa4:	d65f03c0 	ret

00000000a001baa8 <z_mrsh_k_futex_wait>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_futex_wait(struct k_futex * futex, int expected, k_timeout_t timeout);
uintptr_t z_mrsh_k_futex_wait(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a001baa8:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a001baac:	910003fd 	mov	x29, sp
    a001bab0:	f90027e0 	str	x0, [sp, #72]
    a001bab4:	f90023e1 	str	x1, [sp, #64]
    a001bab8:	f9001fe2 	str	x2, [sp, #56]
    a001babc:	f9001be3 	str	x3, [sp, #48]
    a001bac0:	f90017e4 	str	x4, [sp, #40]
    a001bac4:	f90013e5 	str	x5, [sp, #32]
    a001bac8:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a001bacc:	90000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001bad0:	913f8000 	add	x0, x0, #0xfe0
    a001bad4:	f9400800 	ldr	x0, [x0, #16]
    a001bad8:	f9400fe1 	ldr	x1, [sp, #24]
    a001badc:	f9008401 	str	x1, [x0, #264]
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_futex_wait(*(struct k_futex **)&arg0, *(int*)&arg1, *(k_timeout_t*)&arg2)
    a001bae0:	910123e0 	add	x0, sp, #0x48
    a001bae4:	f9400003 	ldr	x3, [x0]
    a001bae8:	910103e0 	add	x0, sp, #0x40
    a001baec:	b9400001 	ldr	w1, [x0]
    a001baf0:	9100e3e0 	add	x0, sp, #0x38
    a001baf4:	f9400002 	ldr	x2, [x0]
    a001baf8:	aa0303e0 	mov	x0, x3
    a001bafc:	97ffffd0 	bl	a001ba3c <z_vrfy_k_futex_wait>
    a001bb00:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a001bb04:	90000160 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001bb08:	913f8000 	add	x0, x0, #0xfe0
    a001bb0c:	f9400800 	ldr	x0, [x0, #16]
    a001bb10:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a001bb14:	b9805fe0 	ldrsw	x0, [sp, #92]
}
    a001bb18:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a001bb1c:	d65f03c0 	ret

00000000a001bb20 <sys_dlist_init>:
{
    a001bb20:	d10043ff 	sub	sp, sp, #0x10
    a001bb24:	f90007e0 	str	x0, [sp, #8]
	list->head = (sys_dnode_t *)list;
    a001bb28:	f94007e0 	ldr	x0, [sp, #8]
    a001bb2c:	f94007e1 	ldr	x1, [sp, #8]
    a001bb30:	f9000001 	str	x1, [x0]
	list->tail = (sys_dnode_t *)list;
    a001bb34:	f94007e0 	ldr	x0, [sp, #8]
    a001bb38:	f94007e1 	ldr	x1, [sp, #8]
    a001bb3c:	f9000401 	str	x1, [x0, #8]
}
    a001bb40:	d503201f 	nop
    a001bb44:	910043ff 	add	sp, sp, #0x10
    a001bb48:	d65f03c0 	ret

00000000a001bb4c <sys_dnode_init>:
{
    a001bb4c:	d10043ff 	sub	sp, sp, #0x10
    a001bb50:	f90007e0 	str	x0, [sp, #8]
	node->next = NULL;
    a001bb54:	f94007e0 	ldr	x0, [sp, #8]
    a001bb58:	f900001f 	str	xzr, [x0]
	node->prev = NULL;
    a001bb5c:	f94007e0 	ldr	x0, [sp, #8]
    a001bb60:	f900041f 	str	xzr, [x0, #8]
}
    a001bb64:	d503201f 	nop
    a001bb68:	910043ff 	add	sp, sp, #0x10
    a001bb6c:	d65f03c0 	ret

00000000a001bb70 <sys_dlist_append>:
{
    a001bb70:	d10083ff 	sub	sp, sp, #0x20
    a001bb74:	f90007e0 	str	x0, [sp, #8]
    a001bb78:	f90003e1 	str	x1, [sp]
	sys_dnode_t *const tail = list->tail;
    a001bb7c:	f94007e0 	ldr	x0, [sp, #8]
    a001bb80:	f9400400 	ldr	x0, [x0, #8]
    a001bb84:	f9000fe0 	str	x0, [sp, #24]
	node->next = list;
    a001bb88:	f94003e0 	ldr	x0, [sp]
    a001bb8c:	f94007e1 	ldr	x1, [sp, #8]
    a001bb90:	f9000001 	str	x1, [x0]
	node->prev = tail;
    a001bb94:	f94003e0 	ldr	x0, [sp]
    a001bb98:	f9400fe1 	ldr	x1, [sp, #24]
    a001bb9c:	f9000401 	str	x1, [x0, #8]
	tail->next = node;
    a001bba0:	f9400fe0 	ldr	x0, [sp, #24]
    a001bba4:	f94003e1 	ldr	x1, [sp]
    a001bba8:	f9000001 	str	x1, [x0]
	list->tail = node;
    a001bbac:	f94007e0 	ldr	x0, [sp, #8]
    a001bbb0:	f94003e1 	ldr	x1, [sp]
    a001bbb4:	f9000401 	str	x1, [x0, #8]
}
    a001bbb8:	d503201f 	nop
    a001bbbc:	910083ff 	add	sp, sp, #0x20
    a001bbc0:	d65f03c0 	ret

00000000a001bbc4 <sys_dlist_remove>:
{
    a001bbc4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a001bbc8:	910003fd 	mov	x29, sp
    a001bbcc:	f9000fe0 	str	x0, [sp, #24]
	sys_dnode_t *const prev = node->prev;
    a001bbd0:	f9400fe0 	ldr	x0, [sp, #24]
    a001bbd4:	f9400400 	ldr	x0, [x0, #8]
    a001bbd8:	f90017e0 	str	x0, [sp, #40]
	sys_dnode_t *const next = node->next;
    a001bbdc:	f9400fe0 	ldr	x0, [sp, #24]
    a001bbe0:	f9400000 	ldr	x0, [x0]
    a001bbe4:	f90013e0 	str	x0, [sp, #32]
	prev->next = next;
    a001bbe8:	f94017e0 	ldr	x0, [sp, #40]
    a001bbec:	f94013e1 	ldr	x1, [sp, #32]
    a001bbf0:	f9000001 	str	x1, [x0]
	next->prev = prev;
    a001bbf4:	f94013e0 	ldr	x0, [sp, #32]
    a001bbf8:	f94017e1 	ldr	x1, [sp, #40]
    a001bbfc:	f9000401 	str	x1, [x0, #8]
	sys_dnode_init(node);
    a001bc00:	f9400fe0 	ldr	x0, [sp, #24]
    a001bc04:	97ffffd2 	bl	a001bb4c <sys_dnode_init>
}
    a001bc08:	d503201f 	nop
    a001bc0c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a001bc10:	d65f03c0 	ret

00000000a001bc14 <check_add_partition>:

struct k_mem_domain k_mem_domain_default;

static bool check_add_partition(struct k_mem_domain *domain,
				struct k_mem_partition *part)
{
    a001bc14:	d10e03ff 	sub	sp, sp, #0x380
    a001bc18:	f90007e0 	str	x0, [sp, #8]
    a001bc1c:	f90003e1 	str	x1, [sp]

	int i;
	uintptr_t pstart, pend, dstart, dend;

	if (part == NULL) {
    a001bc20:	f94003e0 	ldr	x0, [sp]
    a001bc24:	f100001f 	cmp	x0, #0x0
    a001bc28:	54000061 	b.ne	a001bc34 <check_add_partition+0x20>  // b.any
		LOG_ERR("NULL k_mem_partition provided");
		return false;
    a001bc2c:	52800000 	mov	w0, #0x0                   	// #0
    a001bc30:	14000040 	b	a001bd30 <check_add_partition+0x11c>
			part->start);
		return false;
	}
#endif

	if (part->size == 0U) {
    a001bc34:	f94003e0 	ldr	x0, [sp]
    a001bc38:	f9400400 	ldr	x0, [x0, #8]
    a001bc3c:	f100001f 	cmp	x0, #0x0
    a001bc40:	54000061 	b.ne	a001bc4c <check_add_partition+0x38>  // b.any
		LOG_ERR("zero sized partition at %p with base 0x%lx",
			part, part->start);
		return false;
    a001bc44:	52800000 	mov	w0, #0x0                   	// #0
    a001bc48:	1400003a 	b	a001bd30 <check_add_partition+0x11c>
	}

	pstart = part->start;
    a001bc4c:	f94003e0 	ldr	x0, [sp]
    a001bc50:	f9400000 	ldr	x0, [x0]
    a001bc54:	f901afe0 	str	x0, [sp, #856]
	pend = part->start + part->size;
    a001bc58:	f94003e0 	ldr	x0, [sp]
    a001bc5c:	f9400001 	ldr	x1, [x0]
    a001bc60:	f94003e0 	ldr	x0, [sp]
    a001bc64:	f9400400 	ldr	x0, [x0, #8]
    a001bc68:	8b000020 	add	x0, x1, x0
    a001bc6c:	f901abe0 	str	x0, [sp, #848]

	if (pend <= pstart) {
    a001bc70:	f941abe1 	ldr	x1, [sp, #848]
    a001bc74:	f941afe0 	ldr	x0, [sp, #856]
    a001bc78:	eb00003f 	cmp	x1, x0
    a001bc7c:	54000068 	b.hi	a001bc88 <check_add_partition+0x74>  // b.pmore
		LOG_ERR("invalid partition %p, wraparound detected. base 0x%lx size %zu",
			part, part->start, part->size);
		return false;
    a001bc80:	52800000 	mov	w0, #0x0                   	// #0
    a001bc84:	1400002b 	b	a001bd30 <check_add_partition+0x11c>
	}

	/* Check that this partition doesn't overlap any existing ones already
	 * in the domain
	 */
	for (i = 0; i < domain->num_partitions; i++) {
    a001bc88:	b9037fff 	str	wzr, [sp, #892]
    a001bc8c:	14000022 	b	a001bd14 <check_add_partition+0x100>
		struct k_mem_partition *dpart = &domain->partitions[i];
    a001bc90:	b9837fe1 	ldrsw	x1, [sp, #892]
    a001bc94:	d2800300 	mov	x0, #0x18                  	// #24
    a001bc98:	9b007c20 	mul	x0, x1, x0
    a001bc9c:	91004000 	add	x0, x0, #0x10
    a001bca0:	f94007e1 	ldr	x1, [sp, #8]
    a001bca4:	8b000020 	add	x0, x1, x0
    a001bca8:	f901bbe0 	str	x0, [sp, #880]

		if (dpart->size == 0U) {
    a001bcac:	f941bbe0 	ldr	x0, [sp, #880]
    a001bcb0:	f9400400 	ldr	x0, [x0, #8]
    a001bcb4:	f100001f 	cmp	x0, #0x0
    a001bcb8:	54000260 	b.eq	a001bd04 <check_add_partition+0xf0>  // b.none
			/* Unused slot */
			continue;
		}

		dstart = dpart->start;
    a001bcbc:	f941bbe0 	ldr	x0, [sp, #880]
    a001bcc0:	f9400000 	ldr	x0, [x0]
    a001bcc4:	f901b7e0 	str	x0, [sp, #872]
		dend = dstart + dpart->size;
    a001bcc8:	f941bbe0 	ldr	x0, [sp, #880]
    a001bccc:	f9400400 	ldr	x0, [x0, #8]
    a001bcd0:	f941b7e1 	ldr	x1, [sp, #872]
    a001bcd4:	8b000020 	add	x0, x1, x0
    a001bcd8:	f901b3e0 	str	x0, [sp, #864]

		if (pend > dstart && dend > pstart) {
    a001bcdc:	f941abe1 	ldr	x1, [sp, #848]
    a001bce0:	f941b7e0 	ldr	x0, [sp, #872]
    a001bce4:	eb00003f 	cmp	x1, x0
    a001bce8:	54000109 	b.ls	a001bd08 <check_add_partition+0xf4>  // b.plast
    a001bcec:	f941b3e1 	ldr	x1, [sp, #864]
    a001bcf0:	f941afe0 	ldr	x0, [sp, #856]
    a001bcf4:	eb00003f 	cmp	x1, x0
    a001bcf8:	54000089 	b.ls	a001bd08 <check_add_partition+0xf4>  // b.plast
			LOG_ERR("partition %p base %lx (size %zu) overlaps existing base %lx (size %zu)",
				part, part->start, part->size,
				dpart->start, dpart->size);
			return false;
    a001bcfc:	52800000 	mov	w0, #0x0                   	// #0
    a001bd00:	1400000c 	b	a001bd30 <check_add_partition+0x11c>
			continue;
    a001bd04:	d503201f 	nop
	for (i = 0; i < domain->num_partitions; i++) {
    a001bd08:	b9437fe0 	ldr	w0, [sp, #892]
    a001bd0c:	11000400 	add	w0, w0, #0x1
    a001bd10:	b9037fe0 	str	w0, [sp, #892]
    a001bd14:	f94007e0 	ldr	x0, [sp, #8]
    a001bd18:	39468000 	ldrb	w0, [x0, #416]
    a001bd1c:	2a0003e1 	mov	w1, w0
    a001bd20:	b9437fe0 	ldr	w0, [sp, #892]
    a001bd24:	6b01001f 	cmp	w0, w1
    a001bd28:	54fffb4b 	b.lt	a001bc90 <check_add_partition+0x7c>  // b.tstop
		}
	}

	return true;
    a001bd2c:	52800020 	mov	w0, #0x1                   	// #1
}
    a001bd30:	910e03ff 	add	sp, sp, #0x380
    a001bd34:	d65f03c0 	ret

00000000a001bd38 <k_mem_domain_init>:

int k_mem_domain_init(struct k_mem_domain *domain, uint8_t num_parts,
		      struct k_mem_partition *parts[])
{
    a001bd38:	d10d43ff 	sub	sp, sp, #0x350
    a001bd3c:	a9007bfd 	stp	x29, x30, [sp]
    a001bd40:	910003fd 	mov	x29, sp
    a001bd44:	f90017e0 	str	x0, [sp, #40]
    a001bd48:	39009fe1 	strb	w1, [sp, #39]
    a001bd4c:	f9000fe2 	str	x2, [sp, #24]
	k_spinlock_key_t key;
	int ret = 0;
    a001bd50:	b9032fff 	str	wzr, [sp, #812]

	CHECKIF(domain == NULL) {
    a001bd54:	f94017e0 	ldr	x0, [sp, #40]
    a001bd58:	f100001f 	cmp	x0, #0x0
    a001bd5c:	54000081 	b.ne	a001bd6c <k_mem_domain_init+0x34>  // b.any
		ret = -EINVAL;
    a001bd60:	128002a0 	mov	w0, #0xffffffea            	// #-22
    a001bd64:	b9032fe0 	str	w0, [sp, #812]
		goto out;
    a001bd68:	1400007e 	b	a001bf60 <k_mem_domain_init+0x228>
	}

	CHECKIF(!(num_parts == 0U || parts != NULL)) {
    a001bd6c:	39409fe0 	ldrb	w0, [sp, #39]
    a001bd70:	7100001f 	cmp	w0, #0x0
    a001bd74:	540000e0 	b.eq	a001bd90 <k_mem_domain_init+0x58>  // b.none
    a001bd78:	f9400fe0 	ldr	x0, [sp, #24]
    a001bd7c:	f100001f 	cmp	x0, #0x0
    a001bd80:	54000081 	b.ne	a001bd90 <k_mem_domain_init+0x58>  // b.any
		LOG_ERR("parts array is NULL and num_parts is nonzero");
		ret = -EINVAL;
    a001bd84:	128002a0 	mov	w0, #0xffffffea            	// #-22
    a001bd88:	b9032fe0 	str	w0, [sp, #812]
		goto out;
    a001bd8c:	14000075 	b	a001bf60 <k_mem_domain_init+0x228>
	}

	CHECKIF(!(num_parts <= max_partitions)) {
    a001bd90:	b00003a0 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a001bd94:	9111c400 	add	x0, x0, #0x471
    a001bd98:	39400000 	ldrb	w0, [x0]
    a001bd9c:	39409fe1 	ldrb	w1, [sp, #39]
    a001bda0:	6b00003f 	cmp	w1, w0
    a001bda4:	54000089 	b.ls	a001bdb4 <k_mem_domain_init+0x7c>  // b.plast
		LOG_ERR("num_parts of %d exceeds maximum allowable partitions (%d)",
			num_parts, max_partitions);
		ret = -EINVAL;
    a001bda8:	128002a0 	mov	w0, #0xffffffea            	// #-22
    a001bdac:	b9032fe0 	str	w0, [sp, #812]
		goto out;
    a001bdb0:	1400006c 	b	a001bf60 <k_mem_domain_init+0x228>
    a001bdb4:	b00003a0 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a001bdb8:	910ac000 	add	x0, x0, #0x2b0
    a001bdbc:	f90193e0 	str	x0, [sp, #800]
MAKE_REG_HELPER(daif)
    a001bdc0:	d53b4220 	mrs	x0, daif
    a001bdc4:	f9018fe0 	str	x0, [sp, #792]
    a001bdc8:	f9418fe0 	ldr	x0, [sp, #792]
    a001bdcc:	d503201f 	nop
	key = read_daif();
    a001bdd0:	b9033fe0 	str	w0, [sp, #828]
	__asm__ volatile ("msr DAIFSet, %0"
    a001bdd4:	d50342df 	msr	daifset, #0x2
}
    a001bdd8:	d503201f 	nop
	return key;
    a001bddc:	b9433fe0 	ldr	w0, [sp, #828]
	k.key = arch_irq_lock();
    a001bde0:	b902fbe0 	str	w0, [sp, #760]
	return k;
    a001bde4:	b942fbe0 	ldr	w0, [sp, #760]
    a001bde8:	b9030be0 	str	w0, [sp, #776]
	}

	key = k_spin_lock(&z_mem_domain_lock);

	domain->num_partitions = 0U;
    a001bdec:	f94017e0 	ldr	x0, [sp, #40]
    a001bdf0:	3906801f 	strb	wzr, [x0, #416]
	(void)memset(domain->partitions, 0, sizeof(domain->partitions));
    a001bdf4:	f94017e0 	ldr	x0, [sp, #40]
    a001bdf8:	91004000 	add	x0, x0, #0x10
    a001bdfc:	d2803002 	mov	x2, #0x180                 	// #384
    a001be00:	52800001 	mov	w1, #0x0                   	// #0
    a001be04:	97ffc03f 	bl	a000bf00 <memset>
	sys_dlist_init(&domain->mem_domain_q);
    a001be08:	f94017e0 	ldr	x0, [sp, #40]
    a001be0c:	91064000 	add	x0, x0, #0x190
    a001be10:	97ffff44 	bl	a001bb20 <sys_dlist_init>

#ifdef CONFIG_ARCH_MEM_DOMAIN_DATA
	ret = arch_mem_domain_init(domain);
    a001be14:	f94017e0 	ldr	x0, [sp, #40]
    a001be18:	97ffbd38 	bl	a000b2f8 <arch_mem_domain_init>
    a001be1c:	b9032fe0 	str	w0, [sp, #812]

	if (ret != 0) {
    a001be20:	b9432fe0 	ldr	w0, [sp, #812]
    a001be24:	7100001f 	cmp	w0, #0x0
    a001be28:	54000080 	b.eq	a001be38 <k_mem_domain_init+0x100>  // b.none
		LOG_ERR("architecture-specific initialization failed for domain %p with %d",
			domain, ret);
		ret = -ENOMEM;
    a001be2c:	12800160 	mov	w0, #0xfffffff4            	// #-12
    a001be30:	b9032fe0 	str	w0, [sp, #812]
		goto unlock_out;
    a001be34:	1400003d 	b	a001bf28 <k_mem_domain_init+0x1f0>
	}
#endif
	if (num_parts != 0U) {
    a001be38:	39409fe0 	ldrb	w0, [sp, #39]
    a001be3c:	7100001f 	cmp	w0, #0x0
    a001be40:	54000720 	b.eq	a001bf24 <k_mem_domain_init+0x1ec>  // b.none
		uint32_t i;

		for (i = 0U; i < num_parts; i++) {
    a001be44:	b90313ff 	str	wzr, [sp, #784]
    a001be48:	14000033 	b	a001bf14 <k_mem_domain_init+0x1dc>
			CHECKIF(!check_add_partition(domain, parts[i])) {
    a001be4c:	b94313e0 	ldr	w0, [sp, #784]
    a001be50:	d37df000 	lsl	x0, x0, #3
    a001be54:	f9400fe1 	ldr	x1, [sp, #24]
    a001be58:	8b000020 	add	x0, x1, x0
    a001be5c:	f9400000 	ldr	x0, [x0]
    a001be60:	aa0003e1 	mov	x1, x0
    a001be64:	f94017e0 	ldr	x0, [sp, #40]
    a001be68:	97ffff6b 	bl	a001bc14 <check_add_partition>
    a001be6c:	12001c00 	and	w0, w0, #0xff
    a001be70:	52000000 	eor	w0, w0, #0x1
    a001be74:	12001c00 	and	w0, w0, #0xff
    a001be78:	7100001f 	cmp	w0, #0x0
    a001be7c:	54000080 	b.eq	a001be8c <k_mem_domain_init+0x154>  // b.none
				LOG_ERR("invalid partition index %d (%p)",
					i, parts[i]);
				ret = -EINVAL;
    a001be80:	128002a0 	mov	w0, #0xffffffea            	// #-22
    a001be84:	b9032fe0 	str	w0, [sp, #812]
				goto unlock_out;
    a001be88:	14000028 	b	a001bf28 <k_mem_domain_init+0x1f0>
			}

			domain->partitions[i] = *parts[i];
    a001be8c:	b94313e0 	ldr	w0, [sp, #784]
    a001be90:	d37df000 	lsl	x0, x0, #3
    a001be94:	f9400fe1 	ldr	x1, [sp, #24]
    a001be98:	8b000020 	add	x0, x1, x0
    a001be9c:	f9400003 	ldr	x3, [x0]
    a001bea0:	f94017e1 	ldr	x1, [sp, #40]
    a001bea4:	b94313e2 	ldr	w2, [sp, #784]
    a001bea8:	d2800300 	mov	x0, #0x18                  	// #24
    a001beac:	9b007c40 	mul	x0, x2, x0
    a001beb0:	8b000020 	add	x0, x1, x0
    a001beb4:	91004000 	add	x0, x0, #0x10
    a001beb8:	aa0003e2 	mov	x2, x0
    a001bebc:	a9400460 	ldp	x0, x1, [x3]
    a001bec0:	a9000440 	stp	x0, x1, [x2]
    a001bec4:	f9400860 	ldr	x0, [x3, #16]
    a001bec8:	f9000840 	str	x0, [x2, #16]
			domain->num_partitions++;
    a001becc:	f94017e0 	ldr	x0, [sp, #40]
    a001bed0:	39468000 	ldrb	w0, [x0, #416]
    a001bed4:	11000400 	add	w0, w0, #0x1
    a001bed8:	12001c01 	and	w1, w0, #0xff
    a001bedc:	f94017e0 	ldr	x0, [sp, #40]
    a001bee0:	39068001 	strb	w1, [x0, #416]
#ifdef CONFIG_ARCH_MEM_DOMAIN_SYNCHRONOUS_API
			int ret2 = arch_mem_domain_partition_add(domain, i);
    a001bee4:	b94313e1 	ldr	w1, [sp, #784]
    a001bee8:	f94017e0 	ldr	x0, [sp, #40]
    a001beec:	97ffbd73 	bl	a000b4b8 <arch_mem_domain_partition_add>
    a001bef0:	b90317e0 	str	w0, [sp, #788]

			ARG_UNUSED(ret2);
			CHECKIF(ret2 != 0) {
    a001bef4:	b94317e0 	ldr	w0, [sp, #788]
    a001bef8:	7100001f 	cmp	w0, #0x0
    a001befc:	54000060 	b.eq	a001bf08 <k_mem_domain_init+0x1d0>  // b.none
				ret = ret2;
    a001bf00:	b94317e0 	ldr	w0, [sp, #788]
    a001bf04:	b9032fe0 	str	w0, [sp, #812]
		for (i = 0U; i < num_parts; i++) {
    a001bf08:	b94313e0 	ldr	w0, [sp, #784]
    a001bf0c:	11000400 	add	w0, w0, #0x1
    a001bf10:	b90313e0 	str	w0, [sp, #784]
    a001bf14:	39409fe0 	ldrb	w0, [sp, #39]
    a001bf18:	b94313e1 	ldr	w1, [sp, #784]
    a001bf1c:	6b00003f 	cmp	w1, w0
    a001bf20:	54fff963 	b.cc	a001be4c <k_mem_domain_init+0x114>  // b.lo, b.ul, b.last
			}
#endif
		}
	}

unlock_out:
    a001bf24:	d503201f 	nop
    a001bf28:	b00003a0 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a001bf2c:	910ac000 	add	x0, x0, #0x2b0
    a001bf30:	f9019be0 	str	x0, [sp, #816]
    a001bf34:	b9430be0 	ldr	w0, [sp, #776]
    a001bf38:	b90303e0 	str	w0, [sp, #768]
	arch_irq_unlock(key.key);
    a001bf3c:	b94303e0 	ldr	w0, [sp, #768]
    a001bf40:	b9034fe0 	str	w0, [sp, #844]
	write_daif(key);
    a001bf44:	b9434fe0 	ldr	w0, [sp, #844]
    a001bf48:	f901a3e0 	str	x0, [sp, #832]
MAKE_REG_HELPER(daif)
    a001bf4c:	f941a3e0 	ldr	x0, [sp, #832]
    a001bf50:	d51b4220 	msr	daif, x0
    a001bf54:	d503201f 	nop
}
    a001bf58:	d503201f 	nop
}
    a001bf5c:	d503201f 	nop
	k_spin_unlock(&z_mem_domain_lock, key);

out:
	return ret;
    a001bf60:	b9432fe0 	ldr	w0, [sp, #812]
}
    a001bf64:	a9407bfd 	ldp	x29, x30, [sp]
    a001bf68:	910d43ff 	add	sp, sp, #0x350
    a001bf6c:	d65f03c0 	ret

00000000a001bf70 <add_thread_locked>:
	return ret;
}

static int add_thread_locked(struct k_mem_domain *domain,
			     k_tid_t thread)
{
    a001bf70:	a9a57bfd 	stp	x29, x30, [sp, #-432]!
    a001bf74:	910003fd 	mov	x29, sp
    a001bf78:	f9000fe0 	str	x0, [sp, #24]
    a001bf7c:	f9000be1 	str	x1, [sp, #16]
	int ret = 0;
    a001bf80:	b901afff 	str	wzr, [sp, #428]

	__ASSERT_NO_MSG(domain != NULL);
	__ASSERT_NO_MSG(thread != NULL);

	LOG_DBG("add thread %p to domain %p\n", thread, domain);
	sys_dlist_append(&domain->mem_domain_q,
    a001bf84:	f9400fe0 	ldr	x0, [sp, #24]
    a001bf88:	91064002 	add	x2, x0, #0x190
    a001bf8c:	f9400be0 	ldr	x0, [sp, #16]
    a001bf90:	9103a000 	add	x0, x0, #0xe8
    a001bf94:	aa0003e1 	mov	x1, x0
    a001bf98:	aa0203e0 	mov	x0, x2
    a001bf9c:	97fffef5 	bl	a001bb70 <sys_dlist_append>
			 &thread->mem_domain_info.mem_domain_q_node);
	thread->mem_domain_info.mem_domain = domain;
    a001bfa0:	f9400be0 	ldr	x0, [sp, #16]
    a001bfa4:	f9400fe1 	ldr	x1, [sp, #24]
    a001bfa8:	f9007c01 	str	x1, [x0, #248]

#ifdef CONFIG_ARCH_MEM_DOMAIN_SYNCHRONOUS_API
	ret = arch_mem_domain_thread_add(thread);
    a001bfac:	f9400be0 	ldr	x0, [sp, #16]
    a001bfb0:	97ffbd76 	bl	a000b588 <arch_mem_domain_thread_add>
    a001bfb4:	b901afe0 	str	w0, [sp, #428]
#endif

	return ret;
    a001bfb8:	b941afe0 	ldr	w0, [sp, #428]
}
    a001bfbc:	a8db7bfd 	ldp	x29, x30, [sp], #432
    a001bfc0:	d65f03c0 	ret

00000000a001bfc4 <remove_thread_locked>:

static int remove_thread_locked(struct k_thread *thread)
{
    a001bfc4:	a9a57bfd 	stp	x29, x30, [sp, #-432]!
    a001bfc8:	910003fd 	mov	x29, sp
    a001bfcc:	f9000fe0 	str	x0, [sp, #24]
	int ret = 0;
    a001bfd0:	b901afff 	str	wzr, [sp, #428]

	__ASSERT_NO_MSG(thread != NULL);
	LOG_DBG("remove thread %p from memory domain %p\n",
		thread, thread->mem_domain_info.mem_domain);
	sys_dlist_remove(&thread->mem_domain_info.mem_domain_q_node);
    a001bfd4:	f9400fe0 	ldr	x0, [sp, #24]
    a001bfd8:	9103a000 	add	x0, x0, #0xe8
    a001bfdc:	97fffefa 	bl	a001bbc4 <sys_dlist_remove>

#ifdef CONFIG_ARCH_MEM_DOMAIN_SYNCHRONOUS_API
	ret = arch_mem_domain_thread_remove(thread);
    a001bfe0:	f9400fe0 	ldr	x0, [sp, #24]
    a001bfe4:	97ffbdb3 	bl	a000b6b0 <arch_mem_domain_thread_remove>
    a001bfe8:	b901afe0 	str	w0, [sp, #428]
#endif

	return ret;
    a001bfec:	b941afe0 	ldr	w0, [sp, #428]
}
    a001bff0:	a8db7bfd 	ldp	x29, x30, [sp], #432
    a001bff4:	d65f03c0 	ret

00000000a001bff8 <z_mem_domain_init_thread>:

/* Called from thread object initialization */
void z_mem_domain_init_thread(struct k_thread *thread)
{
    a001bff8:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    a001bffc:	910003fd 	mov	x29, sp
    a001c000:	f9000fe0 	str	x0, [sp, #24]
    a001c004:	900003a0 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a001c008:	910ac000 	add	x0, x0, #0x2b0
    a001c00c:	f90027e0 	str	x0, [sp, #72]
    a001c010:	d53b4220 	mrs	x0, daif
    a001c014:	f90023e0 	str	x0, [sp, #64]
    a001c018:	f94023e0 	ldr	x0, [sp, #64]
    a001c01c:	d503201f 	nop
	key = read_daif();
    a001c020:	b9003fe0 	str	w0, [sp, #60]
	__asm__ volatile ("msr DAIFSet, %0"
    a001c024:	d50342df 	msr	daifset, #0x2
}
    a001c028:	d503201f 	nop
	return key;
    a001c02c:	b9403fe0 	ldr	w0, [sp, #60]
	k.key = arch_irq_lock();
    a001c030:	b90033e0 	str	w0, [sp, #48]
	return k;
    a001c034:	b94033e0 	ldr	w0, [sp, #48]
    a001c038:	b9003be0 	str	w0, [sp, #56]
	int ret;
	k_spinlock_key_t key = k_spin_lock(&z_mem_domain_lock);

	/* New threads inherit memory domain configuration from parent */
	ret = add_thread_locked(_current->mem_domain_info.mem_domain, thread);
    a001c03c:	f0000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001c040:	913f8000 	add	x0, x0, #0xfe0
    a001c044:	f9400800 	ldr	x0, [x0, #16]
    a001c048:	f9407c00 	ldr	x0, [x0, #248]
    a001c04c:	f9400fe1 	ldr	x1, [sp, #24]
    a001c050:	97ffffc8 	bl	a001bf70 <add_thread_locked>
    a001c054:	b9006fe0 	str	w0, [sp, #108]
    a001c058:	900003a0 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a001c05c:	910ac000 	add	x0, x0, #0x2b0
    a001c060:	f90033e0 	str	x0, [sp, #96]
    a001c064:	b9403be0 	ldr	w0, [sp, #56]
    a001c068:	b9002be0 	str	w0, [sp, #40]
	arch_irq_unlock(key.key);
    a001c06c:	b9402be0 	ldr	w0, [sp, #40]
    a001c070:	b9005fe0 	str	w0, [sp, #92]
	write_daif(key);
    a001c074:	b9405fe0 	ldr	w0, [sp, #92]
    a001c078:	f9002be0 	str	x0, [sp, #80]
MAKE_REG_HELPER(daif)
    a001c07c:	f9402be0 	ldr	x0, [sp, #80]
    a001c080:	d51b4220 	msr	daif, x0
    a001c084:	d503201f 	nop
}
    a001c088:	d503201f 	nop
}
    a001c08c:	d503201f 	nop
	__ASSERT_NO_MSG(ret == 0);
	ARG_UNUSED(ret);

	k_spin_unlock(&z_mem_domain_lock, key);
}
    a001c090:	d503201f 	nop
    a001c094:	a8c77bfd 	ldp	x29, x30, [sp], #112
    a001c098:	d65f03c0 	ret

00000000a001c09c <z_mem_domain_exit_thread>:

/* Called when thread aborts during teardown tasks. sched_spinlock is held */
void z_mem_domain_exit_thread(struct k_thread *thread)
{
    a001c09c:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    a001c0a0:	910003fd 	mov	x29, sp
    a001c0a4:	f9000fe0 	str	x0, [sp, #24]
    a001c0a8:	900003a0 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a001c0ac:	910ac000 	add	x0, x0, #0x2b0
    a001c0b0:	f90027e0 	str	x0, [sp, #72]
    a001c0b4:	d53b4220 	mrs	x0, daif
    a001c0b8:	f90023e0 	str	x0, [sp, #64]
    a001c0bc:	f94023e0 	ldr	x0, [sp, #64]
    a001c0c0:	d503201f 	nop
	key = read_daif();
    a001c0c4:	b9003fe0 	str	w0, [sp, #60]
	__asm__ volatile ("msr DAIFSet, %0"
    a001c0c8:	d50342df 	msr	daifset, #0x2
}
    a001c0cc:	d503201f 	nop
	return key;
    a001c0d0:	b9403fe0 	ldr	w0, [sp, #60]
	k.key = arch_irq_lock();
    a001c0d4:	b90033e0 	str	w0, [sp, #48]
	return k;
    a001c0d8:	b94033e0 	ldr	w0, [sp, #48]
    a001c0dc:	b9003be0 	str	w0, [sp, #56]
	int ret;

	k_spinlock_key_t key = k_spin_lock(&z_mem_domain_lock);

	ret = remove_thread_locked(thread);
    a001c0e0:	f9400fe0 	ldr	x0, [sp, #24]
    a001c0e4:	97ffffb8 	bl	a001bfc4 <remove_thread_locked>
    a001c0e8:	b9006fe0 	str	w0, [sp, #108]
    a001c0ec:	900003a0 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a001c0f0:	910ac000 	add	x0, x0, #0x2b0
    a001c0f4:	f90033e0 	str	x0, [sp, #96]
    a001c0f8:	b9403be0 	ldr	w0, [sp, #56]
    a001c0fc:	b9002be0 	str	w0, [sp, #40]
	arch_irq_unlock(key.key);
    a001c100:	b9402be0 	ldr	w0, [sp, #40]
    a001c104:	b9005fe0 	str	w0, [sp, #92]
	write_daif(key);
    a001c108:	b9405fe0 	ldr	w0, [sp, #92]
    a001c10c:	f9002be0 	str	x0, [sp, #80]
MAKE_REG_HELPER(daif)
    a001c110:	f9402be0 	ldr	x0, [sp, #80]
    a001c114:	d51b4220 	msr	daif, x0
    a001c118:	d503201f 	nop
}
    a001c11c:	d503201f 	nop
}
    a001c120:	d503201f 	nop
	__ASSERT_NO_MSG(ret == 0);
	ARG_UNUSED(ret);

	k_spin_unlock(&z_mem_domain_lock, key);
}
    a001c124:	d503201f 	nop
    a001c128:	a8c77bfd 	ldp	x29, x30, [sp], #112
    a001c12c:	d65f03c0 	ret

00000000a001c130 <init_mem_domain_module>:

	return ret;
}

static int init_mem_domain_module(const struct device *arg)
{
    a001c130:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a001c134:	910003fd 	mov	x29, sp
    a001c138:	f9000fe0 	str	x0, [sp, #24]
	int ret;

	ARG_UNUSED(arg);
	ARG_UNUSED(ret);

	max_partitions = arch_mem_domain_max_partitions_get();
    a001c13c:	97ffbc6d 	bl	a000b2f0 <arch_mem_domain_max_partitions_get>
    a001c140:	12001c01 	and	w1, w0, #0xff
    a001c144:	900003a0 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a001c148:	9111c400 	add	x0, x0, #0x471
    a001c14c:	39000001 	strb	w1, [x0]
	 * CONFIG_MAX_DOMAIN_PARTITIONS, or would encounter array index
	 * out of bounds error.
	 */
	__ASSERT(max_partitions <= CONFIG_MAX_DOMAIN_PARTITIONS, "");

	ret = k_mem_domain_init(&k_mem_domain_default, 0, NULL);
    a001c150:	d2800002 	mov	x2, #0x0                   	// #0
    a001c154:	52800001 	mov	w1, #0x0                   	// #0
    a001c158:	900003a0 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a001c15c:	910ac000 	add	x0, x0, #0x2b0
    a001c160:	97fffef6 	bl	a001bd38 <k_mem_domain_init>
    a001c164:	b9002fe0 	str	w0, [sp, #44]
	ret = k_mem_domain_add_partition(&k_mem_domain_default,
					 &z_libc_partition);
	__ASSERT(ret == 0, "failed to add default libc mem partition");
#endif /* Z_LIBC_PARTITION_EXISTS */

	return 0;
    a001c168:	52800000 	mov	w0, #0x0                   	// #0
}
    a001c16c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a001c170:	d65f03c0 	ret

00000000a001c174 <sys_dnode_init>:
{
    a001c174:	d10043ff 	sub	sp, sp, #0x10
    a001c178:	f90007e0 	str	x0, [sp, #8]
	node->next = NULL;
    a001c17c:	f94007e0 	ldr	x0, [sp, #8]
    a001c180:	f900001f 	str	xzr, [x0]
	node->prev = NULL;
    a001c184:	f94007e0 	ldr	x0, [sp, #8]
    a001c188:	f900041f 	str	xzr, [x0, #8]
}
    a001c18c:	d503201f 	nop
    a001c190:	910043ff 	add	sp, sp, #0x10
    a001c194:	d65f03c0 	ret

00000000a001c198 <sys_dlist_is_empty>:
{
    a001c198:	d10043ff 	sub	sp, sp, #0x10
    a001c19c:	f90007e0 	str	x0, [sp, #8]
	return list->head == list;
    a001c1a0:	f94007e0 	ldr	x0, [sp, #8]
    a001c1a4:	f9400000 	ldr	x0, [x0]
    a001c1a8:	f94007e1 	ldr	x1, [sp, #8]
    a001c1ac:	eb00003f 	cmp	x1, x0
    a001c1b0:	1a9f17e0 	cset	w0, eq  // eq = none
    a001c1b4:	12001c00 	and	w0, w0, #0xff
}
    a001c1b8:	910043ff 	add	sp, sp, #0x10
    a001c1bc:	d65f03c0 	ret

00000000a001c1c0 <sys_dlist_peek_head>:
{
    a001c1c0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a001c1c4:	910003fd 	mov	x29, sp
    a001c1c8:	f9000fe0 	str	x0, [sp, #24]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    a001c1cc:	f9400fe0 	ldr	x0, [sp, #24]
    a001c1d0:	97fffff2 	bl	a001c198 <sys_dlist_is_empty>
    a001c1d4:	12001c00 	and	w0, w0, #0xff
    a001c1d8:	7100001f 	cmp	w0, #0x0
    a001c1dc:	54000081 	b.ne	a001c1ec <sys_dlist_peek_head+0x2c>  // b.any
    a001c1e0:	f9400fe0 	ldr	x0, [sp, #24]
    a001c1e4:	f9400000 	ldr	x0, [x0]
    a001c1e8:	14000002 	b	a001c1f0 <sys_dlist_peek_head+0x30>
    a001c1ec:	d2800000 	mov	x0, #0x0                   	// #0
}
    a001c1f0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a001c1f4:	d65f03c0 	ret

00000000a001c1f8 <sys_dlist_peek_next_no_check>:
{
    a001c1f8:	d10043ff 	sub	sp, sp, #0x10
    a001c1fc:	f90007e0 	str	x0, [sp, #8]
    a001c200:	f90003e1 	str	x1, [sp]
	return (node == list->tail) ? NULL : node->next;
    a001c204:	f94007e0 	ldr	x0, [sp, #8]
    a001c208:	f9400400 	ldr	x0, [x0, #8]
    a001c20c:	f94003e1 	ldr	x1, [sp]
    a001c210:	eb00003f 	cmp	x1, x0
    a001c214:	54000080 	b.eq	a001c224 <sys_dlist_peek_next_no_check+0x2c>  // b.none
    a001c218:	f94003e0 	ldr	x0, [sp]
    a001c21c:	f9400000 	ldr	x0, [x0]
    a001c220:	14000002 	b	a001c228 <sys_dlist_peek_next_no_check+0x30>
    a001c224:	d2800000 	mov	x0, #0x0                   	// #0
}
    a001c228:	910043ff 	add	sp, sp, #0x10
    a001c22c:	d65f03c0 	ret

00000000a001c230 <sys_dlist_peek_next>:
{
    a001c230:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a001c234:	910003fd 	mov	x29, sp
    a001c238:	f9000fe0 	str	x0, [sp, #24]
    a001c23c:	f9000be1 	str	x1, [sp, #16]
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    a001c240:	f9400be0 	ldr	x0, [sp, #16]
    a001c244:	f100001f 	cmp	x0, #0x0
    a001c248:	540000a0 	b.eq	a001c25c <sys_dlist_peek_next+0x2c>  // b.none
    a001c24c:	f9400be1 	ldr	x1, [sp, #16]
    a001c250:	f9400fe0 	ldr	x0, [sp, #24]
    a001c254:	97ffffe9 	bl	a001c1f8 <sys_dlist_peek_next_no_check>
    a001c258:	14000002 	b	a001c260 <sys_dlist_peek_next+0x30>
    a001c25c:	d2800000 	mov	x0, #0x0                   	// #0
}
    a001c260:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a001c264:	d65f03c0 	ret

00000000a001c268 <sys_dlist_append>:
{
    a001c268:	d10083ff 	sub	sp, sp, #0x20
    a001c26c:	f90007e0 	str	x0, [sp, #8]
    a001c270:	f90003e1 	str	x1, [sp]
	sys_dnode_t *const tail = list->tail;
    a001c274:	f94007e0 	ldr	x0, [sp, #8]
    a001c278:	f9400400 	ldr	x0, [x0, #8]
    a001c27c:	f9000fe0 	str	x0, [sp, #24]
	node->next = list;
    a001c280:	f94003e0 	ldr	x0, [sp]
    a001c284:	f94007e1 	ldr	x1, [sp, #8]
    a001c288:	f9000001 	str	x1, [x0]
	node->prev = tail;
    a001c28c:	f94003e0 	ldr	x0, [sp]
    a001c290:	f9400fe1 	ldr	x1, [sp, #24]
    a001c294:	f9000401 	str	x1, [x0, #8]
	tail->next = node;
    a001c298:	f9400fe0 	ldr	x0, [sp, #24]
    a001c29c:	f94003e1 	ldr	x1, [sp]
    a001c2a0:	f9000001 	str	x1, [x0]
	list->tail = node;
    a001c2a4:	f94007e0 	ldr	x0, [sp, #8]
    a001c2a8:	f94003e1 	ldr	x1, [sp]
    a001c2ac:	f9000401 	str	x1, [x0, #8]
}
    a001c2b0:	d503201f 	nop
    a001c2b4:	910083ff 	add	sp, sp, #0x20
    a001c2b8:	d65f03c0 	ret

00000000a001c2bc <sys_dlist_remove>:
{
    a001c2bc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a001c2c0:	910003fd 	mov	x29, sp
    a001c2c4:	f9000fe0 	str	x0, [sp, #24]
	sys_dnode_t *const prev = node->prev;
    a001c2c8:	f9400fe0 	ldr	x0, [sp, #24]
    a001c2cc:	f9400400 	ldr	x0, [x0, #8]
    a001c2d0:	f90017e0 	str	x0, [sp, #40]
	sys_dnode_t *const next = node->next;
    a001c2d4:	f9400fe0 	ldr	x0, [sp, #24]
    a001c2d8:	f9400000 	ldr	x0, [x0]
    a001c2dc:	f90013e0 	str	x0, [sp, #32]
	prev->next = next;
    a001c2e0:	f94017e0 	ldr	x0, [sp, #40]
    a001c2e4:	f94013e1 	ldr	x1, [sp, #32]
    a001c2e8:	f9000001 	str	x1, [x0]
	next->prev = prev;
    a001c2ec:	f94013e0 	ldr	x0, [sp, #32]
    a001c2f0:	f94017e1 	ldr	x1, [sp, #40]
    a001c2f4:	f9000401 	str	x1, [x0, #8]
	sys_dnode_init(node);
    a001c2f8:	f9400fe0 	ldr	x0, [sp, #24]
    a001c2fc:	97ffff9e 	bl	a001c174 <sys_dnode_init>
}
    a001c300:	d503201f 	nop
    a001c304:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a001c308:	d65f03c0 	ret

00000000a001c30c <size_add_overflow>:
{
    a001c30c:	d10083ff 	sub	sp, sp, #0x20
    a001c310:	f9000fe0 	str	x0, [sp, #24]
    a001c314:	f9000be1 	str	x1, [sp, #16]
    a001c318:	f90007e2 	str	x2, [sp, #8]
	return __builtin_add_overflow(a, b, result);
    a001c31c:	d2800002 	mov	x2, #0x0                   	// #0
    a001c320:	f9400fe0 	ldr	x0, [sp, #24]
    a001c324:	f9400be1 	ldr	x1, [sp, #16]
    a001c328:	ab010000 	adds	x0, x0, x1
    a001c32c:	54000043 	b.cc	a001c334 <size_add_overflow+0x28>  // b.lo, b.ul, b.last
    a001c330:	d2800022 	mov	x2, #0x1                   	// #1
    a001c334:	aa0003e1 	mov	x1, x0
    a001c338:	f94007e0 	ldr	x0, [sp, #8]
    a001c33c:	f9000001 	str	x1, [x0]
    a001c340:	aa0203e0 	mov	x0, x2
    a001c344:	12000000 	and	w0, w0, #0x1
    a001c348:	12001c00 	and	w0, w0, #0xff
}
    a001c34c:	910083ff 	add	sp, sp, #0x20
    a001c350:	d65f03c0 	ret

00000000a001c354 <z_user_string_nlen>:
{
    a001c354:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a001c358:	910003fd 	mov	x29, sp
    a001c35c:	f90017e0 	str	x0, [sp, #40]
    a001c360:	f90013e1 	str	x1, [sp, #32]
    a001c364:	f9000fe2 	str	x2, [sp, #24]
	return arch_user_string_nlen(src, maxlen, err);
    a001c368:	f9400fe2 	ldr	x2, [sp, #24]
    a001c36c:	f94013e1 	ldr	x1, [sp, #32]
    a001c370:	f94017e0 	ldr	x0, [sp, #40]
    a001c374:	97ffbd31 	bl	a000b838 <arch_user_string_nlen>
}
    a001c378:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a001c37c:	d65f03c0 	ret

00000000a001c380 <obj_size_get>:
 * TODO: Write some hash table code that will replace both obj_rb_tree
 * and obj_list.
 */

static size_t obj_size_get(enum k_objects otype)
{
    a001c380:	d10083ff 	sub	sp, sp, #0x20
    a001c384:	b9000fe0 	str	w0, [sp, #12]
	size_t ret;

	switch (otype) {
    a001c388:	b9400fe0 	ldr	w0, [sp, #12]
    a001c38c:	7100401f 	cmp	w0, #0x10
    a001c390:	54000b20 	b.eq	a001c4f4 <obj_size_get+0x174>  // b.none
    a001c394:	b9400fe0 	ldr	w0, [sp, #12]
    a001c398:	7100401f 	cmp	w0, #0x10
    a001c39c:	54000b28 	b.hi	a001c500 <obj_size_get+0x180>  // b.pmore
    a001c3a0:	b9400fe0 	ldr	w0, [sp, #12]
    a001c3a4:	7100281f 	cmp	w0, #0xa
    a001c3a8:	54000a00 	b.eq	a001c4e8 <obj_size_get+0x168>  // b.none
    a001c3ac:	b9400fe0 	ldr	w0, [sp, #12]
    a001c3b0:	7100281f 	cmp	w0, #0xa
    a001c3b4:	54000a68 	b.hi	a001c500 <obj_size_get+0x180>  // b.pmore
    a001c3b8:	b9400fe0 	ldr	w0, [sp, #12]
    a001c3bc:	7100241f 	cmp	w0, #0x9
    a001c3c0:	540008e0 	b.eq	a001c4dc <obj_size_get+0x15c>  // b.none
    a001c3c4:	b9400fe0 	ldr	w0, [sp, #12]
    a001c3c8:	7100241f 	cmp	w0, #0x9
    a001c3cc:	540009a8 	b.hi	a001c500 <obj_size_get+0x180>  // b.pmore
    a001c3d0:	b9400fe0 	ldr	w0, [sp, #12]
    a001c3d4:	7100201f 	cmp	w0, #0x8
    a001c3d8:	540007c0 	b.eq	a001c4d0 <obj_size_get+0x150>  // b.none
    a001c3dc:	b9400fe0 	ldr	w0, [sp, #12]
    a001c3e0:	7100201f 	cmp	w0, #0x8
    a001c3e4:	540008e8 	b.hi	a001c500 <obj_size_get+0x180>  // b.pmore
    a001c3e8:	b9400fe0 	ldr	w0, [sp, #12]
    a001c3ec:	71001c1f 	cmp	w0, #0x7
    a001c3f0:	540006a0 	b.eq	a001c4c4 <obj_size_get+0x144>  // b.none
    a001c3f4:	b9400fe0 	ldr	w0, [sp, #12]
    a001c3f8:	71001c1f 	cmp	w0, #0x7
    a001c3fc:	54000828 	b.hi	a001c500 <obj_size_get+0x180>  // b.pmore
    a001c400:	b9400fe0 	ldr	w0, [sp, #12]
    a001c404:	7100181f 	cmp	w0, #0x6
    a001c408:	54000580 	b.eq	a001c4b8 <obj_size_get+0x138>  // b.none
    a001c40c:	b9400fe0 	ldr	w0, [sp, #12]
    a001c410:	7100181f 	cmp	w0, #0x6
    a001c414:	54000768 	b.hi	a001c500 <obj_size_get+0x180>  // b.pmore
    a001c418:	b9400fe0 	ldr	w0, [sp, #12]
    a001c41c:	7100141f 	cmp	w0, #0x5
    a001c420:	54000460 	b.eq	a001c4ac <obj_size_get+0x12c>  // b.none
    a001c424:	b9400fe0 	ldr	w0, [sp, #12]
    a001c428:	7100141f 	cmp	w0, #0x5
    a001c42c:	540006a8 	b.hi	a001c500 <obj_size_get+0x180>  // b.pmore
    a001c430:	b9400fe0 	ldr	w0, [sp, #12]
    a001c434:	7100101f 	cmp	w0, #0x4
    a001c438:	54000340 	b.eq	a001c4a0 <obj_size_get+0x120>  // b.none
    a001c43c:	b9400fe0 	ldr	w0, [sp, #12]
    a001c440:	7100101f 	cmp	w0, #0x4
    a001c444:	540005e8 	b.hi	a001c500 <obj_size_get+0x180>  // b.pmore
    a001c448:	b9400fe0 	ldr	w0, [sp, #12]
    a001c44c:	71000c1f 	cmp	w0, #0x3
    a001c450:	54000220 	b.eq	a001c494 <obj_size_get+0x114>  // b.none
    a001c454:	b9400fe0 	ldr	w0, [sp, #12]
    a001c458:	71000c1f 	cmp	w0, #0x3
    a001c45c:	54000528 	b.hi	a001c500 <obj_size_get+0x180>  // b.pmore
    a001c460:	b9400fe0 	ldr	w0, [sp, #12]
    a001c464:	7100041f 	cmp	w0, #0x1
    a001c468:	540000a0 	b.eq	a001c47c <obj_size_get+0xfc>  // b.none
    a001c46c:	b9400fe0 	ldr	w0, [sp, #12]
    a001c470:	7100081f 	cmp	w0, #0x2
    a001c474:	540000a0 	b.eq	a001c488 <obj_size_get+0x108>  // b.none
    a001c478:	14000022 	b	a001c500 <obj_size_get+0x180>
/* Non device/stack objects */
case K_OBJ_MEM_SLAB: ret = sizeof(struct k_mem_slab); break;
    a001c47c:	d2800700 	mov	x0, #0x38                  	// #56
    a001c480:	f9000fe0 	str	x0, [sp, #24]
    a001c484:	14000022 	b	a001c50c <obj_size_get+0x18c>
case K_OBJ_MSGQ: ret = sizeof(struct k_msgq); break;
    a001c488:	d2800900 	mov	x0, #0x48                  	// #72
    a001c48c:	f9000fe0 	str	x0, [sp, #24]
    a001c490:	1400001f 	b	a001c50c <obj_size_get+0x18c>
case K_OBJ_MUTEX: ret = sizeof(struct k_mutex); break;
    a001c494:	d2800400 	mov	x0, #0x20                  	// #32
    a001c498:	f9000fe0 	str	x0, [sp, #24]
    a001c49c:	1400001c 	b	a001c50c <obj_size_get+0x18c>
case K_OBJ_PIPE: ret = sizeof(struct k_pipe); break;
    a001c4a0:	d2800a00 	mov	x0, #0x50                  	// #80
    a001c4a4:	f9000fe0 	str	x0, [sp, #24]
    a001c4a8:	14000019 	b	a001c50c <obj_size_get+0x18c>
case K_OBJ_QUEUE: ret = sizeof(struct k_queue); break;
    a001c4ac:	d2800400 	mov	x0, #0x20                  	// #32
    a001c4b0:	f9000fe0 	str	x0, [sp, #24]
    a001c4b4:	14000016 	b	a001c50c <obj_size_get+0x18c>
case K_OBJ_POLL_SIGNAL: ret = sizeof(struct k_poll_signal); break;
    a001c4b8:	d2800300 	mov	x0, #0x18                  	// #24
    a001c4bc:	f9000fe0 	str	x0, [sp, #24]
    a001c4c0:	14000013 	b	a001c50c <obj_size_get+0x18c>
case K_OBJ_SEM: ret = sizeof(struct k_sem); break;
    a001c4c4:	d2800300 	mov	x0, #0x18                  	// #24
    a001c4c8:	f9000fe0 	str	x0, [sp, #24]
    a001c4cc:	14000010 	b	a001c50c <obj_size_get+0x18c>
case K_OBJ_STACK: ret = sizeof(struct k_stack); break;
    a001c4d0:	d2800600 	mov	x0, #0x30                  	// #48
    a001c4d4:	f9000fe0 	str	x0, [sp, #24]
    a001c4d8:	1400000d 	b	a001c50c <obj_size_get+0x18c>
case K_OBJ_THREAD: ret = sizeof(struct k_thread); break;
    a001c4dc:	d2802700 	mov	x0, #0x138                 	// #312
    a001c4e0:	f9000fe0 	str	x0, [sp, #24]
    a001c4e4:	1400000a 	b	a001c50c <obj_size_get+0x18c>
case K_OBJ_TIMER: ret = sizeof(struct k_timer); break;
    a001c4e8:	d2800b00 	mov	x0, #0x58                  	// #88
    a001c4ec:	f9000fe0 	str	x0, [sp, #24]
    a001c4f0:	14000007 	b	a001c50c <obj_size_get+0x18c>
case K_OBJ_CONDVAR: ret = sizeof(struct k_condvar); break;
    a001c4f4:	d2800200 	mov	x0, #0x10                  	// #16
    a001c4f8:	f9000fe0 	str	x0, [sp, #24]
    a001c4fc:	14000004 	b	a001c50c <obj_size_get+0x18c>
#include <otype-to-size.h>
	default:
		ret = sizeof(const struct device);
    a001c500:	d2800600 	mov	x0, #0x30                  	// #48
    a001c504:	f9000fe0 	str	x0, [sp, #24]
		break;
    a001c508:	d503201f 	nop
	}

	return ret;
    a001c50c:	f9400fe0 	ldr	x0, [sp, #24]
}
    a001c510:	910083ff 	add	sp, sp, #0x20
    a001c514:	d65f03c0 	ret

00000000a001c518 <obj_align_get>:

static size_t obj_align_get(enum k_objects otype)
{
    a001c518:	d10083ff 	sub	sp, sp, #0x20
    a001c51c:	b9000fe0 	str	w0, [sp, #12]
	size_t ret;

	switch (otype) {
    a001c520:	b9400fe0 	ldr	w0, [sp, #12]
    a001c524:	7100241f 	cmp	w0, #0x9
    a001c528:	54000081 	b.ne	a001c538 <obj_align_get+0x20>  // b.any
	case K_OBJ_THREAD:
#ifdef ARCH_DYNAMIC_OBJ_K_THREAD_ALIGNMENT
		ret = ARCH_DYNAMIC_OBJ_K_THREAD_ALIGNMENT;
#else
		ret = __alignof(struct dyn_obj);
    a001c52c:	d2800100 	mov	x0, #0x8                   	// #8
    a001c530:	f9000fe0 	str	x0, [sp, #24]
#endif
		break;
    a001c534:	14000004 	b	a001c544 <obj_align_get+0x2c>
	default:
		ret = __alignof(struct dyn_obj);
    a001c538:	d2800100 	mov	x0, #0x8                   	// #8
    a001c53c:	f9000fe0 	str	x0, [sp, #24]
		break;
    a001c540:	d503201f 	nop
	}

	return ret;
    a001c544:	f9400fe0 	ldr	x0, [sp, #24]
}
    a001c548:	910083ff 	add	sp, sp, #0x20
    a001c54c:	d65f03c0 	ret

00000000a001c550 <node_lessthan>:

static bool node_lessthan(struct rbnode *a, struct rbnode *b)
{
    a001c550:	d10043ff 	sub	sp, sp, #0x10
    a001c554:	f90007e0 	str	x0, [sp, #8]
    a001c558:	f90003e1 	str	x1, [sp]
	return a < b;
    a001c55c:	f94007e1 	ldr	x1, [sp, #8]
    a001c560:	f94003e0 	ldr	x0, [sp]
    a001c564:	eb00003f 	cmp	x1, x0
    a001c568:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
    a001c56c:	12001c00 	and	w0, w0, #0xff
}
    a001c570:	910043ff 	add	sp, sp, #0x10
    a001c574:	d65f03c0 	ret

00000000a001c578 <node_to_dyn_obj>:

static inline struct dyn_obj *node_to_dyn_obj(struct rbnode *node)
{
    a001c578:	d10043ff 	sub	sp, sp, #0x10
    a001c57c:	f90007e0 	str	x0, [sp, #8]
	return CONTAINER_OF(node, struct dyn_obj, node);
    a001c580:	f94007e0 	ldr	x0, [sp, #8]
    a001c584:	d100a000 	sub	x0, x0, #0x28
}
    a001c588:	910043ff 	add	sp, sp, #0x10
    a001c58c:	d65f03c0 	ret

00000000a001c590 <dyn_obj_to_node>:

static inline struct rbnode *dyn_obj_to_node(void *obj)
{
    a001c590:	d10083ff 	sub	sp, sp, #0x20
    a001c594:	f90007e0 	str	x0, [sp, #8]
	struct dyn_obj *dobj = CONTAINER_OF(obj, struct dyn_obj, data);
    a001c598:	f94007e0 	ldr	x0, [sp, #8]
    a001c59c:	d100e000 	sub	x0, x0, #0x38
    a001c5a0:	f9000fe0 	str	x0, [sp, #24]

	return &dobj->node;
    a001c5a4:	f9400fe0 	ldr	x0, [sp, #24]
    a001c5a8:	9100a000 	add	x0, x0, #0x28
}
    a001c5ac:	910083ff 	add	sp, sp, #0x20
    a001c5b0:	d65f03c0 	ret

00000000a001c5b4 <dyn_object_find>:

static struct dyn_obj *dyn_object_find(void *obj)
{
    a001c5b4:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
    a001c5b8:	910003fd 	mov	x29, sp
    a001c5bc:	f9000fe0 	str	x0, [sp, #24]
	/* For any dynamically allocated kernel object, the object
	 * pointer is just a member of the containing struct dyn_obj,
	 * so just a little arithmetic is necessary to locate the
	 * corresponding struct rbnode
	 */
	node = dyn_obj_to_node(obj);
    a001c5c0:	f9400fe0 	ldr	x0, [sp, #24]
    a001c5c4:	97fffff3 	bl	a001c590 <dyn_obj_to_node>
    a001c5c8:	f9003be0 	str	x0, [sp, #112]
    a001c5cc:	900003a0 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a001c5d0:	91116000 	add	x0, x0, #0x458
    a001c5d4:	f90037e0 	str	x0, [sp, #104]
    a001c5d8:	d53b4220 	mrs	x0, daif
    a001c5dc:	f90033e0 	str	x0, [sp, #96]
    a001c5e0:	f94033e0 	ldr	x0, [sp, #96]
    a001c5e4:	d503201f 	nop
	key = read_daif();
    a001c5e8:	b9005fe0 	str	w0, [sp, #92]
	__asm__ volatile ("msr DAIFSet, %0"
    a001c5ec:	d50342df 	msr	daifset, #0x2
}
    a001c5f0:	d503201f 	nop
	return key;
    a001c5f4:	b9405fe0 	ldr	w0, [sp, #92]
	k.key = arch_irq_lock();
    a001c5f8:	b9002be0 	str	w0, [sp, #40]
	return k;
    a001c5fc:	b9402be0 	ldr	w0, [sp, #40]
    a001c600:	b9003be0 	str	w0, [sp, #56]

	k_spinlock_key_t key = k_spin_lock(&lists_lock);
	if (rb_contains(&obj_rb_tree, node)) {
    a001c604:	f9403be1 	ldr	x1, [sp, #112]
    a001c608:	f00003e0 	adrp	x0, a009b000 <twom1000.10>
    a001c60c:	91020000 	add	x0, x0, #0x80
    a001c610:	97ffa153 	bl	a0004b5c <rb_contains>
    a001c614:	12001c00 	and	w0, w0, #0xff
    a001c618:	7100001f 	cmp	w0, #0x0
    a001c61c:	540000a0 	b.eq	a001c630 <dyn_object_find+0x7c>  // b.none
		ret = node_to_dyn_obj(node);
    a001c620:	f9403be0 	ldr	x0, [sp, #112]
    a001c624:	97ffffd5 	bl	a001c578 <node_to_dyn_obj>
    a001c628:	f9003fe0 	str	x0, [sp, #120]
    a001c62c:	14000002 	b	a001c634 <dyn_object_find+0x80>
	} else {
		ret = NULL;
    a001c630:	f9003fff 	str	xzr, [sp, #120]
    a001c634:	900003a0 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a001c638:	91116000 	add	x0, x0, #0x458
    a001c63c:	f9002be0 	str	x0, [sp, #80]
    a001c640:	b9403be0 	ldr	w0, [sp, #56]
    a001c644:	b90033e0 	str	w0, [sp, #48]
	arch_irq_unlock(key.key);
    a001c648:	b94033e0 	ldr	w0, [sp, #48]
    a001c64c:	b9004fe0 	str	w0, [sp, #76]
	write_daif(key);
    a001c650:	b9404fe0 	ldr	w0, [sp, #76]
    a001c654:	f90023e0 	str	x0, [sp, #64]
MAKE_REG_HELPER(daif)
    a001c658:	f94023e0 	ldr	x0, [sp, #64]
    a001c65c:	d51b4220 	msr	daif, x0
    a001c660:	d503201f 	nop
}
    a001c664:	d503201f 	nop
}
    a001c668:	d503201f 	nop
	}
	k_spin_unlock(&lists_lock, key);

	return ret;
    a001c66c:	f9403fe0 	ldr	x0, [sp, #120]
}
    a001c670:	a8c87bfd 	ldp	x29, x30, [sp], #128
    a001c674:	d65f03c0 	ret

00000000a001c678 <thread_idx_alloc>:
 * @param tidx The new thread index if successful
 *
 * @return true if successful, false if failed
 **/
static bool thread_idx_alloc(uintptr_t *tidx)
{
    a001c678:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a001c67c:	910003fd 	mov	x29, sp
    a001c680:	f9000fe0 	str	x0, [sp, #24]
	int i;
	int idx;
	int base;

	base = 0;
    a001c684:	b9004bff 	str	wzr, [sp, #72]
	for (i = 0; i < CONFIG_MAX_THREAD_BYTES; i++) {
    a001c688:	b9004fff 	str	wzr, [sp, #76]
    a001c68c:	14000042 	b	a001c794 <thread_idx_alloc+0x11c>
		idx = find_lsb_set(_thread_idx_map[i]);
    a001c690:	f00003e0 	adrp	x0, a009b000 <twom1000.10>
    a001c694:	91041001 	add	x1, x0, #0x104
    a001c698:	b9804fe0 	ldrsw	x0, [sp, #76]
    a001c69c:	38606820 	ldrb	w0, [x1, x0]
    a001c6a0:	b90043e0 	str	w0, [sp, #64]
 */

static ALWAYS_INLINE unsigned int find_lsb_set(uint32_t op)
{
#ifdef CONFIG_TOOLCHAIN_HAS_BUILTIN_FFS
	return __builtin_ffs(op);
    a001c6a4:	b94043e0 	ldr	w0, [sp, #64]
    a001c6a8:	7100001f 	cmp	w0, #0x0
    a001c6ac:	5ac00000 	rbit	w0, w0
    a001c6b0:	5ac01000 	clz	w0, w0
    a001c6b4:	1a8007e0 	csinc	w0, wzr, w0, eq  // eq = none
    a001c6b8:	b90047e0 	str	w0, [sp, #68]

		if (idx != 0) {
    a001c6bc:	b94047e0 	ldr	w0, [sp, #68]
    a001c6c0:	7100001f 	cmp	w0, #0x0
    a001c6c4:	540005c0 	b.eq	a001c77c <thread_idx_alloc+0x104>  // b.none
			*tidx = base + (idx - 1);
    a001c6c8:	b94047e0 	ldr	w0, [sp, #68]
    a001c6cc:	51000401 	sub	w1, w0, #0x1
    a001c6d0:	b9404be0 	ldr	w0, [sp, #72]
    a001c6d4:	0b000020 	add	w0, w1, w0
    a001c6d8:	93407c01 	sxtw	x1, w0
    a001c6dc:	f9400fe0 	ldr	x0, [sp, #24]
    a001c6e0:	f9000001 	str	x1, [x0]

			sys_bitfield_clear_bit((mem_addr_t)_thread_idx_map,
    a001c6e4:	f00003e0 	adrp	x0, a009b000 <twom1000.10>
    a001c6e8:	91041000 	add	x0, x0, #0x104
					       *tidx);
    a001c6ec:	f9400fe1 	ldr	x1, [sp, #24]
    a001c6f0:	f9400021 	ldr	x1, [x1]
    a001c6f4:	f9001fe0 	str	x0, [sp, #56]
    a001c6f8:	b90037e1 	str	w1, [sp, #52]
}

static ALWAYS_INLINE
	void sys_bitfield_clear_bit(mem_addr_t addr, unsigned int bit)
{
	sys_clear_bit(addr + ((bit >> 5) << 2), bit & 0x1F);
    a001c6fc:	b94037e0 	ldr	w0, [sp, #52]
    a001c700:	53057c00 	lsr	w0, w0, #5
    a001c704:	531e7400 	lsl	w0, w0, #2
    a001c708:	2a0003e1 	mov	w1, w0
    a001c70c:	f9401fe0 	ldr	x0, [sp, #56]
    a001c710:	8b000021 	add	x1, x1, x0
    a001c714:	b94037e0 	ldr	w0, [sp, #52]
    a001c718:	12001000 	and	w0, w0, #0x1f
    a001c71c:	f90017e1 	str	x1, [sp, #40]
    a001c720:	b90027e0 	str	w0, [sp, #36]
	uint32_t temp = *(volatile uint32_t *)addr;
    a001c724:	f94017e0 	ldr	x0, [sp, #40]
    a001c728:	b9400000 	ldr	w0, [x0]
    a001c72c:	b90023e0 	str	w0, [sp, #32]
	*(volatile uint32_t *)addr = temp & ~(1 << bit);
    a001c730:	b94027e0 	ldr	w0, [sp, #36]
    a001c734:	52800021 	mov	w1, #0x1                   	// #1
    a001c738:	1ac02020 	lsl	w0, w1, w0
    a001c73c:	2a2003e0 	mvn	w0, w0
    a001c740:	2a0003e2 	mov	w2, w0
    a001c744:	f94017e0 	ldr	x0, [sp, #40]
    a001c748:	b94023e1 	ldr	w1, [sp, #32]
    a001c74c:	0a010041 	and	w1, w2, w1
    a001c750:	b9000001 	str	w1, [x0]
}
    a001c754:	d503201f 	nop
}
    a001c758:	d503201f 	nop

			/* Clear permission from all objects */
			z_object_wordlist_foreach(clear_perms_cb,
						   (void *)*tidx);
    a001c75c:	f9400fe0 	ldr	x0, [sp, #24]
    a001c760:	f9400000 	ldr	x0, [x0]
			z_object_wordlist_foreach(clear_perms_cb,
    a001c764:	aa0003e1 	mov	x1, x0
    a001c768:	b0000000 	adrp	x0, a001d000 <z_thread_perms_set+0x1c>
    a001c76c:	91052000 	add	x0, x0, #0x148
    a001c770:	940000c2 	bl	a001ca78 <z_object_wordlist_foreach>

			return true;
    a001c774:	52800020 	mov	w0, #0x1                   	// #1
    a001c778:	1400000b 	b	a001c7a4 <thread_idx_alloc+0x12c>
		}

		base += 8;
    a001c77c:	b9404be0 	ldr	w0, [sp, #72]
    a001c780:	11002000 	add	w0, w0, #0x8
    a001c784:	b9004be0 	str	w0, [sp, #72]
	for (i = 0; i < CONFIG_MAX_THREAD_BYTES; i++) {
    a001c788:	b9404fe0 	ldr	w0, [sp, #76]
    a001c78c:	11000400 	add	w0, w0, #0x1
    a001c790:	b9004fe0 	str	w0, [sp, #76]
    a001c794:	b9404fe0 	ldr	w0, [sp, #76]
    a001c798:	7100041f 	cmp	w0, #0x1
    a001c79c:	54fff7ad 	b.le	a001c690 <thread_idx_alloc+0x18>
	}

	return false;
    a001c7a0:	52800000 	mov	w0, #0x0                   	// #0
}
    a001c7a4:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a001c7a8:	d65f03c0 	ret

00000000a001c7ac <z_dynamic_object_aligned_create>:

	sys_bitfield_set_bit((mem_addr_t)_thread_idx_map, tidx);
}

struct z_object *z_dynamic_object_aligned_create(size_t align, size_t size)
{
    a001c7ac:	a9a57bfd 	stp	x29, x30, [sp, #-432]!
    a001c7b0:	910003fd 	mov	x29, sp
    a001c7b4:	f9000fe0 	str	x0, [sp, #24]
    a001c7b8:	f9000be1 	str	x1, [sp, #16]
	struct dyn_obj *dyn;

	dyn = z_thread_aligned_alloc(align, sizeof(*dyn) + size);
    a001c7bc:	f9400be0 	ldr	x0, [sp, #16]
    a001c7c0:	9100e000 	add	x0, x0, #0x38
    a001c7c4:	aa0003e1 	mov	x1, x0
    a001c7c8:	f9400fe0 	ldr	x0, [sp, #24]
    a001c7cc:	97fffbc6 	bl	a001b6e4 <z_thread_aligned_alloc>
    a001c7d0:	f900bfe0 	str	x0, [sp, #376]
	if (dyn == NULL) {
    a001c7d4:	f940bfe0 	ldr	x0, [sp, #376]
    a001c7d8:	f100001f 	cmp	x0, #0x0
    a001c7dc:	54000061 	b.ne	a001c7e8 <z_dynamic_object_aligned_create+0x3c>  // b.any
		LOG_ERR("could not allocate kernel object, out of memory");
		return NULL;
    a001c7e0:	d2800000 	mov	x0, #0x0                   	// #0
    a001c7e4:	14000037 	b	a001c8c0 <z_dynamic_object_aligned_create+0x114>
	}

	dyn->kobj.name = &dyn->data;
    a001c7e8:	f940bfe0 	ldr	x0, [sp, #376]
    a001c7ec:	9100e001 	add	x1, x0, #0x38
    a001c7f0:	f940bfe0 	ldr	x0, [sp, #376]
    a001c7f4:	f9000001 	str	x1, [x0]
	dyn->kobj.type = K_OBJ_ANY;
    a001c7f8:	f940bfe0 	ldr	x0, [sp, #376]
    a001c7fc:	3900281f 	strb	wzr, [x0, #10]
	dyn->kobj.flags = 0;
    a001c800:	f940bfe0 	ldr	x0, [sp, #376]
    a001c804:	39002c1f 	strb	wzr, [x0, #11]
	(void)memset(dyn->kobj.perms, 0, CONFIG_MAX_THREAD_BYTES);
    a001c808:	f940bfe0 	ldr	x0, [sp, #376]
    a001c80c:	91002000 	add	x0, x0, #0x8
    a001c810:	d2800042 	mov	x2, #0x2                   	// #2
    a001c814:	52800001 	mov	w1, #0x0                   	// #0
    a001c818:	97ffbdba 	bl	a000bf00 <memset>
    a001c81c:	900003a0 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a001c820:	91116000 	add	x0, x0, #0x458
    a001c824:	f900cfe0 	str	x0, [sp, #408]
    a001c828:	d53b4220 	mrs	x0, daif
    a001c82c:	f900cbe0 	str	x0, [sp, #400]
    a001c830:	f940cbe0 	ldr	x0, [sp, #400]
    a001c834:	d503201f 	nop
	key = read_daif();
    a001c838:	b901afe0 	str	w0, [sp, #428]
	__asm__ volatile ("msr DAIFSet, %0"
    a001c83c:	d50342df 	msr	daifset, #0x2
}
    a001c840:	d503201f 	nop
	return key;
    a001c844:	b941afe0 	ldr	w0, [sp, #428]
	k.key = arch_irq_lock();
    a001c848:	b9016be0 	str	w0, [sp, #360]
	return k;
    a001c84c:	b9416be0 	ldr	w0, [sp, #360]
    a001c850:	b90173e0 	str	w0, [sp, #368]

	k_spinlock_key_t key = k_spin_lock(&lists_lock);

	rb_insert(&obj_rb_tree, &dyn->node);
    a001c854:	f940bfe0 	ldr	x0, [sp, #376]
    a001c858:	9100a000 	add	x0, x0, #0x28
    a001c85c:	aa0003e1 	mov	x1, x0
    a001c860:	f00003e0 	adrp	x0, a009b000 <twom1000.10>
    a001c864:	91020000 	add	x0, x0, #0x80
    a001c868:	97ff9e28 	bl	a0004108 <rb_insert>
	sys_dlist_append(&obj_list, &dyn->dobj_list);
    a001c86c:	f940bfe0 	ldr	x0, [sp, #376]
    a001c870:	91006000 	add	x0, x0, #0x18
    a001c874:	aa0003e1 	mov	x1, x0
    a001c878:	f00003e0 	adrp	x0, a009b000 <twom1000.10>
    a001c87c:	91026000 	add	x0, x0, #0x98
    a001c880:	97fffe7a 	bl	a001c268 <sys_dlist_append>
    a001c884:	900003a0 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a001c888:	91116000 	add	x0, x0, #0x458
    a001c88c:	f900c3e0 	str	x0, [sp, #384]
    a001c890:	b94173e0 	ldr	w0, [sp, #368]
    a001c894:	b90163e0 	str	w0, [sp, #352]
	arch_irq_unlock(key.key);
    a001c898:	b94163e0 	ldr	w0, [sp, #352]
    a001c89c:	b9018fe0 	str	w0, [sp, #396]
	write_daif(key);
    a001c8a0:	b9418fe0 	ldr	w0, [sp, #396]
    a001c8a4:	f900d3e0 	str	x0, [sp, #416]
MAKE_REG_HELPER(daif)
    a001c8a8:	f940d3e0 	ldr	x0, [sp, #416]
    a001c8ac:	d51b4220 	msr	daif, x0
    a001c8b0:	d503201f 	nop
}
    a001c8b4:	d503201f 	nop
}
    a001c8b8:	d503201f 	nop
	k_spin_unlock(&lists_lock, key);

	return &dyn->kobj;
    a001c8bc:	f940bfe0 	ldr	x0, [sp, #376]
}
    a001c8c0:	a8db7bfd 	ldp	x29, x30, [sp], #432
    a001c8c4:	d65f03c0 	ret

00000000a001c8c8 <z_impl_k_object_alloc>:

void *z_impl_k_object_alloc(enum k_objects otype)
{
    a001c8c8:	d10903ff 	sub	sp, sp, #0x240
    a001c8cc:	a9007bfd 	stp	x29, x30, [sp]
    a001c8d0:	910003fd 	mov	x29, sp
    a001c8d4:	f9000bf3 	str	x19, [sp, #16]
    a001c8d8:	b9002fe0 	str	w0, [sp, #44]
	struct z_object *zo;
	uintptr_t tidx = 0;
    a001c8dc:	f9011bff 	str	xzr, [sp, #560]

	if (otype <= K_OBJ_ANY || otype >= K_OBJ_LAST) {
    a001c8e0:	b9402fe0 	ldr	w0, [sp, #44]
    a001c8e4:	7100001f 	cmp	w0, #0x0
    a001c8e8:	54000080 	b.eq	a001c8f8 <z_impl_k_object_alloc+0x30>  // b.none
    a001c8ec:	b9402fe0 	ldr	w0, [sp, #44]
    a001c8f0:	7100d81f 	cmp	w0, #0x36
    a001c8f4:	54000069 	b.ls	a001c900 <z_impl_k_object_alloc+0x38>  // b.plast
		LOG_ERR("bad object type %d requested", otype);
		return NULL;
    a001c8f8:	d2800000 	mov	x0, #0x0                   	// #0
    a001c8fc:	14000047 	b	a001ca18 <z_impl_k_object_alloc+0x150>
	}

	switch (otype) {
    a001c900:	b9402fe0 	ldr	w0, [sp, #44]
    a001c904:	71003c1f 	cmp	w0, #0xf
    a001c908:	54000348 	b.hi	a001c970 <z_impl_k_object_alloc+0xa8>  // b.pmore
    a001c90c:	b9402fe0 	ldr	w0, [sp, #44]
    a001c910:	7100381f 	cmp	w0, #0xe
    a001c914:	540002a2 	b.cs	a001c968 <z_impl_k_object_alloc+0xa0>  // b.hs, b.nlast
    a001c918:	b9402fe0 	ldr	w0, [sp, #44]
    a001c91c:	7100241f 	cmp	w0, #0x9
    a001c920:	54000120 	b.eq	a001c944 <z_impl_k_object_alloc+0x7c>  // b.none
    a001c924:	b9402fe0 	ldr	w0, [sp, #44]
    a001c928:	7100241f 	cmp	w0, #0x9
    a001c92c:	54000223 	b.cc	a001c970 <z_impl_k_object_alloc+0xa8>  // b.lo, b.ul, b.last
    a001c930:	b9402fe0 	ldr	w0, [sp, #44]
    a001c934:	51002c00 	sub	w0, w0, #0xb
    a001c938:	7100041f 	cmp	w0, #0x1
    a001c93c:	540001a8 	b.hi	a001c970 <z_impl_k_object_alloc+0xa8>  // b.pmore
    a001c940:	1400000a 	b	a001c968 <z_impl_k_object_alloc+0xa0>
	case K_OBJ_THREAD:
		if (!thread_idx_alloc(&tidx)) {
    a001c944:	9108c3e0 	add	x0, sp, #0x230
    a001c948:	97ffff4c 	bl	a001c678 <thread_idx_alloc>
    a001c94c:	12001c00 	and	w0, w0, #0xff
    a001c950:	52000000 	eor	w0, w0, #0x1
    a001c954:	12001c00 	and	w0, w0, #0xff
    a001c958:	7100001f 	cmp	w0, #0x0
    a001c95c:	540000e0 	b.eq	a001c978 <z_impl_k_object_alloc+0xb0>  // b.none
			LOG_ERR("out of free thread indexes");
			return NULL;
    a001c960:	d2800000 	mov	x0, #0x0                   	// #0
    a001c964:	1400002d 	b	a001ca18 <z_impl_k_object_alloc+0x150>
	case K_OBJ_SYS_MUTEX:			/* Lives in user memory */
	case K_OBJ_THREAD_STACK_ELEMENT:	/* No aligned allocator */
	case K_OBJ_NET_SOCKET:			/* Indeterminate size */
		LOG_ERR("forbidden object type '%s' requested",
			otype_to_str(otype));
		return NULL;
    a001c968:	d2800000 	mov	x0, #0x0                   	// #0
    a001c96c:	1400002b 	b	a001ca18 <z_impl_k_object_alloc+0x150>
	default:
		/* Remainder within bounds are permitted */
		break;
    a001c970:	d503201f 	nop
    a001c974:	14000002 	b	a001c97c <z_impl_k_object_alloc+0xb4>
		break;
    a001c978:	d503201f 	nop
	}

	zo = z_dynamic_object_aligned_create(obj_align_get(otype),
    a001c97c:	b9402fe0 	ldr	w0, [sp, #44]
    a001c980:	97fffee6 	bl	a001c518 <obj_align_get>
    a001c984:	aa0003f3 	mov	x19, x0
    a001c988:	b9402fe0 	ldr	w0, [sp, #44]
    a001c98c:	97fffe7d 	bl	a001c380 <obj_size_get>
    a001c990:	aa0003e1 	mov	x1, x0
    a001c994:	aa1303e0 	mov	x0, x19
    a001c998:	97ffff85 	bl	a001c7ac <z_dynamic_object_aligned_create>
    a001c99c:	f9011fe0 	str	x0, [sp, #568]
					     obj_size_get(otype));
	if (zo == NULL) {
    a001c9a0:	f9411fe0 	ldr	x0, [sp, #568]
    a001c9a4:	f100001f 	cmp	x0, #0x0
    a001c9a8:	54000061 	b.ne	a001c9b4 <z_impl_k_object_alloc+0xec>  // b.any
		return NULL;
    a001c9ac:	d2800000 	mov	x0, #0x0                   	// #0
    a001c9b0:	1400001a 	b	a001ca18 <z_impl_k_object_alloc+0x150>
	}
	zo->type = otype;
    a001c9b4:	b9402fe0 	ldr	w0, [sp, #44]
    a001c9b8:	12001c01 	and	w1, w0, #0xff
    a001c9bc:	f9411fe0 	ldr	x0, [sp, #568]
    a001c9c0:	39002801 	strb	w1, [x0, #10]

	if (otype == K_OBJ_THREAD) {
    a001c9c4:	b9402fe0 	ldr	w0, [sp, #44]
    a001c9c8:	7100241f 	cmp	w0, #0x9
    a001c9cc:	540000a1 	b.ne	a001c9e0 <z_impl_k_object_alloc+0x118>  // b.any
		zo->data.thread_id = tidx;
    a001c9d0:	f9411be0 	ldr	x0, [sp, #560]
    a001c9d4:	2a0003e1 	mov	w1, w0
    a001c9d8:	f9411fe0 	ldr	x0, [sp, #568]
    a001c9dc:	b9000c01 	str	w1, [x0, #12]
	}

	/* The allocating thread implicitly gets permission on kernel objects
	 * that it allocates
	 */
	z_thread_perms_set(zo, _current);
    a001c9e0:	f0000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001c9e4:	913f8000 	add	x0, x0, #0xfe0
    a001c9e8:	f9400800 	ldr	x0, [x0, #16]
    a001c9ec:	aa0003e1 	mov	x1, x0
    a001c9f0:	f9411fe0 	ldr	x0, [sp, #568]
    a001c9f4:	9400017c 	bl	a001cfe4 <z_thread_perms_set>

	/* Activates reference counting logic for automatic disposal when
	 * all permissions have been revoked
	 */
	zo->flags |= K_OBJ_FLAG_ALLOC;
    a001c9f8:	f9411fe0 	ldr	x0, [sp, #568]
    a001c9fc:	39402c00 	ldrb	w0, [x0, #11]
    a001ca00:	321e0000 	orr	w0, w0, #0x4
    a001ca04:	12001c01 	and	w1, w0, #0xff
    a001ca08:	f9411fe0 	ldr	x0, [sp, #568]
    a001ca0c:	39002c01 	strb	w1, [x0, #11]

	return zo->name;
    a001ca10:	f9411fe0 	ldr	x0, [sp, #568]
    a001ca14:	f9400000 	ldr	x0, [x0]
}
    a001ca18:	f9400bf3 	ldr	x19, [sp, #16]
    a001ca1c:	a9407bfd 	ldp	x29, x30, [sp]
    a001ca20:	910903ff 	add	sp, sp, #0x240
    a001ca24:	d65f03c0 	ret

00000000a001ca28 <z_object_find>:
		k_free(dyn);
	}
}

struct z_object *z_object_find(const void *obj)
{
    a001ca28:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a001ca2c:	910003fd 	mov	x29, sp
    a001ca30:	f9000fe0 	str	x0, [sp, #24]
	struct z_object *ret;

	ret = z_object_gperf_find(obj);
    a001ca34:	f9400fe0 	ldr	x0, [sp, #24]
    a001ca38:	940012dd 	bl	a00215ac <z_object_gperf_find>
    a001ca3c:	f90017e0 	str	x0, [sp, #40]

	if (ret == NULL) {
    a001ca40:	f94017e0 	ldr	x0, [sp, #40]
    a001ca44:	f100001f 	cmp	x0, #0x0
    a001ca48:	54000121 	b.ne	a001ca6c <z_object_find+0x44>  // b.any

		/* The cast to pointer-to-non-const violates MISRA
		 * 11.8 but is justified since we know dynamic objects
		 * were not declared with a const qualifier.
		 */
		dynamic_obj = dyn_object_find((void *)obj);
    a001ca4c:	f9400fe0 	ldr	x0, [sp, #24]
    a001ca50:	97fffed9 	bl	a001c5b4 <dyn_object_find>
    a001ca54:	f90013e0 	str	x0, [sp, #32]
		if (dynamic_obj != NULL) {
    a001ca58:	f94013e0 	ldr	x0, [sp, #32]
    a001ca5c:	f100001f 	cmp	x0, #0x0
    a001ca60:	54000060 	b.eq	a001ca6c <z_object_find+0x44>  // b.none
			ret = &dynamic_obj->kobj;
    a001ca64:	f94013e0 	ldr	x0, [sp, #32]
    a001ca68:	f90017e0 	str	x0, [sp, #40]
		}
	}

	return ret;
    a001ca6c:	f94017e0 	ldr	x0, [sp, #40]
}
    a001ca70:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a001ca74:	d65f03c0 	ret

00000000a001ca78 <z_object_wordlist_foreach>:

void z_object_wordlist_foreach(_wordlist_cb_func_t func, void *context)
{
    a001ca78:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
    a001ca7c:	910003fd 	mov	x29, sp
    a001ca80:	f9000fe0 	str	x0, [sp, #24]
    a001ca84:	f9000be1 	str	x1, [sp, #16]
	struct dyn_obj *obj, *next;

	z_object_gperf_wordlist_foreach(func, context);
    a001ca88:	f9400be1 	ldr	x1, [sp, #16]
    a001ca8c:	f9400fe0 	ldr	x0, [sp, #24]
    a001ca90:	940012da 	bl	a00215f8 <z_object_gperf_wordlist_foreach>
    a001ca94:	900003a0 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a001ca98:	91116000 	add	x0, x0, #0x458
    a001ca9c:	f90037e0 	str	x0, [sp, #104]
    a001caa0:	d53b4220 	mrs	x0, daif
    a001caa4:	f90033e0 	str	x0, [sp, #96]
    a001caa8:	f94033e0 	ldr	x0, [sp, #96]
    a001caac:	d503201f 	nop
	key = read_daif();
    a001cab0:	b9005fe0 	str	w0, [sp, #92]
	__asm__ volatile ("msr DAIFSet, %0"
    a001cab4:	d50342df 	msr	daifset, #0x2
}
    a001cab8:	d503201f 	nop
	return key;
    a001cabc:	b9405fe0 	ldr	w0, [sp, #92]
	k.key = arch_irq_lock();
    a001cac0:	b9002be0 	str	w0, [sp, #40]
	return k;
    a001cac4:	b9402be0 	ldr	w0, [sp, #40]
    a001cac8:	b9003be0 	str	w0, [sp, #56]

	k_spinlock_key_t key = k_spin_lock(&lists_lock);

	SYS_DLIST_FOR_EACH_CONTAINER_SAFE(&obj_list, obj, next, dobj_list) {
    a001cacc:	f00003e0 	adrp	x0, a009b000 <twom1000.10>
    a001cad0:	91026000 	add	x0, x0, #0x98
    a001cad4:	97fffdbb 	bl	a001c1c0 <sys_dlist_peek_head>
    a001cad8:	f100001f 	cmp	x0, #0x0
    a001cadc:	540000c0 	b.eq	a001caf4 <z_object_wordlist_foreach+0x7c>  // b.none
    a001cae0:	f00003e0 	adrp	x0, a009b000 <twom1000.10>
    a001cae4:	91026000 	add	x0, x0, #0x98
    a001cae8:	97fffdb6 	bl	a001c1c0 <sys_dlist_peek_head>
    a001caec:	d1006000 	sub	x0, x0, #0x18
    a001caf0:	14000002 	b	a001caf8 <z_object_wordlist_foreach+0x80>
    a001caf4:	d2800000 	mov	x0, #0x0                   	// #0
    a001caf8:	f9003fe0 	str	x0, [sp, #120]
    a001cafc:	f9403fe0 	ldr	x0, [sp, #120]
    a001cb00:	f100001f 	cmp	x0, #0x0
    a001cb04:	54000260 	b.eq	a001cb50 <z_object_wordlist_foreach+0xd8>  // b.none
    a001cb08:	f9403fe0 	ldr	x0, [sp, #120]
    a001cb0c:	91006000 	add	x0, x0, #0x18
    a001cb10:	aa0003e1 	mov	x1, x0
    a001cb14:	f00003e0 	adrp	x0, a009b000 <twom1000.10>
    a001cb18:	91026000 	add	x0, x0, #0x98
    a001cb1c:	97fffdc5 	bl	a001c230 <sys_dlist_peek_next>
    a001cb20:	f100001f 	cmp	x0, #0x0
    a001cb24:	54000120 	b.eq	a001cb48 <z_object_wordlist_foreach+0xd0>  // b.none
    a001cb28:	f9403fe0 	ldr	x0, [sp, #120]
    a001cb2c:	91006000 	add	x0, x0, #0x18
    a001cb30:	aa0003e1 	mov	x1, x0
    a001cb34:	f00003e0 	adrp	x0, a009b000 <twom1000.10>
    a001cb38:	91026000 	add	x0, x0, #0x98
    a001cb3c:	97fffdbd 	bl	a001c230 <sys_dlist_peek_next>
    a001cb40:	d1006000 	sub	x0, x0, #0x18
    a001cb44:	14000004 	b	a001cb54 <z_object_wordlist_foreach+0xdc>
    a001cb48:	d2800000 	mov	x0, #0x0                   	// #0
    a001cb4c:	14000002 	b	a001cb54 <z_object_wordlist_foreach+0xdc>
    a001cb50:	d2800000 	mov	x0, #0x0                   	// #0
    a001cb54:	f9003be0 	str	x0, [sp, #112]
    a001cb58:	1400001e 	b	a001cbd0 <z_object_wordlist_foreach+0x158>
		func(&obj->kobj, context);
    a001cb5c:	f9403fe0 	ldr	x0, [sp, #120]
    a001cb60:	f9400fe2 	ldr	x2, [sp, #24]
    a001cb64:	f9400be1 	ldr	x1, [sp, #16]
    a001cb68:	d63f0040 	blr	x2
	SYS_DLIST_FOR_EACH_CONTAINER_SAFE(&obj_list, obj, next, dobj_list) {
    a001cb6c:	f9403be0 	ldr	x0, [sp, #112]
    a001cb70:	f9003fe0 	str	x0, [sp, #120]
    a001cb74:	f9403fe0 	ldr	x0, [sp, #120]
    a001cb78:	f100001f 	cmp	x0, #0x0
    a001cb7c:	54000260 	b.eq	a001cbc8 <z_object_wordlist_foreach+0x150>  // b.none
    a001cb80:	f9403fe0 	ldr	x0, [sp, #120]
    a001cb84:	91006000 	add	x0, x0, #0x18
    a001cb88:	aa0003e1 	mov	x1, x0
    a001cb8c:	f00003e0 	adrp	x0, a009b000 <twom1000.10>
    a001cb90:	91026000 	add	x0, x0, #0x98
    a001cb94:	97fffda7 	bl	a001c230 <sys_dlist_peek_next>
    a001cb98:	f100001f 	cmp	x0, #0x0
    a001cb9c:	54000120 	b.eq	a001cbc0 <z_object_wordlist_foreach+0x148>  // b.none
    a001cba0:	f9403fe0 	ldr	x0, [sp, #120]
    a001cba4:	91006000 	add	x0, x0, #0x18
    a001cba8:	aa0003e1 	mov	x1, x0
    a001cbac:	f00003e0 	adrp	x0, a009b000 <twom1000.10>
    a001cbb0:	91026000 	add	x0, x0, #0x98
    a001cbb4:	97fffd9f 	bl	a001c230 <sys_dlist_peek_next>
    a001cbb8:	d1006000 	sub	x0, x0, #0x18
    a001cbbc:	14000004 	b	a001cbcc <z_object_wordlist_foreach+0x154>
    a001cbc0:	d2800000 	mov	x0, #0x0                   	// #0
    a001cbc4:	14000002 	b	a001cbcc <z_object_wordlist_foreach+0x154>
    a001cbc8:	d2800000 	mov	x0, #0x0                   	// #0
    a001cbcc:	f9003be0 	str	x0, [sp, #112]
    a001cbd0:	f9403fe0 	ldr	x0, [sp, #120]
    a001cbd4:	f100001f 	cmp	x0, #0x0
    a001cbd8:	54fffc21 	b.ne	a001cb5c <z_object_wordlist_foreach+0xe4>  // b.any
    a001cbdc:	900003a0 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a001cbe0:	91116000 	add	x0, x0, #0x458
    a001cbe4:	f9002be0 	str	x0, [sp, #80]
    a001cbe8:	b9403be0 	ldr	w0, [sp, #56]
    a001cbec:	b90033e0 	str	w0, [sp, #48]
	arch_irq_unlock(key.key);
    a001cbf0:	b94033e0 	ldr	w0, [sp, #48]
    a001cbf4:	b9004fe0 	str	w0, [sp, #76]
	write_daif(key);
    a001cbf8:	b9404fe0 	ldr	w0, [sp, #76]
    a001cbfc:	f90023e0 	str	x0, [sp, #64]
MAKE_REG_HELPER(daif)
    a001cc00:	f94023e0 	ldr	x0, [sp, #64]
    a001cc04:	d51b4220 	msr	daif, x0
    a001cc08:	d503201f 	nop
}
    a001cc0c:	d503201f 	nop
}
    a001cc10:	d503201f 	nop
	}
	k_spin_unlock(&lists_lock, key);
}
    a001cc14:	d503201f 	nop
    a001cc18:	a8c87bfd 	ldp	x29, x30, [sp], #128
    a001cc1c:	d65f03c0 	ret

00000000a001cc20 <thread_index_get>:
#endif /* CONFIG_DYNAMIC_OBJECTS */

static unsigned int thread_index_get(struct k_thread *thread)
{
    a001cc20:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a001cc24:	910003fd 	mov	x29, sp
    a001cc28:	f9000fe0 	str	x0, [sp, #24]
	struct z_object *ko;

	ko = z_object_find(thread);
    a001cc2c:	f9400fe0 	ldr	x0, [sp, #24]
    a001cc30:	97ffff7e 	bl	a001ca28 <z_object_find>
    a001cc34:	f90017e0 	str	x0, [sp, #40]

	if (ko == NULL) {
    a001cc38:	f94017e0 	ldr	x0, [sp, #40]
    a001cc3c:	f100001f 	cmp	x0, #0x0
    a001cc40:	54000061 	b.ne	a001cc4c <thread_index_get+0x2c>  // b.any
		return -1;
    a001cc44:	12800000 	mov	w0, #0xffffffff            	// #-1
    a001cc48:	14000003 	b	a001cc54 <thread_index_get+0x34>
	}

	return ko->data.thread_id;
    a001cc4c:	f94017e0 	ldr	x0, [sp, #40]
    a001cc50:	b9400c00 	ldr	w0, [x0, #12]
}
    a001cc54:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a001cc58:	d65f03c0 	ret

00000000a001cc5c <unref_check>:

static void unref_check(struct z_object *ko, uintptr_t index)
{
    a001cc5c:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
    a001cc60:	910003fd 	mov	x29, sp
    a001cc64:	f9000fe0 	str	x0, [sp, #24]
    a001cc68:	f9000be1 	str	x1, [sp, #16]
    a001cc6c:	900003a0 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a001cc70:	91116000 	add	x0, x0, #0x458
    a001cc74:	f90033e0 	str	x0, [sp, #96]
    a001cc78:	d53b4220 	mrs	x0, daif
    a001cc7c:	f9002fe0 	str	x0, [sp, #88]
    a001cc80:	f9402fe0 	ldr	x0, [sp, #88]
    a001cc84:	d503201f 	nop
	key = read_daif();
    a001cc88:	b90057e0 	str	w0, [sp, #84]
	__asm__ volatile ("msr DAIFSet, %0"
    a001cc8c:	d50342df 	msr	daifset, #0x2
}
    a001cc90:	d503201f 	nop
	return key;
    a001cc94:	b94057e0 	ldr	w0, [sp, #84]
	k.key = arch_irq_lock();
    a001cc98:	b90023e0 	str	w0, [sp, #32]
	return k;
    a001cc9c:	b94023e0 	ldr	w0, [sp, #32]
    a001cca0:	b90033e0 	str	w0, [sp, #48]
	k_spinlock_key_t key = k_spin_lock(&obj_lock);

	sys_bitfield_clear_bit((mem_addr_t)&ko->perms, index);
    a001cca4:	f9400fe0 	ldr	x0, [sp, #24]
    a001cca8:	91002000 	add	x0, x0, #0x8
    a001ccac:	aa0003e1 	mov	x1, x0
    a001ccb0:	f9400be0 	ldr	x0, [sp, #16]
    a001ccb4:	f90043e1 	str	x1, [sp, #128]
    a001ccb8:	b9007fe0 	str	w0, [sp, #124]
	sys_clear_bit(addr + ((bit >> 5) << 2), bit & 0x1F);
    a001ccbc:	b9407fe0 	ldr	w0, [sp, #124]
    a001ccc0:	53057c00 	lsr	w0, w0, #5
    a001ccc4:	531e7400 	lsl	w0, w0, #2
    a001ccc8:	2a0003e1 	mov	w1, w0
    a001cccc:	f94043e0 	ldr	x0, [sp, #128]
    a001ccd0:	8b000021 	add	x1, x1, x0
    a001ccd4:	b9407fe0 	ldr	w0, [sp, #124]
    a001ccd8:	12001000 	and	w0, w0, #0x1f
    a001ccdc:	f9003be1 	str	x1, [sp, #112]
    a001cce0:	b9006fe0 	str	w0, [sp, #108]
	uint32_t temp = *(volatile uint32_t *)addr;
    a001cce4:	f9403be0 	ldr	x0, [sp, #112]
    a001cce8:	b9400000 	ldr	w0, [x0]
    a001ccec:	b9006be0 	str	w0, [sp, #104]
	*(volatile uint32_t *)addr = temp & ~(1 << bit);
    a001ccf0:	b9406fe0 	ldr	w0, [sp, #108]
    a001ccf4:	52800021 	mov	w1, #0x1                   	// #1
    a001ccf8:	1ac02020 	lsl	w0, w1, w0
    a001ccfc:	2a2003e0 	mvn	w0, w0
    a001cd00:	2a0003e2 	mov	w2, w0
    a001cd04:	f9403be0 	ldr	x0, [sp, #112]
    a001cd08:	b9406be1 	ldr	w1, [sp, #104]
    a001cd0c:	0a010041 	and	w1, w2, w1
    a001cd10:	b9000001 	str	w1, [x0]
}
    a001cd14:	d503201f 	nop
}
    a001cd18:	d503201f 	nop

#ifdef CONFIG_DYNAMIC_OBJECTS
	if ((ko->flags & K_OBJ_FLAG_ALLOC) == 0U) {
    a001cd1c:	f9400fe0 	ldr	x0, [sp, #24]
    a001cd20:	39402c00 	ldrb	w0, [x0, #11]
    a001cd24:	92401c00 	and	x0, x0, #0xff
    a001cd28:	927e0000 	and	x0, x0, #0x4
    a001cd2c:	f100001f 	cmp	x0, #0x0
    a001cd30:	540006c0 	b.eq	a001ce08 <unref_check+0x1ac>  // b.none
		/* skip unref check for static kernel object */
		goto out;
	}

	void *vko = ko;
    a001cd34:	f9400fe0 	ldr	x0, [sp, #24]
    a001cd38:	f9004be0 	str	x0, [sp, #144]

	struct dyn_obj *dyn = CONTAINER_OF(vko, struct dyn_obj, kobj);
    a001cd3c:	f9404be0 	ldr	x0, [sp, #144]
    a001cd40:	f90047e0 	str	x0, [sp, #136]

	__ASSERT(IS_PTR_ALIGNED(dyn, struct dyn_obj), "unaligned z_object");

	for (int i = 0; i < CONFIG_MAX_THREAD_BYTES; i++) {
    a001cd44:	b9009fff 	str	wzr, [sp, #156]
    a001cd48:	1400000a 	b	a001cd70 <unref_check+0x114>
		if (ko->perms[i] != 0U) {
    a001cd4c:	f9400fe1 	ldr	x1, [sp, #24]
    a001cd50:	b9809fe0 	ldrsw	x0, [sp, #156]
    a001cd54:	8b000020 	add	x0, x1, x0
    a001cd58:	39402000 	ldrb	w0, [x0, #8]
    a001cd5c:	7100001f 	cmp	w0, #0x0
    a001cd60:	54000581 	b.ne	a001ce10 <unref_check+0x1b4>  // b.any
	for (int i = 0; i < CONFIG_MAX_THREAD_BYTES; i++) {
    a001cd64:	b9409fe0 	ldr	w0, [sp, #156]
    a001cd68:	11000400 	add	w0, w0, #0x1
    a001cd6c:	b9009fe0 	str	w0, [sp, #156]
    a001cd70:	b9409fe0 	ldr	w0, [sp, #156]
    a001cd74:	7100041f 	cmp	w0, #0x1
    a001cd78:	54fffead 	b.le	a001cd4c <unref_check+0xf0>
	/* This object has no more references. Some objects may have
	 * dynamically allocated resources, require cleanup, or need to be
	 * marked as uninitailized when all references are gone. What
	 * specifically needs to happen depends on the object type.
	 */
	switch (ko->type) {
    a001cd7c:	f9400fe0 	ldr	x0, [sp, #24]
    a001cd80:	39402800 	ldrb	w0, [x0, #10]
    a001cd84:	7100201f 	cmp	w0, #0x8
    a001cd88:	540001e0 	b.eq	a001cdc4 <unref_check+0x168>  // b.none
    a001cd8c:	7100201f 	cmp	w0, #0x8
    a001cd90:	5400022c 	b.gt	a001cdd4 <unref_check+0x178>
    a001cd94:	7100081f 	cmp	w0, #0x2
    a001cd98:	540000e0 	b.eq	a001cdb4 <unref_check+0x158>  // b.none
    a001cd9c:	7100101f 	cmp	w0, #0x4
    a001cda0:	540001a1 	b.ne	a001cdd4 <unref_check+0x178>  // b.any
	case K_OBJ_PIPE:
		k_pipe_cleanup((struct k_pipe *)ko->name);
    a001cda4:	f9400fe0 	ldr	x0, [sp, #24]
    a001cda8:	f9400000 	ldr	x0, [x0]
    a001cdac:	9400094a 	bl	a001f2d4 <k_pipe_cleanup>
		break;
    a001cdb0:	1400000a 	b	a001cdd8 <unref_check+0x17c>
	case K_OBJ_MSGQ:
		k_msgq_cleanup((struct k_msgq *)ko->name);
    a001cdb4:	f9400fe0 	ldr	x0, [sp, #24]
    a001cdb8:	f9400000 	ldr	x0, [x0]
    a001cdbc:	9400045a 	bl	a001df24 <k_msgq_cleanup>
		break;
    a001cdc0:	14000006 	b	a001cdd8 <unref_check+0x17c>
	case K_OBJ_STACK:
		k_stack_cleanup((struct k_stack *)ko->name);
    a001cdc4:	f9400fe0 	ldr	x0, [sp, #24]
    a001cdc8:	f9400000 	ldr	x0, [x0]
    a001cdcc:	94000fdb 	bl	a0020d38 <k_stack_cleanup>
		break;
    a001cdd0:	14000002 	b	a001cdd8 <unref_check+0x17c>
	default:
		/* Nothing to do */
		break;
    a001cdd4:	d503201f 	nop
	}

	rb_remove(&obj_rb_tree, &dyn->node);
    a001cdd8:	f94047e0 	ldr	x0, [sp, #136]
    a001cddc:	9100a000 	add	x0, x0, #0x28
    a001cde0:	aa0003e1 	mov	x1, x0
    a001cde4:	f00003e0 	adrp	x0, a009b000 <twom1000.10>
    a001cde8:	91020000 	add	x0, x0, #0x80
    a001cdec:	97ff9e36 	bl	a00046c4 <rb_remove>
	sys_dlist_remove(&dyn->dobj_list);
    a001cdf0:	f94047e0 	ldr	x0, [sp, #136]
    a001cdf4:	91006000 	add	x0, x0, #0x18
    a001cdf8:	97fffd31 	bl	a001c2bc <sys_dlist_remove>
	k_free(dyn);
    a001cdfc:	f94047e0 	ldr	x0, [sp, #136]
    a001ce00:	97fffa25 	bl	a001b694 <k_free>
    a001ce04:	14000004 	b	a001ce14 <unref_check+0x1b8>
		goto out;
    a001ce08:	d503201f 	nop
    a001ce0c:	14000002 	b	a001ce14 <unref_check+0x1b8>
			goto out;
    a001ce10:	d503201f 	nop
    a001ce14:	900003a0 	adrp	x0, a0090000 <z_page_frames+0x47d68>
    a001ce18:	91116000 	add	x0, x0, #0x458
    a001ce1c:	f90027e0 	str	x0, [sp, #72]
    a001ce20:	b94033e0 	ldr	w0, [sp, #48]
    a001ce24:	b9002be0 	str	w0, [sp, #40]
	arch_irq_unlock(key.key);
    a001ce28:	b9402be0 	ldr	w0, [sp, #40]
    a001ce2c:	b90047e0 	str	w0, [sp, #68]
	write_daif(key);
    a001ce30:	b94047e0 	ldr	w0, [sp, #68]
    a001ce34:	f9001fe0 	str	x0, [sp, #56]
MAKE_REG_HELPER(daif)
    a001ce38:	f9401fe0 	ldr	x0, [sp, #56]
    a001ce3c:	d51b4220 	msr	daif, x0
    a001ce40:	d503201f 	nop
}
    a001ce44:	d503201f 	nop
}
    a001ce48:	d503201f 	nop
out:
#endif
	k_spin_unlock(&obj_lock, key);
}
    a001ce4c:	d503201f 	nop
    a001ce50:	a8ca7bfd 	ldp	x29, x30, [sp], #160
    a001ce54:	d65f03c0 	ret

00000000a001ce58 <wordlist_cb>:

static void wordlist_cb(struct z_object *ko, void *ctx_ptr)
{
    a001ce58:	d10183ff 	sub	sp, sp, #0x60
    a001ce5c:	f90007e0 	str	x0, [sp, #8]
    a001ce60:	f90003e1 	str	x1, [sp]
	struct perm_ctx *ctx = (struct perm_ctx *)ctx_ptr;
    a001ce64:	f94003e0 	ldr	x0, [sp]
    a001ce68:	f9002fe0 	str	x0, [sp, #88]

	if (sys_bitfield_test_bit((mem_addr_t)&ko->perms, ctx->parent_id) &&
    a001ce6c:	f94007e0 	ldr	x0, [sp, #8]
    a001ce70:	91002000 	add	x0, x0, #0x8
    a001ce74:	aa0003e1 	mov	x1, x0
    a001ce78:	f9402fe0 	ldr	x0, [sp, #88]
    a001ce7c:	b9400000 	ldr	w0, [x0]
    a001ce80:	f9002be1 	str	x1, [sp, #80]
    a001ce84:	b9004fe0 	str	w0, [sp, #76]

static ALWAYS_INLINE
	int sys_bitfield_test_bit(mem_addr_t addr, unsigned int bit)
{
	return sys_test_bit(addr + ((bit >> 5) << 2), bit & 0x1F);
    a001ce88:	b9404fe0 	ldr	w0, [sp, #76]
    a001ce8c:	53057c00 	lsr	w0, w0, #5
    a001ce90:	531e7400 	lsl	w0, w0, #2
    a001ce94:	2a0003e1 	mov	w1, w0
    a001ce98:	f9402be0 	ldr	x0, [sp, #80]
    a001ce9c:	8b000021 	add	x1, x1, x0
    a001cea0:	b9404fe0 	ldr	w0, [sp, #76]
    a001cea4:	12001000 	and	w0, w0, #0x1f
    a001cea8:	f90023e1 	str	x1, [sp, #64]
    a001ceac:	b9003fe0 	str	w0, [sp, #60]
	uint32_t temp = *(volatile uint32_t *)addr;
    a001ceb0:	f94023e0 	ldr	x0, [sp, #64]
    a001ceb4:	b9400000 	ldr	w0, [x0]
    a001ceb8:	b9003be0 	str	w0, [sp, #56]
	return temp & (1 << bit);
    a001cebc:	b9403fe0 	ldr	w0, [sp, #60]
    a001cec0:	52800021 	mov	w1, #0x1                   	// #1
    a001cec4:	1ac02020 	lsl	w0, w1, w0
    a001cec8:	2a0003e1 	mov	w1, w0
    a001cecc:	b9403be0 	ldr	w0, [sp, #56]
    a001ced0:	0a000020 	and	w0, w1, w0
	return sys_test_bit(addr + ((bit >> 5) << 2), bit & 0x1F);
    a001ced4:	d503201f 	nop
    a001ced8:	7100001f 	cmp	w0, #0x0
    a001cedc:	540004a0 	b.eq	a001cf70 <wordlist_cb+0x118>  // b.none
				  (struct k_thread *)ko->name != ctx->parent) {
    a001cee0:	f94007e0 	ldr	x0, [sp, #8]
    a001cee4:	f9400001 	ldr	x1, [x0]
    a001cee8:	f9402fe0 	ldr	x0, [sp, #88]
    a001ceec:	f9400400 	ldr	x0, [x0, #8]
	if (sys_bitfield_test_bit((mem_addr_t)&ko->perms, ctx->parent_id) &&
    a001cef0:	eb00003f 	cmp	x1, x0
    a001cef4:	540003e0 	b.eq	a001cf70 <wordlist_cb+0x118>  // b.none
		sys_bitfield_set_bit((mem_addr_t)&ko->perms, ctx->child_id);
    a001cef8:	f94007e0 	ldr	x0, [sp, #8]
    a001cefc:	91002000 	add	x0, x0, #0x8
    a001cf00:	aa0003e1 	mov	x1, x0
    a001cf04:	f9402fe0 	ldr	x0, [sp, #88]
    a001cf08:	b9400400 	ldr	w0, [x0, #4]
    a001cf0c:	f9001be1 	str	x1, [sp, #48]
    a001cf10:	b9002fe0 	str	w0, [sp, #44]
	sys_set_bit(addr + ((bit >> 5) << 2), bit & 0x1F);
    a001cf14:	b9402fe0 	ldr	w0, [sp, #44]
    a001cf18:	53057c00 	lsr	w0, w0, #5
    a001cf1c:	531e7400 	lsl	w0, w0, #2
    a001cf20:	2a0003e1 	mov	w1, w0
    a001cf24:	f9401be0 	ldr	x0, [sp, #48]
    a001cf28:	8b000021 	add	x1, x1, x0
    a001cf2c:	b9402fe0 	ldr	w0, [sp, #44]
    a001cf30:	12001000 	and	w0, w0, #0x1f
    a001cf34:	f90013e1 	str	x1, [sp, #32]
    a001cf38:	b9001fe0 	str	w0, [sp, #28]
	uint32_t temp = *(volatile uint32_t *)addr;
    a001cf3c:	f94013e0 	ldr	x0, [sp, #32]
    a001cf40:	b9400000 	ldr	w0, [x0]
    a001cf44:	b9001be0 	str	w0, [sp, #24]
	*(volatile uint32_t *)addr = temp | (1 << bit);
    a001cf48:	b9401fe0 	ldr	w0, [sp, #28]
    a001cf4c:	52800021 	mov	w1, #0x1                   	// #1
    a001cf50:	1ac02020 	lsl	w0, w1, w0
    a001cf54:	2a0003e2 	mov	w2, w0
    a001cf58:	f94013e0 	ldr	x0, [sp, #32]
    a001cf5c:	b9401be1 	ldr	w1, [sp, #24]
    a001cf60:	2a010041 	orr	w1, w2, w1
    a001cf64:	b9000001 	str	w1, [x0]
}
    a001cf68:	d503201f 	nop
}
    a001cf6c:	d503201f 	nop
	}
}
    a001cf70:	d503201f 	nop
    a001cf74:	910183ff 	add	sp, sp, #0x60
    a001cf78:	d65f03c0 	ret

00000000a001cf7c <z_thread_perms_inherit>:

void z_thread_perms_inherit(struct k_thread *parent, struct k_thread *child)
{
    a001cf7c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a001cf80:	910003fd 	mov	x29, sp
    a001cf84:	f9000fe0 	str	x0, [sp, #24]
    a001cf88:	f9000be1 	str	x1, [sp, #16]
	struct perm_ctx ctx = {
		thread_index_get(parent),
    a001cf8c:	f9400fe0 	ldr	x0, [sp, #24]
    a001cf90:	97ffff24 	bl	a001cc20 <thread_index_get>
	struct perm_ctx ctx = {
    a001cf94:	b90023e0 	str	w0, [sp, #32]
		thread_index_get(child),
    a001cf98:	f9400be0 	ldr	x0, [sp, #16]
    a001cf9c:	97ffff21 	bl	a001cc20 <thread_index_get>
	struct perm_ctx ctx = {
    a001cfa0:	b90027e0 	str	w0, [sp, #36]
    a001cfa4:	f9400fe0 	ldr	x0, [sp, #24]
    a001cfa8:	f90017e0 	str	x0, [sp, #40]
		parent
	};

	if ((ctx.parent_id != -1) && (ctx.child_id != -1)) {
    a001cfac:	b94023e0 	ldr	w0, [sp, #32]
    a001cfb0:	3100041f 	cmn	w0, #0x1
    a001cfb4:	54000120 	b.eq	a001cfd8 <z_thread_perms_inherit+0x5c>  // b.none
    a001cfb8:	b94027e0 	ldr	w0, [sp, #36]
    a001cfbc:	3100041f 	cmn	w0, #0x1
    a001cfc0:	540000c0 	b.eq	a001cfd8 <z_thread_perms_inherit+0x5c>  // b.none
		z_object_wordlist_foreach(wordlist_cb, &ctx);
    a001cfc4:	910083e0 	add	x0, sp, #0x20
    a001cfc8:	aa0003e1 	mov	x1, x0
    a001cfcc:	90000000 	adrp	x0, a001c000 <z_mem_domain_init_thread+0x8>
    a001cfd0:	91396000 	add	x0, x0, #0xe58
    a001cfd4:	97fffea9 	bl	a001ca78 <z_object_wordlist_foreach>
	}
}
    a001cfd8:	d503201f 	nop
    a001cfdc:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a001cfe0:	d65f03c0 	ret

00000000a001cfe4 <z_thread_perms_set>:

void z_thread_perms_set(struct z_object *ko, struct k_thread *thread)
{
    a001cfe4:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a001cfe8:	910003fd 	mov	x29, sp
    a001cfec:	f9000fe0 	str	x0, [sp, #24]
    a001cff0:	f9000be1 	str	x1, [sp, #16]
	int index = thread_index_get(thread);
    a001cff4:	f9400be0 	ldr	x0, [sp, #16]
    a001cff8:	97ffff0a 	bl	a001cc20 <thread_index_get>
    a001cffc:	b9004fe0 	str	w0, [sp, #76]

	if (index != -1) {
    a001d000:	b9404fe0 	ldr	w0, [sp, #76]
    a001d004:	3100041f 	cmn	w0, #0x1
    a001d008:	540003c0 	b.eq	a001d080 <z_thread_perms_set+0x9c>  // b.none
		sys_bitfield_set_bit((mem_addr_t)&ko->perms, index);
    a001d00c:	f9400fe0 	ldr	x0, [sp, #24]
    a001d010:	91002000 	add	x0, x0, #0x8
    a001d014:	aa0003e1 	mov	x1, x0
    a001d018:	b9404fe0 	ldr	w0, [sp, #76]
    a001d01c:	f90023e1 	str	x1, [sp, #64]
    a001d020:	b9003fe0 	str	w0, [sp, #60]
	sys_set_bit(addr + ((bit >> 5) << 2), bit & 0x1F);
    a001d024:	b9403fe0 	ldr	w0, [sp, #60]
    a001d028:	53057c00 	lsr	w0, w0, #5
    a001d02c:	531e7400 	lsl	w0, w0, #2
    a001d030:	2a0003e1 	mov	w1, w0
    a001d034:	f94023e0 	ldr	x0, [sp, #64]
    a001d038:	8b000021 	add	x1, x1, x0
    a001d03c:	b9403fe0 	ldr	w0, [sp, #60]
    a001d040:	12001000 	and	w0, w0, #0x1f
    a001d044:	f9001be1 	str	x1, [sp, #48]
    a001d048:	b9002fe0 	str	w0, [sp, #44]
	uint32_t temp = *(volatile uint32_t *)addr;
    a001d04c:	f9401be0 	ldr	x0, [sp, #48]
    a001d050:	b9400000 	ldr	w0, [x0]
    a001d054:	b9002be0 	str	w0, [sp, #40]
	*(volatile uint32_t *)addr = temp | (1 << bit);
    a001d058:	b9402fe0 	ldr	w0, [sp, #44]
    a001d05c:	52800021 	mov	w1, #0x1                   	// #1
    a001d060:	1ac02020 	lsl	w0, w1, w0
    a001d064:	2a0003e2 	mov	w2, w0
    a001d068:	f9401be0 	ldr	x0, [sp, #48]
    a001d06c:	b9402be1 	ldr	w1, [sp, #40]
    a001d070:	2a010041 	orr	w1, w2, w1
    a001d074:	b9000001 	str	w1, [x0]
}
    a001d078:	d503201f 	nop
}
    a001d07c:	d503201f 	nop
	}
}
    a001d080:	d503201f 	nop
    a001d084:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a001d088:	d65f03c0 	ret

00000000a001d08c <z_thread_perms_clear>:

void z_thread_perms_clear(struct z_object *ko, struct k_thread *thread)
{
    a001d08c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a001d090:	910003fd 	mov	x29, sp
    a001d094:	f9000fe0 	str	x0, [sp, #24]
    a001d098:	f9000be1 	str	x1, [sp, #16]
	int index = thread_index_get(thread);
    a001d09c:	f9400be0 	ldr	x0, [sp, #16]
    a001d0a0:	97fffee0 	bl	a001cc20 <thread_index_get>
    a001d0a4:	b9004fe0 	str	w0, [sp, #76]

	if (index != -1) {
    a001d0a8:	b9404fe0 	ldr	w0, [sp, #76]
    a001d0ac:	3100041f 	cmn	w0, #0x1
    a001d0b0:	54000460 	b.eq	a001d13c <z_thread_perms_clear+0xb0>  // b.none
		sys_bitfield_clear_bit((mem_addr_t)&ko->perms, index);
    a001d0b4:	f9400fe0 	ldr	x0, [sp, #24]
    a001d0b8:	91002000 	add	x0, x0, #0x8
    a001d0bc:	aa0003e1 	mov	x1, x0
    a001d0c0:	b9404fe0 	ldr	w0, [sp, #76]
    a001d0c4:	f90023e1 	str	x1, [sp, #64]
    a001d0c8:	b9003fe0 	str	w0, [sp, #60]
	sys_clear_bit(addr + ((bit >> 5) << 2), bit & 0x1F);
    a001d0cc:	b9403fe0 	ldr	w0, [sp, #60]
    a001d0d0:	53057c00 	lsr	w0, w0, #5
    a001d0d4:	531e7400 	lsl	w0, w0, #2
    a001d0d8:	2a0003e1 	mov	w1, w0
    a001d0dc:	f94023e0 	ldr	x0, [sp, #64]
    a001d0e0:	8b000021 	add	x1, x1, x0
    a001d0e4:	b9403fe0 	ldr	w0, [sp, #60]
    a001d0e8:	12001000 	and	w0, w0, #0x1f
    a001d0ec:	f9001be1 	str	x1, [sp, #48]
    a001d0f0:	b9002fe0 	str	w0, [sp, #44]
	uint32_t temp = *(volatile uint32_t *)addr;
    a001d0f4:	f9401be0 	ldr	x0, [sp, #48]
    a001d0f8:	b9400000 	ldr	w0, [x0]
    a001d0fc:	b9002be0 	str	w0, [sp, #40]
	*(volatile uint32_t *)addr = temp & ~(1 << bit);
    a001d100:	b9402fe0 	ldr	w0, [sp, #44]
    a001d104:	52800021 	mov	w1, #0x1                   	// #1
    a001d108:	1ac02020 	lsl	w0, w1, w0
    a001d10c:	2a2003e0 	mvn	w0, w0
    a001d110:	2a0003e2 	mov	w2, w0
    a001d114:	f9401be0 	ldr	x0, [sp, #48]
    a001d118:	b9402be1 	ldr	w1, [sp, #40]
    a001d11c:	0a010041 	and	w1, w2, w1
    a001d120:	b9000001 	str	w1, [x0]
}
    a001d124:	d503201f 	nop
}
    a001d128:	d503201f 	nop
		unref_check(ko, index);
    a001d12c:	b9804fe0 	ldrsw	x0, [sp, #76]
    a001d130:	aa0003e1 	mov	x1, x0
    a001d134:	f9400fe0 	ldr	x0, [sp, #24]
    a001d138:	97fffec9 	bl	a001cc5c <unref_check>
	}
}
    a001d13c:	d503201f 	nop
    a001d140:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a001d144:	d65f03c0 	ret

00000000a001d148 <clear_perms_cb>:

static void clear_perms_cb(struct z_object *ko, void *ctx_ptr)
{
    a001d148:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a001d14c:	910003fd 	mov	x29, sp
    a001d150:	f9000fe0 	str	x0, [sp, #24]
    a001d154:	f9000be1 	str	x1, [sp, #16]
	uintptr_t id = (uintptr_t)ctx_ptr;
    a001d158:	f9400be0 	ldr	x0, [sp, #16]
    a001d15c:	f90017e0 	str	x0, [sp, #40]

	unref_check(ko, id);
    a001d160:	f94017e1 	ldr	x1, [sp, #40]
    a001d164:	f9400fe0 	ldr	x0, [sp, #24]
    a001d168:	97fffebd 	bl	a001cc5c <unref_check>
}
    a001d16c:	d503201f 	nop
    a001d170:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a001d174:	d65f03c0 	ret

00000000a001d178 <z_thread_perms_all_clear>:

void z_thread_perms_all_clear(struct k_thread *thread)
{
    a001d178:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a001d17c:	910003fd 	mov	x29, sp
    a001d180:	f9000fe0 	str	x0, [sp, #24]
	uintptr_t index = thread_index_get(thread);
    a001d184:	f9400fe0 	ldr	x0, [sp, #24]
    a001d188:	97fffea6 	bl	a001cc20 <thread_index_get>
    a001d18c:	2a0003e0 	mov	w0, w0
    a001d190:	f90017e0 	str	x0, [sp, #40]

	if ((int)index != -1) {
    a001d194:	f94017e0 	ldr	x0, [sp, #40]
    a001d198:	3100041f 	cmn	w0, #0x1
    a001d19c:	540000c0 	b.eq	a001d1b4 <z_thread_perms_all_clear+0x3c>  // b.none
		z_object_wordlist_foreach(clear_perms_cb, (void *)index);
    a001d1a0:	f94017e0 	ldr	x0, [sp, #40]
    a001d1a4:	aa0003e1 	mov	x1, x0
    a001d1a8:	90000000 	adrp	x0, a001d000 <z_thread_perms_set+0x1c>
    a001d1ac:	91052000 	add	x0, x0, #0x148
    a001d1b0:	97fffe32 	bl	a001ca78 <z_object_wordlist_foreach>
	}
}
    a001d1b4:	d503201f 	nop
    a001d1b8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a001d1bc:	d65f03c0 	ret

00000000a001d1c0 <thread_perms_test>:

static int thread_perms_test(struct z_object *ko)
{
    a001d1c0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a001d1c4:	910003fd 	mov	x29, sp
    a001d1c8:	f9000fe0 	str	x0, [sp, #24]
	int index;

	if ((ko->flags & K_OBJ_FLAG_PUBLIC) != 0U) {
    a001d1cc:	f9400fe0 	ldr	x0, [sp, #24]
    a001d1d0:	39402c00 	ldrb	w0, [x0, #11]
    a001d1d4:	92401c00 	and	x0, x0, #0xff
    a001d1d8:	927f0000 	and	x0, x0, #0x2
    a001d1dc:	f100001f 	cmp	x0, #0x0
    a001d1e0:	54000060 	b.eq	a001d1ec <thread_perms_test+0x2c>  // b.none
		return 1;
    a001d1e4:	52800020 	mov	w0, #0x1                   	// #1
    a001d1e8:	14000025 	b	a001d27c <thread_perms_test+0xbc>
	}

	index = thread_index_get(_current);
    a001d1ec:	d0000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001d1f0:	913f8000 	add	x0, x0, #0xfe0
    a001d1f4:	f9400800 	ldr	x0, [x0, #16]
    a001d1f8:	97fffe8a 	bl	a001cc20 <thread_index_get>
    a001d1fc:	b9004fe0 	str	w0, [sp, #76]
	if (index != -1) {
    a001d200:	b9404fe0 	ldr	w0, [sp, #76]
    a001d204:	3100041f 	cmn	w0, #0x1
    a001d208:	54000380 	b.eq	a001d278 <thread_perms_test+0xb8>  // b.none
		return sys_bitfield_test_bit((mem_addr_t)&ko->perms, index);
    a001d20c:	f9400fe0 	ldr	x0, [sp, #24]
    a001d210:	91002000 	add	x0, x0, #0x8
    a001d214:	aa0003e1 	mov	x1, x0
    a001d218:	b9404fe0 	ldr	w0, [sp, #76]
    a001d21c:	f90023e1 	str	x1, [sp, #64]
    a001d220:	b9003fe0 	str	w0, [sp, #60]
	return sys_test_bit(addr + ((bit >> 5) << 2), bit & 0x1F);
    a001d224:	b9403fe0 	ldr	w0, [sp, #60]
    a001d228:	53057c00 	lsr	w0, w0, #5
    a001d22c:	531e7400 	lsl	w0, w0, #2
    a001d230:	2a0003e1 	mov	w1, w0
    a001d234:	f94023e0 	ldr	x0, [sp, #64]
    a001d238:	8b000021 	add	x1, x1, x0
    a001d23c:	b9403fe0 	ldr	w0, [sp, #60]
    a001d240:	12001000 	and	w0, w0, #0x1f
    a001d244:	f9001be1 	str	x1, [sp, #48]
    a001d248:	b9002fe0 	str	w0, [sp, #44]
	uint32_t temp = *(volatile uint32_t *)addr;
    a001d24c:	f9401be0 	ldr	x0, [sp, #48]
    a001d250:	b9400000 	ldr	w0, [x0]
    a001d254:	b9002be0 	str	w0, [sp, #40]
	return temp & (1 << bit);
    a001d258:	b9402fe0 	ldr	w0, [sp, #44]
    a001d25c:	52800021 	mov	w1, #0x1                   	// #1
    a001d260:	1ac02020 	lsl	w0, w1, w0
    a001d264:	2a0003e1 	mov	w1, w0
    a001d268:	b9402be0 	ldr	w0, [sp, #40]
    a001d26c:	0a000020 	and	w0, w1, w0
	return sys_test_bit(addr + ((bit >> 5) << 2), bit & 0x1F);
    a001d270:	d503201f 	nop
    a001d274:	14000002 	b	a001d27c <thread_perms_test+0xbc>
	}
	return 0;
    a001d278:	52800000 	mov	w0, #0x0                   	// #0
}
    a001d27c:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a001d280:	d65f03c0 	ret

00000000a001d284 <z_impl_k_object_access_grant>:
		break;
	}
}

void z_impl_k_object_access_grant(const void *object, struct k_thread *thread)
{
    a001d284:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a001d288:	910003fd 	mov	x29, sp
    a001d28c:	f9000fe0 	str	x0, [sp, #24]
    a001d290:	f9000be1 	str	x1, [sp, #16]
	struct z_object *ko = z_object_find(object);
    a001d294:	f9400fe0 	ldr	x0, [sp, #24]
    a001d298:	97fffde4 	bl	a001ca28 <z_object_find>
    a001d29c:	f90017e0 	str	x0, [sp, #40]

	if (ko != NULL) {
    a001d2a0:	f94017e0 	ldr	x0, [sp, #40]
    a001d2a4:	f100001f 	cmp	x0, #0x0
    a001d2a8:	54000080 	b.eq	a001d2b8 <z_impl_k_object_access_grant+0x34>  // b.none
		z_thread_perms_set(ko, thread);
    a001d2ac:	f9400be1 	ldr	x1, [sp, #16]
    a001d2b0:	f94017e0 	ldr	x0, [sp, #40]
    a001d2b4:	97ffff4c 	bl	a001cfe4 <z_thread_perms_set>
	}
}
    a001d2b8:	d503201f 	nop
    a001d2bc:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a001d2c0:	d65f03c0 	ret

00000000a001d2c4 <z_object_validate>:
	}
}

int z_object_validate(struct z_object *ko, enum k_objects otype,
		       enum _obj_init_check init)
{
    a001d2c4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a001d2c8:	910003fd 	mov	x29, sp
    a001d2cc:	f9000fe0 	str	x0, [sp, #24]
    a001d2d0:	b90017e1 	str	w1, [sp, #20]
    a001d2d4:	b90013e2 	str	w2, [sp, #16]
	if (unlikely((ko == NULL) ||
    a001d2d8:	f9400fe0 	ldr	x0, [sp, #24]
    a001d2dc:	f100001f 	cmp	x0, #0x0
    a001d2e0:	1a9f17e0 	cset	w0, eq  // eq = none
    a001d2e4:	12001c00 	and	w0, w0, #0xff
    a001d2e8:	92401c00 	and	x0, x0, #0xff
    a001d2ec:	f100001f 	cmp	x0, #0x0
    a001d2f0:	540002e1 	b.ne	a001d34c <z_object_validate+0x88>  // b.any
    a001d2f4:	b94017e0 	ldr	w0, [sp, #20]
    a001d2f8:	7100001f 	cmp	w0, #0x0
    a001d2fc:	1a9f07e0 	cset	w0, ne  // ne = any
    a001d300:	12001c00 	and	w0, w0, #0xff
    a001d304:	92401c00 	and	x0, x0, #0xff
    a001d308:	f100001f 	cmp	x0, #0x0
    a001d30c:	540001a0 	b.eq	a001d340 <z_object_validate+0x7c>  // b.none
    a001d310:	f9400fe0 	ldr	x0, [sp, #24]
    a001d314:	39402800 	ldrb	w0, [x0, #10]
    a001d318:	2a0003e1 	mov	w1, w0
    a001d31c:	b94017e0 	ldr	w0, [sp, #20]
    a001d320:	6b01001f 	cmp	w0, w1
    a001d324:	1a9f07e0 	cset	w0, ne  // ne = any
    a001d328:	12001c00 	and	w0, w0, #0xff
    a001d32c:	92401c00 	and	x0, x0, #0xff
    a001d330:	f100001f 	cmp	x0, #0x0
    a001d334:	54000060 	b.eq	a001d340 <z_object_validate+0x7c>  // b.none
    a001d338:	52800020 	mov	w0, #0x1                   	// #1
    a001d33c:	14000002 	b	a001d344 <z_object_validate+0x80>
    a001d340:	52800000 	mov	w0, #0x0                   	// #0
    a001d344:	7100001f 	cmp	w0, #0x0
    a001d348:	54000060 	b.eq	a001d354 <z_object_validate+0x90>  // b.none
		(otype != K_OBJ_ANY && ko->type != otype))) {
		return -EBADF;
    a001d34c:	12800100 	mov	w0, #0xfffffff7            	// #-9
    a001d350:	1400002e 	b	a001d408 <z_object_validate+0x144>
	}

	/* Manipulation of any kernel objects by a user thread requires that
	 * thread be granted access first, even for uninitialized objects
	 */
	if (unlikely(thread_perms_test(ko) == 0)) {
    a001d354:	f9400fe0 	ldr	x0, [sp, #24]
    a001d358:	97ffff9a 	bl	a001d1c0 <thread_perms_test>
    a001d35c:	7100001f 	cmp	w0, #0x0
    a001d360:	1a9f17e0 	cset	w0, eq  // eq = none
    a001d364:	12001c00 	and	w0, w0, #0xff
    a001d368:	92401c00 	and	x0, x0, #0xff
    a001d36c:	f100001f 	cmp	x0, #0x0
    a001d370:	54000060 	b.eq	a001d37c <z_object_validate+0xb8>  // b.none
		return -EPERM;
    a001d374:	12800000 	mov	w0, #0xffffffff            	// #-1
    a001d378:	14000024 	b	a001d408 <z_object_validate+0x144>
	}

	/* Initialization state checks. _OBJ_INIT_ANY, we don't care */
	if (likely(init == _OBJ_INIT_TRUE)) {
    a001d37c:	b94013e0 	ldr	w0, [sp, #16]
    a001d380:	7100001f 	cmp	w0, #0x0
    a001d384:	1a9f17e0 	cset	w0, eq  // eq = none
    a001d388:	12001c00 	and	w0, w0, #0xff
    a001d38c:	92401c00 	and	x0, x0, #0xff
    a001d390:	f100001f 	cmp	x0, #0x0
    a001d394:	540001a0 	b.eq	a001d3c8 <z_object_validate+0x104>  // b.none
		/* Object MUST be initialized */
		if (unlikely((ko->flags & K_OBJ_FLAG_INITIALIZED) == 0U)) {
    a001d398:	f9400fe0 	ldr	x0, [sp, #24]
    a001d39c:	39402c00 	ldrb	w0, [x0, #11]
    a001d3a0:	92401c00 	and	x0, x0, #0xff
    a001d3a4:	92400000 	and	x0, x0, #0x1
    a001d3a8:	f100001f 	cmp	x0, #0x0
    a001d3ac:	1a9f17e0 	cset	w0, eq  // eq = none
    a001d3b0:	12001c00 	and	w0, w0, #0xff
    a001d3b4:	92401c00 	and	x0, x0, #0xff
    a001d3b8:	f100001f 	cmp	x0, #0x0
    a001d3bc:	54000240 	b.eq	a001d404 <z_object_validate+0x140>  // b.none
			return -EINVAL;
    a001d3c0:	128002a0 	mov	w0, #0xffffffea            	// #-22
    a001d3c4:	14000011 	b	a001d408 <z_object_validate+0x144>
		}
	} else if (init == _OBJ_INIT_FALSE) { /* _OBJ_INIT_FALSE case */
    a001d3c8:	b94013e0 	ldr	w0, [sp, #16]
    a001d3cc:	3100041f 	cmn	w0, #0x1
    a001d3d0:	540001a1 	b.ne	a001d404 <z_object_validate+0x140>  // b.any
		/* Object MUST NOT be initialized */
		if (unlikely((ko->flags & K_OBJ_FLAG_INITIALIZED) != 0U)) {
    a001d3d4:	f9400fe0 	ldr	x0, [sp, #24]
    a001d3d8:	39402c00 	ldrb	w0, [x0, #11]
    a001d3dc:	92401c00 	and	x0, x0, #0xff
    a001d3e0:	92400000 	and	x0, x0, #0x1
    a001d3e4:	f100001f 	cmp	x0, #0x0
    a001d3e8:	1a9f07e0 	cset	w0, ne  // ne = any
    a001d3ec:	12001c00 	and	w0, w0, #0xff
    a001d3f0:	92401c00 	and	x0, x0, #0xff
    a001d3f4:	f100001f 	cmp	x0, #0x0
    a001d3f8:	54000060 	b.eq	a001d404 <z_object_validate+0x140>  // b.none
			return -EADDRINUSE;
    a001d3fc:	12800de0 	mov	w0, #0xffffff90            	// #-112
    a001d400:	14000002 	b	a001d408 <z_object_validate+0x144>
		}
	} else {
		/* _OBJ_INIT_ANY */
	}

	return 0;
    a001d404:	52800000 	mov	w0, #0x0                   	// #0
}
    a001d408:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a001d40c:	d65f03c0 	ret

00000000a001d410 <z_object_init>:

void z_object_init(const void *obj)
{
    a001d410:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a001d414:	910003fd 	mov	x29, sp
    a001d418:	f9000fe0 	str	x0, [sp, #24]
	 *
	 * This function runs after the object has been initialized and
	 * finalizes it
	 */

	ko = z_object_find(obj);
    a001d41c:	f9400fe0 	ldr	x0, [sp, #24]
    a001d420:	97fffd82 	bl	a001ca28 <z_object_find>
    a001d424:	f90017e0 	str	x0, [sp, #40]
	if (ko == NULL) {
    a001d428:	f94017e0 	ldr	x0, [sp, #40]
    a001d42c:	f100001f 	cmp	x0, #0x0
    a001d430:	54000100 	b.eq	a001d450 <z_object_init+0x40>  // b.none
		 */
		return;
	}

	/* Allows non-initialization system calls to be made on this object */
	ko->flags |= K_OBJ_FLAG_INITIALIZED;
    a001d434:	f94017e0 	ldr	x0, [sp, #40]
    a001d438:	39402c00 	ldrb	w0, [x0, #11]
    a001d43c:	32000000 	orr	w0, w0, #0x1
    a001d440:	12001c01 	and	w1, w0, #0xff
    a001d444:	f94017e0 	ldr	x0, [sp, #40]
    a001d448:	39002c01 	strb	w1, [x0, #11]
    a001d44c:	14000002 	b	a001d454 <z_object_init+0x44>
		return;
    a001d450:	d503201f 	nop
}
    a001d454:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a001d458:	d65f03c0 	ret

00000000a001d45c <z_object_uninit>:
		ko->flags |= K_OBJ_FLAG_INITIALIZED;
	}
}

void z_object_uninit(const void *obj)
{
    a001d45c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a001d460:	910003fd 	mov	x29, sp
    a001d464:	f9000fe0 	str	x0, [sp, #24]
	struct z_object *ko;

	/* See comments in z_object_init() */
	ko = z_object_find(obj);
    a001d468:	f9400fe0 	ldr	x0, [sp, #24]
    a001d46c:	97fffd6f 	bl	a001ca28 <z_object_find>
    a001d470:	f90017e0 	str	x0, [sp, #40]
	if (ko == NULL) {
    a001d474:	f94017e0 	ldr	x0, [sp, #40]
    a001d478:	f100001f 	cmp	x0, #0x0
    a001d47c:	54000100 	b.eq	a001d49c <z_object_uninit+0x40>  // b.none
		return;
	}

	ko->flags &= ~K_OBJ_FLAG_INITIALIZED;
    a001d480:	f94017e0 	ldr	x0, [sp, #40]
    a001d484:	39402c00 	ldrb	w0, [x0, #11]
    a001d488:	121f7800 	and	w0, w0, #0xfffffffe
    a001d48c:	12001c01 	and	w1, w0, #0xff
    a001d490:	f94017e0 	ldr	x0, [sp, #40]
    a001d494:	39002c01 	strb	w1, [x0, #11]
    a001d498:	14000002 	b	a001d4a0 <z_object_uninit+0x44>
		return;
    a001d49c:	d503201f 	nop
}
    a001d4a0:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a001d4a4:	d65f03c0 	ret

00000000a001d4a8 <user_copy>:
out_err:
	return dst;
}

static int user_copy(void *dst, const void *src, size_t size, bool to_user)
{
    a001d4a8:	d10b03ff 	sub	sp, sp, #0x2c0
    a001d4ac:	a9007bfd 	stp	x29, x30, [sp]
    a001d4b0:	910003fd 	mov	x29, sp
    a001d4b4:	f90017e0 	str	x0, [sp, #40]
    a001d4b8:	f90013e1 	str	x1, [sp, #32]
    a001d4bc:	f9000fe2 	str	x2, [sp, #24]
    a001d4c0:	39005fe3 	strb	w3, [sp, #23]
	int ret = EFAULT;
    a001d4c4:	528001c0 	mov	w0, #0xe                   	// #14
    a001d4c8:	b902bfe0 	str	w0, [sp, #700]

	/* Does the caller in user mode have access to this memory? */
	if (to_user ? Z_SYSCALL_MEMORY_WRITE(dst, size) :
    a001d4cc:	39405fe0 	ldrb	w0, [sp, #23]
    a001d4d0:	7100001f 	cmp	w0, #0x0
    a001d4d4:	54000180 	b.eq	a001d504 <user_copy+0x5c>  // b.none
    a001d4d8:	52800022 	mov	w2, #0x1                   	// #1
    a001d4dc:	f9400fe1 	ldr	x1, [sp, #24]
    a001d4e0:	f94017e0 	ldr	x0, [sp, #40]
    a001d4e4:	97ffb8e2 	bl	a000b86c <arch_buffer_validate>
    a001d4e8:	7100001f 	cmp	w0, #0x0
    a001d4ec:	1a9f07e0 	cset	w0, ne  // ne = any
    a001d4f0:	390aefe0 	strb	w0, [sp, #699]
    a001d4f4:	394aefe0 	ldrb	w0, [sp, #699]
    a001d4f8:	7100001f 	cmp	w0, #0x0
    a001d4fc:	394aefe0 	ldrb	w0, [sp, #699]
    a001d500:	1400000b 	b	a001d52c <user_copy+0x84>
			Z_SYSCALL_MEMORY_READ(src, size)) {
    a001d504:	52800002 	mov	w2, #0x0                   	// #0
    a001d508:	f9400fe1 	ldr	x1, [sp, #24]
    a001d50c:	f94013e0 	ldr	x0, [sp, #32]
    a001d510:	97ffb8d7 	bl	a000b86c <arch_buffer_validate>
    a001d514:	7100001f 	cmp	w0, #0x0
    a001d518:	1a9f07e0 	cset	w0, ne  // ne = any
    a001d51c:	390aebe0 	strb	w0, [sp, #698]
    a001d520:	394aebe0 	ldrb	w0, [sp, #698]
    a001d524:	7100001f 	cmp	w0, #0x0
    a001d528:	394aebe0 	ldrb	w0, [sp, #698]
	if (to_user ? Z_SYSCALL_MEMORY_WRITE(dst, size) :
    a001d52c:	7100001f 	cmp	w0, #0x0
    a001d530:	540000e1 	b.ne	a001d54c <user_copy+0xa4>  // b.any
		goto out_err;
	}

	(void)memcpy(dst, src, size);
    a001d534:	f9400fe2 	ldr	x2, [sp, #24]
    a001d538:	f94013e1 	ldr	x1, [sp, #32]
    a001d53c:	f94017e0 	ldr	x0, [sp, #40]
    a001d540:	97ffba56 	bl	a000be98 <memcpy>
	ret = 0;
    a001d544:	b902bfff 	str	wzr, [sp, #700]
    a001d548:	14000002 	b	a001d550 <user_copy+0xa8>
		goto out_err;
    a001d54c:	d503201f 	nop
out_err:
	return ret;
    a001d550:	b942bfe0 	ldr	w0, [sp, #700]
}
    a001d554:	a9407bfd 	ldp	x29, x30, [sp]
    a001d558:	910b03ff 	add	sp, sp, #0x2c0
    a001d55c:	d65f03c0 	ret

00000000a001d560 <z_user_from_copy>:

int z_user_from_copy(void *dst, const void *src, size_t size)
{
    a001d560:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a001d564:	910003fd 	mov	x29, sp
    a001d568:	f90017e0 	str	x0, [sp, #40]
    a001d56c:	f90013e1 	str	x1, [sp, #32]
    a001d570:	f9000fe2 	str	x2, [sp, #24]
	return user_copy(dst, src, size, false);
    a001d574:	52800003 	mov	w3, #0x0                   	// #0
    a001d578:	f9400fe2 	ldr	x2, [sp, #24]
    a001d57c:	f94013e1 	ldr	x1, [sp, #32]
    a001d580:	f94017e0 	ldr	x0, [sp, #40]
    a001d584:	97ffffc9 	bl	a001d4a8 <user_copy>
}
    a001d588:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a001d58c:	d65f03c0 	ret

00000000a001d590 <z_user_to_copy>:

int z_user_to_copy(void *dst, const void *src, size_t size)
{
    a001d590:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a001d594:	910003fd 	mov	x29, sp
    a001d598:	f90017e0 	str	x0, [sp, #40]
    a001d59c:	f90013e1 	str	x1, [sp, #32]
    a001d5a0:	f9000fe2 	str	x2, [sp, #24]
	return user_copy(dst, src, size, true);
    a001d5a4:	52800023 	mov	w3, #0x1                   	// #1
    a001d5a8:	f9400fe2 	ldr	x2, [sp, #24]
    a001d5ac:	f94013e1 	ldr	x1, [sp, #32]
    a001d5b0:	f94017e0 	ldr	x0, [sp, #40]
    a001d5b4:	97ffffbd 	bl	a001d4a8 <user_copy>
}
    a001d5b8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a001d5bc:	d65f03c0 	ret

00000000a001d5c0 <z_user_string_copy>:
out:
	return ret;
}

int z_user_string_copy(char *dst, const char *src, size_t maxlen)
{
    a001d5c0:	d10843ff 	sub	sp, sp, #0x210
    a001d5c4:	a9007bfd 	stp	x29, x30, [sp]
    a001d5c8:	910003fd 	mov	x29, sp
    a001d5cc:	f90017e0 	str	x0, [sp, #40]
    a001d5d0:	f90013e1 	str	x1, [sp, #32]
    a001d5d4:	f9000fe2 	str	x2, [sp, #24]
	size_t actual_len;
	int ret, err;

	actual_len = z_user_string_nlen(src, maxlen, &err);
    a001d5d8:	9107f3e0 	add	x0, sp, #0x1fc
    a001d5dc:	aa0003e2 	mov	x2, x0
    a001d5e0:	f9400fe1 	ldr	x1, [sp, #24]
    a001d5e4:	f94013e0 	ldr	x0, [sp, #32]
    a001d5e8:	97fffb5b 	bl	a001c354 <z_user_string_nlen>
    a001d5ec:	f90103e0 	str	x0, [sp, #512]
	if (err != 0) {
    a001d5f0:	b941ffe0 	ldr	w0, [sp, #508]
    a001d5f4:	7100001f 	cmp	w0, #0x0
    a001d5f8:	54000080 	b.eq	a001d608 <z_user_string_copy+0x48>  // b.none
		ret = EFAULT;
    a001d5fc:	528001c0 	mov	w0, #0xe                   	// #14
    a001d600:	b9020fe0 	str	w0, [sp, #524]
		goto out;
    a001d604:	1400001e 	b	a001d67c <z_user_string_copy+0xbc>
	}
	if (actual_len == maxlen) {
    a001d608:	f94103e0 	ldr	x0, [sp, #512]
    a001d60c:	f9400fe1 	ldr	x1, [sp, #24]
    a001d610:	eb00003f 	cmp	x1, x0
    a001d614:	54000081 	b.ne	a001d624 <z_user_string_copy+0x64>  // b.any
		/* Not NULL terminated */
		LOG_ERR("string too long %p (%zu)", src, actual_len);
		ret = EINVAL;
    a001d618:	528002c0 	mov	w0, #0x16                  	// #22
    a001d61c:	b9020fe0 	str	w0, [sp, #524]
		goto out;
    a001d620:	14000017 	b	a001d67c <z_user_string_copy+0xbc>
	}
	if (size_add_overflow(actual_len, 1, &actual_len)) {
    a001d624:	f94103e0 	ldr	x0, [sp, #512]
    a001d628:	910803e1 	add	x1, sp, #0x200
    a001d62c:	aa0103e2 	mov	x2, x1
    a001d630:	d2800021 	mov	x1, #0x1                   	// #1
    a001d634:	97fffb36 	bl	a001c30c <size_add_overflow>
    a001d638:	12001c00 	and	w0, w0, #0xff
    a001d63c:	7100001f 	cmp	w0, #0x0
    a001d640:	54000080 	b.eq	a001d650 <z_user_string_copy+0x90>  // b.none
		LOG_ERR("overflow");
		ret = EINVAL;
    a001d644:	528002c0 	mov	w0, #0x16                  	// #22
    a001d648:	b9020fe0 	str	w0, [sp, #524]
		goto out;
    a001d64c:	1400000c 	b	a001d67c <z_user_string_copy+0xbc>
	}

	ret = z_user_from_copy(dst, src, actual_len);
    a001d650:	f94103e0 	ldr	x0, [sp, #512]
    a001d654:	aa0003e2 	mov	x2, x0
    a001d658:	f94013e1 	ldr	x1, [sp, #32]
    a001d65c:	f94017e0 	ldr	x0, [sp, #40]
    a001d660:	97ffffc0 	bl	a001d560 <z_user_from_copy>
    a001d664:	b9020fe0 	str	w0, [sp, #524]

	/* See comment above in z_user_string_alloc_copy() */
	dst[actual_len - 1] = '\0';
    a001d668:	f94103e0 	ldr	x0, [sp, #512]
    a001d66c:	d1000400 	sub	x0, x0, #0x1
    a001d670:	f94017e1 	ldr	x1, [sp, #40]
    a001d674:	8b000020 	add	x0, x1, x0
    a001d678:	3900001f 	strb	wzr, [x0]
out:
	return ret;
    a001d67c:	b9420fe0 	ldr	w0, [sp, #524]
}
    a001d680:	a9407bfd 	ldp	x29, x30, [sp]
    a001d684:	910843ff 	add	sp, sp, #0x210
    a001d688:	d65f03c0 	ret

00000000a001d68c <app_shmem_bss_zero>:

extern char __app_shmem_regions_start[];
extern char __app_shmem_regions_end[];

static int app_shmem_bss_zero(const struct device *unused)
{
    a001d68c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a001d690:	910003fd 	mov	x29, sp
    a001d694:	f9000fe0 	str	x0, [sp, #24]
	struct z_app_region *region, *end;

	ARG_UNUSED(unused);

	end = (struct z_app_region *)&__app_shmem_regions_end;
    a001d698:	d0000020 	adrp	x0, a0023000 <__rodata_region_start>
    a001d69c:	913a4000 	add	x0, x0, #0xe90
    a001d6a0:	f90013e0 	str	x0, [sp, #32]
	region = (struct z_app_region *)&__app_shmem_regions_start;
    a001d6a4:	d0000020 	adrp	x0, a0023000 <__rodata_region_start>
    a001d6a8:	913a0000 	add	x0, x0, #0xe80
    a001d6ac:	f90017e0 	str	x0, [sp, #40]

	for ( ; region < end; region++) {
    a001d6b0:	1400000c 	b	a001d6e0 <app_shmem_bss_zero+0x54>
		}

		if (do_clear)
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */
		{
			(void)memset(region->bss_start, 0, region->bss_size);
    a001d6b4:	f94017e0 	ldr	x0, [sp, #40]
    a001d6b8:	f9400003 	ldr	x3, [x0]
    a001d6bc:	f94017e0 	ldr	x0, [sp, #40]
    a001d6c0:	f9400400 	ldr	x0, [x0, #8]
    a001d6c4:	aa0003e2 	mov	x2, x0
    a001d6c8:	52800001 	mov	w1, #0x0                   	// #0
    a001d6cc:	aa0303e0 	mov	x0, x3
    a001d6d0:	97ffba0c 	bl	a000bf00 <memset>
	for ( ; region < end; region++) {
    a001d6d4:	f94017e0 	ldr	x0, [sp, #40]
    a001d6d8:	91004000 	add	x0, x0, #0x10
    a001d6dc:	f90017e0 	str	x0, [sp, #40]
    a001d6e0:	f94017e1 	ldr	x1, [sp, #40]
    a001d6e4:	f94013e0 	ldr	x0, [sp, #32]
    a001d6e8:	eb00003f 	cmp	x1, x0
    a001d6ec:	54fffe43 	b.cc	a001d6b4 <app_shmem_bss_zero+0x28>  // b.lo, b.ul, b.last
		}
	}

	return 0;
    a001d6f0:	52800000 	mov	w0, #0x0                   	// #0
}
    a001d6f4:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a001d6f8:	d65f03c0 	ret

00000000a001d6fc <handler_bad_syscall>:

static uintptr_t handler_bad_syscall(uintptr_t bad_id, uintptr_t arg2,
				     uintptr_t arg3, uintptr_t arg4,
				     uintptr_t arg5, uintptr_t arg6,
				     void *ssf)
{
    a001d6fc:	a9a57bfd 	stp	x29, x30, [sp, #-432]!
    a001d700:	910003fd 	mov	x29, sp
    a001d704:	f90027e0 	str	x0, [sp, #72]
    a001d708:	f90023e1 	str	x1, [sp, #64]
    a001d70c:	f9001fe2 	str	x2, [sp, #56]
    a001d710:	f9001be3 	str	x3, [sp, #48]
    a001d714:	f90017e4 	str	x4, [sp, #40]
    a001d718:	f90013e5 	str	x5, [sp, #32]
    a001d71c:	f9000fe6 	str	x6, [sp, #24]
	LOG_ERR("Bad system call id %" PRIuPTR " invoked", bad_id);
	arch_syscall_oops(ssf);
    a001d720:	f9400fe0 	ldr	x0, [sp, #24]
    a001d724:	97ffae8d 	bl	a0009158 <arch_syscall_oops>

00000000a001d728 <z_mrsh_adc_channel_setup>:
}

static uintptr_t handler_no_syscall(uintptr_t arg1, uintptr_t arg2,
				    uintptr_t arg3, uintptr_t arg4,
				    uintptr_t arg5, uintptr_t arg6, void *ssf)
{
    a001d728:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a001d72c:	910003fd 	mov	x29, sp
    a001d730:	f90027e0 	str	x0, [sp, #72]
    a001d734:	f90023e1 	str	x1, [sp, #64]
    a001d738:	f9001fe2 	str	x2, [sp, #56]
    a001d73c:	f9001be3 	str	x3, [sp, #48]
    a001d740:	f90017e4 	str	x4, [sp, #40]
    a001d744:	f90013e5 	str	x5, [sp, #32]
    a001d748:	f9000fe6 	str	x6, [sp, #24]
	LOG_ERR("Unimplemented system call");
	arch_syscall_oops(ssf);
    a001d74c:	f9400fe0 	ldr	x0, [sp, #24]
    a001d750:	97ffae82 	bl	a0009158 <arch_syscall_oops>

00000000a001d754 <arch_syscall_invoke1>:
{
    a001d754:	d10043ff 	sub	sp, sp, #0x10
    a001d758:	f90007e0 	str	x0, [sp, #8]
    a001d75c:	f90003e1 	str	x1, [sp]
	register uint64_t ret __asm__("x0") = arg1;
    a001d760:	f94007e0 	ldr	x0, [sp, #8]
	register uint64_t r8 __asm__("x8") = call_id;
    a001d764:	f94003e8 	ldr	x8, [sp]
	__asm__ volatile("svc %[svid]\n"
    a001d768:	d4000061 	svc	#0x3
}
    a001d76c:	910043ff 	add	sp, sp, #0x10
    a001d770:	d65f03c0 	ret

00000000a001d774 <k_busy_wait>:
{
    a001d774:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a001d778:	910003fd 	mov	x29, sp
    a001d77c:	b9001fe0 	str	w0, [sp, #28]
	bool ret = false;
    a001d780:	3900bfff 	strb	wzr, [sp, #47]
	ret = false;
    a001d784:	3900bfff 	strb	wzr, [sp, #47]
	return ret;
    a001d788:	3940bfe0 	ldrb	w0, [sp, #47]
	if (z_syscall_trap()) {
    a001d78c:	7100001f 	cmp	w0, #0x0
    a001d790:	540000c0 	b.eq	a001d7a8 <k_busy_wait+0x34>  // b.none
		arch_syscall_invoke1(*(uintptr_t *)&usec_to_wait, K_SYSCALL_K_BUSY_WAIT);
    a001d794:	910073e0 	add	x0, sp, #0x1c
    a001d798:	f9400000 	ldr	x0, [x0]
    a001d79c:	d2801001 	mov	x1, #0x80                  	// #128
    a001d7a0:	97ffffed 	bl	a001d754 <arch_syscall_invoke1>
		return;
    a001d7a4:	14000003 	b	a001d7b0 <k_busy_wait+0x3c>
	z_impl_k_busy_wait(usec_to_wait);
    a001d7a8:	b9401fe0 	ldr	w0, [sp, #28]
    a001d7ac:	97fff2f3 	bl	a001a378 <z_impl_k_busy_wait>
}
    a001d7b0:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a001d7b4:	d65f03c0 	ret

00000000a001d7b8 <boot_banner>:
#define BOOT_DELAY_BANNER ""
#endif

#if defined(CONFIG_BOOT_DELAY) || CONFIG_BOOT_DELAY > 0
void boot_banner(void)
{
    a001d7b8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    a001d7bc:	910003fd 	mov	x29, sp
	static const unsigned int boot_delay = CONFIG_BOOT_DELAY;
#else
	static const unsigned int boot_delay;
#endif

	if (boot_delay > 0 && IS_ENABLED(CONFIG_MULTITHREADING)) {
    a001d7c0:	90000040 	adrp	x0, a0025000 <_k_syscall_table+0x7c8>
    a001d7c4:	910d6000 	add	x0, x0, #0x358
    a001d7c8:	b9400000 	ldr	w0, [x0]
    a001d7cc:	7100001f 	cmp	w0, #0x0
    a001d7d0:	540000c0 	b.eq	a001d7e8 <boot_banner+0x30>  // b.none
		printk("***** delaying boot " STRINGIFY(
    a001d7d4:	f0000020 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a001d7d8:	91118000 	add	x0, x0, #0x460
    a001d7dc:	97ff98a9 	bl	a0003a80 <printk>
			CONFIG_BOOT_DELAY) "ms (per build configuration) *****\n");
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
    a001d7e0:	52800000 	mov	w0, #0x0                   	// #0
    a001d7e4:	97ffffe4 	bl	a001d774 <k_busy_wait>
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
    a001d7e8:	f0000020 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a001d7ec:	91128002 	add	x2, x0, #0x4a0
    a001d7f0:	f0000020 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a001d7f4:	9112a001 	add	x1, x0, #0x4a8
    a001d7f8:	f0000020 	adrp	x0, a0024000 <_kobject_rodata_area_used+0x68>
    a001d7fc:	91132000 	add	x0, x0, #0x4c8
    a001d800:	97ff98a0 	bl	a0003a80 <printk>
#else
	printk("*** Booting Zephyr OS version %s %s ***\n",
	       KERNEL_VERSION_STRING, BOOT_DELAY_BANNER);
#endif
#endif
}
    a001d804:	d503201f 	nop
    a001d808:	a8c17bfd 	ldp	x29, x30, [sp], #16
    a001d80c:	d65f03c0 	ret

00000000a001d810 <sys_dlist_init>:
{
    a001d810:	d10043ff 	sub	sp, sp, #0x10
    a001d814:	f90007e0 	str	x0, [sp, #8]
	list->head = (sys_dnode_t *)list;
    a001d818:	f94007e0 	ldr	x0, [sp, #8]
    a001d81c:	f94007e1 	ldr	x1, [sp, #8]
    a001d820:	f9000001 	str	x1, [x0]
	list->tail = (sys_dnode_t *)list;
    a001d824:	f94007e0 	ldr	x0, [sp, #8]
    a001d828:	f94007e1 	ldr	x1, [sp, #8]
    a001d82c:	f9000401 	str	x1, [x0, #8]
}
    a001d830:	d503201f 	nop
    a001d834:	910043ff 	add	sp, sp, #0x10
    a001d838:	d65f03c0 	ret

00000000a001d83c <z_waitq_init>:
{
    a001d83c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a001d840:	910003fd 	mov	x29, sp
    a001d844:	f9000fe0 	str	x0, [sp, #24]
	sys_dlist_init(&w->waitq);
    a001d848:	f9400fe0 	ldr	x0, [sp, #24]
    a001d84c:	97fffff1 	bl	a001d810 <sys_dlist_init>
}
    a001d850:	d503201f 	nop
    a001d854:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a001d858:	d65f03c0 	ret

00000000a001d85c <k_heap_init>:
#include <wait_q.h>
#include <init.h>
#include <linker/linker-defs.h>

void k_heap_init(struct k_heap *h, void *mem, size_t bytes)
{
    a001d85c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a001d860:	910003fd 	mov	x29, sp
    a001d864:	f90017e0 	str	x0, [sp, #40]
    a001d868:	f90013e1 	str	x1, [sp, #32]
    a001d86c:	f9000fe2 	str	x2, [sp, #24]
	z_waitq_init(&h->wait_q);
    a001d870:	f94017e0 	ldr	x0, [sp, #40]
    a001d874:	91006000 	add	x0, x0, #0x18
    a001d878:	97fffff1 	bl	a001d83c <z_waitq_init>
	sys_heap_init(&h->heap, mem, bytes);
    a001d87c:	f94017e0 	ldr	x0, [sp, #40]
    a001d880:	f9400fe2 	ldr	x2, [sp, #24]
    a001d884:	f94013e1 	ldr	x1, [sp, #32]
    a001d888:	97ffa12e 	bl	a0005d40 <sys_heap_init>

	SYS_PORT_TRACING_OBJ_INIT(k_heap, h);
}
    a001d88c:	d503201f 	nop
    a001d890:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a001d894:	d65f03c0 	ret

00000000a001d898 <statics_init>:

static int statics_init(const struct device *unused)
{
    a001d898:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a001d89c:	910003fd 	mov	x29, sp
    a001d8a0:	f9000fe0 	str	x0, [sp, #24]
	ARG_UNUSED(unused);
	STRUCT_SECTION_FOREACH(k_heap, h) {
    a001d8a4:	d00003e0 	adrp	x0, a009b000 <twom1000.10>
    a001d8a8:	9102d000 	add	x0, x0, #0xb4
    a001d8ac:	f90017e0 	str	x0, [sp, #40]
    a001d8b0:	1400000b 	b	a001d8dc <statics_init+0x44>
		}

		if (do_clear)
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */
		{
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
    a001d8b4:	f94017e0 	ldr	x0, [sp, #40]
    a001d8b8:	f9400401 	ldr	x1, [x0, #8]
    a001d8bc:	f94017e0 	ldr	x0, [sp, #40]
    a001d8c0:	f9400800 	ldr	x0, [x0, #16]
    a001d8c4:	aa0003e2 	mov	x2, x0
    a001d8c8:	f94017e0 	ldr	x0, [sp, #40]
    a001d8cc:	97ffffe4 	bl	a001d85c <k_heap_init>
	STRUCT_SECTION_FOREACH(k_heap, h) {
    a001d8d0:	f94017e0 	ldr	x0, [sp, #40]
    a001d8d4:	9100a000 	add	x0, x0, #0x28
    a001d8d8:	f90017e0 	str	x0, [sp, #40]
    a001d8dc:	f94017e1 	ldr	x1, [sp, #40]
    a001d8e0:	d00003e0 	adrp	x0, a009b000 <twom1000.10>
    a001d8e4:	9102d000 	add	x0, x0, #0xb4
    a001d8e8:	eb00003f 	cmp	x1, x0
    a001d8ec:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
    a001d8f0:	12001c00 	and	w0, w0, #0xff
    a001d8f4:	7100001f 	cmp	w0, #0x0
    a001d8f8:	54fffde1 	b.ne	a001d8b4 <statics_init+0x1c>  // b.any
		}
	}
	return 0;
    a001d8fc:	52800000 	mov	w0, #0x0                   	// #0
}
    a001d900:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a001d904:	d65f03c0 	ret

00000000a001d908 <k_heap_aligned_alloc>:
SYS_INIT(statics_init, POST_KERNEL, 0);
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */

void *k_heap_aligned_alloc(struct k_heap *h, size_t align, size_t bytes,
			k_timeout_t timeout)
{
    a001d908:	a9b47bfd 	stp	x29, x30, [sp, #-192]!
    a001d90c:	910003fd 	mov	x29, sp
    a001d910:	f90017e0 	str	x0, [sp, #40]
    a001d914:	f90013e1 	str	x1, [sp, #32]
    a001d918:	f9000fe2 	str	x2, [sp, #24]
    a001d91c:	f9000be3 	str	x3, [sp, #16]
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
    a001d920:	f9400be0 	ldr	x0, [sp, #16]
    a001d924:	97fff2c1 	bl	a001a428 <sys_clock_timeout_end_calc>
    a001d928:	f90057e0 	str	x0, [sp, #168]
	void *ret = NULL;
    a001d92c:	f9005fff 	str	xzr, [sp, #184]
	k_spinlock_key_t key = k_spin_lock(&h->lock);
    a001d930:	f94017e0 	ldr	x0, [sp, #40]
    a001d934:	9100a000 	add	x0, x0, #0x28
    a001d938:	f9004fe0 	str	x0, [sp, #152]
    a001d93c:	d53b4220 	mrs	x0, daif
    a001d940:	f9004be0 	str	x0, [sp, #144]
    a001d944:	f9404be0 	ldr	x0, [sp, #144]
    a001d948:	d503201f 	nop
	key = read_daif();
    a001d94c:	b9008fe0 	str	w0, [sp, #140]
	__asm__ volatile ("msr DAIFSet, %0"
    a001d950:	d50342df 	msr	daifset, #0x2
}
    a001d954:	d503201f 	nop
	return key;
    a001d958:	b9408fe0 	ldr	w0, [sp, #140]
	k.key = arch_irq_lock();
    a001d95c:	b90043e0 	str	w0, [sp, #64]
	return k;
    a001d960:	b94043e0 	ldr	w0, [sp, #64]
    a001d964:	b90053e0 	str	w0, [sp, #80]

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap, aligned_alloc, h, timeout);

	__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), "");

	bool blocked_alloc = false;
    a001d968:	3902dfff 	strb	wzr, [sp, #183]

	while (ret == NULL) {
    a001d96c:	14000030 	b	a001da2c <k_heap_aligned_alloc+0x124>
		ret = sys_heap_aligned_alloc(&h->heap, align, bytes);
    a001d970:	f94017e0 	ldr	x0, [sp, #40]
    a001d974:	f9400fe2 	ldr	x2, [sp, #24]
    a001d978:	f94013e1 	ldr	x1, [sp, #32]
    a001d97c:	97ffa063 	bl	a0005b08 <sys_heap_aligned_alloc>
    a001d980:	f9005fe0 	str	x0, [sp, #184]

		now = sys_clock_tick_get();
    a001d984:	97fff227 	bl	a001a220 <sys_clock_tick_get>
    a001d988:	f90053e0 	str	x0, [sp, #160]
		if (!IS_ENABLED(CONFIG_MULTITHREADING) ||
    a001d98c:	f9405fe0 	ldr	x0, [sp, #184]
    a001d990:	f100001f 	cmp	x0, #0x0
    a001d994:	54000521 	b.ne	a001da38 <k_heap_aligned_alloc+0x130>  // b.any
		    (ret != NULL) || ((end - now) <= 0)) {
    a001d998:	f94057e1 	ldr	x1, [sp, #168]
    a001d99c:	f94053e0 	ldr	x0, [sp, #160]
    a001d9a0:	cb000020 	sub	x0, x1, x0
    a001d9a4:	f100001f 	cmp	x0, #0x0
    a001d9a8:	5400048d 	b.le	a001da38 <k_heap_aligned_alloc+0x130>
			break;
		}

		if (!blocked_alloc) {
    a001d9ac:	3942dfe0 	ldrb	w0, [sp, #183]
    a001d9b0:	52000000 	eor	w0, w0, #0x1
    a001d9b4:	12001c00 	and	w0, w0, #0xff
    a001d9b8:	7100001f 	cmp	w0, #0x0
    a001d9bc:	54000060 	b.eq	a001d9c8 <k_heap_aligned_alloc+0xc0>  // b.none
			blocked_alloc = true;
    a001d9c0:	52800020 	mov	w0, #0x1                   	// #1
    a001d9c4:	3902dfe0 	strb	w0, [sp, #183]
			/**
			 * @todo	Trace attempt to avoid empty trace segments
			 */
		}

		(void) z_pend_curr(&h->lock, key, &h->wait_q,
    a001d9c8:	f94017e0 	ldr	x0, [sp, #40]
    a001d9cc:	9100a004 	add	x4, x0, #0x28
    a001d9d0:	f94017e0 	ldr	x0, [sp, #40]
    a001d9d4:	91006002 	add	x2, x0, #0x18
				   K_TICKS(end - now));
    a001d9d8:	f94057e1 	ldr	x1, [sp, #168]
    a001d9dc:	f94053e0 	ldr	x0, [sp, #160]
    a001d9e0:	cb000020 	sub	x0, x1, x0
		(void) z_pend_curr(&h->lock, key, &h->wait_q,
    a001d9e4:	aa0003e3 	mov	x3, x0
    a001d9e8:	b94053e1 	ldr	w1, [sp, #80]
    a001d9ec:	aa0403e0 	mov	x0, x4
    a001d9f0:	97ffe84b 	bl	a0017b1c <z_pend_curr>
		key = k_spin_lock(&h->lock);
    a001d9f4:	f94017e0 	ldr	x0, [sp, #40]
    a001d9f8:	9100a000 	add	x0, x0, #0x28
    a001d9fc:	f90043e0 	str	x0, [sp, #128]
MAKE_REG_HELPER(daif)
    a001da00:	d53b4220 	mrs	x0, daif
    a001da04:	f9003fe0 	str	x0, [sp, #120]
    a001da08:	f9403fe0 	ldr	x0, [sp, #120]
    a001da0c:	d503201f 	nop
	key = read_daif();
    a001da10:	b90077e0 	str	w0, [sp, #116]
	__asm__ volatile ("msr DAIFSet, %0"
    a001da14:	d50342df 	msr	daifset, #0x2
}
    a001da18:	d503201f 	nop
	return key;
    a001da1c:	b94077e0 	ldr	w0, [sp, #116]
	k.key = arch_irq_lock();
    a001da20:	b9003be0 	str	w0, [sp, #56]
	return k;
    a001da24:	b9403be0 	ldr	w0, [sp, #56]
    a001da28:	b90053e0 	str	w0, [sp, #80]
	while (ret == NULL) {
    a001da2c:	f9405fe0 	ldr	x0, [sp, #184]
    a001da30:	f100001f 	cmp	x0, #0x0
    a001da34:	54fff9e0 	b.eq	a001d970 <k_heap_aligned_alloc+0x68>  // b.none
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap, aligned_alloc, h, timeout, ret);

	k_spin_unlock(&h->lock, key);
    a001da38:	f94017e0 	ldr	x0, [sp, #40]
    a001da3c:	9100a000 	add	x0, x0, #0x28
    a001da40:	f90037e0 	str	x0, [sp, #104]
    a001da44:	b94053e0 	ldr	w0, [sp, #80]
    a001da48:	b9004be0 	str	w0, [sp, #72]
	arch_irq_unlock(key.key);
    a001da4c:	b9404be0 	ldr	w0, [sp, #72]
    a001da50:	b90067e0 	str	w0, [sp, #100]
	write_daif(key);
    a001da54:	b94067e0 	ldr	w0, [sp, #100]
    a001da58:	f9002fe0 	str	x0, [sp, #88]
MAKE_REG_HELPER(daif)
    a001da5c:	f9402fe0 	ldr	x0, [sp, #88]
    a001da60:	d51b4220 	msr	daif, x0
    a001da64:	d503201f 	nop
}
    a001da68:	d503201f 	nop
}
    a001da6c:	d503201f 	nop
	return ret;
    a001da70:	f9405fe0 	ldr	x0, [sp, #184]
}
    a001da74:	a8cc7bfd 	ldp	x29, x30, [sp], #192
    a001da78:	d65f03c0 	ret

00000000a001da7c <k_heap_free>:

	return ret;
}

void k_heap_free(struct k_heap *h, void *mem)
{
    a001da7c:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    a001da80:	910003fd 	mov	x29, sp
    a001da84:	f9000fe0 	str	x0, [sp, #24]
    a001da88:	f9000be1 	str	x1, [sp, #16]
	k_spinlock_key_t key = k_spin_lock(&h->lock);
    a001da8c:	f9400fe0 	ldr	x0, [sp, #24]
    a001da90:	9100a000 	add	x0, x0, #0x28
    a001da94:	f90037e0 	str	x0, [sp, #104]
    a001da98:	d53b4220 	mrs	x0, daif
    a001da9c:	f90033e0 	str	x0, [sp, #96]
    a001daa0:	f94033e0 	ldr	x0, [sp, #96]
    a001daa4:	d503201f 	nop
	key = read_daif();
    a001daa8:	b9005fe0 	str	w0, [sp, #92]
	__asm__ volatile ("msr DAIFSet, %0"
    a001daac:	d50342df 	msr	daifset, #0x2
}
    a001dab0:	d503201f 	nop
	return key;
    a001dab4:	b9405fe0 	ldr	w0, [sp, #92]
	k.key = arch_irq_lock();
    a001dab8:	b9002be0 	str	w0, [sp, #40]
	return k;
    a001dabc:	b9402be0 	ldr	w0, [sp, #40]
    a001dac0:	b9003be0 	str	w0, [sp, #56]

	sys_heap_free(&h->heap, mem);
    a001dac4:	f9400fe0 	ldr	x0, [sp, #24]
    a001dac8:	f9400be1 	ldr	x1, [sp, #16]
    a001dacc:	97ff9f62 	bl	a0005854 <sys_heap_free>

	SYS_PORT_TRACING_OBJ_FUNC(k_heap, free, h);
	if (IS_ENABLED(CONFIG_MULTITHREADING) && z_unpend_all(&h->wait_q) != 0) {
    a001dad0:	f9400fe0 	ldr	x0, [sp, #24]
    a001dad4:	91006000 	add	x0, x0, #0x18
    a001dad8:	97ffea5f 	bl	a0018454 <z_unpend_all>
    a001dadc:	7100001f 	cmp	w0, #0x0
    a001dae0:	540000c0 	b.eq	a001daf8 <k_heap_free+0x7c>  // b.none
		z_reschedule(&h->lock, key);
    a001dae4:	f9400fe0 	ldr	x0, [sp, #24]
    a001dae8:	9100a000 	add	x0, x0, #0x28
    a001daec:	b9403be1 	ldr	w1, [sp, #56]
    a001daf0:	97ffe98b 	bl	a001811c <z_reschedule>
	} else {
		k_spin_unlock(&h->lock, key);
	}
}
    a001daf4:	1400000f 	b	a001db30 <k_heap_free+0xb4>
		k_spin_unlock(&h->lock, key);
    a001daf8:	f9400fe0 	ldr	x0, [sp, #24]
    a001dafc:	9100a000 	add	x0, x0, #0x28
    a001db00:	f9002be0 	str	x0, [sp, #80]
    a001db04:	b9403be0 	ldr	w0, [sp, #56]
    a001db08:	b90033e0 	str	w0, [sp, #48]
	arch_irq_unlock(key.key);
    a001db0c:	b94033e0 	ldr	w0, [sp, #48]
    a001db10:	b9004fe0 	str	w0, [sp, #76]
	write_daif(key);
    a001db14:	b9404fe0 	ldr	w0, [sp, #76]
    a001db18:	f90023e0 	str	x0, [sp, #64]
MAKE_REG_HELPER(daif)
    a001db1c:	f94023e0 	ldr	x0, [sp, #64]
    a001db20:	d51b4220 	msr	daif, x0
    a001db24:	d503201f 	nop
}
    a001db28:	d503201f 	nop
}
    a001db2c:	d503201f 	nop
}
    a001db30:	d503201f 	nop
    a001db34:	a8c77bfd 	ldp	x29, x30, [sp], #112
    a001db38:	d65f03c0 	ret

00000000a001db3c <sys_dlist_init>:
{
    a001db3c:	d10043ff 	sub	sp, sp, #0x10
    a001db40:	f90007e0 	str	x0, [sp, #8]
	list->head = (sys_dnode_t *)list;
    a001db44:	f94007e0 	ldr	x0, [sp, #8]
    a001db48:	f94007e1 	ldr	x1, [sp, #8]
    a001db4c:	f9000001 	str	x1, [x0]
	list->tail = (sys_dnode_t *)list;
    a001db50:	f94007e0 	ldr	x0, [sp, #8]
    a001db54:	f94007e1 	ldr	x1, [sp, #8]
    a001db58:	f9000401 	str	x1, [x0, #8]
}
    a001db5c:	d503201f 	nop
    a001db60:	910043ff 	add	sp, sp, #0x10
    a001db64:	d65f03c0 	ret

00000000a001db68 <sys_dlist_is_empty>:
{
    a001db68:	d10043ff 	sub	sp, sp, #0x10
    a001db6c:	f90007e0 	str	x0, [sp, #8]
	return list->head == list;
    a001db70:	f94007e0 	ldr	x0, [sp, #8]
    a001db74:	f9400000 	ldr	x0, [x0]
    a001db78:	f94007e1 	ldr	x1, [sp, #8]
    a001db7c:	eb00003f 	cmp	x1, x0
    a001db80:	1a9f17e0 	cset	w0, eq  // eq = none
    a001db84:	12001c00 	and	w0, w0, #0xff
}
    a001db88:	910043ff 	add	sp, sp, #0x10
    a001db8c:	d65f03c0 	ret

00000000a001db90 <sys_dlist_peek_head>:
{
    a001db90:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a001db94:	910003fd 	mov	x29, sp
    a001db98:	f9000fe0 	str	x0, [sp, #24]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    a001db9c:	f9400fe0 	ldr	x0, [sp, #24]
    a001dba0:	97fffff2 	bl	a001db68 <sys_dlist_is_empty>
    a001dba4:	12001c00 	and	w0, w0, #0xff
    a001dba8:	7100001f 	cmp	w0, #0x0
    a001dbac:	54000081 	b.ne	a001dbbc <sys_dlist_peek_head+0x2c>  // b.any
    a001dbb0:	f9400fe0 	ldr	x0, [sp, #24]
    a001dbb4:	f9400000 	ldr	x0, [x0]
    a001dbb8:	14000002 	b	a001dbc0 <sys_dlist_peek_head+0x30>
    a001dbbc:	d2800000 	mov	x0, #0x0                   	// #0
}
    a001dbc0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a001dbc4:	d65f03c0 	ret

00000000a001dbc8 <z_impl_k_msgq_num_free_get>:
{
    a001dbc8:	d10043ff 	sub	sp, sp, #0x10
    a001dbcc:	f90007e0 	str	x0, [sp, #8]
	return msgq->max_msgs - msgq->used_msgs;
    a001dbd0:	f94007e0 	ldr	x0, [sp, #8]
    a001dbd4:	b9401801 	ldr	w1, [x0, #24]
    a001dbd8:	f94007e0 	ldr	x0, [sp, #8]
    a001dbdc:	b9404000 	ldr	w0, [x0, #64]
    a001dbe0:	4b000020 	sub	w0, w1, w0
}
    a001dbe4:	910043ff 	add	sp, sp, #0x10
    a001dbe8:	d65f03c0 	ret

00000000a001dbec <z_impl_k_msgq_num_used_get>:
{
    a001dbec:	d10043ff 	sub	sp, sp, #0x10
    a001dbf0:	f90007e0 	str	x0, [sp, #8]
	return msgq->used_msgs;
    a001dbf4:	f94007e0 	ldr	x0, [sp, #8]
    a001dbf8:	b9404000 	ldr	w0, [x0, #64]
}
    a001dbfc:	910043ff 	add	sp, sp, #0x10
    a001dc00:	d65f03c0 	ret

00000000a001dc04 <z_thread_malloc>:
{
    a001dc04:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a001dc08:	910003fd 	mov	x29, sp
    a001dc0c:	f9000fe0 	str	x0, [sp, #24]
	return z_thread_aligned_alloc(0, size);
    a001dc10:	f9400fe1 	ldr	x1, [sp, #24]
    a001dc14:	d2800000 	mov	x0, #0x0                   	// #0
    a001dc18:	97fff6b3 	bl	a001b6e4 <z_thread_aligned_alloc>
}
    a001dc1c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a001dc20:	d65f03c0 	ret

00000000a001dc24 <z_waitq_init>:
{
    a001dc24:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a001dc28:	910003fd 	mov	x29, sp
    a001dc2c:	f9000fe0 	str	x0, [sp, #24]
	sys_dlist_init(&w->waitq);
    a001dc30:	f9400fe0 	ldr	x0, [sp, #24]
    a001dc34:	97ffffc2 	bl	a001db3c <sys_dlist_init>
}
    a001dc38:	d503201f 	nop
    a001dc3c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a001dc40:	d65f03c0 	ret

00000000a001dc44 <z_waitq_head>:
{
    a001dc44:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a001dc48:	910003fd 	mov	x29, sp
    a001dc4c:	f9000fe0 	str	x0, [sp, #24]
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
    a001dc50:	f9400fe0 	ldr	x0, [sp, #24]
    a001dc54:	97ffffcf 	bl	a001db90 <sys_dlist_peek_head>
}
    a001dc58:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a001dc5c:	d65f03c0 	ret

00000000a001dc60 <size_mul_overflow>:
{
    a001dc60:	d10083ff 	sub	sp, sp, #0x20
    a001dc64:	f9000fe0 	str	x0, [sp, #24]
    a001dc68:	f9000be1 	str	x1, [sp, #16]
    a001dc6c:	f90007e2 	str	x2, [sp, #8]
	return __builtin_mul_overflow(a, b, result);
    a001dc70:	d2800002 	mov	x2, #0x0                   	// #0
    a001dc74:	f9400fe1 	ldr	x1, [sp, #24]
    a001dc78:	f9400be0 	ldr	x0, [sp, #16]
    a001dc7c:	9b007c23 	mul	x3, x1, x0
    a001dc80:	9bc07c20 	umulh	x0, x1, x0
    a001dc84:	aa0303e4 	mov	x4, x3
    a001dc88:	aa0003e5 	mov	x5, x0
    a001dc8c:	aa0503e6 	mov	x6, x5
    a001dc90:	d2800007 	mov	x7, #0x0                   	// #0
    a001dc94:	f10000df 	cmp	x6, #0x0
    a001dc98:	54000040 	b.eq	a001dca0 <size_mul_overflow+0x40>  // b.none
    a001dc9c:	d2800022 	mov	x2, #0x1                   	// #1
    a001dca0:	aa0403e0 	mov	x0, x4
    a001dca4:	aa0003e1 	mov	x1, x0
    a001dca8:	f94007e0 	ldr	x0, [sp, #8]
    a001dcac:	f9000001 	str	x1, [x0]
    a001dcb0:	aa0203e0 	mov	x0, x2
    a001dcb4:	12000000 	and	w0, w0, #0x1
    a001dcb8:	12001c00 	and	w0, w0, #0xff
}
    a001dcbc:	910083ff 	add	sp, sp, #0x20
    a001dcc0:	d65f03c0 	ret

00000000a001dcc4 <z_obj_validation_check>:
{
    a001dcc4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    a001dcc8:	910003fd 	mov	x29, sp
    a001dccc:	f90017e0 	str	x0, [sp, #40]
    a001dcd0:	f90013e1 	str	x1, [sp, #32]
    a001dcd4:	b9001fe2 	str	w2, [sp, #28]
    a001dcd8:	b9001be3 	str	w3, [sp, #24]
	ret = z_object_validate(ko, otype, init);
    a001dcdc:	b9401be2 	ldr	w2, [sp, #24]
    a001dce0:	b9401fe1 	ldr	w1, [sp, #28]
    a001dce4:	f94017e0 	ldr	x0, [sp, #40]
    a001dce8:	97fffd77 	bl	a001d2c4 <z_object_validate>
    a001dcec:	b9003fe0 	str	w0, [sp, #60]
	return ret;
    a001dcf0:	b9403fe0 	ldr	w0, [sp, #60]
}
    a001dcf4:	a8c47bfd 	ldp	x29, x30, [sp], #64
    a001dcf8:	d65f03c0 	ret

00000000a001dcfc <k_msgq_init>:
}
#endif /* CONFIG_POLL */

void k_msgq_init(struct k_msgq *msgq, char *buffer, size_t msg_size,
		 uint32_t max_msgs)
{
    a001dcfc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a001dd00:	910003fd 	mov	x29, sp
    a001dd04:	f90017e0 	str	x0, [sp, #40]
    a001dd08:	f90013e1 	str	x1, [sp, #32]
    a001dd0c:	f9000fe2 	str	x2, [sp, #24]
    a001dd10:	b90017e3 	str	w3, [sp, #20]
	msgq->msg_size = msg_size;
    a001dd14:	f94017e0 	ldr	x0, [sp, #40]
    a001dd18:	f9400fe1 	ldr	x1, [sp, #24]
    a001dd1c:	f9000801 	str	x1, [x0, #16]
	msgq->max_msgs = max_msgs;
    a001dd20:	f94017e0 	ldr	x0, [sp, #40]
    a001dd24:	b94017e1 	ldr	w1, [sp, #20]
    a001dd28:	b9001801 	str	w1, [x0, #24]
	msgq->buffer_start = buffer;
    a001dd2c:	f94017e0 	ldr	x0, [sp, #40]
    a001dd30:	f94013e1 	ldr	x1, [sp, #32]
    a001dd34:	f9001001 	str	x1, [x0, #32]
	msgq->buffer_end = buffer + (max_msgs * msg_size);
    a001dd38:	b94017e1 	ldr	w1, [sp, #20]
    a001dd3c:	f9400fe0 	ldr	x0, [sp, #24]
    a001dd40:	9b007c20 	mul	x0, x1, x0
    a001dd44:	f94013e1 	ldr	x1, [sp, #32]
    a001dd48:	8b000021 	add	x1, x1, x0
    a001dd4c:	f94017e0 	ldr	x0, [sp, #40]
    a001dd50:	f9001401 	str	x1, [x0, #40]
	msgq->read_ptr = buffer;
    a001dd54:	f94017e0 	ldr	x0, [sp, #40]
    a001dd58:	f94013e1 	ldr	x1, [sp, #32]
    a001dd5c:	f9001801 	str	x1, [x0, #48]
	msgq->write_ptr = buffer;
    a001dd60:	f94017e0 	ldr	x0, [sp, #40]
    a001dd64:	f94013e1 	ldr	x1, [sp, #32]
    a001dd68:	f9001c01 	str	x1, [x0, #56]
	msgq->used_msgs = 0;
    a001dd6c:	f94017e0 	ldr	x0, [sp, #40]
    a001dd70:	b900401f 	str	wzr, [x0, #64]
	msgq->flags = 0;
    a001dd74:	f94017e0 	ldr	x0, [sp, #40]
    a001dd78:	3901101f 	strb	wzr, [x0, #68]
	z_waitq_init(&msgq->wait_q);
    a001dd7c:	f94017e0 	ldr	x0, [sp, #40]
    a001dd80:	97ffffa9 	bl	a001dc24 <z_waitq_init>
	sys_dlist_init(&msgq->poll_events);
#endif	/* CONFIG_POLL */

	SYS_PORT_TRACING_OBJ_INIT(k_msgq, msgq);

	z_object_init(msgq);
    a001dd84:	f94017e0 	ldr	x0, [sp, #40]
    a001dd88:	97fffda2 	bl	a001d410 <z_object_init>
}
    a001dd8c:	d503201f 	nop
    a001dd90:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a001dd94:	d65f03c0 	ret

00000000a001dd98 <z_impl_k_msgq_alloc_init>:

int z_impl_k_msgq_alloc_init(struct k_msgq *msgq, size_t msg_size,
			    uint32_t max_msgs)
{
    a001dd98:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a001dd9c:	910003fd 	mov	x29, sp
    a001dda0:	f90017e0 	str	x0, [sp, #40]
    a001dda4:	f90013e1 	str	x1, [sp, #32]
    a001dda8:	b9001fe2 	str	w2, [sp, #28]
	int ret;
	size_t total_size;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, alloc_init, msgq);

	if (size_mul_overflow(msg_size, max_msgs, &total_size)) {
    a001ddac:	b9401fe0 	ldr	w0, [sp, #28]
    a001ddb0:	9100e3e1 	add	x1, sp, #0x38
    a001ddb4:	aa0103e2 	mov	x2, x1
    a001ddb8:	aa0003e1 	mov	x1, x0
    a001ddbc:	f94013e0 	ldr	x0, [sp, #32]
    a001ddc0:	97ffffa8 	bl	a001dc60 <size_mul_overflow>
    a001ddc4:	12001c00 	and	w0, w0, #0xff
    a001ddc8:	7100001f 	cmp	w0, #0x0
    a001ddcc:	54000080 	b.eq	a001dddc <z_impl_k_msgq_alloc_init+0x44>  // b.none
		ret = -EINVAL;
    a001ddd0:	128002a0 	mov	w0, #0xffffffea            	// #-22
    a001ddd4:	b9004fe0 	str	w0, [sp, #76]
    a001ddd8:	14000013 	b	a001de24 <z_impl_k_msgq_alloc_init+0x8c>
	} else {
		buffer = z_thread_malloc(total_size);
    a001dddc:	f9401fe0 	ldr	x0, [sp, #56]
    a001dde0:	97ffff89 	bl	a001dc04 <z_thread_malloc>
    a001dde4:	f90023e0 	str	x0, [sp, #64]
		if (buffer != NULL) {
    a001dde8:	f94023e0 	ldr	x0, [sp, #64]
    a001ddec:	f100001f 	cmp	x0, #0x0
    a001ddf0:	54000160 	b.eq	a001de1c <z_impl_k_msgq_alloc_init+0x84>  // b.none
			k_msgq_init(msgq, buffer, msg_size, max_msgs);
    a001ddf4:	b9401fe3 	ldr	w3, [sp, #28]
    a001ddf8:	f94013e2 	ldr	x2, [sp, #32]
    a001ddfc:	f94023e1 	ldr	x1, [sp, #64]
    a001de00:	f94017e0 	ldr	x0, [sp, #40]
    a001de04:	97ffffbe 	bl	a001dcfc <k_msgq_init>
			msgq->flags = K_MSGQ_FLAG_ALLOC;
    a001de08:	f94017e0 	ldr	x0, [sp, #40]
    a001de0c:	52800021 	mov	w1, #0x1                   	// #1
    a001de10:	39011001 	strb	w1, [x0, #68]
			ret = 0;
    a001de14:	b9004fff 	str	wzr, [sp, #76]
    a001de18:	14000003 	b	a001de24 <z_impl_k_msgq_alloc_init+0x8c>
		} else {
			ret = -ENOMEM;
    a001de1c:	12800160 	mov	w0, #0xfffffff4            	// #-12
    a001de20:	b9004fe0 	str	w0, [sp, #76]
		}
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, alloc_init, msgq, ret);

	return ret;
    a001de24:	b9404fe0 	ldr	w0, [sp, #76]
}
    a001de28:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a001de2c:	d65f03c0 	ret

00000000a001de30 <z_vrfy_k_msgq_alloc_init>:

#ifdef CONFIG_USERSPACE
int z_vrfy_k_msgq_alloc_init(struct k_msgq *msgq, size_t msg_size,
			    uint32_t max_msgs)
{
    a001de30:	a9a67bfd 	stp	x29, x30, [sp, #-416]!
    a001de34:	910003fd 	mov	x29, sp
    a001de38:	f90017e0 	str	x0, [sp, #40]
    a001de3c:	f90013e1 	str	x1, [sp, #32]
    a001de40:	b9001fe2 	str	w2, [sp, #28]
	Z_OOPS(Z_SYSCALL_OBJ_NEVER_INIT(msgq, K_OBJ_MSGQ));
    a001de44:	f94017e0 	ldr	x0, [sp, #40]
    a001de48:	97fffaf8 	bl	a001ca28 <z_object_find>
    a001de4c:	12800003 	mov	w3, #0xffffffff            	// #-1
    a001de50:	52800042 	mov	w2, #0x2                   	// #2
    a001de54:	f94017e1 	ldr	x1, [sp, #40]
    a001de58:	97ffff9b 	bl	a001dcc4 <z_obj_validation_check>
    a001de5c:	7100001f 	cmp	w0, #0x0
    a001de60:	1a9f07e0 	cset	w0, ne  // ne = any
    a001de64:	39067fe0 	strb	w0, [sp, #415]
    a001de68:	39467fe0 	ldrb	w0, [sp, #415]
    a001de6c:	7100001f 	cmp	w0, #0x0
    a001de70:	39467fe0 	ldrb	w0, [sp, #415]
    a001de74:	7100001f 	cmp	w0, #0x0
    a001de78:	540000c0 	b.eq	a001de90 <z_vrfy_k_msgq_alloc_init+0x60>  // b.none
    a001de7c:	d0000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001de80:	913f8000 	add	x0, x0, #0xfe0
    a001de84:	f9400800 	ldr	x0, [x0, #16]
    a001de88:	f9408400 	ldr	x0, [x0, #264]
    a001de8c:	97ffacb3 	bl	a0009158 <arch_syscall_oops>

	return z_impl_k_msgq_alloc_init(msgq, msg_size, max_msgs);
    a001de90:	b9401fe2 	ldr	w2, [sp, #28]
    a001de94:	f94013e1 	ldr	x1, [sp, #32]
    a001de98:	f94017e0 	ldr	x0, [sp, #40]
    a001de9c:	97ffffbf 	bl	a001dd98 <z_impl_k_msgq_alloc_init>
}
    a001dea0:	a8da7bfd 	ldp	x29, x30, [sp], #416
    a001dea4:	d65f03c0 	ret

00000000a001dea8 <z_mrsh_k_msgq_alloc_init>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_msgq_alloc_init(struct k_msgq * msgq, size_t msg_size, uint32_t max_msgs);
uintptr_t z_mrsh_k_msgq_alloc_init(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a001dea8:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a001deac:	910003fd 	mov	x29, sp
    a001deb0:	f90027e0 	str	x0, [sp, #72]
    a001deb4:	f90023e1 	str	x1, [sp, #64]
    a001deb8:	f9001fe2 	str	x2, [sp, #56]
    a001debc:	f9001be3 	str	x3, [sp, #48]
    a001dec0:	f90017e4 	str	x4, [sp, #40]
    a001dec4:	f90013e5 	str	x5, [sp, #32]
    a001dec8:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a001decc:	d0000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001ded0:	913f8000 	add	x0, x0, #0xfe0
    a001ded4:	f9400800 	ldr	x0, [x0, #16]
    a001ded8:	f9400fe1 	ldr	x1, [sp, #24]
    a001dedc:	f9008401 	str	x1, [x0, #264]
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_msgq_alloc_init(*(struct k_msgq **)&arg0, *(size_t*)&arg1, *(uint32_t*)&arg2)
    a001dee0:	910123e0 	add	x0, sp, #0x48
    a001dee4:	f9400003 	ldr	x3, [x0]
    a001dee8:	910103e0 	add	x0, sp, #0x40
    a001deec:	f9400001 	ldr	x1, [x0]
    a001def0:	9100e3e0 	add	x0, sp, #0x38
    a001def4:	b9400000 	ldr	w0, [x0]
    a001def8:	2a0003e2 	mov	w2, w0
    a001defc:	aa0303e0 	mov	x0, x3
    a001df00:	97ffffcc 	bl	a001de30 <z_vrfy_k_msgq_alloc_init>
    a001df04:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a001df08:	d0000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001df0c:	913f8000 	add	x0, x0, #0xfe0
    a001df10:	f9400800 	ldr	x0, [x0, #16]
    a001df14:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a001df18:	b9805fe0 	ldrsw	x0, [sp, #92]
}
    a001df1c:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a001df20:	d65f03c0 	ret

00000000a001df24 <k_msgq_cleanup>:
#include <syscalls/k_msgq_alloc_init_mrsh.c>
#endif

int k_msgq_cleanup(struct k_msgq *msgq)
{
    a001df24:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a001df28:	910003fd 	mov	x29, sp
    a001df2c:	f9000fe0 	str	x0, [sp, #24]
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, cleanup, msgq);

	CHECKIF(z_waitq_head(&msgq->wait_q) != NULL) {
    a001df30:	f9400fe0 	ldr	x0, [sp, #24]
    a001df34:	97ffff44 	bl	a001dc44 <z_waitq_head>
    a001df38:	f100001f 	cmp	x0, #0x0
    a001df3c:	54000060 	b.eq	a001df48 <k_msgq_cleanup+0x24>  // b.none
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, cleanup, msgq, -EBUSY);

		return -EBUSY;
    a001df40:	128001e0 	mov	w0, #0xfffffff0            	// #-16
    a001df44:	14000011 	b	a001df88 <k_msgq_cleanup+0x64>
	}

	if ((msgq->flags & K_MSGQ_FLAG_ALLOC) != 0U) {
    a001df48:	f9400fe0 	ldr	x0, [sp, #24]
    a001df4c:	39411000 	ldrb	w0, [x0, #68]
    a001df50:	92401c00 	and	x0, x0, #0xff
    a001df54:	92400000 	and	x0, x0, #0x1
    a001df58:	f100001f 	cmp	x0, #0x0
    a001df5c:	54000140 	b.eq	a001df84 <k_msgq_cleanup+0x60>  // b.none
		k_free(msgq->buffer_start);
    a001df60:	f9400fe0 	ldr	x0, [sp, #24]
    a001df64:	f9401000 	ldr	x0, [x0, #32]
    a001df68:	97fff5cb 	bl	a001b694 <k_free>
		msgq->flags &= ~K_MSGQ_FLAG_ALLOC;
    a001df6c:	f9400fe0 	ldr	x0, [sp, #24]
    a001df70:	39411000 	ldrb	w0, [x0, #68]
    a001df74:	121f7800 	and	w0, w0, #0xfffffffe
    a001df78:	12001c01 	and	w1, w0, #0xff
    a001df7c:	f9400fe0 	ldr	x0, [sp, #24]
    a001df80:	39011001 	strb	w1, [x0, #68]
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, cleanup, msgq, 0);

	return 0;
    a001df84:	52800000 	mov	w0, #0x0                   	// #0
}
    a001df88:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a001df8c:	d65f03c0 	ret

00000000a001df90 <z_impl_k_msgq_put>:


int z_impl_k_msgq_put(struct k_msgq *msgq, const void *data, k_timeout_t timeout)
{
    a001df90:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
    a001df94:	910003fd 	mov	x29, sp
    a001df98:	f90017e0 	str	x0, [sp, #40]
    a001df9c:	f90013e1 	str	x1, [sp, #32]
    a001dfa0:	f9000fe2 	str	x2, [sp, #24]

	struct k_thread *pending_thread;
	k_spinlock_key_t key;
	int result;

	key = k_spin_lock(&msgq->lock);
    a001dfa4:	f94017e0 	ldr	x0, [sp, #40]
    a001dfa8:	91004000 	add	x0, x0, #0x10
    a001dfac:	f90047e0 	str	x0, [sp, #136]
    a001dfb0:	d53b4220 	mrs	x0, daif
    a001dfb4:	f90043e0 	str	x0, [sp, #128]
    a001dfb8:	f94043e0 	ldr	x0, [sp, #128]
    a001dfbc:	d503201f 	nop
	key = read_daif();
    a001dfc0:	b9007fe0 	str	w0, [sp, #124]
	__asm__ volatile ("msr DAIFSet, %0"
    a001dfc4:	d50342df 	msr	daifset, #0x2
}
    a001dfc8:	d503201f 	nop
	return key;
    a001dfcc:	b9407fe0 	ldr	w0, [sp, #124]
	k.key = arch_irq_lock();
    a001dfd0:	b9003be0 	str	w0, [sp, #56]
	return k;
    a001dfd4:	b9403be0 	ldr	w0, [sp, #56]
    a001dfd8:	b9004be0 	str	w0, [sp, #72]

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, put, msgq, timeout);

	if (msgq->used_msgs < msgq->max_msgs) {
    a001dfdc:	f94017e0 	ldr	x0, [sp, #40]
    a001dfe0:	b9404001 	ldr	w1, [x0, #64]
    a001dfe4:	f94017e0 	ldr	x0, [sp, #40]
    a001dfe8:	b9401800 	ldr	w0, [x0, #24]
    a001dfec:	6b00003f 	cmp	w1, w0
    a001dff0:	540007c2 	b.cs	a001e0e8 <z_impl_k_msgq_put+0x158>  // b.hs, b.nlast
		/* message queue isn't full */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
    a001dff4:	f94017e0 	ldr	x0, [sp, #40]
    a001dff8:	97ffe70c 	bl	a0017c28 <z_unpend_first_thread>
    a001dffc:	f9004be0 	str	x0, [sp, #144]
		if (pending_thread != NULL) {
    a001e000:	f9404be0 	ldr	x0, [sp, #144]
    a001e004:	f100001f 	cmp	x0, #0x0
    a001e008:	54000300 	b.eq	a001e068 <z_impl_k_msgq_put+0xd8>  // b.none
			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, put, msgq, timeout, 0);

			/* give message to waiting thread */
			(void)memcpy(pending_thread->base.swap_data, data,
    a001e00c:	f9404be0 	ldr	x0, [sp, #144]
    a001e010:	f9401003 	ldr	x3, [x0, #32]
    a001e014:	f94017e0 	ldr	x0, [sp, #40]
    a001e018:	f9400800 	ldr	x0, [x0, #16]
    a001e01c:	aa0003e2 	mov	x2, x0
    a001e020:	f94013e1 	ldr	x1, [sp, #32]
    a001e024:	aa0303e0 	mov	x0, x3
    a001e028:	97ffb79c 	bl	a000be98 <memcpy>
    a001e02c:	f9404be0 	ldr	x0, [sp, #144]
    a001e030:	f9003be0 	str	x0, [sp, #112]
    a001e034:	b9006fff 	str	wzr, [sp, #108]
	thread->swap_retval = value;
    a001e038:	b9406fe1 	ldr	w1, [sp, #108]
    a001e03c:	f9403be0 	ldr	x0, [sp, #112]
    a001e040:	b9011001 	str	w1, [x0, #272]
}
    a001e044:	d503201f 	nop
			       msgq->msg_size);
			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
    a001e048:	f9404be0 	ldr	x0, [sp, #144]
    a001e04c:	97ffe429 	bl	a00170f0 <z_ready_thread>
			z_reschedule(&msgq->lock, key);
    a001e050:	f94017e0 	ldr	x0, [sp, #40]
    a001e054:	91004000 	add	x0, x0, #0x10
    a001e058:	b9404be1 	ldr	w1, [sp, #72]
    a001e05c:	97ffe830 	bl	a001811c <z_reschedule>
			return 0;
    a001e060:	52800000 	mov	w0, #0x0                   	// #0
    a001e064:	14000046 	b	a001e17c <z_impl_k_msgq_put+0x1ec>
		} else {
			/* put message in queue */
			(void)memcpy(msgq->write_ptr, data, msgq->msg_size);
    a001e068:	f94017e0 	ldr	x0, [sp, #40]
    a001e06c:	f9401c03 	ldr	x3, [x0, #56]
    a001e070:	f94017e0 	ldr	x0, [sp, #40]
    a001e074:	f9400800 	ldr	x0, [x0, #16]
    a001e078:	aa0003e2 	mov	x2, x0
    a001e07c:	f94013e1 	ldr	x1, [sp, #32]
    a001e080:	aa0303e0 	mov	x0, x3
    a001e084:	97ffb785 	bl	a000be98 <memcpy>
			msgq->write_ptr += msgq->msg_size;
    a001e088:	f94017e0 	ldr	x0, [sp, #40]
    a001e08c:	f9401c01 	ldr	x1, [x0, #56]
    a001e090:	f94017e0 	ldr	x0, [sp, #40]
    a001e094:	f9400800 	ldr	x0, [x0, #16]
    a001e098:	8b000021 	add	x1, x1, x0
    a001e09c:	f94017e0 	ldr	x0, [sp, #40]
    a001e0a0:	f9001c01 	str	x1, [x0, #56]
			if (msgq->write_ptr == msgq->buffer_end) {
    a001e0a4:	f94017e0 	ldr	x0, [sp, #40]
    a001e0a8:	f9401c01 	ldr	x1, [x0, #56]
    a001e0ac:	f94017e0 	ldr	x0, [sp, #40]
    a001e0b0:	f9401400 	ldr	x0, [x0, #40]
    a001e0b4:	eb00003f 	cmp	x1, x0
    a001e0b8:	540000a1 	b.ne	a001e0cc <z_impl_k_msgq_put+0x13c>  // b.any
				msgq->write_ptr = msgq->buffer_start;
    a001e0bc:	f94017e0 	ldr	x0, [sp, #40]
    a001e0c0:	f9401001 	ldr	x1, [x0, #32]
    a001e0c4:	f94017e0 	ldr	x0, [sp, #40]
    a001e0c8:	f9001c01 	str	x1, [x0, #56]
			}
			msgq->used_msgs++;
    a001e0cc:	f94017e0 	ldr	x0, [sp, #40]
    a001e0d0:	b9404000 	ldr	w0, [x0, #64]
    a001e0d4:	11000401 	add	w1, w0, #0x1
    a001e0d8:	f94017e0 	ldr	x0, [sp, #40]
    a001e0dc:	b9004001 	str	w1, [x0, #64]
#ifdef CONFIG_POLL
			handle_poll_events(msgq, K_POLL_STATE_MSGQ_DATA_AVAILABLE);
#endif /* CONFIG_POLL */
		}
		result = 0;
    a001e0e0:	b9009fff 	str	wzr, [sp, #156]
    a001e0e4:	14000017 	b	a001e140 <z_impl_k_msgq_put+0x1b0>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    a001e0e8:	f9400fe0 	ldr	x0, [sp, #24]
    a001e0ec:	d2800001 	mov	x1, #0x0                   	// #0
    a001e0f0:	eb01001f 	cmp	x0, x1
    a001e0f4:	54000081 	b.ne	a001e104 <z_impl_k_msgq_put+0x174>  // b.any
		/* don't wait for message space to become available */
		result = -ENOMSG;
    a001e0f8:	12800440 	mov	w0, #0xffffffdd            	// #-35
    a001e0fc:	b9009fe0 	str	w0, [sp, #156]
    a001e100:	14000010 	b	a001e140 <z_impl_k_msgq_put+0x1b0>
	} else {
		SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_msgq, put, msgq, timeout);

		/* wait for put message success, failure, or timeout */
		_current->base.swap_data = (void *) data;
    a001e104:	b0000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001e108:	913f8000 	add	x0, x0, #0xfe0
    a001e10c:	f9400800 	ldr	x0, [x0, #16]
    a001e110:	f94013e1 	ldr	x1, [sp, #32]
    a001e114:	f9001001 	str	x1, [x0, #32]

		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
    a001e118:	f94017e0 	ldr	x0, [sp, #40]
    a001e11c:	91004000 	add	x0, x0, #0x10
    a001e120:	f94017e1 	ldr	x1, [sp, #40]
    a001e124:	f9400fe3 	ldr	x3, [sp, #24]
    a001e128:	aa0103e2 	mov	x2, x1
    a001e12c:	b9404be1 	ldr	w1, [sp, #72]
    a001e130:	97ffe67b 	bl	a0017b1c <z_pend_curr>
    a001e134:	b9009fe0 	str	w0, [sp, #156]
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, put, msgq, timeout, result);
		return result;
    a001e138:	b9409fe0 	ldr	w0, [sp, #156]
    a001e13c:	14000010 	b	a001e17c <z_impl_k_msgq_put+0x1ec>
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, put, msgq, timeout, result);

	k_spin_unlock(&msgq->lock, key);
    a001e140:	f94017e0 	ldr	x0, [sp, #40]
    a001e144:	91004000 	add	x0, x0, #0x10
    a001e148:	f90033e0 	str	x0, [sp, #96]
    a001e14c:	b9404be0 	ldr	w0, [sp, #72]
    a001e150:	b90043e0 	str	w0, [sp, #64]
	arch_irq_unlock(key.key);
    a001e154:	b94043e0 	ldr	w0, [sp, #64]
    a001e158:	b9005fe0 	str	w0, [sp, #92]
	write_daif(key);
    a001e15c:	b9405fe0 	ldr	w0, [sp, #92]
    a001e160:	f9002be0 	str	x0, [sp, #80]
MAKE_REG_HELPER(daif)
    a001e164:	f9402be0 	ldr	x0, [sp, #80]
    a001e168:	d51b4220 	msr	daif, x0
    a001e16c:	d503201f 	nop
}
    a001e170:	d503201f 	nop
}
    a001e174:	d503201f 	nop

	return result;
    a001e178:	b9409fe0 	ldr	w0, [sp, #156]
}
    a001e17c:	a8ca7bfd 	ldp	x29, x30, [sp], #160
    a001e180:	d65f03c0 	ret

00000000a001e184 <z_vrfy_k_msgq_put>:

#ifdef CONFIG_USERSPACE
static inline int z_vrfy_k_msgq_put(struct k_msgq *msgq, const void *data,
				    k_timeout_t timeout)
{
    a001e184:	d10983ff 	sub	sp, sp, #0x260
    a001e188:	a9007bfd 	stp	x29, x30, [sp]
    a001e18c:	910003fd 	mov	x29, sp
    a001e190:	f90017e0 	str	x0, [sp, #40]
    a001e194:	f90013e1 	str	x1, [sp, #32]
    a001e198:	f9000fe2 	str	x2, [sp, #24]
	Z_OOPS(Z_SYSCALL_OBJ(msgq, K_OBJ_MSGQ));
    a001e19c:	f94017e0 	ldr	x0, [sp, #40]
    a001e1a0:	97fffa22 	bl	a001ca28 <z_object_find>
    a001e1a4:	52800003 	mov	w3, #0x0                   	// #0
    a001e1a8:	52800042 	mov	w2, #0x2                   	// #2
    a001e1ac:	f94017e1 	ldr	x1, [sp, #40]
    a001e1b0:	97fffec5 	bl	a001dcc4 <z_obj_validation_check>
    a001e1b4:	7100001f 	cmp	w0, #0x0
    a001e1b8:	1a9f07e0 	cset	w0, ne  // ne = any
    a001e1bc:	39097be0 	strb	w0, [sp, #606]
    a001e1c0:	39497be0 	ldrb	w0, [sp, #606]
    a001e1c4:	7100001f 	cmp	w0, #0x0
    a001e1c8:	39497be0 	ldrb	w0, [sp, #606]
    a001e1cc:	7100001f 	cmp	w0, #0x0
    a001e1d0:	540000c0 	b.eq	a001e1e8 <z_vrfy_k_msgq_put+0x64>  // b.none
    a001e1d4:	b0000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001e1d8:	913f8000 	add	x0, x0, #0xfe0
    a001e1dc:	f9400800 	ldr	x0, [x0, #16]
    a001e1e0:	f9408400 	ldr	x0, [x0, #264]
    a001e1e4:	97ffabdd 	bl	a0009158 <arch_syscall_oops>
	Z_OOPS(Z_SYSCALL_MEMORY_READ(data, msgq->msg_size));
    a001e1e8:	f94017e0 	ldr	x0, [sp, #40]
    a001e1ec:	f9400800 	ldr	x0, [x0, #16]
    a001e1f0:	52800002 	mov	w2, #0x0                   	// #0
    a001e1f4:	aa0003e1 	mov	x1, x0
    a001e1f8:	f94013e0 	ldr	x0, [sp, #32]
    a001e1fc:	97ffb59c 	bl	a000b86c <arch_buffer_validate>
    a001e200:	7100001f 	cmp	w0, #0x0
    a001e204:	1a9f07e0 	cset	w0, ne  // ne = any
    a001e208:	39097fe0 	strb	w0, [sp, #607]
    a001e20c:	39497fe0 	ldrb	w0, [sp, #607]
    a001e210:	7100001f 	cmp	w0, #0x0
    a001e214:	39497fe0 	ldrb	w0, [sp, #607]
    a001e218:	7100001f 	cmp	w0, #0x0
    a001e21c:	540000c0 	b.eq	a001e234 <z_vrfy_k_msgq_put+0xb0>  // b.none
    a001e220:	b0000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001e224:	913f8000 	add	x0, x0, #0xfe0
    a001e228:	f9400800 	ldr	x0, [x0, #16]
    a001e22c:	f9408400 	ldr	x0, [x0, #264]
    a001e230:	97ffabca 	bl	a0009158 <arch_syscall_oops>

	return z_impl_k_msgq_put(msgq, data, timeout);
    a001e234:	f9400fe2 	ldr	x2, [sp, #24]
    a001e238:	f94013e1 	ldr	x1, [sp, #32]
    a001e23c:	f94017e0 	ldr	x0, [sp, #40]
    a001e240:	97ffff54 	bl	a001df90 <z_impl_k_msgq_put>
}
    a001e244:	a9407bfd 	ldp	x29, x30, [sp]
    a001e248:	910983ff 	add	sp, sp, #0x260
    a001e24c:	d65f03c0 	ret

00000000a001e250 <z_mrsh_k_msgq_put>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_msgq_put(struct k_msgq * msgq, const void * data, k_timeout_t timeout);
uintptr_t z_mrsh_k_msgq_put(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a001e250:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a001e254:	910003fd 	mov	x29, sp
    a001e258:	f90027e0 	str	x0, [sp, #72]
    a001e25c:	f90023e1 	str	x1, [sp, #64]
    a001e260:	f9001fe2 	str	x2, [sp, #56]
    a001e264:	f9001be3 	str	x3, [sp, #48]
    a001e268:	f90017e4 	str	x4, [sp, #40]
    a001e26c:	f90013e5 	str	x5, [sp, #32]
    a001e270:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a001e274:	b0000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001e278:	913f8000 	add	x0, x0, #0xfe0
    a001e27c:	f9400800 	ldr	x0, [x0, #16]
    a001e280:	f9400fe1 	ldr	x1, [sp, #24]
    a001e284:	f9008401 	str	x1, [x0, #264]
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_msgq_put(*(struct k_msgq **)&arg0, *(const void **)&arg1, *(k_timeout_t*)&arg2)
    a001e288:	910123e0 	add	x0, sp, #0x48
    a001e28c:	f9400003 	ldr	x3, [x0]
    a001e290:	910103e0 	add	x0, sp, #0x40
    a001e294:	f9400001 	ldr	x1, [x0]
    a001e298:	9100e3e0 	add	x0, sp, #0x38
    a001e29c:	f9400002 	ldr	x2, [x0]
    a001e2a0:	aa0303e0 	mov	x0, x3
    a001e2a4:	97ffffb8 	bl	a001e184 <z_vrfy_k_msgq_put>
    a001e2a8:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a001e2ac:	b0000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001e2b0:	913f8000 	add	x0, x0, #0xfe0
    a001e2b4:	f9400800 	ldr	x0, [x0, #16]
    a001e2b8:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a001e2bc:	b9805fe0 	ldrsw	x0, [sp, #92]
}
    a001e2c0:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a001e2c4:	d65f03c0 	ret

00000000a001e2c8 <z_impl_k_msgq_get_attrs>:
#include <syscalls/k_msgq_put_mrsh.c>
#endif

void z_impl_k_msgq_get_attrs(struct k_msgq *msgq, struct k_msgq_attrs *attrs)
{
    a001e2c8:	d10043ff 	sub	sp, sp, #0x10
    a001e2cc:	f90007e0 	str	x0, [sp, #8]
    a001e2d0:	f90003e1 	str	x1, [sp]
	attrs->msg_size = msgq->msg_size;
    a001e2d4:	f94007e0 	ldr	x0, [sp, #8]
    a001e2d8:	f9400801 	ldr	x1, [x0, #16]
    a001e2dc:	f94003e0 	ldr	x0, [sp]
    a001e2e0:	f9000001 	str	x1, [x0]
	attrs->max_msgs = msgq->max_msgs;
    a001e2e4:	f94007e0 	ldr	x0, [sp, #8]
    a001e2e8:	b9401801 	ldr	w1, [x0, #24]
    a001e2ec:	f94003e0 	ldr	x0, [sp]
    a001e2f0:	b9000801 	str	w1, [x0, #8]
	attrs->used_msgs = msgq->used_msgs;
    a001e2f4:	f94007e0 	ldr	x0, [sp, #8]
    a001e2f8:	b9404001 	ldr	w1, [x0, #64]
    a001e2fc:	f94003e0 	ldr	x0, [sp]
    a001e300:	b9000c01 	str	w1, [x0, #12]
}
    a001e304:	d503201f 	nop
    a001e308:	910043ff 	add	sp, sp, #0x10
    a001e30c:	d65f03c0 	ret

00000000a001e310 <z_vrfy_k_msgq_get_attrs>:

#ifdef CONFIG_USERSPACE
static inline void z_vrfy_k_msgq_get_attrs(struct k_msgq *msgq,
					   struct k_msgq_attrs *attrs)
{
    a001e310:	d10943ff 	sub	sp, sp, #0x250
    a001e314:	a9007bfd 	stp	x29, x30, [sp]
    a001e318:	910003fd 	mov	x29, sp
    a001e31c:	f9000fe0 	str	x0, [sp, #24]
    a001e320:	f9000be1 	str	x1, [sp, #16]
	Z_OOPS(Z_SYSCALL_OBJ(msgq, K_OBJ_MSGQ));
    a001e324:	f9400fe0 	ldr	x0, [sp, #24]
    a001e328:	97fff9c0 	bl	a001ca28 <z_object_find>
    a001e32c:	52800003 	mov	w3, #0x0                   	// #0
    a001e330:	52800042 	mov	w2, #0x2                   	// #2
    a001e334:	f9400fe1 	ldr	x1, [sp, #24]
    a001e338:	97fffe63 	bl	a001dcc4 <z_obj_validation_check>
    a001e33c:	7100001f 	cmp	w0, #0x0
    a001e340:	1a9f07e0 	cset	w0, ne  // ne = any
    a001e344:	39093be0 	strb	w0, [sp, #590]
    a001e348:	39493be0 	ldrb	w0, [sp, #590]
    a001e34c:	7100001f 	cmp	w0, #0x0
    a001e350:	39493be0 	ldrb	w0, [sp, #590]
    a001e354:	7100001f 	cmp	w0, #0x0
    a001e358:	540000c0 	b.eq	a001e370 <z_vrfy_k_msgq_get_attrs+0x60>  // b.none
    a001e35c:	b0000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001e360:	913f8000 	add	x0, x0, #0xfe0
    a001e364:	f9400800 	ldr	x0, [x0, #16]
    a001e368:	f9408400 	ldr	x0, [x0, #264]
    a001e36c:	97ffab7b 	bl	a0009158 <arch_syscall_oops>
	Z_OOPS(Z_SYSCALL_MEMORY_WRITE(attrs, sizeof(struct k_msgq_attrs)));
    a001e370:	52800022 	mov	w2, #0x1                   	// #1
    a001e374:	d2800201 	mov	x1, #0x10                  	// #16
    a001e378:	f9400be0 	ldr	x0, [sp, #16]
    a001e37c:	97ffb53c 	bl	a000b86c <arch_buffer_validate>
    a001e380:	7100001f 	cmp	w0, #0x0
    a001e384:	1a9f07e0 	cset	w0, ne  // ne = any
    a001e388:	39093fe0 	strb	w0, [sp, #591]
    a001e38c:	39493fe0 	ldrb	w0, [sp, #591]
    a001e390:	7100001f 	cmp	w0, #0x0
    a001e394:	39493fe0 	ldrb	w0, [sp, #591]
    a001e398:	7100001f 	cmp	w0, #0x0
    a001e39c:	540000c0 	b.eq	a001e3b4 <z_vrfy_k_msgq_get_attrs+0xa4>  // b.none
    a001e3a0:	b0000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001e3a4:	913f8000 	add	x0, x0, #0xfe0
    a001e3a8:	f9400800 	ldr	x0, [x0, #16]
    a001e3ac:	f9408400 	ldr	x0, [x0, #264]
    a001e3b0:	97ffab6a 	bl	a0009158 <arch_syscall_oops>
	z_impl_k_msgq_get_attrs(msgq, attrs);
    a001e3b4:	f9400be1 	ldr	x1, [sp, #16]
    a001e3b8:	f9400fe0 	ldr	x0, [sp, #24]
    a001e3bc:	97ffffc3 	bl	a001e2c8 <z_impl_k_msgq_get_attrs>
}
    a001e3c0:	d503201f 	nop
    a001e3c4:	a9407bfd 	ldp	x29, x30, [sp]
    a001e3c8:	910943ff 	add	sp, sp, #0x250
    a001e3cc:	d65f03c0 	ret

00000000a001e3d0 <z_mrsh_k_msgq_get_attrs>:
#include <syscalls/kernel.h>

extern void z_vrfy_k_msgq_get_attrs(struct k_msgq * msgq, struct k_msgq_attrs * attrs);
uintptr_t z_mrsh_k_msgq_get_attrs(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a001e3d0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a001e3d4:	910003fd 	mov	x29, sp
    a001e3d8:	f90027e0 	str	x0, [sp, #72]
    a001e3dc:	f90023e1 	str	x1, [sp, #64]
    a001e3e0:	f9001fe2 	str	x2, [sp, #56]
    a001e3e4:	f9001be3 	str	x3, [sp, #48]
    a001e3e8:	f90017e4 	str	x4, [sp, #40]
    a001e3ec:	f90013e5 	str	x5, [sp, #32]
    a001e3f0:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a001e3f4:	b0000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001e3f8:	913f8000 	add	x0, x0, #0xfe0
    a001e3fc:	f9400800 	ldr	x0, [x0, #16]
    a001e400:	f9400fe1 	ldr	x1, [sp, #24]
    a001e404:	f9008401 	str	x1, [x0, #264]
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_msgq_get_attrs(*(struct k_msgq **)&arg0, *(struct k_msgq_attrs **)&arg1)
    a001e408:	910123e0 	add	x0, sp, #0x48
    a001e40c:	f9400002 	ldr	x2, [x0]
    a001e410:	910103e0 	add	x0, sp, #0x40
    a001e414:	f9400000 	ldr	x0, [x0]
    a001e418:	aa0003e1 	mov	x1, x0
    a001e41c:	aa0203e0 	mov	x0, x2
    a001e420:	97ffffbc 	bl	a001e310 <z_vrfy_k_msgq_get_attrs>
;
	_current->syscall_frame = NULL;
    a001e424:	b0000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001e428:	913f8000 	add	x0, x0, #0xfe0
    a001e42c:	f9400800 	ldr	x0, [x0, #16]
    a001e430:	f900841f 	str	xzr, [x0, #264]
	return 0;
    a001e434:	d2800000 	mov	x0, #0x0                   	// #0
}
    a001e438:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a001e43c:	d65f03c0 	ret

00000000a001e440 <z_impl_k_msgq_get>:
#include <syscalls/k_msgq_get_attrs_mrsh.c>
#endif

int z_impl_k_msgq_get(struct k_msgq *msgq, void *data, k_timeout_t timeout)
{
    a001e440:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
    a001e444:	910003fd 	mov	x29, sp
    a001e448:	f90017e0 	str	x0, [sp, #40]
    a001e44c:	f90013e1 	str	x1, [sp, #32]
    a001e450:	f9000fe2 	str	x2, [sp, #24]

	k_spinlock_key_t key;
	struct k_thread *pending_thread;
	int result;

	key = k_spin_lock(&msgq->lock);
    a001e454:	f94017e0 	ldr	x0, [sp, #40]
    a001e458:	91004000 	add	x0, x0, #0x10
    a001e45c:	f90047e0 	str	x0, [sp, #136]
    a001e460:	d53b4220 	mrs	x0, daif
    a001e464:	f90043e0 	str	x0, [sp, #128]
    a001e468:	f94043e0 	ldr	x0, [sp, #128]
    a001e46c:	d503201f 	nop
	key = read_daif();
    a001e470:	b9007fe0 	str	w0, [sp, #124]
	__asm__ volatile ("msr DAIFSet, %0"
    a001e474:	d50342df 	msr	daifset, #0x2
}
    a001e478:	d503201f 	nop
	return key;
    a001e47c:	b9407fe0 	ldr	w0, [sp, #124]
	k.key = arch_irq_lock();
    a001e480:	b9003be0 	str	w0, [sp, #56]
	return k;
    a001e484:	b9403be0 	ldr	w0, [sp, #56]
    a001e488:	b9004be0 	str	w0, [sp, #72]

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, get, msgq, timeout);

	if (msgq->used_msgs > 0U) {
    a001e48c:	f94017e0 	ldr	x0, [sp, #40]
    a001e490:	b9404000 	ldr	w0, [x0, #64]
    a001e494:	7100001f 	cmp	w0, #0x0
    a001e498:	54000a80 	b.eq	a001e5e8 <z_impl_k_msgq_get+0x1a8>  // b.none
		/* take first available message from queue */
		(void)memcpy(data, msgq->read_ptr, msgq->msg_size);
    a001e49c:	f94017e0 	ldr	x0, [sp, #40]
    a001e4a0:	f9401801 	ldr	x1, [x0, #48]
    a001e4a4:	f94017e0 	ldr	x0, [sp, #40]
    a001e4a8:	f9400800 	ldr	x0, [x0, #16]
    a001e4ac:	aa0003e2 	mov	x2, x0
    a001e4b0:	f94013e0 	ldr	x0, [sp, #32]
    a001e4b4:	97ffb679 	bl	a000be98 <memcpy>
		msgq->read_ptr += msgq->msg_size;
    a001e4b8:	f94017e0 	ldr	x0, [sp, #40]
    a001e4bc:	f9401801 	ldr	x1, [x0, #48]
    a001e4c0:	f94017e0 	ldr	x0, [sp, #40]
    a001e4c4:	f9400800 	ldr	x0, [x0, #16]
    a001e4c8:	8b000021 	add	x1, x1, x0
    a001e4cc:	f94017e0 	ldr	x0, [sp, #40]
    a001e4d0:	f9001801 	str	x1, [x0, #48]
		if (msgq->read_ptr == msgq->buffer_end) {
    a001e4d4:	f94017e0 	ldr	x0, [sp, #40]
    a001e4d8:	f9401801 	ldr	x1, [x0, #48]
    a001e4dc:	f94017e0 	ldr	x0, [sp, #40]
    a001e4e0:	f9401400 	ldr	x0, [x0, #40]
    a001e4e4:	eb00003f 	cmp	x1, x0
    a001e4e8:	540000a1 	b.ne	a001e4fc <z_impl_k_msgq_get+0xbc>  // b.any
			msgq->read_ptr = msgq->buffer_start;
    a001e4ec:	f94017e0 	ldr	x0, [sp, #40]
    a001e4f0:	f9401001 	ldr	x1, [x0, #32]
    a001e4f4:	f94017e0 	ldr	x0, [sp, #40]
    a001e4f8:	f9001801 	str	x1, [x0, #48]
		}
		msgq->used_msgs--;
    a001e4fc:	f94017e0 	ldr	x0, [sp, #40]
    a001e500:	b9404000 	ldr	w0, [x0, #64]
    a001e504:	51000401 	sub	w1, w0, #0x1
    a001e508:	f94017e0 	ldr	x0, [sp, #40]
    a001e50c:	b9004001 	str	w1, [x0, #64]

		/* handle first thread waiting to write (if any) */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
    a001e510:	f94017e0 	ldr	x0, [sp, #40]
    a001e514:	97ffe5c5 	bl	a0017c28 <z_unpend_first_thread>
    a001e518:	f9004be0 	str	x0, [sp, #144]
		if (pending_thread != NULL) {
    a001e51c:	f9404be0 	ldr	x0, [sp, #144]
    a001e520:	f100001f 	cmp	x0, #0x0
    a001e524:	540005e0 	b.eq	a001e5e0 <z_impl_k_msgq_get+0x1a0>  // b.none
			SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_msgq, get, msgq, timeout);

			/* add thread's message to queue */
			(void)memcpy(msgq->write_ptr, pending_thread->base.swap_data,
    a001e528:	f94017e0 	ldr	x0, [sp, #40]
    a001e52c:	f9401c03 	ldr	x3, [x0, #56]
    a001e530:	f9404be0 	ldr	x0, [sp, #144]
    a001e534:	f9401001 	ldr	x1, [x0, #32]
    a001e538:	f94017e0 	ldr	x0, [sp, #40]
    a001e53c:	f9400800 	ldr	x0, [x0, #16]
    a001e540:	aa0003e2 	mov	x2, x0
    a001e544:	aa0303e0 	mov	x0, x3
    a001e548:	97ffb654 	bl	a000be98 <memcpy>
			       msgq->msg_size);
			msgq->write_ptr += msgq->msg_size;
    a001e54c:	f94017e0 	ldr	x0, [sp, #40]
    a001e550:	f9401c01 	ldr	x1, [x0, #56]
    a001e554:	f94017e0 	ldr	x0, [sp, #40]
    a001e558:	f9400800 	ldr	x0, [x0, #16]
    a001e55c:	8b000021 	add	x1, x1, x0
    a001e560:	f94017e0 	ldr	x0, [sp, #40]
    a001e564:	f9001c01 	str	x1, [x0, #56]
			if (msgq->write_ptr == msgq->buffer_end) {
    a001e568:	f94017e0 	ldr	x0, [sp, #40]
    a001e56c:	f9401c01 	ldr	x1, [x0, #56]
    a001e570:	f94017e0 	ldr	x0, [sp, #40]
    a001e574:	f9401400 	ldr	x0, [x0, #40]
    a001e578:	eb00003f 	cmp	x1, x0
    a001e57c:	540000a1 	b.ne	a001e590 <z_impl_k_msgq_get+0x150>  // b.any
				msgq->write_ptr = msgq->buffer_start;
    a001e580:	f94017e0 	ldr	x0, [sp, #40]
    a001e584:	f9401001 	ldr	x1, [x0, #32]
    a001e588:	f94017e0 	ldr	x0, [sp, #40]
    a001e58c:	f9001c01 	str	x1, [x0, #56]
			}
			msgq->used_msgs++;
    a001e590:	f94017e0 	ldr	x0, [sp, #40]
    a001e594:	b9404000 	ldr	w0, [x0, #64]
    a001e598:	11000401 	add	w1, w0, #0x1
    a001e59c:	f94017e0 	ldr	x0, [sp, #40]
    a001e5a0:	b9004001 	str	w1, [x0, #64]
    a001e5a4:	f9404be0 	ldr	x0, [sp, #144]
    a001e5a8:	f9003be0 	str	x0, [sp, #112]
    a001e5ac:	b9006fff 	str	wzr, [sp, #108]
	thread->swap_retval = value;
    a001e5b0:	b9406fe1 	ldr	w1, [sp, #108]
    a001e5b4:	f9403be0 	ldr	x0, [sp, #112]
    a001e5b8:	b9011001 	str	w1, [x0, #272]
}
    a001e5bc:	d503201f 	nop

			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
    a001e5c0:	f9404be0 	ldr	x0, [sp, #144]
    a001e5c4:	97ffe2cb 	bl	a00170f0 <z_ready_thread>
			z_reschedule(&msgq->lock, key);
    a001e5c8:	f94017e0 	ldr	x0, [sp, #40]
    a001e5cc:	91004000 	add	x0, x0, #0x10
    a001e5d0:	b9404be1 	ldr	w1, [sp, #72]
    a001e5d4:	97ffe6d2 	bl	a001811c <z_reschedule>

			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, 0);

			return 0;
    a001e5d8:	52800000 	mov	w0, #0x0                   	// #0
    a001e5dc:	14000028 	b	a001e67c <z_impl_k_msgq_get+0x23c>
		}
		result = 0;
    a001e5e0:	b9009fff 	str	wzr, [sp, #156]
    a001e5e4:	14000017 	b	a001e640 <z_impl_k_msgq_get+0x200>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    a001e5e8:	f9400fe0 	ldr	x0, [sp, #24]
    a001e5ec:	d2800001 	mov	x1, #0x0                   	// #0
    a001e5f0:	eb01001f 	cmp	x0, x1
    a001e5f4:	54000081 	b.ne	a001e604 <z_impl_k_msgq_get+0x1c4>  // b.any
		/* don't wait for a message to become available */
		result = -ENOMSG;
    a001e5f8:	12800440 	mov	w0, #0xffffffdd            	// #-35
    a001e5fc:	b9009fe0 	str	w0, [sp, #156]
    a001e600:	14000010 	b	a001e640 <z_impl_k_msgq_get+0x200>
	} else {
		SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_msgq, get, msgq, timeout);

		/* wait for get message success or timeout */
		_current->base.swap_data = data;
    a001e604:	b0000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001e608:	913f8000 	add	x0, x0, #0xfe0
    a001e60c:	f9400800 	ldr	x0, [x0, #16]
    a001e610:	f94013e1 	ldr	x1, [sp, #32]
    a001e614:	f9001001 	str	x1, [x0, #32]

		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
    a001e618:	f94017e0 	ldr	x0, [sp, #40]
    a001e61c:	91004000 	add	x0, x0, #0x10
    a001e620:	f94017e1 	ldr	x1, [sp, #40]
    a001e624:	f9400fe3 	ldr	x3, [sp, #24]
    a001e628:	aa0103e2 	mov	x2, x1
    a001e62c:	b9404be1 	ldr	w1, [sp, #72]
    a001e630:	97ffe53b 	bl	a0017b1c <z_pend_curr>
    a001e634:	b9009fe0 	str	w0, [sp, #156]
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, result);
		return result;
    a001e638:	b9409fe0 	ldr	w0, [sp, #156]
    a001e63c:	14000010 	b	a001e67c <z_impl_k_msgq_get+0x23c>
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, result);

	k_spin_unlock(&msgq->lock, key);
    a001e640:	f94017e0 	ldr	x0, [sp, #40]
    a001e644:	91004000 	add	x0, x0, #0x10
    a001e648:	f90033e0 	str	x0, [sp, #96]
    a001e64c:	b9404be0 	ldr	w0, [sp, #72]
    a001e650:	b90043e0 	str	w0, [sp, #64]
	arch_irq_unlock(key.key);
    a001e654:	b94043e0 	ldr	w0, [sp, #64]
    a001e658:	b9005fe0 	str	w0, [sp, #92]
	write_daif(key);
    a001e65c:	b9405fe0 	ldr	w0, [sp, #92]
    a001e660:	f9002be0 	str	x0, [sp, #80]
MAKE_REG_HELPER(daif)
    a001e664:	f9402be0 	ldr	x0, [sp, #80]
    a001e668:	d51b4220 	msr	daif, x0
    a001e66c:	d503201f 	nop
}
    a001e670:	d503201f 	nop
}
    a001e674:	d503201f 	nop

	return result;
    a001e678:	b9409fe0 	ldr	w0, [sp, #156]
}
    a001e67c:	a8ca7bfd 	ldp	x29, x30, [sp], #160
    a001e680:	d65f03c0 	ret

00000000a001e684 <z_vrfy_k_msgq_get>:

#ifdef CONFIG_USERSPACE
static inline int z_vrfy_k_msgq_get(struct k_msgq *msgq, void *data,
				    k_timeout_t timeout)
{
    a001e684:	d10983ff 	sub	sp, sp, #0x260
    a001e688:	a9007bfd 	stp	x29, x30, [sp]
    a001e68c:	910003fd 	mov	x29, sp
    a001e690:	f90017e0 	str	x0, [sp, #40]
    a001e694:	f90013e1 	str	x1, [sp, #32]
    a001e698:	f9000fe2 	str	x2, [sp, #24]
	Z_OOPS(Z_SYSCALL_OBJ(msgq, K_OBJ_MSGQ));
    a001e69c:	f94017e0 	ldr	x0, [sp, #40]
    a001e6a0:	97fff8e2 	bl	a001ca28 <z_object_find>
    a001e6a4:	52800003 	mov	w3, #0x0                   	// #0
    a001e6a8:	52800042 	mov	w2, #0x2                   	// #2
    a001e6ac:	f94017e1 	ldr	x1, [sp, #40]
    a001e6b0:	97fffd85 	bl	a001dcc4 <z_obj_validation_check>
    a001e6b4:	7100001f 	cmp	w0, #0x0
    a001e6b8:	1a9f07e0 	cset	w0, ne  // ne = any
    a001e6bc:	39097be0 	strb	w0, [sp, #606]
    a001e6c0:	39497be0 	ldrb	w0, [sp, #606]
    a001e6c4:	7100001f 	cmp	w0, #0x0
    a001e6c8:	39497be0 	ldrb	w0, [sp, #606]
    a001e6cc:	7100001f 	cmp	w0, #0x0
    a001e6d0:	540000c0 	b.eq	a001e6e8 <z_vrfy_k_msgq_get+0x64>  // b.none
    a001e6d4:	b0000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001e6d8:	913f8000 	add	x0, x0, #0xfe0
    a001e6dc:	f9400800 	ldr	x0, [x0, #16]
    a001e6e0:	f9408400 	ldr	x0, [x0, #264]
    a001e6e4:	97ffaa9d 	bl	a0009158 <arch_syscall_oops>
	Z_OOPS(Z_SYSCALL_MEMORY_WRITE(data, msgq->msg_size));
    a001e6e8:	f94017e0 	ldr	x0, [sp, #40]
    a001e6ec:	f9400800 	ldr	x0, [x0, #16]
    a001e6f0:	52800022 	mov	w2, #0x1                   	// #1
    a001e6f4:	aa0003e1 	mov	x1, x0
    a001e6f8:	f94013e0 	ldr	x0, [sp, #32]
    a001e6fc:	97ffb45c 	bl	a000b86c <arch_buffer_validate>
    a001e700:	7100001f 	cmp	w0, #0x0
    a001e704:	1a9f07e0 	cset	w0, ne  // ne = any
    a001e708:	39097fe0 	strb	w0, [sp, #607]
    a001e70c:	39497fe0 	ldrb	w0, [sp, #607]
    a001e710:	7100001f 	cmp	w0, #0x0
    a001e714:	39497fe0 	ldrb	w0, [sp, #607]
    a001e718:	7100001f 	cmp	w0, #0x0
    a001e71c:	540000c0 	b.eq	a001e734 <z_vrfy_k_msgq_get+0xb0>  // b.none
    a001e720:	b0000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001e724:	913f8000 	add	x0, x0, #0xfe0
    a001e728:	f9400800 	ldr	x0, [x0, #16]
    a001e72c:	f9408400 	ldr	x0, [x0, #264]
    a001e730:	97ffaa8a 	bl	a0009158 <arch_syscall_oops>

	return z_impl_k_msgq_get(msgq, data, timeout);
    a001e734:	f9400fe2 	ldr	x2, [sp, #24]
    a001e738:	f94013e1 	ldr	x1, [sp, #32]
    a001e73c:	f94017e0 	ldr	x0, [sp, #40]
    a001e740:	97ffff40 	bl	a001e440 <z_impl_k_msgq_get>
}
    a001e744:	a9407bfd 	ldp	x29, x30, [sp]
    a001e748:	910983ff 	add	sp, sp, #0x260
    a001e74c:	d65f03c0 	ret

00000000a001e750 <z_mrsh_k_msgq_get>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_msgq_get(struct k_msgq * msgq, void * data, k_timeout_t timeout);
uintptr_t z_mrsh_k_msgq_get(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a001e750:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a001e754:	910003fd 	mov	x29, sp
    a001e758:	f90027e0 	str	x0, [sp, #72]
    a001e75c:	f90023e1 	str	x1, [sp, #64]
    a001e760:	f9001fe2 	str	x2, [sp, #56]
    a001e764:	f9001be3 	str	x3, [sp, #48]
    a001e768:	f90017e4 	str	x4, [sp, #40]
    a001e76c:	f90013e5 	str	x5, [sp, #32]
    a001e770:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a001e774:	b0000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001e778:	913f8000 	add	x0, x0, #0xfe0
    a001e77c:	f9400800 	ldr	x0, [x0, #16]
    a001e780:	f9400fe1 	ldr	x1, [sp, #24]
    a001e784:	f9008401 	str	x1, [x0, #264]
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_msgq_get(*(struct k_msgq **)&arg0, *(void **)&arg1, *(k_timeout_t*)&arg2)
    a001e788:	910123e0 	add	x0, sp, #0x48
    a001e78c:	f9400003 	ldr	x3, [x0]
    a001e790:	910103e0 	add	x0, sp, #0x40
    a001e794:	f9400001 	ldr	x1, [x0]
    a001e798:	9100e3e0 	add	x0, sp, #0x38
    a001e79c:	f9400002 	ldr	x2, [x0]
    a001e7a0:	aa0303e0 	mov	x0, x3
    a001e7a4:	97ffffb8 	bl	a001e684 <z_vrfy_k_msgq_get>
    a001e7a8:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a001e7ac:	b0000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001e7b0:	913f8000 	add	x0, x0, #0xfe0
    a001e7b4:	f9400800 	ldr	x0, [x0, #16]
    a001e7b8:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a001e7bc:	b9805fe0 	ldrsw	x0, [sp, #92]
}
    a001e7c0:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a001e7c4:	d65f03c0 	ret

00000000a001e7c8 <z_impl_k_msgq_peek>:
#include <syscalls/k_msgq_get_mrsh.c>
#endif

int z_impl_k_msgq_peek(struct k_msgq *msgq, void *data)
{
    a001e7c8:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    a001e7cc:	910003fd 	mov	x29, sp
    a001e7d0:	f9000fe0 	str	x0, [sp, #24]
    a001e7d4:	f9000be1 	str	x1, [sp, #16]
	k_spinlock_key_t key;
	int result;

	key = k_spin_lock(&msgq->lock);
    a001e7d8:	f9400fe0 	ldr	x0, [sp, #24]
    a001e7dc:	91004000 	add	x0, x0, #0x10
    a001e7e0:	f90033e0 	str	x0, [sp, #96]
    a001e7e4:	d53b4220 	mrs	x0, daif
    a001e7e8:	f9002fe0 	str	x0, [sp, #88]
    a001e7ec:	f9402fe0 	ldr	x0, [sp, #88]
    a001e7f0:	d503201f 	nop
	key = read_daif();
    a001e7f4:	b90057e0 	str	w0, [sp, #84]
	__asm__ volatile ("msr DAIFSet, %0"
    a001e7f8:	d50342df 	msr	daifset, #0x2
}
    a001e7fc:	d503201f 	nop
	return key;
    a001e800:	b94057e0 	ldr	w0, [sp, #84]
	k.key = arch_irq_lock();
    a001e804:	b90023e0 	str	w0, [sp, #32]
	return k;
    a001e808:	b94023e0 	ldr	w0, [sp, #32]
    a001e80c:	b90033e0 	str	w0, [sp, #48]

	if (msgq->used_msgs > 0U) {
    a001e810:	f9400fe0 	ldr	x0, [sp, #24]
    a001e814:	b9404000 	ldr	w0, [x0, #64]
    a001e818:	7100001f 	cmp	w0, #0x0
    a001e81c:	54000140 	b.eq	a001e844 <z_impl_k_msgq_peek+0x7c>  // b.none
		/* take first available message from queue */
		(void)memcpy(data, msgq->read_ptr, msgq->msg_size);
    a001e820:	f9400fe0 	ldr	x0, [sp, #24]
    a001e824:	f9401801 	ldr	x1, [x0, #48]
    a001e828:	f9400fe0 	ldr	x0, [sp, #24]
    a001e82c:	f9400800 	ldr	x0, [x0, #16]
    a001e830:	aa0003e2 	mov	x2, x0
    a001e834:	f9400be0 	ldr	x0, [sp, #16]
    a001e838:	97ffb598 	bl	a000be98 <memcpy>
		result = 0;
    a001e83c:	b9006fff 	str	wzr, [sp, #108]
    a001e840:	14000003 	b	a001e84c <z_impl_k_msgq_peek+0x84>
	} else {
		/* don't wait for a message to become available */
		result = -ENOMSG;
    a001e844:	12800440 	mov	w0, #0xffffffdd            	// #-35
    a001e848:	b9006fe0 	str	w0, [sp, #108]
	}

	SYS_PORT_TRACING_OBJ_FUNC(k_msgq, peek, msgq, result);

	k_spin_unlock(&msgq->lock, key);
    a001e84c:	f9400fe0 	ldr	x0, [sp, #24]
    a001e850:	91004000 	add	x0, x0, #0x10
    a001e854:	f90027e0 	str	x0, [sp, #72]
    a001e858:	b94033e0 	ldr	w0, [sp, #48]
    a001e85c:	b9002be0 	str	w0, [sp, #40]
	arch_irq_unlock(key.key);
    a001e860:	b9402be0 	ldr	w0, [sp, #40]
    a001e864:	b90047e0 	str	w0, [sp, #68]
	write_daif(key);
    a001e868:	b94047e0 	ldr	w0, [sp, #68]
    a001e86c:	f9001fe0 	str	x0, [sp, #56]
MAKE_REG_HELPER(daif)
    a001e870:	f9401fe0 	ldr	x0, [sp, #56]
    a001e874:	d51b4220 	msr	daif, x0
    a001e878:	d503201f 	nop
}
    a001e87c:	d503201f 	nop
}
    a001e880:	d503201f 	nop

	return result;
    a001e884:	b9406fe0 	ldr	w0, [sp, #108]
}
    a001e888:	a8c77bfd 	ldp	x29, x30, [sp], #112
    a001e88c:	d65f03c0 	ret

00000000a001e890 <z_vrfy_k_msgq_peek>:

#ifdef CONFIG_USERSPACE
static inline int z_vrfy_k_msgq_peek(struct k_msgq *msgq, void *data)
{
    a001e890:	d10943ff 	sub	sp, sp, #0x250
    a001e894:	a9007bfd 	stp	x29, x30, [sp]
    a001e898:	910003fd 	mov	x29, sp
    a001e89c:	f9000fe0 	str	x0, [sp, #24]
    a001e8a0:	f9000be1 	str	x1, [sp, #16]
	Z_OOPS(Z_SYSCALL_OBJ(msgq, K_OBJ_MSGQ));
    a001e8a4:	f9400fe0 	ldr	x0, [sp, #24]
    a001e8a8:	97fff860 	bl	a001ca28 <z_object_find>
    a001e8ac:	52800003 	mov	w3, #0x0                   	// #0
    a001e8b0:	52800042 	mov	w2, #0x2                   	// #2
    a001e8b4:	f9400fe1 	ldr	x1, [sp, #24]
    a001e8b8:	97fffd03 	bl	a001dcc4 <z_obj_validation_check>
    a001e8bc:	7100001f 	cmp	w0, #0x0
    a001e8c0:	1a9f07e0 	cset	w0, ne  // ne = any
    a001e8c4:	39093be0 	strb	w0, [sp, #590]
    a001e8c8:	39493be0 	ldrb	w0, [sp, #590]
    a001e8cc:	7100001f 	cmp	w0, #0x0
    a001e8d0:	39493be0 	ldrb	w0, [sp, #590]
    a001e8d4:	7100001f 	cmp	w0, #0x0
    a001e8d8:	540000c0 	b.eq	a001e8f0 <z_vrfy_k_msgq_peek+0x60>  // b.none
    a001e8dc:	b0000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001e8e0:	913f8000 	add	x0, x0, #0xfe0
    a001e8e4:	f9400800 	ldr	x0, [x0, #16]
    a001e8e8:	f9408400 	ldr	x0, [x0, #264]
    a001e8ec:	97ffaa1b 	bl	a0009158 <arch_syscall_oops>
	Z_OOPS(Z_SYSCALL_MEMORY_WRITE(data, msgq->msg_size));
    a001e8f0:	f9400fe0 	ldr	x0, [sp, #24]
    a001e8f4:	f9400800 	ldr	x0, [x0, #16]
    a001e8f8:	52800022 	mov	w2, #0x1                   	// #1
    a001e8fc:	aa0003e1 	mov	x1, x0
    a001e900:	f9400be0 	ldr	x0, [sp, #16]
    a001e904:	97ffb3da 	bl	a000b86c <arch_buffer_validate>
    a001e908:	7100001f 	cmp	w0, #0x0
    a001e90c:	1a9f07e0 	cset	w0, ne  // ne = any
    a001e910:	39093fe0 	strb	w0, [sp, #591]
    a001e914:	39493fe0 	ldrb	w0, [sp, #591]
    a001e918:	7100001f 	cmp	w0, #0x0
    a001e91c:	39493fe0 	ldrb	w0, [sp, #591]
    a001e920:	7100001f 	cmp	w0, #0x0
    a001e924:	540000c0 	b.eq	a001e93c <z_vrfy_k_msgq_peek+0xac>  // b.none
    a001e928:	b0000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001e92c:	913f8000 	add	x0, x0, #0xfe0
    a001e930:	f9400800 	ldr	x0, [x0, #16]
    a001e934:	f9408400 	ldr	x0, [x0, #264]
    a001e938:	97ffaa08 	bl	a0009158 <arch_syscall_oops>

	return z_impl_k_msgq_peek(msgq, data);
    a001e93c:	f9400be1 	ldr	x1, [sp, #16]
    a001e940:	f9400fe0 	ldr	x0, [sp, #24]
    a001e944:	97ffffa1 	bl	a001e7c8 <z_impl_k_msgq_peek>
}
    a001e948:	a9407bfd 	ldp	x29, x30, [sp]
    a001e94c:	910943ff 	add	sp, sp, #0x250
    a001e950:	d65f03c0 	ret

00000000a001e954 <z_mrsh_k_msgq_peek>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_msgq_peek(struct k_msgq * msgq, void * data);
uintptr_t z_mrsh_k_msgq_peek(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a001e954:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a001e958:	910003fd 	mov	x29, sp
    a001e95c:	f90027e0 	str	x0, [sp, #72]
    a001e960:	f90023e1 	str	x1, [sp, #64]
    a001e964:	f9001fe2 	str	x2, [sp, #56]
    a001e968:	f9001be3 	str	x3, [sp, #48]
    a001e96c:	f90017e4 	str	x4, [sp, #40]
    a001e970:	f90013e5 	str	x5, [sp, #32]
    a001e974:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a001e978:	b0000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001e97c:	913f8000 	add	x0, x0, #0xfe0
    a001e980:	f9400800 	ldr	x0, [x0, #16]
    a001e984:	f9400fe1 	ldr	x1, [sp, #24]
    a001e988:	f9008401 	str	x1, [x0, #264]
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_msgq_peek(*(struct k_msgq **)&arg0, *(void **)&arg1)
    a001e98c:	910123e0 	add	x0, sp, #0x48
    a001e990:	f9400002 	ldr	x2, [x0]
    a001e994:	910103e0 	add	x0, sp, #0x40
    a001e998:	f9400000 	ldr	x0, [x0]
    a001e99c:	aa0003e1 	mov	x1, x0
    a001e9a0:	aa0203e0 	mov	x0, x2
    a001e9a4:	97ffffbb 	bl	a001e890 <z_vrfy_k_msgq_peek>
    a001e9a8:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a001e9ac:	b0000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001e9b0:	913f8000 	add	x0, x0, #0xfe0
    a001e9b4:	f9400800 	ldr	x0, [x0, #16]
    a001e9b8:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a001e9bc:	b9805fe0 	ldrsw	x0, [sp, #92]
}
    a001e9c0:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a001e9c4:	d65f03c0 	ret

00000000a001e9c8 <z_impl_k_msgq_purge>:
#include <syscalls/k_msgq_peek_mrsh.c>
#endif

void z_impl_k_msgq_purge(struct k_msgq *msgq)
{
    a001e9c8:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a001e9cc:	910003fd 	mov	x29, sp
    a001e9d0:	f9000fe0 	str	x0, [sp, #24]
	k_spinlock_key_t key;
	struct k_thread *pending_thread;

	key = k_spin_lock(&msgq->lock);
    a001e9d4:	f9400fe0 	ldr	x0, [sp, #24]
    a001e9d8:	91004000 	add	x0, x0, #0x10
    a001e9dc:	f9002be0 	str	x0, [sp, #80]
    a001e9e0:	d53b4220 	mrs	x0, daif
    a001e9e4:	f90027e0 	str	x0, [sp, #72]
    a001e9e8:	f94027e0 	ldr	x0, [sp, #72]
    a001e9ec:	d503201f 	nop
	key = read_daif();
    a001e9f0:	b90047e0 	str	w0, [sp, #68]
	__asm__ volatile ("msr DAIFSet, %0"
    a001e9f4:	d50342df 	msr	daifset, #0x2
}
    a001e9f8:	d503201f 	nop
	return key;
    a001e9fc:	b94047e0 	ldr	w0, [sp, #68]
	k.key = arch_irq_lock();
    a001ea00:	b9002be0 	str	w0, [sp, #40]
	return k;
    a001ea04:	b9402be0 	ldr	w0, [sp, #40]
    a001ea08:	b90033e0 	str	w0, [sp, #48]

	SYS_PORT_TRACING_OBJ_FUNC(k_msgq, purge, msgq);

	/* wake up any threads that are waiting to write */
	while ((pending_thread = z_unpend_first_thread(&msgq->wait_q)) != NULL) {
    a001ea0c:	1400000b 	b	a001ea38 <z_impl_k_msgq_purge+0x70>
    a001ea10:	f9402fe0 	ldr	x0, [sp, #88]
    a001ea14:	f9001fe0 	str	x0, [sp, #56]
    a001ea18:	12800440 	mov	w0, #0xffffffdd            	// #-35
    a001ea1c:	b90037e0 	str	w0, [sp, #52]
	thread->swap_retval = value;
    a001ea20:	b94037e1 	ldr	w1, [sp, #52]
    a001ea24:	f9401fe0 	ldr	x0, [sp, #56]
    a001ea28:	b9011001 	str	w1, [x0, #272]
}
    a001ea2c:	d503201f 	nop
		arch_thread_return_value_set(pending_thread, -ENOMSG);
		z_ready_thread(pending_thread);
    a001ea30:	f9402fe0 	ldr	x0, [sp, #88]
    a001ea34:	97ffe1af 	bl	a00170f0 <z_ready_thread>
	while ((pending_thread = z_unpend_first_thread(&msgq->wait_q)) != NULL) {
    a001ea38:	f9400fe0 	ldr	x0, [sp, #24]
    a001ea3c:	97ffe47b 	bl	a0017c28 <z_unpend_first_thread>
    a001ea40:	f9002fe0 	str	x0, [sp, #88]
    a001ea44:	f9402fe0 	ldr	x0, [sp, #88]
    a001ea48:	f100001f 	cmp	x0, #0x0
    a001ea4c:	54fffe21 	b.ne	a001ea10 <z_impl_k_msgq_purge+0x48>  // b.any
	}

	msgq->used_msgs = 0;
    a001ea50:	f9400fe0 	ldr	x0, [sp, #24]
    a001ea54:	b900401f 	str	wzr, [x0, #64]
	msgq->read_ptr = msgq->write_ptr;
    a001ea58:	f9400fe0 	ldr	x0, [sp, #24]
    a001ea5c:	f9401c01 	ldr	x1, [x0, #56]
    a001ea60:	f9400fe0 	ldr	x0, [sp, #24]
    a001ea64:	f9001801 	str	x1, [x0, #48]

	z_reschedule(&msgq->lock, key);
    a001ea68:	f9400fe0 	ldr	x0, [sp, #24]
    a001ea6c:	91004000 	add	x0, x0, #0x10
    a001ea70:	b94033e1 	ldr	w1, [sp, #48]
    a001ea74:	97ffe5aa 	bl	a001811c <z_reschedule>
}
    a001ea78:	d503201f 	nop
    a001ea7c:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a001ea80:	d65f03c0 	ret

00000000a001ea84 <z_vrfy_k_msgq_purge>:

#ifdef CONFIG_USERSPACE
static inline void z_vrfy_k_msgq_purge(struct k_msgq *msgq)
{
    a001ea84:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a001ea88:	910003fd 	mov	x29, sp
    a001ea8c:	f9000fe0 	str	x0, [sp, #24]
	Z_OOPS(Z_SYSCALL_OBJ(msgq, K_OBJ_MSGQ));
    a001ea90:	f9400fe0 	ldr	x0, [sp, #24]
    a001ea94:	97fff7e5 	bl	a001ca28 <z_object_find>
    a001ea98:	52800003 	mov	w3, #0x0                   	// #0
    a001ea9c:	52800042 	mov	w2, #0x2                   	// #2
    a001eaa0:	f9400fe1 	ldr	x1, [sp, #24]
    a001eaa4:	97fffc88 	bl	a001dcc4 <z_obj_validation_check>
    a001eaa8:	7100001f 	cmp	w0, #0x0
    a001eaac:	1a9f07e0 	cset	w0, ne  // ne = any
    a001eab0:	39063fe0 	strb	w0, [sp, #399]
    a001eab4:	39463fe0 	ldrb	w0, [sp, #399]
    a001eab8:	7100001f 	cmp	w0, #0x0
    a001eabc:	39463fe0 	ldrb	w0, [sp, #399]
    a001eac0:	7100001f 	cmp	w0, #0x0
    a001eac4:	540000c0 	b.eq	a001eadc <z_vrfy_k_msgq_purge+0x58>  // b.none
    a001eac8:	b0000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001eacc:	913f8000 	add	x0, x0, #0xfe0
    a001ead0:	f9400800 	ldr	x0, [x0, #16]
    a001ead4:	f9408400 	ldr	x0, [x0, #264]
    a001ead8:	97ffa9a0 	bl	a0009158 <arch_syscall_oops>
	z_impl_k_msgq_purge(msgq);
    a001eadc:	f9400fe0 	ldr	x0, [sp, #24]
    a001eae0:	97ffffba 	bl	a001e9c8 <z_impl_k_msgq_purge>
}
    a001eae4:	d503201f 	nop
    a001eae8:	a8d97bfd 	ldp	x29, x30, [sp], #400
    a001eaec:	d65f03c0 	ret

00000000a001eaf0 <z_mrsh_k_msgq_purge>:
#include <syscalls/kernel.h>

extern void z_vrfy_k_msgq_purge(struct k_msgq * msgq);
uintptr_t z_mrsh_k_msgq_purge(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a001eaf0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a001eaf4:	910003fd 	mov	x29, sp
    a001eaf8:	f90027e0 	str	x0, [sp, #72]
    a001eafc:	f90023e1 	str	x1, [sp, #64]
    a001eb00:	f9001fe2 	str	x2, [sp, #56]
    a001eb04:	f9001be3 	str	x3, [sp, #48]
    a001eb08:	f90017e4 	str	x4, [sp, #40]
    a001eb0c:	f90013e5 	str	x5, [sp, #32]
    a001eb10:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a001eb14:	b0000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001eb18:	913f8000 	add	x0, x0, #0xfe0
    a001eb1c:	f9400800 	ldr	x0, [x0, #16]
    a001eb20:	f9400fe1 	ldr	x1, [sp, #24]
    a001eb24:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_msgq_purge(*(struct k_msgq **)&arg0)
    a001eb28:	910123e0 	add	x0, sp, #0x48
    a001eb2c:	f9400000 	ldr	x0, [x0]
    a001eb30:	97ffffd5 	bl	a001ea84 <z_vrfy_k_msgq_purge>
;
	_current->syscall_frame = NULL;
    a001eb34:	b0000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001eb38:	913f8000 	add	x0, x0, #0xfe0
    a001eb3c:	f9400800 	ldr	x0, [x0, #16]
    a001eb40:	f900841f 	str	xzr, [x0, #264]
	return 0;
    a001eb44:	d2800000 	mov	x0, #0x0                   	// #0
}
    a001eb48:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a001eb4c:	d65f03c0 	ret

00000000a001eb50 <z_vrfy_k_msgq_num_free_get>:
#include <syscalls/k_msgq_purge_mrsh.c>

static inline uint32_t z_vrfy_k_msgq_num_free_get(struct k_msgq *msgq)
{
    a001eb50:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a001eb54:	910003fd 	mov	x29, sp
    a001eb58:	f9000fe0 	str	x0, [sp, #24]
	Z_OOPS(Z_SYSCALL_OBJ(msgq, K_OBJ_MSGQ));
    a001eb5c:	f9400fe0 	ldr	x0, [sp, #24]
    a001eb60:	97fff7b2 	bl	a001ca28 <z_object_find>
    a001eb64:	52800003 	mov	w3, #0x0                   	// #0
    a001eb68:	52800042 	mov	w2, #0x2                   	// #2
    a001eb6c:	f9400fe1 	ldr	x1, [sp, #24]
    a001eb70:	97fffc55 	bl	a001dcc4 <z_obj_validation_check>
    a001eb74:	7100001f 	cmp	w0, #0x0
    a001eb78:	1a9f07e0 	cset	w0, ne  // ne = any
    a001eb7c:	39063fe0 	strb	w0, [sp, #399]
    a001eb80:	39463fe0 	ldrb	w0, [sp, #399]
    a001eb84:	7100001f 	cmp	w0, #0x0
    a001eb88:	39463fe0 	ldrb	w0, [sp, #399]
    a001eb8c:	7100001f 	cmp	w0, #0x0
    a001eb90:	540000c0 	b.eq	a001eba8 <z_vrfy_k_msgq_num_free_get+0x58>  // b.none
    a001eb94:	b0000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001eb98:	913f8000 	add	x0, x0, #0xfe0
    a001eb9c:	f9400800 	ldr	x0, [x0, #16]
    a001eba0:	f9408400 	ldr	x0, [x0, #264]
    a001eba4:	97ffa96d 	bl	a0009158 <arch_syscall_oops>
	return z_impl_k_msgq_num_free_get(msgq);
    a001eba8:	f9400fe0 	ldr	x0, [sp, #24]
    a001ebac:	97fffc07 	bl	a001dbc8 <z_impl_k_msgq_num_free_get>
}
    a001ebb0:	a8d97bfd 	ldp	x29, x30, [sp], #400
    a001ebb4:	d65f03c0 	ret

00000000a001ebb8 <z_mrsh_k_msgq_num_free_get>:
#include <syscalls/kernel.h>

extern uint32_t z_vrfy_k_msgq_num_free_get(struct k_msgq * msgq);
uintptr_t z_mrsh_k_msgq_num_free_get(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a001ebb8:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a001ebbc:	910003fd 	mov	x29, sp
    a001ebc0:	f90027e0 	str	x0, [sp, #72]
    a001ebc4:	f90023e1 	str	x1, [sp, #64]
    a001ebc8:	f9001fe2 	str	x2, [sp, #56]
    a001ebcc:	f9001be3 	str	x3, [sp, #48]
    a001ebd0:	f90017e4 	str	x4, [sp, #40]
    a001ebd4:	f90013e5 	str	x5, [sp, #32]
    a001ebd8:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a001ebdc:	b0000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001ebe0:	913f8000 	add	x0, x0, #0xfe0
    a001ebe4:	f9400800 	ldr	x0, [x0, #16]
    a001ebe8:	f9400fe1 	ldr	x1, [sp, #24]
    a001ebec:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	uint32_t ret = z_vrfy_k_msgq_num_free_get(*(struct k_msgq **)&arg0)
    a001ebf0:	910123e0 	add	x0, sp, #0x48
    a001ebf4:	f9400000 	ldr	x0, [x0]
    a001ebf8:	97ffffd6 	bl	a001eb50 <z_vrfy_k_msgq_num_free_get>
    a001ebfc:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a001ec00:	b0000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001ec04:	913f8000 	add	x0, x0, #0xfe0
    a001ec08:	f9400800 	ldr	x0, [x0, #16]
    a001ec0c:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a001ec10:	b9405fe0 	ldr	w0, [sp, #92]
}
    a001ec14:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a001ec18:	d65f03c0 	ret

00000000a001ec1c <z_vrfy_k_msgq_num_used_get>:
#include <syscalls/k_msgq_num_free_get_mrsh.c>

static inline uint32_t z_vrfy_k_msgq_num_used_get(struct k_msgq *msgq)
{
    a001ec1c:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a001ec20:	910003fd 	mov	x29, sp
    a001ec24:	f9000fe0 	str	x0, [sp, #24]
	Z_OOPS(Z_SYSCALL_OBJ(msgq, K_OBJ_MSGQ));
    a001ec28:	f9400fe0 	ldr	x0, [sp, #24]
    a001ec2c:	97fff77f 	bl	a001ca28 <z_object_find>
    a001ec30:	52800003 	mov	w3, #0x0                   	// #0
    a001ec34:	52800042 	mov	w2, #0x2                   	// #2
    a001ec38:	f9400fe1 	ldr	x1, [sp, #24]
    a001ec3c:	97fffc22 	bl	a001dcc4 <z_obj_validation_check>
    a001ec40:	7100001f 	cmp	w0, #0x0
    a001ec44:	1a9f07e0 	cset	w0, ne  // ne = any
    a001ec48:	39063fe0 	strb	w0, [sp, #399]
    a001ec4c:	39463fe0 	ldrb	w0, [sp, #399]
    a001ec50:	7100001f 	cmp	w0, #0x0
    a001ec54:	39463fe0 	ldrb	w0, [sp, #399]
    a001ec58:	7100001f 	cmp	w0, #0x0
    a001ec5c:	540000c0 	b.eq	a001ec74 <z_vrfy_k_msgq_num_used_get+0x58>  // b.none
    a001ec60:	b0000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001ec64:	913f8000 	add	x0, x0, #0xfe0
    a001ec68:	f9400800 	ldr	x0, [x0, #16]
    a001ec6c:	f9408400 	ldr	x0, [x0, #264]
    a001ec70:	97ffa93a 	bl	a0009158 <arch_syscall_oops>
	return z_impl_k_msgq_num_used_get(msgq);
    a001ec74:	f9400fe0 	ldr	x0, [sp, #24]
    a001ec78:	97fffbdd 	bl	a001dbec <z_impl_k_msgq_num_used_get>
}
    a001ec7c:	a8d97bfd 	ldp	x29, x30, [sp], #400
    a001ec80:	d65f03c0 	ret

00000000a001ec84 <z_mrsh_k_msgq_num_used_get>:
#include <syscalls/kernel.h>

extern uint32_t z_vrfy_k_msgq_num_used_get(struct k_msgq * msgq);
uintptr_t z_mrsh_k_msgq_num_used_get(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a001ec84:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a001ec88:	910003fd 	mov	x29, sp
    a001ec8c:	f90027e0 	str	x0, [sp, #72]
    a001ec90:	f90023e1 	str	x1, [sp, #64]
    a001ec94:	f9001fe2 	str	x2, [sp, #56]
    a001ec98:	f9001be3 	str	x3, [sp, #48]
    a001ec9c:	f90017e4 	str	x4, [sp, #40]
    a001eca0:	f90013e5 	str	x5, [sp, #32]
    a001eca4:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a001eca8:	b0000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001ecac:	913f8000 	add	x0, x0, #0xfe0
    a001ecb0:	f9400800 	ldr	x0, [x0, #16]
    a001ecb4:	f9400fe1 	ldr	x1, [sp, #24]
    a001ecb8:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	uint32_t ret = z_vrfy_k_msgq_num_used_get(*(struct k_msgq **)&arg0)
    a001ecbc:	910123e0 	add	x0, sp, #0x48
    a001ecc0:	f9400000 	ldr	x0, [x0]
    a001ecc4:	97ffffd6 	bl	a001ec1c <z_vrfy_k_msgq_num_used_get>
    a001ecc8:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a001eccc:	b0000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001ecd0:	913f8000 	add	x0, x0, #0xfe0
    a001ecd4:	f9400800 	ldr	x0, [x0, #16]
    a001ecd8:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a001ecdc:	b9405fe0 	ldr	w0, [sp, #92]
}
    a001ece0:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a001ece4:	d65f03c0 	ret

00000000a001ece8 <sys_dlist_init>:
{
    a001ece8:	d10043ff 	sub	sp, sp, #0x10
    a001ecec:	f90007e0 	str	x0, [sp, #8]
	list->head = (sys_dnode_t *)list;
    a001ecf0:	f94007e0 	ldr	x0, [sp, #8]
    a001ecf4:	f94007e1 	ldr	x1, [sp, #8]
    a001ecf8:	f9000001 	str	x1, [x0]
	list->tail = (sys_dnode_t *)list;
    a001ecfc:	f94007e0 	ldr	x0, [sp, #8]
    a001ed00:	f94007e1 	ldr	x1, [sp, #8]
    a001ed04:	f9000401 	str	x1, [x0, #8]
}
    a001ed08:	d503201f 	nop
    a001ed0c:	910043ff 	add	sp, sp, #0x10
    a001ed10:	d65f03c0 	ret

00000000a001ed14 <sys_dnode_init>:
{
    a001ed14:	d10043ff 	sub	sp, sp, #0x10
    a001ed18:	f90007e0 	str	x0, [sp, #8]
	node->next = NULL;
    a001ed1c:	f94007e0 	ldr	x0, [sp, #8]
    a001ed20:	f900001f 	str	xzr, [x0]
	node->prev = NULL;
    a001ed24:	f94007e0 	ldr	x0, [sp, #8]
    a001ed28:	f900041f 	str	xzr, [x0, #8]
}
    a001ed2c:	d503201f 	nop
    a001ed30:	910043ff 	add	sp, sp, #0x10
    a001ed34:	d65f03c0 	ret

00000000a001ed38 <sys_dlist_is_empty>:
{
    a001ed38:	d10043ff 	sub	sp, sp, #0x10
    a001ed3c:	f90007e0 	str	x0, [sp, #8]
	return list->head == list;
    a001ed40:	f94007e0 	ldr	x0, [sp, #8]
    a001ed44:	f9400000 	ldr	x0, [x0]
    a001ed48:	f94007e1 	ldr	x1, [sp, #8]
    a001ed4c:	eb00003f 	cmp	x1, x0
    a001ed50:	1a9f17e0 	cset	w0, eq  // eq = none
    a001ed54:	12001c00 	and	w0, w0, #0xff
}
    a001ed58:	910043ff 	add	sp, sp, #0x10
    a001ed5c:	d65f03c0 	ret

00000000a001ed60 <sys_dlist_peek_head>:
{
    a001ed60:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a001ed64:	910003fd 	mov	x29, sp
    a001ed68:	f9000fe0 	str	x0, [sp, #24]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    a001ed6c:	f9400fe0 	ldr	x0, [sp, #24]
    a001ed70:	97fffff2 	bl	a001ed38 <sys_dlist_is_empty>
    a001ed74:	12001c00 	and	w0, w0, #0xff
    a001ed78:	7100001f 	cmp	w0, #0x0
    a001ed7c:	54000081 	b.ne	a001ed8c <sys_dlist_peek_head+0x2c>  // b.any
    a001ed80:	f9400fe0 	ldr	x0, [sp, #24]
    a001ed84:	f9400000 	ldr	x0, [x0]
    a001ed88:	14000002 	b	a001ed90 <sys_dlist_peek_head+0x30>
    a001ed8c:	d2800000 	mov	x0, #0x0                   	// #0
}
    a001ed90:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a001ed94:	d65f03c0 	ret

00000000a001ed98 <sys_dlist_peek_next_no_check>:
{
    a001ed98:	d10043ff 	sub	sp, sp, #0x10
    a001ed9c:	f90007e0 	str	x0, [sp, #8]
    a001eda0:	f90003e1 	str	x1, [sp]
	return (node == list->tail) ? NULL : node->next;
    a001eda4:	f94007e0 	ldr	x0, [sp, #8]
    a001eda8:	f9400400 	ldr	x0, [x0, #8]
    a001edac:	f94003e1 	ldr	x1, [sp]
    a001edb0:	eb00003f 	cmp	x1, x0
    a001edb4:	54000080 	b.eq	a001edc4 <sys_dlist_peek_next_no_check+0x2c>  // b.none
    a001edb8:	f94003e0 	ldr	x0, [sp]
    a001edbc:	f9400000 	ldr	x0, [x0]
    a001edc0:	14000002 	b	a001edc8 <sys_dlist_peek_next_no_check+0x30>
    a001edc4:	d2800000 	mov	x0, #0x0                   	// #0
}
    a001edc8:	910043ff 	add	sp, sp, #0x10
    a001edcc:	d65f03c0 	ret

00000000a001edd0 <sys_dlist_peek_next>:
{
    a001edd0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a001edd4:	910003fd 	mov	x29, sp
    a001edd8:	f9000fe0 	str	x0, [sp, #24]
    a001eddc:	f9000be1 	str	x1, [sp, #16]
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    a001ede0:	f9400be0 	ldr	x0, [sp, #16]
    a001ede4:	f100001f 	cmp	x0, #0x0
    a001ede8:	540000a0 	b.eq	a001edfc <sys_dlist_peek_next+0x2c>  // b.none
    a001edec:	f9400be1 	ldr	x1, [sp, #16]
    a001edf0:	f9400fe0 	ldr	x0, [sp, #24]
    a001edf4:	97ffffe9 	bl	a001ed98 <sys_dlist_peek_next_no_check>
    a001edf8:	14000002 	b	a001ee00 <sys_dlist_peek_next+0x30>
    a001edfc:	d2800000 	mov	x0, #0x0                   	// #0
}
    a001ee00:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a001ee04:	d65f03c0 	ret

00000000a001ee08 <sys_dlist_append>:
{
    a001ee08:	d10083ff 	sub	sp, sp, #0x20
    a001ee0c:	f90007e0 	str	x0, [sp, #8]
    a001ee10:	f90003e1 	str	x1, [sp]
	sys_dnode_t *const tail = list->tail;
    a001ee14:	f94007e0 	ldr	x0, [sp, #8]
    a001ee18:	f9400400 	ldr	x0, [x0, #8]
    a001ee1c:	f9000fe0 	str	x0, [sp, #24]
	node->next = list;
    a001ee20:	f94003e0 	ldr	x0, [sp]
    a001ee24:	f94007e1 	ldr	x1, [sp, #8]
    a001ee28:	f9000001 	str	x1, [x0]
	node->prev = tail;
    a001ee2c:	f94003e0 	ldr	x0, [sp]
    a001ee30:	f9400fe1 	ldr	x1, [sp, #24]
    a001ee34:	f9000401 	str	x1, [x0, #8]
	tail->next = node;
    a001ee38:	f9400fe0 	ldr	x0, [sp, #24]
    a001ee3c:	f94003e1 	ldr	x1, [sp]
    a001ee40:	f9000001 	str	x1, [x0]
	list->tail = node;
    a001ee44:	f94007e0 	ldr	x0, [sp, #8]
    a001ee48:	f94003e1 	ldr	x1, [sp]
    a001ee4c:	f9000401 	str	x1, [x0, #8]
}
    a001ee50:	d503201f 	nop
    a001ee54:	910083ff 	add	sp, sp, #0x20
    a001ee58:	d65f03c0 	ret

00000000a001ee5c <sys_dlist_remove>:
{
    a001ee5c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a001ee60:	910003fd 	mov	x29, sp
    a001ee64:	f9000fe0 	str	x0, [sp, #24]
	sys_dnode_t *const prev = node->prev;
    a001ee68:	f9400fe0 	ldr	x0, [sp, #24]
    a001ee6c:	f9400400 	ldr	x0, [x0, #8]
    a001ee70:	f90017e0 	str	x0, [sp, #40]
	sys_dnode_t *const next = node->next;
    a001ee74:	f9400fe0 	ldr	x0, [sp, #24]
    a001ee78:	f9400000 	ldr	x0, [x0]
    a001ee7c:	f90013e0 	str	x0, [sp, #32]
	prev->next = next;
    a001ee80:	f94017e0 	ldr	x0, [sp, #40]
    a001ee84:	f94013e1 	ldr	x1, [sp, #32]
    a001ee88:	f9000001 	str	x1, [x0]
	next->prev = prev;
    a001ee8c:	f94013e0 	ldr	x0, [sp, #32]
    a001ee90:	f94017e1 	ldr	x1, [sp, #40]
    a001ee94:	f9000401 	str	x1, [x0, #8]
	sys_dnode_init(node);
    a001ee98:	f9400fe0 	ldr	x0, [sp, #24]
    a001ee9c:	97ffff9e 	bl	a001ed14 <sys_dnode_init>
}
    a001eea0:	d503201f 	nop
    a001eea4:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a001eea8:	d65f03c0 	ret

00000000a001eeac <sys_dlist_get>:
 *
 * @return the first node in the list, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
    a001eeac:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a001eeb0:	910003fd 	mov	x29, sp
    a001eeb4:	f9000fe0 	str	x0, [sp, #24]
	sys_dnode_t *node = NULL;
    a001eeb8:	f90017ff 	str	xzr, [sp, #40]

	if (!sys_dlist_is_empty(list)) {
    a001eebc:	f9400fe0 	ldr	x0, [sp, #24]
    a001eec0:	97ffff9e 	bl	a001ed38 <sys_dlist_is_empty>
    a001eec4:	12001c00 	and	w0, w0, #0xff
    a001eec8:	52000000 	eor	w0, w0, #0x1
    a001eecc:	12001c00 	and	w0, w0, #0xff
    a001eed0:	7100001f 	cmp	w0, #0x0
    a001eed4:	540000c0 	b.eq	a001eeec <sys_dlist_get+0x40>  // b.none
		node = list->head;
    a001eed8:	f9400fe0 	ldr	x0, [sp, #24]
    a001eedc:	f9400000 	ldr	x0, [x0]
    a001eee0:	f90017e0 	str	x0, [sp, #40]
		sys_dlist_remove(node);
    a001eee4:	f94017e0 	ldr	x0, [sp, #40]
    a001eee8:	97ffffdd 	bl	a001ee5c <sys_dlist_remove>
	}

	return node;
    a001eeec:	f94017e0 	ldr	x0, [sp, #40]
}
    a001eef0:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a001eef4:	d65f03c0 	ret

00000000a001eef8 <z_thread_malloc>:
{
    a001eef8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a001eefc:	910003fd 	mov	x29, sp
    a001ef00:	f9000fe0 	str	x0, [sp, #24]
	return z_thread_aligned_alloc(0, size);
    a001ef04:	f9400fe1 	ldr	x1, [sp, #24]
    a001ef08:	d2800000 	mov	x0, #0x0                   	// #0
    a001ef0c:	97fff1f6 	bl	a001b6e4 <z_thread_aligned_alloc>
}
    a001ef10:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a001ef14:	d65f03c0 	ret

00000000a001ef18 <z_sched_lock>:
	--_current->base.sched_locked;
    a001ef18:	b0000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001ef1c:	913f8000 	add	x0, x0, #0xfe0
    a001ef20:	f9400800 	ldr	x0, [x0, #16]
    a001ef24:	39406c01 	ldrb	w1, [x0, #27]
    a001ef28:	51000421 	sub	w1, w1, #0x1
    a001ef2c:	12001c21 	and	w1, w1, #0xff
    a001ef30:	39006c01 	strb	w1, [x0, #27]
}
    a001ef34:	d503201f 	nop
    a001ef38:	d65f03c0 	ret

00000000a001ef3c <z_waitq_init>:
{
    a001ef3c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a001ef40:	910003fd 	mov	x29, sp
    a001ef44:	f9000fe0 	str	x0, [sp, #24]
	sys_dlist_init(&w->waitq);
    a001ef48:	f9400fe0 	ldr	x0, [sp, #24]
    a001ef4c:	97ffff67 	bl	a001ece8 <sys_dlist_init>
}
    a001ef50:	d503201f 	nop
    a001ef54:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a001ef58:	d65f03c0 	ret

00000000a001ef5c <z_waitq_head>:
{
    a001ef5c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a001ef60:	910003fd 	mov	x29, sp
    a001ef64:	f9000fe0 	str	x0, [sp, #24]
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
    a001ef68:	f9400fe0 	ldr	x0, [sp, #24]
    a001ef6c:	97ffff7d 	bl	a001ed60 <sys_dlist_peek_head>
}
    a001ef70:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a001ef74:	d65f03c0 	ret

00000000a001ef78 <z_obj_validation_check>:
{
    a001ef78:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    a001ef7c:	910003fd 	mov	x29, sp
    a001ef80:	f90017e0 	str	x0, [sp, #40]
    a001ef84:	f90013e1 	str	x1, [sp, #32]
    a001ef88:	b9001fe2 	str	w2, [sp, #28]
    a001ef8c:	b9001be3 	str	w3, [sp, #24]
	ret = z_object_validate(ko, otype, init);
    a001ef90:	b9401be2 	ldr	w2, [sp, #24]
    a001ef94:	b9401fe1 	ldr	w1, [sp, #28]
    a001ef98:	f94017e0 	ldr	x0, [sp, #40]
    a001ef9c:	97fff8ca 	bl	a001d2c4 <z_object_validate>
    a001efa0:	b9003fe0 	str	w0, [sp, #60]
	return ret;
    a001efa4:	b9403fe0 	ldr	w0, [sp, #60]
}
    a001efa8:	a8c47bfd 	ldp	x29, x30, [sp], #64
    a001efac:	d65f03c0 	ret

00000000a001efb0 <k_pipe_init>:
			     void *data, size_t bytes_to_read,
			     size_t *bytes_read, size_t min_xfer,
			     k_timeout_t timeout);

void k_pipe_init(struct k_pipe *pipe, unsigned char *buffer, size_t size)
{
    a001efb0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a001efb4:	910003fd 	mov	x29, sp
    a001efb8:	f90017e0 	str	x0, [sp, #40]
    a001efbc:	f90013e1 	str	x1, [sp, #32]
    a001efc0:	f9000fe2 	str	x2, [sp, #24]
	pipe->buffer = buffer;
    a001efc4:	f94017e0 	ldr	x0, [sp, #40]
    a001efc8:	f94013e1 	ldr	x1, [sp, #32]
    a001efcc:	f9000001 	str	x1, [x0]
	pipe->size = size;
    a001efd0:	f94017e0 	ldr	x0, [sp, #40]
    a001efd4:	f9400fe1 	ldr	x1, [sp, #24]
    a001efd8:	f9000401 	str	x1, [x0, #8]
	pipe->bytes_used = 0;
    a001efdc:	f94017e0 	ldr	x0, [sp, #40]
    a001efe0:	f900081f 	str	xzr, [x0, #16]
	pipe->read_index = 0;
    a001efe4:	f94017e0 	ldr	x0, [sp, #40]
    a001efe8:	f9000c1f 	str	xzr, [x0, #24]
	pipe->write_index = 0;
    a001efec:	f94017e0 	ldr	x0, [sp, #40]
    a001eff0:	f900101f 	str	xzr, [x0, #32]
	pipe->lock = (struct k_spinlock){};
	z_waitq_init(&pipe->wait_q.writers);
    a001eff4:	f94017e0 	ldr	x0, [sp, #40]
    a001eff8:	9100e000 	add	x0, x0, #0x38
    a001effc:	97ffffd0 	bl	a001ef3c <z_waitq_init>
	z_waitq_init(&pipe->wait_q.readers);
    a001f000:	f94017e0 	ldr	x0, [sp, #40]
    a001f004:	9100a000 	add	x0, x0, #0x28
    a001f008:	97ffffcd 	bl	a001ef3c <z_waitq_init>
	SYS_PORT_TRACING_OBJ_INIT(k_pipe, pipe);

	pipe->flags = 0;
    a001f00c:	f94017e0 	ldr	x0, [sp, #40]
    a001f010:	3901201f 	strb	wzr, [x0, #72]
	z_object_init(pipe);
    a001f014:	f94017e0 	ldr	x0, [sp, #40]
    a001f018:	97fff8fe 	bl	a001d410 <z_object_init>
}
    a001f01c:	d503201f 	nop
    a001f020:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a001f024:	d65f03c0 	ret

00000000a001f028 <z_impl_k_pipe_alloc_init>:

int z_impl_k_pipe_alloc_init(struct k_pipe *pipe, size_t size)
{
    a001f028:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a001f02c:	910003fd 	mov	x29, sp
    a001f030:	f9000fe0 	str	x0, [sp, #24]
    a001f034:	f9000be1 	str	x1, [sp, #16]
	void *buffer;
	int ret;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_pipe, alloc_init, pipe);

	if (size != 0U) {
    a001f038:	f9400be0 	ldr	x0, [sp, #16]
    a001f03c:	f100001f 	cmp	x0, #0x0
    a001f040:	54000260 	b.eq	a001f08c <z_impl_k_pipe_alloc_init+0x64>  // b.none
		buffer = z_thread_malloc(size);
    a001f044:	f9400be0 	ldr	x0, [sp, #16]
    a001f048:	97ffffac 	bl	a001eef8 <z_thread_malloc>
    a001f04c:	f90013e0 	str	x0, [sp, #32]
		if (buffer != NULL) {
    a001f050:	f94013e0 	ldr	x0, [sp, #32]
    a001f054:	f100001f 	cmp	x0, #0x0
    a001f058:	54000140 	b.eq	a001f080 <z_impl_k_pipe_alloc_init+0x58>  // b.none
			k_pipe_init(pipe, buffer, size);
    a001f05c:	f9400be2 	ldr	x2, [sp, #16]
    a001f060:	f94013e1 	ldr	x1, [sp, #32]
    a001f064:	f9400fe0 	ldr	x0, [sp, #24]
    a001f068:	97ffffd2 	bl	a001efb0 <k_pipe_init>
			pipe->flags = K_PIPE_FLAG_ALLOC;
    a001f06c:	f9400fe0 	ldr	x0, [sp, #24]
    a001f070:	52800021 	mov	w1, #0x1                   	// #1
    a001f074:	39012001 	strb	w1, [x0, #72]
			ret = 0;
    a001f078:	b9002fff 	str	wzr, [sp, #44]
    a001f07c:	14000009 	b	a001f0a0 <z_impl_k_pipe_alloc_init+0x78>
		} else {
			ret = -ENOMEM;
    a001f080:	12800160 	mov	w0, #0xfffffff4            	// #-12
    a001f084:	b9002fe0 	str	w0, [sp, #44]
    a001f088:	14000006 	b	a001f0a0 <z_impl_k_pipe_alloc_init+0x78>
		}
	} else {
		k_pipe_init(pipe, NULL, 0);
    a001f08c:	d2800002 	mov	x2, #0x0                   	// #0
    a001f090:	d2800001 	mov	x1, #0x0                   	// #0
    a001f094:	f9400fe0 	ldr	x0, [sp, #24]
    a001f098:	97ffffc6 	bl	a001efb0 <k_pipe_init>
		ret = 0;
    a001f09c:	b9002fff 	str	wzr, [sp, #44]
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_pipe, alloc_init, pipe, ret);

	return ret;
    a001f0a0:	b9402fe0 	ldr	w0, [sp, #44]
}
    a001f0a4:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a001f0a8:	d65f03c0 	ret

00000000a001f0ac <z_vrfy_k_pipe_alloc_init>:

#ifdef CONFIG_USERSPACE
static inline int z_vrfy_k_pipe_alloc_init(struct k_pipe *pipe, size_t size)
{
    a001f0ac:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a001f0b0:	910003fd 	mov	x29, sp
    a001f0b4:	f9000fe0 	str	x0, [sp, #24]
    a001f0b8:	f9000be1 	str	x1, [sp, #16]
	Z_OOPS(Z_SYSCALL_OBJ_NEVER_INIT(pipe, K_OBJ_PIPE));
    a001f0bc:	f9400fe0 	ldr	x0, [sp, #24]
    a001f0c0:	97fff65a 	bl	a001ca28 <z_object_find>
    a001f0c4:	12800003 	mov	w3, #0xffffffff            	// #-1
    a001f0c8:	52800082 	mov	w2, #0x4                   	// #4
    a001f0cc:	f9400fe1 	ldr	x1, [sp, #24]
    a001f0d0:	97ffffaa 	bl	a001ef78 <z_obj_validation_check>
    a001f0d4:	7100001f 	cmp	w0, #0x0
    a001f0d8:	1a9f07e0 	cset	w0, ne  // ne = any
    a001f0dc:	39063fe0 	strb	w0, [sp, #399]
    a001f0e0:	39463fe0 	ldrb	w0, [sp, #399]
    a001f0e4:	7100001f 	cmp	w0, #0x0
    a001f0e8:	39463fe0 	ldrb	w0, [sp, #399]
    a001f0ec:	7100001f 	cmp	w0, #0x0
    a001f0f0:	540000c0 	b.eq	a001f108 <z_vrfy_k_pipe_alloc_init+0x5c>  // b.none
    a001f0f4:	90000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001f0f8:	913f8000 	add	x0, x0, #0xfe0
    a001f0fc:	f9400800 	ldr	x0, [x0, #16]
    a001f100:	f9408400 	ldr	x0, [x0, #264]
    a001f104:	97ffa815 	bl	a0009158 <arch_syscall_oops>

	return z_impl_k_pipe_alloc_init(pipe, size);
    a001f108:	f9400be1 	ldr	x1, [sp, #16]
    a001f10c:	f9400fe0 	ldr	x0, [sp, #24]
    a001f110:	97ffffc6 	bl	a001f028 <z_impl_k_pipe_alloc_init>
}
    a001f114:	a8d97bfd 	ldp	x29, x30, [sp], #400
    a001f118:	d65f03c0 	ret

00000000a001f11c <z_mrsh_k_pipe_alloc_init>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_pipe_alloc_init(struct k_pipe * pipe, size_t size);
uintptr_t z_mrsh_k_pipe_alloc_init(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a001f11c:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a001f120:	910003fd 	mov	x29, sp
    a001f124:	f90027e0 	str	x0, [sp, #72]
    a001f128:	f90023e1 	str	x1, [sp, #64]
    a001f12c:	f9001fe2 	str	x2, [sp, #56]
    a001f130:	f9001be3 	str	x3, [sp, #48]
    a001f134:	f90017e4 	str	x4, [sp, #40]
    a001f138:	f90013e5 	str	x5, [sp, #32]
    a001f13c:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a001f140:	90000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001f144:	913f8000 	add	x0, x0, #0xfe0
    a001f148:	f9400800 	ldr	x0, [x0, #16]
    a001f14c:	f9400fe1 	ldr	x1, [sp, #24]
    a001f150:	f9008401 	str	x1, [x0, #264]
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_pipe_alloc_init(*(struct k_pipe **)&arg0, *(size_t*)&arg1)
    a001f154:	910123e0 	add	x0, sp, #0x48
    a001f158:	f9400002 	ldr	x2, [x0]
    a001f15c:	910103e0 	add	x0, sp, #0x40
    a001f160:	f9400000 	ldr	x0, [x0]
    a001f164:	aa0003e1 	mov	x1, x0
    a001f168:	aa0203e0 	mov	x0, x2
    a001f16c:	97ffffd0 	bl	a001f0ac <z_vrfy_k_pipe_alloc_init>
    a001f170:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a001f174:	90000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001f178:	913f8000 	add	x0, x0, #0xfe0
    a001f17c:	f9400800 	ldr	x0, [x0, #16]
    a001f180:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a001f184:	b9805fe0 	ldrsw	x0, [sp, #92]
}
    a001f188:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a001f18c:	d65f03c0 	ret

00000000a001f190 <z_impl_k_pipe_flush>:
#include <syscalls/k_pipe_alloc_init_mrsh.c>
#endif

void z_impl_k_pipe_flush(struct k_pipe *pipe)
{
    a001f190:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a001f194:	910003fd 	mov	x29, sp
    a001f198:	f9000fe0 	str	x0, [sp, #24]
	size_t  bytes_read;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_pipe, flush, pipe);

	k_spinlock_key_t key = k_spin_lock(&pipe->lock);
    a001f19c:	f9400fe0 	ldr	x0, [sp, #24]
    a001f1a0:	9100a000 	add	x0, x0, #0x28
    a001f1a4:	f90027e0 	str	x0, [sp, #72]
MAKE_REG_HELPER(daif)
    a001f1a8:	d53b4220 	mrs	x0, daif
    a001f1ac:	f90023e0 	str	x0, [sp, #64]
    a001f1b0:	f94023e0 	ldr	x0, [sp, #64]
    a001f1b4:	d503201f 	nop
	key = read_daif();
    a001f1b8:	b9003fe0 	str	w0, [sp, #60]
	__asm__ volatile ("msr DAIFSet, %0"
    a001f1bc:	d50342df 	msr	daifset, #0x2
}
    a001f1c0:	d503201f 	nop
	return key;
    a001f1c4:	b9403fe0 	ldr	w0, [sp, #60]
	k.key = arch_irq_lock();
    a001f1c8:	b90023e0 	str	w0, [sp, #32]
	return k;
    a001f1cc:	b94023e0 	ldr	w0, [sp, #32]
    a001f1d0:	b9002be0 	str	w0, [sp, #40]

	(void) pipe_get_internal(key, pipe, NULL, (size_t) -1, &bytes_read, 0,
				 K_NO_WAIT);
    a001f1d4:	d2800001 	mov	x1, #0x0                   	// #0
	(void) pipe_get_internal(key, pipe, NULL, (size_t) -1, &bytes_read, 0,
    a001f1d8:	9100c3e0 	add	x0, sp, #0x30
    a001f1dc:	aa0103e6 	mov	x6, x1
    a001f1e0:	d2800005 	mov	x5, #0x0                   	// #0
    a001f1e4:	aa0003e4 	mov	x4, x0
    a001f1e8:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
    a001f1ec:	d2800002 	mov	x2, #0x0                   	// #0
    a001f1f0:	f9400fe1 	ldr	x1, [sp, #24]
    a001f1f4:	b9402be0 	ldr	w0, [sp, #40]
    a001f1f8:	94000337 	bl	a001fed4 <pipe_get_internal>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_pipe, flush, pipe);
}
    a001f1fc:	d503201f 	nop
    a001f200:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a001f204:	d65f03c0 	ret

00000000a001f208 <z_vrfy_k_pipe_flush>:

#ifdef CONFIG_USERSPACE
void z_vrfy_k_pipe_flush(struct k_pipe *pipe)
{
    a001f208:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a001f20c:	910003fd 	mov	x29, sp
    a001f210:	f9000fe0 	str	x0, [sp, #24]
	Z_OOPS(Z_SYSCALL_OBJ(pipe, K_OBJ_PIPE));
    a001f214:	f9400fe0 	ldr	x0, [sp, #24]
    a001f218:	97fff604 	bl	a001ca28 <z_object_find>
    a001f21c:	52800003 	mov	w3, #0x0                   	// #0
    a001f220:	52800082 	mov	w2, #0x4                   	// #4
    a001f224:	f9400fe1 	ldr	x1, [sp, #24]
    a001f228:	97ffff54 	bl	a001ef78 <z_obj_validation_check>
    a001f22c:	7100001f 	cmp	w0, #0x0
    a001f230:	1a9f07e0 	cset	w0, ne  // ne = any
    a001f234:	39063fe0 	strb	w0, [sp, #399]
    a001f238:	39463fe0 	ldrb	w0, [sp, #399]
    a001f23c:	7100001f 	cmp	w0, #0x0
    a001f240:	39463fe0 	ldrb	w0, [sp, #399]
    a001f244:	7100001f 	cmp	w0, #0x0
    a001f248:	540000c0 	b.eq	a001f260 <z_vrfy_k_pipe_flush+0x58>  // b.none
    a001f24c:	90000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001f250:	913f8000 	add	x0, x0, #0xfe0
    a001f254:	f9400800 	ldr	x0, [x0, #16]
    a001f258:	f9408400 	ldr	x0, [x0, #264]
    a001f25c:	97ffa7bf 	bl	a0009158 <arch_syscall_oops>

	z_impl_k_pipe_flush(pipe);
    a001f260:	f9400fe0 	ldr	x0, [sp, #24]
    a001f264:	97ffffcb 	bl	a001f190 <z_impl_k_pipe_flush>
}
    a001f268:	d503201f 	nop
    a001f26c:	a8d97bfd 	ldp	x29, x30, [sp], #400
    a001f270:	d65f03c0 	ret

00000000a001f274 <z_mrsh_k_pipe_flush>:
#include <syscalls/kernel.h>

extern void z_vrfy_k_pipe_flush(struct k_pipe * pipe);
uintptr_t z_mrsh_k_pipe_flush(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a001f274:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a001f278:	910003fd 	mov	x29, sp
    a001f27c:	f90027e0 	str	x0, [sp, #72]
    a001f280:	f90023e1 	str	x1, [sp, #64]
    a001f284:	f9001fe2 	str	x2, [sp, #56]
    a001f288:	f9001be3 	str	x3, [sp, #48]
    a001f28c:	f90017e4 	str	x4, [sp, #40]
    a001f290:	f90013e5 	str	x5, [sp, #32]
    a001f294:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a001f298:	90000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001f29c:	913f8000 	add	x0, x0, #0xfe0
    a001f2a0:	f9400800 	ldr	x0, [x0, #16]
    a001f2a4:	f9400fe1 	ldr	x1, [sp, #24]
    a001f2a8:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_pipe_flush(*(struct k_pipe **)&arg0)
    a001f2ac:	910123e0 	add	x0, sp, #0x48
    a001f2b0:	f9400000 	ldr	x0, [x0]
    a001f2b4:	97ffffd5 	bl	a001f208 <z_vrfy_k_pipe_flush>
;
	_current->syscall_frame = NULL;
    a001f2b8:	90000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001f2bc:	913f8000 	add	x0, x0, #0xfe0
    a001f2c0:	f9400800 	ldr	x0, [x0, #16]
    a001f2c4:	f900841f 	str	xzr, [x0, #264]
	return 0;
    a001f2c8:	d2800000 	mov	x0, #0x0                   	// #0
}
    a001f2cc:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a001f2d0:	d65f03c0 	ret

00000000a001f2d4 <k_pipe_cleanup>:
	z_impl_k_pipe_buffer_flush(pipe);
}
#endif

int k_pipe_cleanup(struct k_pipe *pipe)
{
    a001f2d4:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
    a001f2d8:	910003fd 	mov	x29, sp
    a001f2dc:	f9000fe0 	str	x0, [sp, #24]
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_pipe, cleanup, pipe);

	k_spinlock_key_t key = k_spin_lock(&pipe->lock);
    a001f2e0:	f9400fe0 	ldr	x0, [sp, #24]
    a001f2e4:	9100a000 	add	x0, x0, #0x28
    a001f2e8:	f90047e0 	str	x0, [sp, #136]
MAKE_REG_HELPER(daif)
    a001f2ec:	d53b4220 	mrs	x0, daif
    a001f2f0:	f90043e0 	str	x0, [sp, #128]
    a001f2f4:	f94043e0 	ldr	x0, [sp, #128]
    a001f2f8:	d503201f 	nop
	key = read_daif();
    a001f2fc:	b9007fe0 	str	w0, [sp, #124]
	__asm__ volatile ("msr DAIFSet, %0"
    a001f300:	d50342df 	msr	daifset, #0x2
}
    a001f304:	d503201f 	nop
	return key;
    a001f308:	b9407fe0 	ldr	w0, [sp, #124]
	k.key = arch_irq_lock();
    a001f30c:	b9002be0 	str	w0, [sp, #40]
	return k;
    a001f310:	b9402be0 	ldr	w0, [sp, #40]
    a001f314:	b90043e0 	str	w0, [sp, #64]

	CHECKIF(z_waitq_head(&pipe->wait_q.readers) != NULL ||
    a001f318:	f9400fe0 	ldr	x0, [sp, #24]
    a001f31c:	9100a000 	add	x0, x0, #0x28
    a001f320:	97ffff0f 	bl	a001ef5c <z_waitq_head>
    a001f324:	f100001f 	cmp	x0, #0x0
    a001f328:	540000c1 	b.ne	a001f340 <k_pipe_cleanup+0x6c>  // b.any
    a001f32c:	f9400fe0 	ldr	x0, [sp, #24]
    a001f330:	9100e000 	add	x0, x0, #0x38
    a001f334:	97ffff0a 	bl	a001ef5c <z_waitq_head>
    a001f338:	f100001f 	cmp	x0, #0x0
    a001f33c:	54000220 	b.eq	a001f380 <k_pipe_cleanup+0xac>  // b.none
			z_waitq_head(&pipe->wait_q.writers) != NULL) {
		k_spin_unlock(&pipe->lock, key);
    a001f340:	f9400fe0 	ldr	x0, [sp, #24]
    a001f344:	9100a000 	add	x0, x0, #0x28
    a001f348:	f9003be0 	str	x0, [sp, #112]
    a001f34c:	b94043e0 	ldr	w0, [sp, #64]
    a001f350:	b90033e0 	str	w0, [sp, #48]
	arch_irq_unlock(key.key);
    a001f354:	b94033e0 	ldr	w0, [sp, #48]
    a001f358:	b9006fe0 	str	w0, [sp, #108]
	write_daif(key);
    a001f35c:	b9406fe0 	ldr	w0, [sp, #108]
    a001f360:	f90033e0 	str	x0, [sp, #96]
MAKE_REG_HELPER(daif)
    a001f364:	f94033e0 	ldr	x0, [sp, #96]
    a001f368:	d51b4220 	msr	daif, x0
    a001f36c:	d503201f 	nop
}
    a001f370:	d503201f 	nop
}
    a001f374:	d503201f 	nop

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_pipe, cleanup, pipe, -EAGAIN);

		return -EAGAIN;
    a001f378:	12800140 	mov	w0, #0xfffffff5            	// #-11
    a001f37c:	14000029 	b	a001f420 <k_pipe_cleanup+0x14c>
	}

	if ((pipe->flags & K_PIPE_FLAG_ALLOC) != 0U) {
    a001f380:	f9400fe0 	ldr	x0, [sp, #24]
    a001f384:	39412000 	ldrb	w0, [x0, #72]
    a001f388:	92401c00 	and	x0, x0, #0xff
    a001f38c:	92400000 	and	x0, x0, #0x1
    a001f390:	f100001f 	cmp	x0, #0x0
    a001f394:	54000280 	b.eq	a001f3e4 <k_pipe_cleanup+0x110>  // b.none
		k_free(pipe->buffer);
    a001f398:	f9400fe0 	ldr	x0, [sp, #24]
    a001f39c:	f9400000 	ldr	x0, [x0]
    a001f3a0:	97fff0bd 	bl	a001b694 <k_free>
		pipe->buffer = NULL;
    a001f3a4:	f9400fe0 	ldr	x0, [sp, #24]
    a001f3a8:	f900001f 	str	xzr, [x0]
		/*
		 * Freeing the buffer changes the pipe into a bufferless
		 * pipe. Reset the pipe's counters to prevent malfunction.
		 */

		pipe->size = 0;
    a001f3ac:	f9400fe0 	ldr	x0, [sp, #24]
    a001f3b0:	f900041f 	str	xzr, [x0, #8]
		pipe->bytes_used = 0;
    a001f3b4:	f9400fe0 	ldr	x0, [sp, #24]
    a001f3b8:	f900081f 	str	xzr, [x0, #16]
		pipe->read_index = 0;
    a001f3bc:	f9400fe0 	ldr	x0, [sp, #24]
    a001f3c0:	f9000c1f 	str	xzr, [x0, #24]
		pipe->write_index = 0;
    a001f3c4:	f9400fe0 	ldr	x0, [sp, #24]
    a001f3c8:	f900101f 	str	xzr, [x0, #32]
		pipe->flags &= ~K_PIPE_FLAG_ALLOC;
    a001f3cc:	f9400fe0 	ldr	x0, [sp, #24]
    a001f3d0:	39412000 	ldrb	w0, [x0, #72]
    a001f3d4:	121f7800 	and	w0, w0, #0xfffffffe
    a001f3d8:	12001c01 	and	w1, w0, #0xff
    a001f3dc:	f9400fe0 	ldr	x0, [sp, #24]
    a001f3e0:	39012001 	strb	w1, [x0, #72]
	}

	k_spin_unlock(&pipe->lock, key);
    a001f3e4:	f9400fe0 	ldr	x0, [sp, #24]
    a001f3e8:	9100a000 	add	x0, x0, #0x28
    a001f3ec:	f9002fe0 	str	x0, [sp, #88]
    a001f3f0:	b94043e0 	ldr	w0, [sp, #64]
    a001f3f4:	b9003be0 	str	w0, [sp, #56]
	arch_irq_unlock(key.key);
    a001f3f8:	b9403be0 	ldr	w0, [sp, #56]
    a001f3fc:	b90057e0 	str	w0, [sp, #84]
	write_daif(key);
    a001f400:	b94057e0 	ldr	w0, [sp, #84]
    a001f404:	f90027e0 	str	x0, [sp, #72]
    a001f408:	f94027e0 	ldr	x0, [sp, #72]
    a001f40c:	d51b4220 	msr	daif, x0
    a001f410:	d503201f 	nop
}
    a001f414:	d503201f 	nop
}
    a001f418:	d503201f 	nop

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_pipe, cleanup, pipe, 0);

	return 0;
    a001f41c:	52800000 	mov	w0, #0x0                   	// #0
}
    a001f420:	a8c97bfd 	ldp	x29, x30, [sp], #144
    a001f424:	d65f03c0 	ret

00000000a001f428 <pipe_xfer>:
 *
 * @return Number of bytes copied
 */
static size_t pipe_xfer(unsigned char *dest, size_t dest_size,
			 const unsigned char *src, size_t src_size)
{
    a001f428:	d100c3ff 	sub	sp, sp, #0x30
    a001f42c:	f9000fe0 	str	x0, [sp, #24]
    a001f430:	f9000be1 	str	x1, [sp, #16]
    a001f434:	f90007e2 	str	x2, [sp, #8]
    a001f438:	f90003e3 	str	x3, [sp]
	size_t num_bytes = MIN(dest_size, src_size);
    a001f43c:	f9400be0 	ldr	x0, [sp, #16]
    a001f440:	f94003e2 	ldr	x2, [sp]
    a001f444:	f94003e1 	ldr	x1, [sp]
    a001f448:	eb00005f 	cmp	x2, x0
    a001f44c:	9a809020 	csel	x0, x1, x0, ls  // ls = plast
    a001f450:	f90017e0 	str	x0, [sp, #40]
	const unsigned char *end = src + num_bytes;
    a001f454:	f94007e1 	ldr	x1, [sp, #8]
    a001f458:	f94017e0 	ldr	x0, [sp, #40]
    a001f45c:	8b000020 	add	x0, x1, x0
    a001f460:	f90013e0 	str	x0, [sp, #32]

	if (dest == NULL) {
    a001f464:	f9400fe0 	ldr	x0, [sp, #24]
    a001f468:	f100001f 	cmp	x0, #0x0
    a001f46c:	540001a1 	b.ne	a001f4a0 <pipe_xfer+0x78>  // b.any
		/* Data is being flushed. Pretend the data was copied. */
		return num_bytes;
    a001f470:	f94017e0 	ldr	x0, [sp, #40]
    a001f474:	14000010 	b	a001f4b4 <pipe_xfer+0x8c>
	}

	while (src != end) {
		*dest = *src;
    a001f478:	f94007e0 	ldr	x0, [sp, #8]
    a001f47c:	39400001 	ldrb	w1, [x0]
    a001f480:	f9400fe0 	ldr	x0, [sp, #24]
    a001f484:	39000001 	strb	w1, [x0]
		dest++;
    a001f488:	f9400fe0 	ldr	x0, [sp, #24]
    a001f48c:	91000400 	add	x0, x0, #0x1
    a001f490:	f9000fe0 	str	x0, [sp, #24]
		src++;
    a001f494:	f94007e0 	ldr	x0, [sp, #8]
    a001f498:	91000400 	add	x0, x0, #0x1
    a001f49c:	f90007e0 	str	x0, [sp, #8]
	while (src != end) {
    a001f4a0:	f94007e1 	ldr	x1, [sp, #8]
    a001f4a4:	f94013e0 	ldr	x0, [sp, #32]
    a001f4a8:	eb00003f 	cmp	x1, x0
    a001f4ac:	54fffe61 	b.ne	a001f478 <pipe_xfer+0x50>  // b.any
	}

	return num_bytes;
    a001f4b0:	f94017e0 	ldr	x0, [sp, #40]
}
    a001f4b4:	9100c3ff 	add	sp, sp, #0x30
    a001f4b8:	d65f03c0 	ret

00000000a001f4bc <pipe_buffer_put>:
 *
 * @return Number of bytes written to the pipe's circular buffer
 */
static size_t pipe_buffer_put(struct k_pipe *pipe,
			       const unsigned char *src, size_t src_size)
{
    a001f4bc:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a001f4c0:	910003fd 	mov	x29, sp
    a001f4c4:	f90017e0 	str	x0, [sp, #40]
    a001f4c8:	f90013e1 	str	x1, [sp, #32]
    a001f4cc:	f9000fe2 	str	x2, [sp, #24]
	size_t  bytes_copied;
	size_t  run_length;
	size_t  num_bytes_written = 0;
    a001f4d0:	f90027ff 	str	xzr, [sp, #72]
	int     i;


	for (i = 0; i < 2; i++) {
    a001f4d4:	b90047ff 	str	wzr, [sp, #68]
    a001f4d8:	14000039 	b	a001f5bc <pipe_buffer_put+0x100>
		run_length = MIN(pipe->size - pipe->bytes_used,
    a001f4dc:	f94017e0 	ldr	x0, [sp, #40]
    a001f4e0:	f9400401 	ldr	x1, [x0, #8]
    a001f4e4:	f94017e0 	ldr	x0, [sp, #40]
    a001f4e8:	f9401000 	ldr	x0, [x0, #32]
    a001f4ec:	cb000021 	sub	x1, x1, x0
    a001f4f0:	f94017e0 	ldr	x0, [sp, #40]
    a001f4f4:	f9400402 	ldr	x2, [x0, #8]
    a001f4f8:	f94017e0 	ldr	x0, [sp, #40]
    a001f4fc:	f9400800 	ldr	x0, [x0, #16]
    a001f500:	cb000040 	sub	x0, x2, x0
    a001f504:	eb00003f 	cmp	x1, x0
    a001f508:	9a809020 	csel	x0, x1, x0, ls  // ls = plast
    a001f50c:	f9001fe0 	str	x0, [sp, #56]
				 pipe->size - pipe->write_index);

		bytes_copied = pipe_xfer(pipe->buffer + pipe->write_index,
    a001f510:	f94017e0 	ldr	x0, [sp, #40]
    a001f514:	f9400001 	ldr	x1, [x0]
    a001f518:	f94017e0 	ldr	x0, [sp, #40]
    a001f51c:	f9401000 	ldr	x0, [x0, #32]
    a001f520:	8b000024 	add	x4, x1, x0
    a001f524:	f94013e1 	ldr	x1, [sp, #32]
    a001f528:	f94027e0 	ldr	x0, [sp, #72]
    a001f52c:	8b000022 	add	x2, x1, x0
    a001f530:	f9400fe1 	ldr	x1, [sp, #24]
    a001f534:	f94027e0 	ldr	x0, [sp, #72]
    a001f538:	cb000020 	sub	x0, x1, x0
    a001f53c:	aa0003e3 	mov	x3, x0
    a001f540:	f9401fe1 	ldr	x1, [sp, #56]
    a001f544:	aa0403e0 	mov	x0, x4
    a001f548:	97ffffb8 	bl	a001f428 <pipe_xfer>
    a001f54c:	f9001be0 	str	x0, [sp, #48]
					  run_length,
					  src + num_bytes_written,
					  src_size - num_bytes_written);

		num_bytes_written += bytes_copied;
    a001f550:	f94027e1 	ldr	x1, [sp, #72]
    a001f554:	f9401be0 	ldr	x0, [sp, #48]
    a001f558:	8b000020 	add	x0, x1, x0
    a001f55c:	f90027e0 	str	x0, [sp, #72]
		pipe->bytes_used += bytes_copied;
    a001f560:	f94017e0 	ldr	x0, [sp, #40]
    a001f564:	f9400801 	ldr	x1, [x0, #16]
    a001f568:	f9401be0 	ldr	x0, [sp, #48]
    a001f56c:	8b000021 	add	x1, x1, x0
    a001f570:	f94017e0 	ldr	x0, [sp, #40]
    a001f574:	f9000801 	str	x1, [x0, #16]
		pipe->write_index += bytes_copied;
    a001f578:	f94017e0 	ldr	x0, [sp, #40]
    a001f57c:	f9401001 	ldr	x1, [x0, #32]
    a001f580:	f9401be0 	ldr	x0, [sp, #48]
    a001f584:	8b000021 	add	x1, x1, x0
    a001f588:	f94017e0 	ldr	x0, [sp, #40]
    a001f58c:	f9001001 	str	x1, [x0, #32]
		if (pipe->write_index == pipe->size) {
    a001f590:	f94017e0 	ldr	x0, [sp, #40]
    a001f594:	f9401001 	ldr	x1, [x0, #32]
    a001f598:	f94017e0 	ldr	x0, [sp, #40]
    a001f59c:	f9400400 	ldr	x0, [x0, #8]
    a001f5a0:	eb00003f 	cmp	x1, x0
    a001f5a4:	54000061 	b.ne	a001f5b0 <pipe_buffer_put+0xf4>  // b.any
			pipe->write_index = 0;
    a001f5a8:	f94017e0 	ldr	x0, [sp, #40]
    a001f5ac:	f900101f 	str	xzr, [x0, #32]
	for (i = 0; i < 2; i++) {
    a001f5b0:	b94047e0 	ldr	w0, [sp, #68]
    a001f5b4:	11000400 	add	w0, w0, #0x1
    a001f5b8:	b90047e0 	str	w0, [sp, #68]
    a001f5bc:	b94047e0 	ldr	w0, [sp, #68]
    a001f5c0:	7100041f 	cmp	w0, #0x1
    a001f5c4:	54fff8cd 	b.le	a001f4dc <pipe_buffer_put+0x20>
		}
	}

	return num_bytes_written;
    a001f5c8:	f94027e0 	ldr	x0, [sp, #72]
}
    a001f5cc:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a001f5d0:	d65f03c0 	ret

00000000a001f5d4 <pipe_buffer_get>:
 *
 * @return Number of bytes read from the pipe's circular buffer
 */
static size_t pipe_buffer_get(struct k_pipe *pipe,
			       unsigned char *dest, size_t dest_size)
{
    a001f5d4:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a001f5d8:	910003fd 	mov	x29, sp
    a001f5dc:	f90017e0 	str	x0, [sp, #40]
    a001f5e0:	f90013e1 	str	x1, [sp, #32]
    a001f5e4:	f9000fe2 	str	x2, [sp, #24]
	size_t  bytes_copied;
	size_t  run_length;
	size_t  num_bytes_read = 0;
    a001f5e8:	f9002fff 	str	xzr, [sp, #88]
	size_t  dest_off;
	int     i;

	for (i = 0; i < 2; i++) {
    a001f5ec:	b90057ff 	str	wzr, [sp, #84]
    a001f5f0:	1400003e 	b	a001f6e8 <pipe_buffer_get+0x114>
		run_length = MIN(pipe->bytes_used,
    a001f5f4:	f94017e0 	ldr	x0, [sp, #40]
    a001f5f8:	f9400401 	ldr	x1, [x0, #8]
    a001f5fc:	f94017e0 	ldr	x0, [sp, #40]
    a001f600:	f9400c00 	ldr	x0, [x0, #24]
    a001f604:	cb000021 	sub	x1, x1, x0
    a001f608:	f94017e0 	ldr	x0, [sp, #40]
    a001f60c:	f9400800 	ldr	x0, [x0, #16]
    a001f610:	eb00003f 	cmp	x1, x0
    a001f614:	9a809020 	csel	x0, x1, x0, ls  // ls = plast
    a001f618:	f90027e0 	str	x0, [sp, #72]
				 pipe->size - pipe->read_index);

		dest_off = (dest == NULL) ? 0 : num_bytes_read;
    a001f61c:	f94013e0 	ldr	x0, [sp, #32]
    a001f620:	f100001f 	cmp	x0, #0x0
    a001f624:	54000060 	b.eq	a001f630 <pipe_buffer_get+0x5c>  // b.none
    a001f628:	f9402fe0 	ldr	x0, [sp, #88]
    a001f62c:	14000002 	b	a001f634 <pipe_buffer_get+0x60>
    a001f630:	d2800000 	mov	x0, #0x0                   	// #0
    a001f634:	f90023e0 	str	x0, [sp, #64]

		bytes_copied = pipe_xfer(dest + dest_off,
    a001f638:	f94013e1 	ldr	x1, [sp, #32]
    a001f63c:	f94023e0 	ldr	x0, [sp, #64]
    a001f640:	8b000024 	add	x4, x1, x0
    a001f644:	f9400fe1 	ldr	x1, [sp, #24]
    a001f648:	f9402fe0 	ldr	x0, [sp, #88]
    a001f64c:	cb000025 	sub	x5, x1, x0
					 dest_size - num_bytes_read,
					 pipe->buffer + pipe->read_index,
    a001f650:	f94017e0 	ldr	x0, [sp, #40]
    a001f654:	f9400001 	ldr	x1, [x0]
    a001f658:	f94017e0 	ldr	x0, [sp, #40]
    a001f65c:	f9400c00 	ldr	x0, [x0, #24]
    a001f660:	8b000020 	add	x0, x1, x0
		bytes_copied = pipe_xfer(dest + dest_off,
    a001f664:	f94027e3 	ldr	x3, [sp, #72]
    a001f668:	aa0003e2 	mov	x2, x0
    a001f66c:	aa0503e1 	mov	x1, x5
    a001f670:	aa0403e0 	mov	x0, x4
    a001f674:	97ffff6d 	bl	a001f428 <pipe_xfer>
    a001f678:	f9001fe0 	str	x0, [sp, #56]
					 run_length);

		num_bytes_read += bytes_copied;
    a001f67c:	f9402fe1 	ldr	x1, [sp, #88]
    a001f680:	f9401fe0 	ldr	x0, [sp, #56]
    a001f684:	8b000020 	add	x0, x1, x0
    a001f688:	f9002fe0 	str	x0, [sp, #88]
		pipe->bytes_used -= bytes_copied;
    a001f68c:	f94017e0 	ldr	x0, [sp, #40]
    a001f690:	f9400801 	ldr	x1, [x0, #16]
    a001f694:	f9401fe0 	ldr	x0, [sp, #56]
    a001f698:	cb000021 	sub	x1, x1, x0
    a001f69c:	f94017e0 	ldr	x0, [sp, #40]
    a001f6a0:	f9000801 	str	x1, [x0, #16]
		pipe->read_index += bytes_copied;
    a001f6a4:	f94017e0 	ldr	x0, [sp, #40]
    a001f6a8:	f9400c01 	ldr	x1, [x0, #24]
    a001f6ac:	f9401fe0 	ldr	x0, [sp, #56]
    a001f6b0:	8b000021 	add	x1, x1, x0
    a001f6b4:	f94017e0 	ldr	x0, [sp, #40]
    a001f6b8:	f9000c01 	str	x1, [x0, #24]
		if (pipe->read_index == pipe->size) {
    a001f6bc:	f94017e0 	ldr	x0, [sp, #40]
    a001f6c0:	f9400c01 	ldr	x1, [x0, #24]
    a001f6c4:	f94017e0 	ldr	x0, [sp, #40]
    a001f6c8:	f9400400 	ldr	x0, [x0, #8]
    a001f6cc:	eb00003f 	cmp	x1, x0
    a001f6d0:	54000061 	b.ne	a001f6dc <pipe_buffer_get+0x108>  // b.any
			pipe->read_index = 0;
    a001f6d4:	f94017e0 	ldr	x0, [sp, #40]
    a001f6d8:	f9000c1f 	str	xzr, [x0, #24]
	for (i = 0; i < 2; i++) {
    a001f6dc:	b94057e0 	ldr	w0, [sp, #84]
    a001f6e0:	11000400 	add	w0, w0, #0x1
    a001f6e4:	b90057e0 	str	w0, [sp, #84]
    a001f6e8:	b94057e0 	ldr	w0, [sp, #84]
    a001f6ec:	7100041f 	cmp	w0, #0x1
    a001f6f0:	54fff82d 	b.le	a001f5f4 <pipe_buffer_get+0x20>
		}
	}

	return num_bytes_read;
    a001f6f4:	f9402fe0 	ldr	x0, [sp, #88]
}
    a001f6f8:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a001f6fc:	d65f03c0 	ret

00000000a001f700 <pipe_xfer_prepare>:
			       _wait_q_t        *wait_q,
			       size_t            pipe_space,
			       size_t            bytes_to_xfer,
			       size_t            min_xfer,
			       k_timeout_t           timeout)
{
    a001f700:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    a001f704:	910003fd 	mov	x29, sp
    a001f708:	f90027e0 	str	x0, [sp, #72]
    a001f70c:	f90023e1 	str	x1, [sp, #64]
    a001f710:	f9001fe2 	str	x2, [sp, #56]
    a001f714:	f9001be3 	str	x3, [sp, #48]
    a001f718:	f90017e4 	str	x4, [sp, #40]
    a001f71c:	f90013e5 	str	x5, [sp, #32]
    a001f720:	f9000fe6 	str	x6, [sp, #24]
	struct k_thread  *thread;
	struct k_pipe_desc *desc;
	size_t num_bytes = 0;
    a001f724:	f90033ff 	str	xzr, [sp, #96]

	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    a001f728:	f9400fe0 	ldr	x0, [sp, #24]
    a001f72c:	d2800001 	mov	x1, #0x0                   	// #0
    a001f730:	eb01001f 	cmp	x0, x1
    a001f734:	54000681 	b.ne	a001f804 <pipe_xfer_prepare+0x104>  // b.any
		_WAIT_Q_FOR_EACH(wait_q, thread) {
    a001f738:	f9401fe0 	ldr	x0, [sp, #56]
    a001f73c:	97fffd89 	bl	a001ed60 <sys_dlist_peek_head>
    a001f740:	f100001f 	cmp	x0, #0x0
    a001f744:	54000080 	b.eq	a001f754 <pipe_xfer_prepare+0x54>  // b.none
    a001f748:	f9401fe0 	ldr	x0, [sp, #56]
    a001f74c:	97fffd85 	bl	a001ed60 <sys_dlist_peek_head>
    a001f750:	14000002 	b	a001f758 <pipe_xfer_prepare+0x58>
    a001f754:	d2800000 	mov	x0, #0x0                   	// #0
    a001f758:	f90037e0 	str	x0, [sp, #104]
    a001f75c:	1400001d 	b	a001f7d0 <pipe_xfer_prepare+0xd0>
			desc = (struct k_pipe_desc *)thread->base.swap_data;
    a001f760:	f94037e0 	ldr	x0, [sp, #104]
    a001f764:	f9401000 	ldr	x0, [x0, #32]
    a001f768:	f9002fe0 	str	x0, [sp, #88]

			num_bytes += desc->bytes_to_xfer;
    a001f76c:	f9402fe0 	ldr	x0, [sp, #88]
    a001f770:	f9400400 	ldr	x0, [x0, #8]
    a001f774:	f94033e1 	ldr	x1, [sp, #96]
    a001f778:	8b000020 	add	x0, x1, x0
    a001f77c:	f90033e0 	str	x0, [sp, #96]

			if (num_bytes >= bytes_to_xfer) {
    a001f780:	f94033e1 	ldr	x1, [sp, #96]
    a001f784:	f94017e0 	ldr	x0, [sp, #40]
    a001f788:	eb00003f 	cmp	x1, x0
    a001f78c:	540002a2 	b.cs	a001f7e0 <pipe_xfer_prepare+0xe0>  // b.hs, b.nlast
		_WAIT_Q_FOR_EACH(wait_q, thread) {
    a001f790:	f94037e0 	ldr	x0, [sp, #104]
    a001f794:	f100001f 	cmp	x0, #0x0
    a001f798:	54000180 	b.eq	a001f7c8 <pipe_xfer_prepare+0xc8>  // b.none
    a001f79c:	f9401fe0 	ldr	x0, [sp, #56]
    a001f7a0:	f94037e1 	ldr	x1, [sp, #104]
    a001f7a4:	97fffd8b 	bl	a001edd0 <sys_dlist_peek_next>
    a001f7a8:	f100001f 	cmp	x0, #0x0
    a001f7ac:	540000a0 	b.eq	a001f7c0 <pipe_xfer_prepare+0xc0>  // b.none
    a001f7b0:	f9401fe0 	ldr	x0, [sp, #56]
    a001f7b4:	f94037e1 	ldr	x1, [sp, #104]
    a001f7b8:	97fffd86 	bl	a001edd0 <sys_dlist_peek_next>
    a001f7bc:	14000004 	b	a001f7cc <pipe_xfer_prepare+0xcc>
    a001f7c0:	d2800000 	mov	x0, #0x0                   	// #0
    a001f7c4:	14000002 	b	a001f7cc <pipe_xfer_prepare+0xcc>
    a001f7c8:	d2800000 	mov	x0, #0x0                   	// #0
    a001f7cc:	f90037e0 	str	x0, [sp, #104]
    a001f7d0:	f94037e0 	ldr	x0, [sp, #104]
    a001f7d4:	f100001f 	cmp	x0, #0x0
    a001f7d8:	54fffc41 	b.ne	a001f760 <pipe_xfer_prepare+0x60>  // b.any
    a001f7dc:	14000002 	b	a001f7e4 <pipe_xfer_prepare+0xe4>
				break;
    a001f7e0:	d503201f 	nop
			}
		}

		if (num_bytes + pipe_space < min_xfer) {
    a001f7e4:	f94033e1 	ldr	x1, [sp, #96]
    a001f7e8:	f9401be0 	ldr	x0, [sp, #48]
    a001f7ec:	8b000020 	add	x0, x1, x0
    a001f7f0:	f94013e1 	ldr	x1, [sp, #32]
    a001f7f4:	eb00003f 	cmp	x1, x0
    a001f7f8:	54000069 	b.ls	a001f804 <pipe_xfer_prepare+0x104>  // b.plast
			return false;
    a001f7fc:	52800000 	mov	w0, #0x0                   	// #0
    a001f800:	14000029 	b	a001f8a4 <pipe_xfer_prepare+0x1a4>
	/*
	 * Either @a timeout is not K_NO_WAIT (so the thread may pend) or
	 * the entire request can be satisfied. Generate the working list.
	 */

	sys_dlist_init(xfer_list);
    a001f804:	f94027e0 	ldr	x0, [sp, #72]
    a001f808:	97fffd38 	bl	a001ece8 <sys_dlist_init>
	num_bytes = 0;
    a001f80c:	f90033ff 	str	xzr, [sp, #96]

	while ((thread = z_waitq_head(wait_q)) != NULL) {
    a001f810:	14000013 	b	a001f85c <pipe_xfer_prepare+0x15c>
		desc = (struct k_pipe_desc *)thread->base.swap_data;
    a001f814:	f94037e0 	ldr	x0, [sp, #104]
    a001f818:	f9401000 	ldr	x0, [x0, #32]
    a001f81c:	f9002fe0 	str	x0, [sp, #88]
		num_bytes += desc->bytes_to_xfer;
    a001f820:	f9402fe0 	ldr	x0, [sp, #88]
    a001f824:	f9400400 	ldr	x0, [x0, #8]
    a001f828:	f94033e1 	ldr	x1, [sp, #96]
    a001f82c:	8b000020 	add	x0, x1, x0
    a001f830:	f90033e0 	str	x0, [sp, #96]

		if (num_bytes > bytes_to_xfer) {
    a001f834:	f94033e1 	ldr	x1, [sp, #96]
    a001f838:	f94017e0 	ldr	x0, [sp, #40]
    a001f83c:	eb00003f 	cmp	x1, x0
    a001f840:	540001c8 	b.hi	a001f878 <pipe_xfer_prepare+0x178>  // b.pmore
		 * This request can be fully satisfied.
		 * Remove it from the wait_q.
		 * Abort its timeout.
		 * Add it to the transfer list.
		 */
		z_unpend_thread(thread);
    a001f844:	f94037e0 	ldr	x0, [sp, #104]
    a001f848:	97ffe12c 	bl	a0017cf8 <z_unpend_thread>
		sys_dlist_append(xfer_list, &thread->base.qnode_dlist);
    a001f84c:	f94037e0 	ldr	x0, [sp, #104]
    a001f850:	aa0003e1 	mov	x1, x0
    a001f854:	f94027e0 	ldr	x0, [sp, #72]
    a001f858:	97fffd6c 	bl	a001ee08 <sys_dlist_append>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
    a001f85c:	f9401fe0 	ldr	x0, [sp, #56]
    a001f860:	97fffdbf 	bl	a001ef5c <z_waitq_head>
    a001f864:	f90037e0 	str	x0, [sp, #104]
    a001f868:	f94037e0 	ldr	x0, [sp, #104]
    a001f86c:	f100001f 	cmp	x0, #0x0
    a001f870:	54fffd21 	b.ne	a001f814 <pipe_xfer_prepare+0x114>  // b.any
    a001f874:	14000002 	b	a001f87c <pipe_xfer_prepare+0x17c>
			break;
    a001f878:	d503201f 	nop
	}

	*waiter = (num_bytes > bytes_to_xfer) ? thread : NULL;
    a001f87c:	f94033e1 	ldr	x1, [sp, #96]
    a001f880:	f94017e0 	ldr	x0, [sp, #40]
    a001f884:	eb00003f 	cmp	x1, x0
    a001f888:	54000069 	b.ls	a001f894 <pipe_xfer_prepare+0x194>  // b.plast
    a001f88c:	f94037e0 	ldr	x0, [sp, #104]
    a001f890:	14000002 	b	a001f898 <pipe_xfer_prepare+0x198>
    a001f894:	d2800000 	mov	x0, #0x0                   	// #0
    a001f898:	f94023e1 	ldr	x1, [sp, #64]
    a001f89c:	f9000020 	str	x0, [x1]

	return true;
    a001f8a0:	52800020 	mov	w0, #0x1                   	// #1
}
    a001f8a4:	a8c77bfd 	ldp	x29, x30, [sp], #112
    a001f8a8:	d65f03c0 	ret

00000000a001f8ac <pipe_return_code>:
 *
 * @return See table above
 */
static int pipe_return_code(size_t min_xfer, size_t bytes_remaining,
			     size_t bytes_requested)
{
    a001f8ac:	d10083ff 	sub	sp, sp, #0x20
    a001f8b0:	f9000fe0 	str	x0, [sp, #24]
    a001f8b4:	f9000be1 	str	x1, [sp, #16]
    a001f8b8:	f90007e2 	str	x2, [sp, #8]
	if (bytes_requested - bytes_remaining >= min_xfer) {
    a001f8bc:	f94007e1 	ldr	x1, [sp, #8]
    a001f8c0:	f9400be0 	ldr	x0, [sp, #16]
    a001f8c4:	cb000020 	sub	x0, x1, x0
    a001f8c8:	f9400fe1 	ldr	x1, [sp, #24]
    a001f8cc:	eb00003f 	cmp	x1, x0
    a001f8d0:	54000068 	b.hi	a001f8dc <pipe_return_code+0x30>  // b.pmore
		/*
		 * At least the minimum number of requested
		 * bytes have been transferred.
		 */
		return 0;
    a001f8d4:	52800000 	mov	w0, #0x0                   	// #0
    a001f8d8:	14000002 	b	a001f8e0 <pipe_return_code+0x34>
	}

	return -EAGAIN;
    a001f8dc:	12800140 	mov	w0, #0xfffffff5            	// #-11
}
    a001f8e0:	910083ff 	add	sp, sp, #0x20
    a001f8e4:	d65f03c0 	ret

00000000a001f8e8 <z_impl_k_pipe_put>:

int z_impl_k_pipe_put(struct k_pipe *pipe, void *data, size_t bytes_to_write,
		     size_t *bytes_written, size_t min_xfer,
		      k_timeout_t timeout)
{
    a001f8e8:	a9ae7bfd 	stp	x29, x30, [sp, #-288]!
    a001f8ec:	910003fd 	mov	x29, sp
    a001f8f0:	f9001fe0 	str	x0, [sp, #56]
    a001f8f4:	f9001be1 	str	x1, [sp, #48]
    a001f8f8:	f90017e2 	str	x2, [sp, #40]
    a001f8fc:	f90013e3 	str	x3, [sp, #32]
    a001f900:	f9000fe4 	str	x4, [sp, #24]
    a001f904:	f9000be5 	str	x5, [sp, #16]
	struct k_thread    *reader;
	struct k_pipe_desc *desc;
	sys_dlist_t    xfer_list;
	size_t         num_bytes_written = 0;
    a001f908:	f9008fff 	str	xzr, [sp, #280]
	size_t         bytes_copied;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_pipe, put, pipe, timeout);

	CHECKIF((min_xfer > bytes_to_write) || bytes_written == NULL) {
    a001f90c:	f9400fe1 	ldr	x1, [sp, #24]
    a001f910:	f94017e0 	ldr	x0, [sp, #40]
    a001f914:	eb00003f 	cmp	x1, x0
    a001f918:	54000088 	b.hi	a001f928 <z_impl_k_pipe_put+0x40>  // b.pmore
    a001f91c:	f94013e0 	ldr	x0, [sp, #32]
    a001f920:	f100001f 	cmp	x0, #0x0
    a001f924:	54000061 	b.ne	a001f930 <z_impl_k_pipe_put+0x48>  // b.any
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_pipe, put, pipe, timeout, -EINVAL);

		return -EINVAL;
    a001f928:	128002a0 	mov	w0, #0xffffffea            	// #-22
    a001f92c:	140000fc 	b	a001fd1c <z_impl_k_pipe_put+0x434>
	}

	k_spinlock_key_t key = k_spin_lock(&pipe->lock);
    a001f930:	f9401fe0 	ldr	x0, [sp, #56]
    a001f934:	9100a000 	add	x0, x0, #0x28
    a001f938:	f9007be0 	str	x0, [sp, #240]
    a001f93c:	d53b4220 	mrs	x0, daif
    a001f940:	f90077e0 	str	x0, [sp, #232]
    a001f944:	f94077e0 	ldr	x0, [sp, #232]
    a001f948:	d503201f 	nop
	key = read_daif();
    a001f94c:	b900e7e0 	str	w0, [sp, #228]
	__asm__ volatile ("msr DAIFSet, %0"
    a001f950:	d50342df 	msr	daifset, #0x2
}
    a001f954:	d503201f 	nop
	return key;
    a001f958:	b940e7e0 	ldr	w0, [sp, #228]
	k.key = arch_irq_lock();
    a001f95c:	b90053e0 	str	w0, [sp, #80]
	return k;
    a001f960:	b94053e0 	ldr	w0, [sp, #80]
    a001f964:	b9007be0 	str	w0, [sp, #120]
	/*
	 * Create a list of "working readers" into which the data will be
	 * directly copied.
	 */

	if (!pipe_xfer_prepare(&xfer_list, &reader, &pipe->wait_q.readers,
    a001f968:	f9401fe0 	ldr	x0, [sp, #56]
    a001f96c:	9100a002 	add	x2, x0, #0x28
				pipe->size - pipe->bytes_used, bytes_to_write,
    a001f970:	f9401fe0 	ldr	x0, [sp, #56]
    a001f974:	f9400401 	ldr	x1, [x0, #8]
    a001f978:	f9401fe0 	ldr	x0, [sp, #56]
    a001f97c:	f9400800 	ldr	x0, [x0, #16]
	if (!pipe_xfer_prepare(&xfer_list, &reader, &pipe->wait_q.readers,
    a001f980:	cb000023 	sub	x3, x1, x0
    a001f984:	910243e1 	add	x1, sp, #0x90
    a001f988:	910203e0 	add	x0, sp, #0x80
    a001f98c:	f9400be6 	ldr	x6, [sp, #16]
    a001f990:	f9400fe5 	ldr	x5, [sp, #24]
    a001f994:	f94017e4 	ldr	x4, [sp, #40]
    a001f998:	97ffff5a 	bl	a001f700 <pipe_xfer_prepare>
    a001f99c:	12001c00 	and	w0, w0, #0xff
    a001f9a0:	52000000 	eor	w0, w0, #0x1
    a001f9a4:	12001c00 	and	w0, w0, #0xff
    a001f9a8:	7100001f 	cmp	w0, #0x0
    a001f9ac:	54000260 	b.eq	a001f9f8 <z_impl_k_pipe_put+0x110>  // b.none
				min_xfer, timeout)) {
		k_spin_unlock(&pipe->lock, key);
    a001f9b0:	f9401fe0 	ldr	x0, [sp, #56]
    a001f9b4:	9100a000 	add	x0, x0, #0x28
    a001f9b8:	f9006fe0 	str	x0, [sp, #216]
    a001f9bc:	b9407be0 	ldr	w0, [sp, #120]
    a001f9c0:	b9005be0 	str	w0, [sp, #88]
	arch_irq_unlock(key.key);
    a001f9c4:	b9405be0 	ldr	w0, [sp, #88]
    a001f9c8:	b900d7e0 	str	w0, [sp, #212]
	write_daif(key);
    a001f9cc:	b940d7e0 	ldr	w0, [sp, #212]
    a001f9d0:	f90067e0 	str	x0, [sp, #200]
MAKE_REG_HELPER(daif)
    a001f9d4:	f94067e0 	ldr	x0, [sp, #200]
    a001f9d8:	d51b4220 	msr	daif, x0
    a001f9dc:	d503201f 	nop
}
    a001f9e0:	d503201f 	nop
}
    a001f9e4:	d503201f 	nop
		*bytes_written = 0;
    a001f9e8:	f94013e0 	ldr	x0, [sp, #32]
    a001f9ec:	f900001f 	str	xzr, [x0]

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_pipe, put, pipe, timeout, -EIO);

		return -EIO;
    a001f9f0:	12800080 	mov	w0, #0xfffffffb            	// #-5
    a001f9f4:	140000ca 	b	a001fd1c <z_impl_k_pipe_put+0x434>
	}

	SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_pipe, put, pipe, timeout);

	z_sched_lock();
    a001f9f8:	97fffd48 	bl	a001ef18 <z_sched_lock>
	k_spin_unlock(&pipe->lock, key);
    a001f9fc:	f9401fe0 	ldr	x0, [sp, #56]
    a001fa00:	9100a000 	add	x0, x0, #0x28
    a001fa04:	f90063e0 	str	x0, [sp, #192]
    a001fa08:	b9407be0 	ldr	w0, [sp, #120]
    a001fa0c:	b90063e0 	str	w0, [sp, #96]
	arch_irq_unlock(key.key);
    a001fa10:	b94063e0 	ldr	w0, [sp, #96]
    a001fa14:	b900bfe0 	str	w0, [sp, #188]
	write_daif(key);
    a001fa18:	b940bfe0 	ldr	w0, [sp, #188]
    a001fa1c:	f9005be0 	str	x0, [sp, #176]
    a001fa20:	f9405be0 	ldr	x0, [sp, #176]
    a001fa24:	d51b4220 	msr	daif, x0
    a001fa28:	d503201f 	nop
}
    a001fa2c:	d503201f 	nop
}
    a001fa30:	d503201f 	nop
	 * still have a pointer to it, but it can not execute until this call
	 * is complete so it is still safe to copy data to it.
	 */

	struct k_thread *thread = (struct k_thread *)
				  sys_dlist_get(&xfer_list);
    a001fa34:	910203e0 	add	x0, sp, #0x80
    a001fa38:	97fffd1d 	bl	a001eeac <sys_dlist_get>
    a001fa3c:	f9008be0 	str	x0, [sp, #272]
	while (thread != NULL) {
    a001fa40:	14000028 	b	a001fae0 <z_impl_k_pipe_put+0x1f8>
		desc = (struct k_pipe_desc *)thread->base.swap_data;
    a001fa44:	f9408be0 	ldr	x0, [sp, #272]
    a001fa48:	f9401000 	ldr	x0, [x0, #32]
    a001fa4c:	f90087e0 	str	x0, [sp, #264]
		bytes_copied = pipe_xfer(desc->buffer, desc->bytes_to_xfer,
    a001fa50:	f94087e0 	ldr	x0, [sp, #264]
    a001fa54:	f9400004 	ldr	x4, [x0]
    a001fa58:	f94087e0 	ldr	x0, [sp, #264]
    a001fa5c:	f9400405 	ldr	x5, [x0, #8]
    a001fa60:	f9401be1 	ldr	x1, [sp, #48]
    a001fa64:	f9408fe0 	ldr	x0, [sp, #280]
    a001fa68:	8b000022 	add	x2, x1, x0
    a001fa6c:	f94017e1 	ldr	x1, [sp, #40]
    a001fa70:	f9408fe0 	ldr	x0, [sp, #280]
    a001fa74:	cb000020 	sub	x0, x1, x0
    a001fa78:	aa0003e3 	mov	x3, x0
    a001fa7c:	aa0503e1 	mov	x1, x5
    a001fa80:	aa0403e0 	mov	x0, x4
    a001fa84:	97fffe69 	bl	a001f428 <pipe_xfer>
    a001fa88:	f90083e0 	str	x0, [sp, #256]
					  (uint8_t *)data + num_bytes_written,
					  bytes_to_write - num_bytes_written);

		num_bytes_written   += bytes_copied;
    a001fa8c:	f9408fe1 	ldr	x1, [sp, #280]
    a001fa90:	f94083e0 	ldr	x0, [sp, #256]
    a001fa94:	8b000020 	add	x0, x1, x0
    a001fa98:	f9008fe0 	str	x0, [sp, #280]
		desc->buffer        += bytes_copied;
    a001fa9c:	f94087e0 	ldr	x0, [sp, #264]
    a001faa0:	f9400001 	ldr	x1, [x0]
    a001faa4:	f94083e0 	ldr	x0, [sp, #256]
    a001faa8:	8b000021 	add	x1, x1, x0
    a001faac:	f94087e0 	ldr	x0, [sp, #264]
    a001fab0:	f9000001 	str	x1, [x0]
		desc->bytes_to_xfer -= bytes_copied;
    a001fab4:	f94087e0 	ldr	x0, [sp, #264]
    a001fab8:	f9400401 	ldr	x1, [x0, #8]
    a001fabc:	f94083e0 	ldr	x0, [sp, #256]
    a001fac0:	cb000021 	sub	x1, x1, x0
    a001fac4:	f94087e0 	ldr	x0, [sp, #264]
    a001fac8:	f9000401 	str	x1, [x0, #8]

		/* The thread's read request has been satisfied. Ready it. */
		z_ready_thread(thread);
    a001facc:	f9408be0 	ldr	x0, [sp, #272]
    a001fad0:	97ffdd88 	bl	a00170f0 <z_ready_thread>

		thread = (struct k_thread *)sys_dlist_get(&xfer_list);
    a001fad4:	910203e0 	add	x0, sp, #0x80
    a001fad8:	97fffcf5 	bl	a001eeac <sys_dlist_get>
    a001fadc:	f9008be0 	str	x0, [sp, #272]
	while (thread != NULL) {
    a001fae0:	f9408be0 	ldr	x0, [sp, #272]
    a001fae4:	f100001f 	cmp	x0, #0x0
    a001fae8:	54fffae1 	b.ne	a001fa44 <z_impl_k_pipe_put+0x15c>  // b.any

	/*
	 * Copy any data to the reader that we left on the wait_q.
	 * It is possible no data will be copied.
	 */
	if (reader != NULL) {
    a001faec:	f9404be0 	ldr	x0, [sp, #144]
    a001faf0:	f100001f 	cmp	x0, #0x0
    a001faf4:	54000460 	b.eq	a001fb80 <z_impl_k_pipe_put+0x298>  // b.none
		desc = (struct k_pipe_desc *)reader->base.swap_data;
    a001faf8:	f9404be0 	ldr	x0, [sp, #144]
    a001fafc:	f9401000 	ldr	x0, [x0, #32]
    a001fb00:	f90087e0 	str	x0, [sp, #264]
		bytes_copied = pipe_xfer(desc->buffer, desc->bytes_to_xfer,
    a001fb04:	f94087e0 	ldr	x0, [sp, #264]
    a001fb08:	f9400004 	ldr	x4, [x0]
    a001fb0c:	f94087e0 	ldr	x0, [sp, #264]
    a001fb10:	f9400405 	ldr	x5, [x0, #8]
    a001fb14:	f9401be1 	ldr	x1, [sp, #48]
    a001fb18:	f9408fe0 	ldr	x0, [sp, #280]
    a001fb1c:	8b000022 	add	x2, x1, x0
    a001fb20:	f94017e1 	ldr	x1, [sp, #40]
    a001fb24:	f9408fe0 	ldr	x0, [sp, #280]
    a001fb28:	cb000020 	sub	x0, x1, x0
    a001fb2c:	aa0003e3 	mov	x3, x0
    a001fb30:	aa0503e1 	mov	x1, x5
    a001fb34:	aa0403e0 	mov	x0, x4
    a001fb38:	97fffe3c 	bl	a001f428 <pipe_xfer>
    a001fb3c:	f90083e0 	str	x0, [sp, #256]
					 (uint8_t *)data + num_bytes_written,
					  bytes_to_write - num_bytes_written);

		num_bytes_written   += bytes_copied;
    a001fb40:	f9408fe1 	ldr	x1, [sp, #280]
    a001fb44:	f94083e0 	ldr	x0, [sp, #256]
    a001fb48:	8b000020 	add	x0, x1, x0
    a001fb4c:	f9008fe0 	str	x0, [sp, #280]
		desc->buffer        += bytes_copied;
    a001fb50:	f94087e0 	ldr	x0, [sp, #264]
    a001fb54:	f9400001 	ldr	x1, [x0]
    a001fb58:	f94083e0 	ldr	x0, [sp, #256]
    a001fb5c:	8b000021 	add	x1, x1, x0
    a001fb60:	f94087e0 	ldr	x0, [sp, #264]
    a001fb64:	f9000001 	str	x1, [x0]
		desc->bytes_to_xfer -= bytes_copied;
    a001fb68:	f94087e0 	ldr	x0, [sp, #264]
    a001fb6c:	f9400401 	ldr	x1, [x0, #8]
    a001fb70:	f94083e0 	ldr	x0, [sp, #256]
    a001fb74:	cb000021 	sub	x1, x1, x0
    a001fb78:	f94087e0 	ldr	x0, [sp, #264]
    a001fb7c:	f9000401 	str	x1, [x0, #8]
	 * As much data as possible has been directly copied to any waiting
	 * readers. Add as much as possible to the pipe's circular buffer.
	 */

	num_bytes_written +=
		pipe_buffer_put(pipe, (uint8_t *)data + num_bytes_written,
    a001fb80:	f9401be1 	ldr	x1, [sp, #48]
    a001fb84:	f9408fe0 	ldr	x0, [sp, #280]
    a001fb88:	8b000023 	add	x3, x1, x0
    a001fb8c:	f94017e1 	ldr	x1, [sp, #40]
    a001fb90:	f9408fe0 	ldr	x0, [sp, #280]
    a001fb94:	cb000020 	sub	x0, x1, x0
    a001fb98:	aa0003e2 	mov	x2, x0
    a001fb9c:	aa0303e1 	mov	x1, x3
    a001fba0:	f9401fe0 	ldr	x0, [sp, #56]
    a001fba4:	97fffe46 	bl	a001f4bc <pipe_buffer_put>
    a001fba8:	aa0003e1 	mov	x1, x0
	num_bytes_written +=
    a001fbac:	f9408fe0 	ldr	x0, [sp, #280]
    a001fbb0:	8b010000 	add	x0, x0, x1
    a001fbb4:	f9008fe0 	str	x0, [sp, #280]
				 bytes_to_write - num_bytes_written);

	if (num_bytes_written == bytes_to_write) {
    a001fbb8:	f9408fe1 	ldr	x1, [sp, #280]
    a001fbbc:	f94017e0 	ldr	x0, [sp, #40]
    a001fbc0:	eb00003f 	cmp	x1, x0
    a001fbc4:	540000e1 	b.ne	a001fbe0 <z_impl_k_pipe_put+0x2f8>  // b.any
		*bytes_written = num_bytes_written;
    a001fbc8:	f94013e0 	ldr	x0, [sp, #32]
    a001fbcc:	f9408fe1 	ldr	x1, [sp, #280]
    a001fbd0:	f9000001 	str	x1, [x0]
		k_sched_unlock();
    a001fbd4:	97ffe1b3 	bl	a00182a0 <k_sched_unlock>

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_pipe, put, pipe, timeout, 0);

		return 0;
    a001fbd8:	52800000 	mov	w0, #0x0                   	// #0
    a001fbdc:	14000050 	b	a001fd1c <z_impl_k_pipe_put+0x434>
	}

	if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT)
    a001fbe0:	f9400be0 	ldr	x0, [sp, #16]
    a001fbe4:	d2800001 	mov	x1, #0x0                   	// #0
    a001fbe8:	eb01001f 	cmp	x0, x1
    a001fbec:	540001c0 	b.eq	a001fc24 <z_impl_k_pipe_put+0x33c>  // b.none
	    && num_bytes_written >= min_xfer
    a001fbf0:	f9408fe1 	ldr	x1, [sp, #280]
    a001fbf4:	f9400fe0 	ldr	x0, [sp, #24]
    a001fbf8:	eb00003f 	cmp	x1, x0
    a001fbfc:	54000143 	b.cc	a001fc24 <z_impl_k_pipe_put+0x33c>  // b.lo, b.ul, b.last
	    && min_xfer > 0U) {
    a001fc00:	f9400fe0 	ldr	x0, [sp, #24]
    a001fc04:	f100001f 	cmp	x0, #0x0
    a001fc08:	540000e0 	b.eq	a001fc24 <z_impl_k_pipe_put+0x33c>  // b.none
		*bytes_written = num_bytes_written;
    a001fc0c:	f94013e0 	ldr	x0, [sp, #32]
    a001fc10:	f9408fe1 	ldr	x1, [sp, #280]
    a001fc14:	f9000001 	str	x1, [x0]
		k_sched_unlock();
    a001fc18:	97ffe1a2 	bl	a00182a0 <k_sched_unlock>

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_pipe, put, pipe, timeout, 0);

		return 0;
    a001fc1c:	52800000 	mov	w0, #0x0                   	// #0
    a001fc20:	1400003f 	b	a001fd1c <z_impl_k_pipe_put+0x434>

	/* Not all data was copied */

	struct k_pipe_desc  pipe_desc;

	pipe_desc.buffer         = (uint8_t *)data + num_bytes_written;
    a001fc24:	f9401be1 	ldr	x1, [sp, #48]
    a001fc28:	f9408fe0 	ldr	x0, [sp, #280]
    a001fc2c:	8b000020 	add	x0, x1, x0
    a001fc30:	f90037e0 	str	x0, [sp, #104]
	pipe_desc.bytes_to_xfer  = bytes_to_write - num_bytes_written;
    a001fc34:	f94017e1 	ldr	x1, [sp, #40]
    a001fc38:	f9408fe0 	ldr	x0, [sp, #280]
    a001fc3c:	cb000020 	sub	x0, x1, x0
    a001fc40:	f9003be0 	str	x0, [sp, #112]

	if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    a001fc44:	f9400be0 	ldr	x0, [sp, #16]
    a001fc48:	d2800001 	mov	x1, #0x0                   	// #0
    a001fc4c:	eb01001f 	cmp	x0, x1
    a001fc50:	540004c0 	b.eq	a001fce8 <z_impl_k_pipe_put+0x400>  // b.none
		_current->base.swap_data = &pipe_desc;
    a001fc54:	90000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001fc58:	913f8000 	add	x0, x0, #0xfe0
    a001fc5c:	f9400800 	ldr	x0, [x0, #16]
    a001fc60:	9101a3e1 	add	x1, sp, #0x68
    a001fc64:	f9001001 	str	x1, [x0, #32]
		/*
		 * Lock interrupts and unlock the scheduler before
		 * manipulating the writers wait_q.
		 */
		k_spinlock_key_t key2 = k_spin_lock(&pipe->lock);
    a001fc68:	f9401fe0 	ldr	x0, [sp, #56]
    a001fc6c:	9100a000 	add	x0, x0, #0x28
    a001fc70:	f90057e0 	str	x0, [sp, #168]
    a001fc74:	d53b4220 	mrs	x0, daif
    a001fc78:	f90053e0 	str	x0, [sp, #160]
    a001fc7c:	f94053e0 	ldr	x0, [sp, #160]
    a001fc80:	d503201f 	nop
	key = read_daif();
    a001fc84:	b9009fe0 	str	w0, [sp, #156]
	__asm__ volatile ("msr DAIFSet, %0"
    a001fc88:	d50342df 	msr	daifset, #0x2
}
    a001fc8c:	d503201f 	nop
	return key;
    a001fc90:	b9409fe0 	ldr	w0, [sp, #156]
	k.key = arch_irq_lock();
    a001fc94:	b90043e0 	str	w0, [sp, #64]
	return k;
    a001fc98:	b94043e0 	ldr	w0, [sp, #64]
    a001fc9c:	b9004be0 	str	w0, [sp, #72]
	++_current->base.sched_locked;
    a001fca0:	90000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001fca4:	913f8000 	add	x0, x0, #0xfe0
    a001fca8:	f9400800 	ldr	x0, [x0, #16]
    a001fcac:	39406c01 	ldrb	w1, [x0, #27]
    a001fcb0:	11000421 	add	w1, w1, #0x1
    a001fcb4:	12001c21 	and	w1, w1, #0xff
    a001fcb8:	39006c01 	strb	w1, [x0, #27]
}
    a001fcbc:	d503201f 	nop
		z_sched_unlock_no_reschedule();
		(void)z_pend_curr(&pipe->lock, key2,
    a001fcc0:	f9401fe0 	ldr	x0, [sp, #56]
    a001fcc4:	9100a004 	add	x4, x0, #0x28
    a001fcc8:	f9401fe0 	ldr	x0, [sp, #56]
    a001fccc:	9100e000 	add	x0, x0, #0x38
    a001fcd0:	f9400be3 	ldr	x3, [sp, #16]
    a001fcd4:	aa0003e2 	mov	x2, x0
    a001fcd8:	b9404be1 	ldr	w1, [sp, #72]
    a001fcdc:	aa0403e0 	mov	x0, x4
    a001fce0:	97ffdf8f 	bl	a0017b1c <z_pend_curr>
    a001fce4:	14000002 	b	a001fcec <z_impl_k_pipe_put+0x404>
				  &pipe->wait_q.writers, timeout);
	} else {
		k_sched_unlock();
    a001fce8:	97ffe16e 	bl	a00182a0 <k_sched_unlock>
	}

	*bytes_written = bytes_to_write - pipe_desc.bytes_to_xfer;
    a001fcec:	f9403be0 	ldr	x0, [sp, #112]
    a001fcf0:	f94017e1 	ldr	x1, [sp, #40]
    a001fcf4:	cb000021 	sub	x1, x1, x0
    a001fcf8:	f94013e0 	ldr	x0, [sp, #32]
    a001fcfc:	f9000001 	str	x1, [x0]

	int ret = pipe_return_code(min_xfer, pipe_desc.bytes_to_xfer,
    a001fd00:	f9403be0 	ldr	x0, [sp, #112]
    a001fd04:	f94017e2 	ldr	x2, [sp, #40]
    a001fd08:	aa0003e1 	mov	x1, x0
    a001fd0c:	f9400fe0 	ldr	x0, [sp, #24]
    a001fd10:	97fffee7 	bl	a001f8ac <pipe_return_code>
    a001fd14:	b900ffe0 	str	w0, [sp, #252]
				   bytes_to_write);
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_pipe, put, pipe, timeout, ret);
	return ret;
    a001fd18:	b940ffe0 	ldr	w0, [sp, #252]
}
    a001fd1c:	a8d27bfd 	ldp	x29, x30, [sp], #288
    a001fd20:	d65f03c0 	ret

00000000a001fd24 <z_vrfy_k_pipe_put>:

#ifdef CONFIG_USERSPACE
int z_vrfy_k_pipe_put(struct k_pipe *pipe, void *data, size_t bytes_to_write,
		     size_t *bytes_written, size_t min_xfer,
		      k_timeout_t timeout)
{
    a001fd24:	d10cc3ff 	sub	sp, sp, #0x330
    a001fd28:	a9007bfd 	stp	x29, x30, [sp]
    a001fd2c:	910003fd 	mov	x29, sp
    a001fd30:	f9001fe0 	str	x0, [sp, #56]
    a001fd34:	f9001be1 	str	x1, [sp, #48]
    a001fd38:	f90017e2 	str	x2, [sp, #40]
    a001fd3c:	f90013e3 	str	x3, [sp, #32]
    a001fd40:	f9000fe4 	str	x4, [sp, #24]
    a001fd44:	f9000be5 	str	x5, [sp, #16]
	Z_OOPS(Z_SYSCALL_OBJ(pipe, K_OBJ_PIPE));
    a001fd48:	f9401fe0 	ldr	x0, [sp, #56]
    a001fd4c:	97fff337 	bl	a001ca28 <z_object_find>
    a001fd50:	52800003 	mov	w3, #0x0                   	// #0
    a001fd54:	52800082 	mov	w2, #0x4                   	// #4
    a001fd58:	f9401fe1 	ldr	x1, [sp, #56]
    a001fd5c:	97fffc87 	bl	a001ef78 <z_obj_validation_check>
    a001fd60:	7100001f 	cmp	w0, #0x0
    a001fd64:	1a9f07e0 	cset	w0, ne  // ne = any
    a001fd68:	390cb7e0 	strb	w0, [sp, #813]
    a001fd6c:	394cb7e0 	ldrb	w0, [sp, #813]
    a001fd70:	7100001f 	cmp	w0, #0x0
    a001fd74:	394cb7e0 	ldrb	w0, [sp, #813]
    a001fd78:	7100001f 	cmp	w0, #0x0
    a001fd7c:	540000c0 	b.eq	a001fd94 <z_vrfy_k_pipe_put+0x70>  // b.none
    a001fd80:	90000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001fd84:	913f8000 	add	x0, x0, #0xfe0
    a001fd88:	f9400800 	ldr	x0, [x0, #16]
    a001fd8c:	f9408400 	ldr	x0, [x0, #264]
    a001fd90:	97ffa4f2 	bl	a0009158 <arch_syscall_oops>
	Z_OOPS(Z_SYSCALL_MEMORY_WRITE(bytes_written, sizeof(*bytes_written)));
    a001fd94:	52800022 	mov	w2, #0x1                   	// #1
    a001fd98:	d2800101 	mov	x1, #0x8                   	// #8
    a001fd9c:	f94013e0 	ldr	x0, [sp, #32]
    a001fda0:	97ffaeb3 	bl	a000b86c <arch_buffer_validate>
    a001fda4:	7100001f 	cmp	w0, #0x0
    a001fda8:	1a9f07e0 	cset	w0, ne  // ne = any
    a001fdac:	390cbbe0 	strb	w0, [sp, #814]
    a001fdb0:	394cbbe0 	ldrb	w0, [sp, #814]
    a001fdb4:	7100001f 	cmp	w0, #0x0
    a001fdb8:	394cbbe0 	ldrb	w0, [sp, #814]
    a001fdbc:	7100001f 	cmp	w0, #0x0
    a001fdc0:	540000c0 	b.eq	a001fdd8 <z_vrfy_k_pipe_put+0xb4>  // b.none
    a001fdc4:	90000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001fdc8:	913f8000 	add	x0, x0, #0xfe0
    a001fdcc:	f9400800 	ldr	x0, [x0, #16]
    a001fdd0:	f9408400 	ldr	x0, [x0, #264]
    a001fdd4:	97ffa4e1 	bl	a0009158 <arch_syscall_oops>
	Z_OOPS(Z_SYSCALL_MEMORY_READ((void *)data, bytes_to_write));
    a001fdd8:	52800002 	mov	w2, #0x0                   	// #0
    a001fddc:	f94017e1 	ldr	x1, [sp, #40]
    a001fde0:	f9401be0 	ldr	x0, [sp, #48]
    a001fde4:	97ffaea2 	bl	a000b86c <arch_buffer_validate>
    a001fde8:	7100001f 	cmp	w0, #0x0
    a001fdec:	1a9f07e0 	cset	w0, ne  // ne = any
    a001fdf0:	390cbfe0 	strb	w0, [sp, #815]
    a001fdf4:	394cbfe0 	ldrb	w0, [sp, #815]
    a001fdf8:	7100001f 	cmp	w0, #0x0
    a001fdfc:	394cbfe0 	ldrb	w0, [sp, #815]
    a001fe00:	7100001f 	cmp	w0, #0x0
    a001fe04:	540000c0 	b.eq	a001fe1c <z_vrfy_k_pipe_put+0xf8>  // b.none
    a001fe08:	90000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001fe0c:	913f8000 	add	x0, x0, #0xfe0
    a001fe10:	f9400800 	ldr	x0, [x0, #16]
    a001fe14:	f9408400 	ldr	x0, [x0, #264]
    a001fe18:	97ffa4d0 	bl	a0009158 <arch_syscall_oops>

	return z_impl_k_pipe_put((struct k_pipe *)pipe, (void *)data,
    a001fe1c:	f9400be5 	ldr	x5, [sp, #16]
    a001fe20:	f9400fe4 	ldr	x4, [sp, #24]
    a001fe24:	f94013e3 	ldr	x3, [sp, #32]
    a001fe28:	f94017e2 	ldr	x2, [sp, #40]
    a001fe2c:	f9401be1 	ldr	x1, [sp, #48]
    a001fe30:	f9401fe0 	ldr	x0, [sp, #56]
    a001fe34:	97fffead 	bl	a001f8e8 <z_impl_k_pipe_put>
				bytes_to_write, bytes_written, min_xfer,
				timeout);
}
    a001fe38:	a9407bfd 	ldp	x29, x30, [sp]
    a001fe3c:	910cc3ff 	add	sp, sp, #0x330
    a001fe40:	d65f03c0 	ret

00000000a001fe44 <z_mrsh_k_pipe_put>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_pipe_put(struct k_pipe * pipe, void * data, size_t bytes_to_write, size_t * bytes_written, size_t min_xfer, k_timeout_t timeout);
uintptr_t z_mrsh_k_pipe_put(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a001fe44:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a001fe48:	910003fd 	mov	x29, sp
    a001fe4c:	f90027e0 	str	x0, [sp, #72]
    a001fe50:	f90023e1 	str	x1, [sp, #64]
    a001fe54:	f9001fe2 	str	x2, [sp, #56]
    a001fe58:	f9001be3 	str	x3, [sp, #48]
    a001fe5c:	f90017e4 	str	x4, [sp, #40]
    a001fe60:	f90013e5 	str	x5, [sp, #32]
    a001fe64:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a001fe68:	90000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001fe6c:	913f8000 	add	x0, x0, #0xfe0
    a001fe70:	f9400800 	ldr	x0, [x0, #16]
    a001fe74:	f9400fe1 	ldr	x1, [sp, #24]
    a001fe78:	f9008401 	str	x1, [x0, #264]
	int ret = z_vrfy_k_pipe_put(*(struct k_pipe **)&arg0, *(void **)&arg1, *(size_t*)&arg2, *(size_t **)&arg3, *(size_t*)&arg4, *(k_timeout_t*)&arg5)
    a001fe7c:	910123e0 	add	x0, sp, #0x48
    a001fe80:	f9400006 	ldr	x6, [x0]
    a001fe84:	910103e0 	add	x0, sp, #0x40
    a001fe88:	f9400001 	ldr	x1, [x0]
    a001fe8c:	9100e3e0 	add	x0, sp, #0x38
    a001fe90:	f9400002 	ldr	x2, [x0]
    a001fe94:	9100c3e0 	add	x0, sp, #0x30
    a001fe98:	f9400003 	ldr	x3, [x0]
    a001fe9c:	9100a3e0 	add	x0, sp, #0x28
    a001fea0:	f9400004 	ldr	x4, [x0]
    a001fea4:	910083e0 	add	x0, sp, #0x20
    a001fea8:	f9400005 	ldr	x5, [x0]
    a001feac:	aa0603e0 	mov	x0, x6
    a001feb0:	97ffff9d 	bl	a001fd24 <z_vrfy_k_pipe_put>
    a001feb4:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a001feb8:	90000140 	adrp	x0, a0047000 <data_compute+0x7df0>
    a001febc:	913f8000 	add	x0, x0, #0xfe0
    a001fec0:	f9400800 	ldr	x0, [x0, #16]
    a001fec4:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a001fec8:	b9805fe0 	ldrsw	x0, [sp, #92]
}
    a001fecc:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a001fed0:	d65f03c0 	ret

00000000a001fed4 <pipe_get_internal>:

static int pipe_get_internal(k_spinlock_key_t key, struct k_pipe *pipe,
			     void *data, size_t bytes_to_read,
			     size_t *bytes_read, size_t min_xfer,
			     k_timeout_t timeout)
{
    a001fed4:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
    a001fed8:	910003fd 	mov	x29, sp
    a001fedc:	b9004be0 	str	w0, [sp, #72]
    a001fee0:	f90023e1 	str	x1, [sp, #64]
    a001fee4:	f9001fe2 	str	x2, [sp, #56]
    a001fee8:	f9001be3 	str	x3, [sp, #48]
    a001feec:	f90017e4 	str	x4, [sp, #40]
    a001fef0:	f90013e5 	str	x5, [sp, #32]
    a001fef4:	f9000fe6 	str	x6, [sp, #24]
	struct k_thread    *writer;
	struct k_pipe_desc *desc;
	sys_dlist_t    xfer_list;
	size_t         num_bytes_read = 0;
    a001fef8:	f90087ff 	str	xzr, [sp, #264]
	/*
	 * Create a list of "working readers" into which the data will be
	 * directly copied.
	 */

	if (!pipe_xfer_prepare(&xfer_list, &writer, &pipe->wait_q.writers,
    a001fefc:	f94023e0 	ldr	x0, [sp, #64]
    a001ff00:	9100e002 	add	x2, x0, #0x38
    a001ff04:	f94023e0 	ldr	x0, [sp, #64]
    a001ff08:	f9400803 	ldr	x3, [x0, #16]
    a001ff0c:	910243e1 	add	x1, sp, #0x90
    a001ff10:	910203e0 	add	x0, sp, #0x80
    a001ff14:	f9400fe6 	ldr	x6, [sp, #24]
    a001ff18:	f94013e5 	ldr	x5, [sp, #32]
    a001ff1c:	f9401be4 	ldr	x4, [sp, #48]
    a001ff20:	97fffdf8 	bl	a001f700 <pipe_xfer_prepare>
    a001ff24:	12001c00 	and	w0, w0, #0xff
    a001ff28:	52000000 	eor	w0, w0, #0x1
    a001ff2c:	12001c00 	and	w0, w0, #0xff
    a001ff30:	7100001f 	cmp	w0, #0x0
    a001ff34:	54000260 	b.eq	a001ff80 <pipe_get_internal+0xac>  // b.none
				pipe->bytes_used, bytes_to_read,
				min_xfer, timeout)) {
		k_spin_unlock(&pipe->lock, key);
    a001ff38:	f94023e0 	ldr	x0, [sp, #64]
    a001ff3c:	9100a000 	add	x0, x0, #0x28
    a001ff40:	f9006fe0 	str	x0, [sp, #216]
    a001ff44:	b9404be0 	ldr	w0, [sp, #72]
    a001ff48:	b90063e0 	str	w0, [sp, #96]
	arch_irq_unlock(key.key);
    a001ff4c:	b94063e0 	ldr	w0, [sp, #96]
    a001ff50:	b900d7e0 	str	w0, [sp, #212]
	write_daif(key);
    a001ff54:	b940d7e0 	ldr	w0, [sp, #212]
    a001ff58:	f90067e0 	str	x0, [sp, #200]
MAKE_REG_HELPER(daif)
    a001ff5c:	f94067e0 	ldr	x0, [sp, #200]
    a001ff60:	d51b4220 	msr	daif, x0
    a001ff64:	d503201f 	nop
}
    a001ff68:	d503201f 	nop
}
    a001ff6c:	d503201f 	nop
		*bytes_read = 0;
    a001ff70:	f94017e0 	ldr	x0, [sp, #40]
    a001ff74:	f900001f 	str	xzr, [x0]

		return -EIO;
    a001ff78:	12800080 	mov	w0, #0xfffffffb            	// #-5
    a001ff7c:	14000115 	b	a00203d0 <pipe_get_internal+0x4fc>
	}

	z_sched_lock();
    a001ff80:	97fffbe6 	bl	a001ef18 <z_sched_lock>
	k_spin_unlock(&pipe->lock, key);
    a001ff84:	f94023e0 	ldr	x0, [sp, #64]
    a001ff88:	9100a000 	add	x0, x0, #0x28
    a001ff8c:	f90063e0 	str	x0, [sp, #192]
    a001ff90:	b9404be0 	ldr	w0, [sp, #72]
    a001ff94:	b9006be0 	str	w0, [sp, #104]
	arch_irq_unlock(key.key);
    a001ff98:	b9406be0 	ldr	w0, [sp, #104]
    a001ff9c:	b900bfe0 	str	w0, [sp, #188]
	write_daif(key);
    a001ffa0:	b940bfe0 	ldr	w0, [sp, #188]
    a001ffa4:	f9005be0 	str	x0, [sp, #176]
    a001ffa8:	f9405be0 	ldr	x0, [sp, #176]
    a001ffac:	d51b4220 	msr	daif, x0
    a001ffb0:	d503201f 	nop
}
    a001ffb4:	d503201f 	nop
}
    a001ffb8:	d503201f 	nop

	num_bytes_read = pipe_buffer_get(pipe, data, bytes_to_read);
    a001ffbc:	f9401be2 	ldr	x2, [sp, #48]
    a001ffc0:	f9401fe1 	ldr	x1, [sp, #56]
    a001ffc4:	f94023e0 	ldr	x0, [sp, #64]
    a001ffc8:	97fffd83 	bl	a001f5d4 <pipe_buffer_get>
    a001ffcc:	f90087e0 	str	x0, [sp, #264]
	 *    still have a pointer to it, but it can not execute until this
	 *    call is complete so it is still safe to copy data from it.
	 */

	struct k_thread *thread = (struct k_thread *)
				  sys_dlist_get(&xfer_list);
    a001ffd0:	910203e0 	add	x0, sp, #0x80
    a001ffd4:	97fffbb6 	bl	a001eeac <sys_dlist_get>
    a001ffd8:	f90083e0 	str	x0, [sp, #256]
	while ((thread != NULL) && (num_bytes_read < bytes_to_read)) {
    a001ffdc:	14000032 	b	a00200a4 <pipe_get_internal+0x1d0>
		desc = (struct k_pipe_desc *)thread->base.swap_data;
    a001ffe0:	f94083e0 	ldr	x0, [sp, #256]
    a001ffe4:	f9401000 	ldr	x0, [x0, #32]
    a001ffe8:	f9007fe0 	str	x0, [sp, #248]
		data_off = (data == NULL) ? 0 : num_bytes_read;
    a001ffec:	f9401fe0 	ldr	x0, [sp, #56]
    a001fff0:	f100001f 	cmp	x0, #0x0
    a001fff4:	54000060 	b.eq	a0020000 <pipe_get_internal+0x12c>  // b.none
    a001fff8:	f94087e0 	ldr	x0, [sp, #264]
    a001fffc:	14000002 	b	a0020004 <pipe_get_internal+0x130>
    a0020000:	d2800000 	mov	x0, #0x0                   	// #0
    a0020004:	f9007be0 	str	x0, [sp, #240]
		bytes_copied = pipe_xfer((uint8_t *)data + data_off,
    a0020008:	f9401fe1 	ldr	x1, [sp, #56]
    a002000c:	f9407be0 	ldr	x0, [sp, #240]
    a0020010:	8b000024 	add	x4, x1, x0
    a0020014:	f9401be1 	ldr	x1, [sp, #48]
    a0020018:	f94087e0 	ldr	x0, [sp, #264]
    a002001c:	cb000021 	sub	x1, x1, x0
					  bytes_to_read - num_bytes_read,
					  desc->buffer, desc->bytes_to_xfer);
    a0020020:	f9407fe0 	ldr	x0, [sp, #248]
    a0020024:	f9400002 	ldr	x2, [x0]
		bytes_copied = pipe_xfer((uint8_t *)data + data_off,
    a0020028:	f9407fe0 	ldr	x0, [sp, #248]
    a002002c:	f9400400 	ldr	x0, [x0, #8]
    a0020030:	aa0003e3 	mov	x3, x0
    a0020034:	aa0403e0 	mov	x0, x4
    a0020038:	97fffcfc 	bl	a001f428 <pipe_xfer>
    a002003c:	f90077e0 	str	x0, [sp, #232]

		num_bytes_read       += bytes_copied;
    a0020040:	f94087e1 	ldr	x1, [sp, #264]
    a0020044:	f94077e0 	ldr	x0, [sp, #232]
    a0020048:	8b000020 	add	x0, x1, x0
    a002004c:	f90087e0 	str	x0, [sp, #264]
		desc->buffer         += bytes_copied;
    a0020050:	f9407fe0 	ldr	x0, [sp, #248]
    a0020054:	f9400001 	ldr	x1, [x0]
    a0020058:	f94077e0 	ldr	x0, [sp, #232]
    a002005c:	8b000021 	add	x1, x1, x0
    a0020060:	f9407fe0 	ldr	x0, [sp, #248]
    a0020064:	f9000001 	str	x1, [x0]
		desc->bytes_to_xfer  -= bytes_copied;
    a0020068:	f9407fe0 	ldr	x0, [sp, #248]
    a002006c:	f9400401 	ldr	x1, [x0, #8]
    a0020070:	f94077e0 	ldr	x0, [sp, #232]
    a0020074:	cb000021 	sub	x1, x1, x0
    a0020078:	f9407fe0 	ldr	x0, [sp, #248]
    a002007c:	f9000401 	str	x1, [x0, #8]
		 * It is expected that the write request will be satisfied.
		 * However, if the read request was satisfied before the
		 * write request was satisfied, then the write request must
		 * finish later when writing to the pipe's circular buffer.
		 */
		if (num_bytes_read == bytes_to_read) {
    a0020080:	f94087e1 	ldr	x1, [sp, #264]
    a0020084:	f9401be0 	ldr	x0, [sp, #48]
    a0020088:	eb00003f 	cmp	x1, x0
    a002008c:	540001c0 	b.eq	a00200c4 <pipe_get_internal+0x1f0>  // b.none
			break;
		}
		z_ready_thread(thread);
    a0020090:	f94083e0 	ldr	x0, [sp, #256]
    a0020094:	97ffdc17 	bl	a00170f0 <z_ready_thread>

		thread = (struct k_thread *)sys_dlist_get(&xfer_list);
    a0020098:	910203e0 	add	x0, sp, #0x80
    a002009c:	97fffb84 	bl	a001eeac <sys_dlist_get>
    a00200a0:	f90083e0 	str	x0, [sp, #256]
	while ((thread != NULL) && (num_bytes_read < bytes_to_read)) {
    a00200a4:	f94083e0 	ldr	x0, [sp, #256]
    a00200a8:	f100001f 	cmp	x0, #0x0
    a00200ac:	540000e0 	b.eq	a00200c8 <pipe_get_internal+0x1f4>  // b.none
    a00200b0:	f94087e1 	ldr	x1, [sp, #264]
    a00200b4:	f9401be0 	ldr	x0, [sp, #48]
    a00200b8:	eb00003f 	cmp	x1, x0
    a00200bc:	54fff923 	b.cc	a001ffe0 <pipe_get_internal+0x10c>  // b.lo, b.ul, b.last
    a00200c0:	14000002 	b	a00200c8 <pipe_get_internal+0x1f4>
			break;
    a00200c4:	d503201f 	nop
	}

	if ((writer != NULL) && (num_bytes_read < bytes_to_read)) {
    a00200c8:	f9404be0 	ldr	x0, [sp, #144]
    a00200cc:	f100001f 	cmp	x0, #0x0
    a00200d0:	54000940 	b.eq	a00201f8 <pipe_get_internal+0x324>  // b.none
    a00200d4:	f94087e1 	ldr	x1, [sp, #264]
    a00200d8:	f9401be0 	ldr	x0, [sp, #48]
    a00200dc:	eb00003f 	cmp	x1, x0
    a00200e0:	540008c2 	b.cs	a00201f8 <pipe_get_internal+0x324>  // b.hs, b.nlast
		desc = (struct k_pipe_desc *)writer->base.swap_data;
    a00200e4:	f9404be0 	ldr	x0, [sp, #144]
    a00200e8:	f9401000 	ldr	x0, [x0, #32]
    a00200ec:	f9007fe0 	str	x0, [sp, #248]
		data_off = (data == NULL) ? 0 : num_bytes_read;
    a00200f0:	f9401fe0 	ldr	x0, [sp, #56]
    a00200f4:	f100001f 	cmp	x0, #0x0
    a00200f8:	54000060 	b.eq	a0020104 <pipe_get_internal+0x230>  // b.none
    a00200fc:	f94087e0 	ldr	x0, [sp, #264]
    a0020100:	14000002 	b	a0020108 <pipe_get_internal+0x234>
    a0020104:	d2800000 	mov	x0, #0x0                   	// #0
    a0020108:	f9007be0 	str	x0, [sp, #240]
		bytes_copied = pipe_xfer((uint8_t *)data + data_off,
    a002010c:	f9401fe1 	ldr	x1, [sp, #56]
    a0020110:	f9407be0 	ldr	x0, [sp, #240]
    a0020114:	8b000024 	add	x4, x1, x0
    a0020118:	f9401be1 	ldr	x1, [sp, #48]
    a002011c:	f94087e0 	ldr	x0, [sp, #264]
    a0020120:	cb000021 	sub	x1, x1, x0
					  bytes_to_read - num_bytes_read,
					  desc->buffer, desc->bytes_to_xfer);
    a0020124:	f9407fe0 	ldr	x0, [sp, #248]
    a0020128:	f9400002 	ldr	x2, [x0]
		bytes_copied = pipe_xfer((uint8_t *)data + data_off,
    a002012c:	f9407fe0 	ldr	x0, [sp, #248]
    a0020130:	f9400400 	ldr	x0, [x0, #8]
    a0020134:	aa0003e3 	mov	x3, x0
    a0020138:	aa0403e0 	mov	x0, x4
    a002013c:	97fffcbb 	bl	a001f428 <pipe_xfer>
    a0020140:	f90077e0 	str	x0, [sp, #232]

		num_bytes_read       += bytes_copied;
    a0020144:	f94087e1 	ldr	x1, [sp, #264]
    a0020148:	f94077e0 	ldr	x0, [sp, #232]
    a002014c:	8b000020 	add	x0, x1, x0
    a0020150:	f90087e0 	str	x0, [sp, #264]
		desc->buffer         += bytes_copied;
    a0020154:	f9407fe0 	ldr	x0, [sp, #248]
    a0020158:	f9400001 	ldr	x1, [x0]
    a002015c:	f94077e0 	ldr	x0, [sp, #232]
    a0020160:	8b000021 	add	x1, x1, x0
    a0020164:	f9407fe0 	ldr	x0, [sp, #248]
    a0020168:	f9000001 	str	x1, [x0]
		desc->bytes_to_xfer  -= bytes_copied;
    a002016c:	f9407fe0 	ldr	x0, [sp, #248]
    a0020170:	f9400401 	ldr	x1, [x0, #8]
    a0020174:	f94077e0 	ldr	x0, [sp, #232]
    a0020178:	cb000021 	sub	x1, x1, x0
    a002017c:	f9407fe0 	ldr	x0, [sp, #248]
    a0020180:	f9000401 	str	x1, [x0, #8]
	/*
	 * Copy as much data as possible from the writers (if any)
	 * into the pipe's circular buffer.
	 */

	while (thread != NULL) {
    a0020184:	1400001d 	b	a00201f8 <pipe_get_internal+0x324>
		desc = (struct k_pipe_desc *)thread->base.swap_data;
    a0020188:	f94083e0 	ldr	x0, [sp, #256]
    a002018c:	f9401000 	ldr	x0, [x0, #32]
    a0020190:	f9007fe0 	str	x0, [sp, #248]
		bytes_copied = pipe_buffer_put(pipe, desc->buffer,
    a0020194:	f9407fe0 	ldr	x0, [sp, #248]
    a0020198:	f9400001 	ldr	x1, [x0]
    a002019c:	f9407fe0 	ldr	x0, [sp, #248]
    a00201a0:	f9400400 	ldr	x0, [x0, #8]
    a00201a4:	aa0003e2 	mov	x2, x0
    a00201a8:	f94023e0 	ldr	x0, [sp, #64]
    a00201ac:	97fffcc4 	bl	a001f4bc <pipe_buffer_put>
    a00201b0:	f90077e0 	str	x0, [sp, #232]
						desc->bytes_to_xfer);

		desc->buffer         += bytes_copied;
    a00201b4:	f9407fe0 	ldr	x0, [sp, #248]
    a00201b8:	f9400001 	ldr	x1, [x0]
    a00201bc:	f94077e0 	ldr	x0, [sp, #232]
    a00201c0:	8b000021 	add	x1, x1, x0
    a00201c4:	f9407fe0 	ldr	x0, [sp, #248]
    a00201c8:	f9000001 	str	x1, [x0]
		desc->bytes_to_xfer  -= bytes_copied;
    a00201cc:	f9407fe0 	ldr	x0, [sp, #248]
    a00201d0:	f9400401 	ldr	x1, [x0, #8]
    a00201d4:	f94077e0 	ldr	x0, [sp, #232]
    a00201d8:	cb000021 	sub	x1, x1, x0
    a00201dc:	f9407fe0 	ldr	x0, [sp, #248]
    a00201e0:	f9000401 	str	x1, [x0, #8]

		/* Write request has been satisfied */
		z_ready_thread(thread);
    a00201e4:	f94083e0 	ldr	x0, [sp, #256]
    a00201e8:	97ffdbc2 	bl	a00170f0 <z_ready_thread>

		thread = (struct k_thread *)sys_dlist_get(&xfer_list);
    a00201ec:	910203e0 	add	x0, sp, #0x80
    a00201f0:	97fffb2f 	bl	a001eeac <sys_dlist_get>
    a00201f4:	f90083e0 	str	x0, [sp, #256]
	while (thread != NULL) {
    a00201f8:	f94083e0 	ldr	x0, [sp, #256]
    a00201fc:	f100001f 	cmp	x0, #0x0
    a0020200:	54fffc41 	b.ne	a0020188 <pipe_get_internal+0x2b4>  // b.any
	}

	if (writer != NULL) {
    a0020204:	f9404be0 	ldr	x0, [sp, #144]
    a0020208:	f100001f 	cmp	x0, #0x0
    a002020c:	54000300 	b.eq	a002026c <pipe_get_internal+0x398>  // b.none
		desc = (struct k_pipe_desc *)writer->base.swap_data;
    a0020210:	f9404be0 	ldr	x0, [sp, #144]
    a0020214:	f9401000 	ldr	x0, [x0, #32]
    a0020218:	f9007fe0 	str	x0, [sp, #248]
		bytes_copied = pipe_buffer_put(pipe, desc->buffer,
    a002021c:	f9407fe0 	ldr	x0, [sp, #248]
    a0020220:	f9400001 	ldr	x1, [x0]
    a0020224:	f9407fe0 	ldr	x0, [sp, #248]
    a0020228:	f9400400 	ldr	x0, [x0, #8]
    a002022c:	aa0003e2 	mov	x2, x0
    a0020230:	f94023e0 	ldr	x0, [sp, #64]
    a0020234:	97fffca2 	bl	a001f4bc <pipe_buffer_put>
    a0020238:	f90077e0 	str	x0, [sp, #232]
						desc->bytes_to_xfer);

		desc->buffer         += bytes_copied;
    a002023c:	f9407fe0 	ldr	x0, [sp, #248]
    a0020240:	f9400001 	ldr	x1, [x0]
    a0020244:	f94077e0 	ldr	x0, [sp, #232]
    a0020248:	8b000021 	add	x1, x1, x0
    a002024c:	f9407fe0 	ldr	x0, [sp, #248]
    a0020250:	f9000001 	str	x1, [x0]
		desc->bytes_to_xfer  -= bytes_copied;
    a0020254:	f9407fe0 	ldr	x0, [sp, #248]
    a0020258:	f9400401 	ldr	x1, [x0, #8]
    a002025c:	f94077e0 	ldr	x0, [sp, #232]
    a0020260:	cb000021 	sub	x1, x1, x0
    a0020264:	f9407fe0 	ldr	x0, [sp, #248]
    a0020268:	f9000401 	str	x1, [x0, #8]
	}

	if (num_bytes_read == bytes_to_read) {
    a002026c:	f94087e1 	ldr	x1, [sp, #264]
    a0020270:	f9401be0 	ldr	x0, [sp, #48]
    a0020274:	eb00003f 	cmp	x1, x0
    a0020278:	540000e1 	b.ne	a0020294 <pipe_get_internal+0x3c0>  // b.any
		k_sched_unlock();
    a002027c:	97ffe009 	bl	a00182a0 <k_sched_unlock>

		*bytes_read = num_bytes_read;
    a0020280:	f94017e0 	ldr	x0, [sp, #40]
    a0020284:	f94087e1 	ldr	x1, [sp, #264]
    a0020288:	f9000001 	str	x1, [x0]

		return 0;
    a002028c:	52800000 	mov	w0, #0x0                   	// #0
    a0020290:	14000050 	b	a00203d0 <pipe_get_internal+0x4fc>
	}

	if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT)
    a0020294:	f9400fe0 	ldr	x0, [sp, #24]
    a0020298:	d2800001 	mov	x1, #0x0                   	// #0
    a002029c:	eb01001f 	cmp	x0, x1
    a00202a0:	540001c0 	b.eq	a00202d8 <pipe_get_internal+0x404>  // b.none
	    && num_bytes_read >= min_xfer
    a00202a4:	f94087e1 	ldr	x1, [sp, #264]
    a00202a8:	f94013e0 	ldr	x0, [sp, #32]
    a00202ac:	eb00003f 	cmp	x1, x0
    a00202b0:	54000143 	b.cc	a00202d8 <pipe_get_internal+0x404>  // b.lo, b.ul, b.last
	    && min_xfer > 0U) {
    a00202b4:	f94013e0 	ldr	x0, [sp, #32]
    a00202b8:	f100001f 	cmp	x0, #0x0
    a00202bc:	540000e0 	b.eq	a00202d8 <pipe_get_internal+0x404>  // b.none
		k_sched_unlock();
    a00202c0:	97ffdff8 	bl	a00182a0 <k_sched_unlock>

		*bytes_read = num_bytes_read;
    a00202c4:	f94017e0 	ldr	x0, [sp, #40]
    a00202c8:	f94087e1 	ldr	x1, [sp, #264]
    a00202cc:	f9000001 	str	x1, [x0]

		return 0;
    a00202d0:	52800000 	mov	w0, #0x0                   	// #0
    a00202d4:	1400003f 	b	a00203d0 <pipe_get_internal+0x4fc>
	 * user-space.
	 */

	struct k_pipe_desc  pipe_desc;

	pipe_desc.buffer        = (uint8_t *)data + num_bytes_read;
    a00202d8:	f9401fe1 	ldr	x1, [sp, #56]
    a00202dc:	f94087e0 	ldr	x0, [sp, #264]
    a00202e0:	8b000020 	add	x0, x1, x0
    a00202e4:	f9003be0 	str	x0, [sp, #112]
	pipe_desc.bytes_to_xfer = bytes_to_read - num_bytes_read;
    a00202e8:	f9401be1 	ldr	x1, [sp, #48]
    a00202ec:	f94087e0 	ldr	x0, [sp, #264]
    a00202f0:	cb000020 	sub	x0, x1, x0
    a00202f4:	f9003fe0 	str	x0, [sp, #120]

	if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    a00202f8:	f9400fe0 	ldr	x0, [sp, #24]
    a00202fc:	d2800001 	mov	x1, #0x0                   	// #0
    a0020300:	eb01001f 	cmp	x0, x1
    a0020304:	540004c0 	b.eq	a002039c <pipe_get_internal+0x4c8>  // b.none
		SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_pipe, get, pipe, timeout);

		_current->base.swap_data = &pipe_desc;
    a0020308:	f0000120 	adrp	x0, a0047000 <data_compute+0x7df0>
    a002030c:	913f8000 	add	x0, x0, #0xfe0
    a0020310:	f9400800 	ldr	x0, [x0, #16]
    a0020314:	9101c3e1 	add	x1, sp, #0x70
    a0020318:	f9001001 	str	x1, [x0, #32]
		k_spinlock_key_t key2 = k_spin_lock(&pipe->lock);
    a002031c:	f94023e0 	ldr	x0, [sp, #64]
    a0020320:	9100a000 	add	x0, x0, #0x28
    a0020324:	f90057e0 	str	x0, [sp, #168]
    a0020328:	d53b4220 	mrs	x0, daif
    a002032c:	f90053e0 	str	x0, [sp, #160]
    a0020330:	f94053e0 	ldr	x0, [sp, #160]
    a0020334:	d503201f 	nop
	key = read_daif();
    a0020338:	b9009fe0 	str	w0, [sp, #156]
	__asm__ volatile ("msr DAIFSet, %0"
    a002033c:	d50342df 	msr	daifset, #0x2
}
    a0020340:	d503201f 	nop
	return key;
    a0020344:	b9409fe0 	ldr	w0, [sp, #156]
	k.key = arch_irq_lock();
    a0020348:	b90053e0 	str	w0, [sp, #80]
	return k;
    a002034c:	b94053e0 	ldr	w0, [sp, #80]
    a0020350:	b9005be0 	str	w0, [sp, #88]
	++_current->base.sched_locked;
    a0020354:	f0000120 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0020358:	913f8000 	add	x0, x0, #0xfe0
    a002035c:	f9400800 	ldr	x0, [x0, #16]
    a0020360:	39406c01 	ldrb	w1, [x0, #27]
    a0020364:	11000421 	add	w1, w1, #0x1
    a0020368:	12001c21 	and	w1, w1, #0xff
    a002036c:	39006c01 	strb	w1, [x0, #27]
}
    a0020370:	d503201f 	nop

		z_sched_unlock_no_reschedule();
		(void)z_pend_curr(&pipe->lock, key2,
    a0020374:	f94023e0 	ldr	x0, [sp, #64]
    a0020378:	9100a004 	add	x4, x0, #0x28
    a002037c:	f94023e0 	ldr	x0, [sp, #64]
    a0020380:	9100a000 	add	x0, x0, #0x28
    a0020384:	f9400fe3 	ldr	x3, [sp, #24]
    a0020388:	aa0003e2 	mov	x2, x0
    a002038c:	b9405be1 	ldr	w1, [sp, #88]
    a0020390:	aa0403e0 	mov	x0, x4
    a0020394:	97ffdde2 	bl	a0017b1c <z_pend_curr>
    a0020398:	14000002 	b	a00203a0 <pipe_get_internal+0x4cc>
				 &pipe->wait_q.readers, timeout);
	} else {
		k_sched_unlock();
    a002039c:	97ffdfc1 	bl	a00182a0 <k_sched_unlock>
	}

	*bytes_read = bytes_to_read - pipe_desc.bytes_to_xfer;
    a00203a0:	f9403fe0 	ldr	x0, [sp, #120]
    a00203a4:	f9401be1 	ldr	x1, [sp, #48]
    a00203a8:	cb000021 	sub	x1, x1, x0
    a00203ac:	f94017e0 	ldr	x0, [sp, #40]
    a00203b0:	f9000001 	str	x1, [x0]

	int ret = pipe_return_code(min_xfer, pipe_desc.bytes_to_xfer,
    a00203b4:	f9403fe0 	ldr	x0, [sp, #120]
    a00203b8:	f9401be2 	ldr	x2, [sp, #48]
    a00203bc:	aa0003e1 	mov	x1, x0
    a00203c0:	f94013e0 	ldr	x0, [sp, #32]
    a00203c4:	97fffd3a 	bl	a001f8ac <pipe_return_code>
    a00203c8:	b900e7e0 	str	w0, [sp, #228]
				   bytes_to_read);
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_pipe, get, pipe, timeout, ret);
	return ret;
    a00203cc:	b940e7e0 	ldr	w0, [sp, #228]
}
    a00203d0:	a8d17bfd 	ldp	x29, x30, [sp], #272
    a00203d4:	d65f03c0 	ret

00000000a00203d8 <z_impl_k_pipe_get>:

int z_impl_k_pipe_get(struct k_pipe *pipe, void *data, size_t bytes_to_read,
		     size_t *bytes_read, size_t min_xfer, k_timeout_t timeout)
{
    a00203d8:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    a00203dc:	910003fd 	mov	x29, sp
    a00203e0:	f9001fe0 	str	x0, [sp, #56]
    a00203e4:	f9001be1 	str	x1, [sp, #48]
    a00203e8:	f90017e2 	str	x2, [sp, #40]
    a00203ec:	f90013e3 	str	x3, [sp, #32]
    a00203f0:	f9000fe4 	str	x4, [sp, #24]
    a00203f4:	f9000be5 	str	x5, [sp, #16]
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_pipe, get, pipe, timeout);

	CHECKIF((min_xfer > bytes_to_read) || bytes_read == NULL) {
    a00203f8:	f9400fe1 	ldr	x1, [sp, #24]
    a00203fc:	f94017e0 	ldr	x0, [sp, #40]
    a0020400:	eb00003f 	cmp	x1, x0
    a0020404:	54000088 	b.hi	a0020414 <z_impl_k_pipe_get+0x3c>  // b.pmore
    a0020408:	f94013e0 	ldr	x0, [sp, #32]
    a002040c:	f100001f 	cmp	x0, #0x0
    a0020410:	54000061 	b.ne	a002041c <z_impl_k_pipe_get+0x44>  // b.any
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_pipe, get, pipe,
					       timeout, -EINVAL);

		return -EINVAL;
    a0020414:	128002a0 	mov	w0, #0xffffffea            	// #-22
    a0020418:	14000019 	b	a002047c <z_impl_k_pipe_get+0xa4>
	}

	k_spinlock_key_t key = k_spin_lock(&pipe->lock);
    a002041c:	f9401fe0 	ldr	x0, [sp, #56]
    a0020420:	9100a000 	add	x0, x0, #0x28
    a0020424:	f90033e0 	str	x0, [sp, #96]
MAKE_REG_HELPER(daif)
    a0020428:	d53b4220 	mrs	x0, daif
    a002042c:	f9002fe0 	str	x0, [sp, #88]
    a0020430:	f9402fe0 	ldr	x0, [sp, #88]
    a0020434:	d503201f 	nop
	key = read_daif();
    a0020438:	b90057e0 	str	w0, [sp, #84]
	__asm__ volatile ("msr DAIFSet, %0"
    a002043c:	d50342df 	msr	daifset, #0x2
}
    a0020440:	d503201f 	nop
	return key;
    a0020444:	b94057e0 	ldr	w0, [sp, #84]
	k.key = arch_irq_lock();
    a0020448:	b9004be0 	str	w0, [sp, #72]
	return k;
    a002044c:	b9404be0 	ldr	w0, [sp, #72]
    a0020450:	b90053e0 	str	w0, [sp, #80]

	int ret = pipe_get_internal(key, pipe, data, bytes_to_read, bytes_read,
    a0020454:	f9400be6 	ldr	x6, [sp, #16]
    a0020458:	f9400fe5 	ldr	x5, [sp, #24]
    a002045c:	f94013e4 	ldr	x4, [sp, #32]
    a0020460:	f94017e3 	ldr	x3, [sp, #40]
    a0020464:	f9401be2 	ldr	x2, [sp, #48]
    a0020468:	f9401fe1 	ldr	x1, [sp, #56]
    a002046c:	b94053e0 	ldr	w0, [sp, #80]
    a0020470:	97fffe99 	bl	a001fed4 <pipe_get_internal>
    a0020474:	b9006fe0 	str	w0, [sp, #108]
				    min_xfer, timeout);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_pipe, get, pipe, timeout, ret);

	return ret;
    a0020478:	b9406fe0 	ldr	w0, [sp, #108]
}
    a002047c:	a8c77bfd 	ldp	x29, x30, [sp], #112
    a0020480:	d65f03c0 	ret

00000000a0020484 <z_vrfy_k_pipe_get>:

#ifdef CONFIG_USERSPACE
int z_vrfy_k_pipe_get(struct k_pipe *pipe, void *data, size_t bytes_to_read,
		      size_t *bytes_read, size_t min_xfer, k_timeout_t timeout)
{
    a0020484:	d10cc3ff 	sub	sp, sp, #0x330
    a0020488:	a9007bfd 	stp	x29, x30, [sp]
    a002048c:	910003fd 	mov	x29, sp
    a0020490:	f9001fe0 	str	x0, [sp, #56]
    a0020494:	f9001be1 	str	x1, [sp, #48]
    a0020498:	f90017e2 	str	x2, [sp, #40]
    a002049c:	f90013e3 	str	x3, [sp, #32]
    a00204a0:	f9000fe4 	str	x4, [sp, #24]
    a00204a4:	f9000be5 	str	x5, [sp, #16]
	Z_OOPS(Z_SYSCALL_OBJ(pipe, K_OBJ_PIPE));
    a00204a8:	f9401fe0 	ldr	x0, [sp, #56]
    a00204ac:	97fff15f 	bl	a001ca28 <z_object_find>
    a00204b0:	52800003 	mov	w3, #0x0                   	// #0
    a00204b4:	52800082 	mov	w2, #0x4                   	// #4
    a00204b8:	f9401fe1 	ldr	x1, [sp, #56]
    a00204bc:	97fffaaf 	bl	a001ef78 <z_obj_validation_check>
    a00204c0:	7100001f 	cmp	w0, #0x0
    a00204c4:	1a9f07e0 	cset	w0, ne  // ne = any
    a00204c8:	390cb7e0 	strb	w0, [sp, #813]
    a00204cc:	394cb7e0 	ldrb	w0, [sp, #813]
    a00204d0:	7100001f 	cmp	w0, #0x0
    a00204d4:	394cb7e0 	ldrb	w0, [sp, #813]
    a00204d8:	7100001f 	cmp	w0, #0x0
    a00204dc:	540000c0 	b.eq	a00204f4 <z_vrfy_k_pipe_get+0x70>  // b.none
    a00204e0:	f0000120 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00204e4:	913f8000 	add	x0, x0, #0xfe0
    a00204e8:	f9400800 	ldr	x0, [x0, #16]
    a00204ec:	f9408400 	ldr	x0, [x0, #264]
    a00204f0:	97ffa31a 	bl	a0009158 <arch_syscall_oops>
	Z_OOPS(Z_SYSCALL_MEMORY_WRITE(bytes_read, sizeof(*bytes_read)));
    a00204f4:	52800022 	mov	w2, #0x1                   	// #1
    a00204f8:	d2800101 	mov	x1, #0x8                   	// #8
    a00204fc:	f94013e0 	ldr	x0, [sp, #32]
    a0020500:	97ffacdb 	bl	a000b86c <arch_buffer_validate>
    a0020504:	7100001f 	cmp	w0, #0x0
    a0020508:	1a9f07e0 	cset	w0, ne  // ne = any
    a002050c:	390cbbe0 	strb	w0, [sp, #814]
    a0020510:	394cbbe0 	ldrb	w0, [sp, #814]
    a0020514:	7100001f 	cmp	w0, #0x0
    a0020518:	394cbbe0 	ldrb	w0, [sp, #814]
    a002051c:	7100001f 	cmp	w0, #0x0
    a0020520:	540000c0 	b.eq	a0020538 <z_vrfy_k_pipe_get+0xb4>  // b.none
    a0020524:	f0000120 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0020528:	913f8000 	add	x0, x0, #0xfe0
    a002052c:	f9400800 	ldr	x0, [x0, #16]
    a0020530:	f9408400 	ldr	x0, [x0, #264]
    a0020534:	97ffa309 	bl	a0009158 <arch_syscall_oops>
	Z_OOPS(Z_SYSCALL_MEMORY_WRITE((void *)data, bytes_to_read));
    a0020538:	52800022 	mov	w2, #0x1                   	// #1
    a002053c:	f94017e1 	ldr	x1, [sp, #40]
    a0020540:	f9401be0 	ldr	x0, [sp, #48]
    a0020544:	97ffacca 	bl	a000b86c <arch_buffer_validate>
    a0020548:	7100001f 	cmp	w0, #0x0
    a002054c:	1a9f07e0 	cset	w0, ne  // ne = any
    a0020550:	390cbfe0 	strb	w0, [sp, #815]
    a0020554:	394cbfe0 	ldrb	w0, [sp, #815]
    a0020558:	7100001f 	cmp	w0, #0x0
    a002055c:	394cbfe0 	ldrb	w0, [sp, #815]
    a0020560:	7100001f 	cmp	w0, #0x0
    a0020564:	540000c0 	b.eq	a002057c <z_vrfy_k_pipe_get+0xf8>  // b.none
    a0020568:	f0000120 	adrp	x0, a0047000 <data_compute+0x7df0>
    a002056c:	913f8000 	add	x0, x0, #0xfe0
    a0020570:	f9400800 	ldr	x0, [x0, #16]
    a0020574:	f9408400 	ldr	x0, [x0, #264]
    a0020578:	97ffa2f8 	bl	a0009158 <arch_syscall_oops>

	return z_impl_k_pipe_get((struct k_pipe *)pipe, (void *)data,
    a002057c:	f9400be5 	ldr	x5, [sp, #16]
    a0020580:	f9400fe4 	ldr	x4, [sp, #24]
    a0020584:	f94013e3 	ldr	x3, [sp, #32]
    a0020588:	f94017e2 	ldr	x2, [sp, #40]
    a002058c:	f9401be1 	ldr	x1, [sp, #48]
    a0020590:	f9401fe0 	ldr	x0, [sp, #56]
    a0020594:	97ffff91 	bl	a00203d8 <z_impl_k_pipe_get>
				bytes_to_read, bytes_read, min_xfer,
				timeout);
}
    a0020598:	a9407bfd 	ldp	x29, x30, [sp]
    a002059c:	910cc3ff 	add	sp, sp, #0x330
    a00205a0:	d65f03c0 	ret

00000000a00205a4 <z_mrsh_k_pipe_get>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_pipe_get(struct k_pipe * pipe, void * data, size_t bytes_to_read, size_t * bytes_read, size_t min_xfer, k_timeout_t timeout);
uintptr_t z_mrsh_k_pipe_get(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a00205a4:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a00205a8:	910003fd 	mov	x29, sp
    a00205ac:	f90027e0 	str	x0, [sp, #72]
    a00205b0:	f90023e1 	str	x1, [sp, #64]
    a00205b4:	f9001fe2 	str	x2, [sp, #56]
    a00205b8:	f9001be3 	str	x3, [sp, #48]
    a00205bc:	f90017e4 	str	x4, [sp, #40]
    a00205c0:	f90013e5 	str	x5, [sp, #32]
    a00205c4:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a00205c8:	f0000120 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00205cc:	913f8000 	add	x0, x0, #0xfe0
    a00205d0:	f9400800 	ldr	x0, [x0, #16]
    a00205d4:	f9400fe1 	ldr	x1, [sp, #24]
    a00205d8:	f9008401 	str	x1, [x0, #264]
	int ret = z_vrfy_k_pipe_get(*(struct k_pipe **)&arg0, *(void **)&arg1, *(size_t*)&arg2, *(size_t **)&arg3, *(size_t*)&arg4, *(k_timeout_t*)&arg5)
    a00205dc:	910123e0 	add	x0, sp, #0x48
    a00205e0:	f9400006 	ldr	x6, [x0]
    a00205e4:	910103e0 	add	x0, sp, #0x40
    a00205e8:	f9400001 	ldr	x1, [x0]
    a00205ec:	9100e3e0 	add	x0, sp, #0x38
    a00205f0:	f9400002 	ldr	x2, [x0]
    a00205f4:	9100c3e0 	add	x0, sp, #0x30
    a00205f8:	f9400003 	ldr	x3, [x0]
    a00205fc:	9100a3e0 	add	x0, sp, #0x28
    a0020600:	f9400004 	ldr	x4, [x0]
    a0020604:	910083e0 	add	x0, sp, #0x20
    a0020608:	f9400005 	ldr	x5, [x0]
    a002060c:	aa0603e0 	mov	x0, x6
    a0020610:	97ffff9d 	bl	a0020484 <z_vrfy_k_pipe_get>
    a0020614:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a0020618:	f0000120 	adrp	x0, a0047000 <data_compute+0x7df0>
    a002061c:	913f8000 	add	x0, x0, #0xfe0
    a0020620:	f9400800 	ldr	x0, [x0, #16]
    a0020624:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a0020628:	b9805fe0 	ldrsw	x0, [sp, #92]
}
    a002062c:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a0020630:	d65f03c0 	ret

00000000a0020634 <z_impl_k_pipe_read_avail>:
#include <syscalls/k_pipe_get_mrsh.c>
#endif

size_t z_impl_k_pipe_read_avail(struct k_pipe *pipe)
{
    a0020634:	d10183ff 	sub	sp, sp, #0x60
    a0020638:	f90007e0 	str	x0, [sp, #8]
	size_t res;
	k_spinlock_key_t key;

	/* Buffer and size are fixed. No need to spin. */
	if (pipe->buffer == NULL || pipe->size == 0U) {
    a002063c:	f94007e0 	ldr	x0, [sp, #8]
    a0020640:	f9400000 	ldr	x0, [x0]
    a0020644:	f100001f 	cmp	x0, #0x0
    a0020648:	540000a0 	b.eq	a002065c <z_impl_k_pipe_read_avail+0x28>  // b.none
    a002064c:	f94007e0 	ldr	x0, [sp, #8]
    a0020650:	f9400400 	ldr	x0, [x0, #8]
    a0020654:	f100001f 	cmp	x0, #0x0
    a0020658:	54000061 	b.ne	a0020664 <z_impl_k_pipe_read_avail+0x30>  // b.any
		res = 0;
    a002065c:	f9002fff 	str	xzr, [sp, #88]
		goto out;
    a0020660:	1400003d 	b	a0020754 <z_impl_k_pipe_read_avail+0x120>
	}

	key = k_spin_lock(&pipe->lock);
    a0020664:	f94007e0 	ldr	x0, [sp, #8]
    a0020668:	9100a000 	add	x0, x0, #0x28
    a002066c:	f9002be0 	str	x0, [sp, #80]
MAKE_REG_HELPER(daif)
    a0020670:	d53b4220 	mrs	x0, daif
    a0020674:	f90027e0 	str	x0, [sp, #72]
    a0020678:	f94027e0 	ldr	x0, [sp, #72]
    a002067c:	d503201f 	nop
	key = read_daif();
    a0020680:	b90047e0 	str	w0, [sp, #68]
	__asm__ volatile ("msr DAIFSet, %0"
    a0020684:	d50342df 	msr	daifset, #0x2
}
    a0020688:	d503201f 	nop
	return key;
    a002068c:	b94047e0 	ldr	w0, [sp, #68]
	k.key = arch_irq_lock();
    a0020690:	b90013e0 	str	w0, [sp, #16]
	return k;
    a0020694:	b94013e0 	ldr	w0, [sp, #16]
    a0020698:	b90023e0 	str	w0, [sp, #32]

	if (pipe->read_index == pipe->write_index) {
    a002069c:	f94007e0 	ldr	x0, [sp, #8]
    a00206a0:	f9400c01 	ldr	x1, [x0, #24]
    a00206a4:	f94007e0 	ldr	x0, [sp, #8]
    a00206a8:	f9401000 	ldr	x0, [x0, #32]
    a00206ac:	eb00003f 	cmp	x1, x0
    a00206b0:	540000a1 	b.ne	a00206c4 <z_impl_k_pipe_read_avail+0x90>  // b.any
		res = pipe->bytes_used;
    a00206b4:	f94007e0 	ldr	x0, [sp, #8]
    a00206b8:	f9400800 	ldr	x0, [x0, #16]
    a00206bc:	f9002fe0 	str	x0, [sp, #88]
    a00206c0:	14000017 	b	a002071c <z_impl_k_pipe_read_avail+0xe8>
	} else if (pipe->read_index < pipe->write_index) {
    a00206c4:	f94007e0 	ldr	x0, [sp, #8]
    a00206c8:	f9400c01 	ldr	x1, [x0, #24]
    a00206cc:	f94007e0 	ldr	x0, [sp, #8]
    a00206d0:	f9401000 	ldr	x0, [x0, #32]
    a00206d4:	eb00003f 	cmp	x1, x0
    a00206d8:	54000102 	b.cs	a00206f8 <z_impl_k_pipe_read_avail+0xc4>  // b.hs, b.nlast
		res = pipe->write_index - pipe->read_index;
    a00206dc:	f94007e0 	ldr	x0, [sp, #8]
    a00206e0:	f9401001 	ldr	x1, [x0, #32]
    a00206e4:	f94007e0 	ldr	x0, [sp, #8]
    a00206e8:	f9400c00 	ldr	x0, [x0, #24]
    a00206ec:	cb000020 	sub	x0, x1, x0
    a00206f0:	f9002fe0 	str	x0, [sp, #88]
    a00206f4:	1400000a 	b	a002071c <z_impl_k_pipe_read_avail+0xe8>
	} else {
		res = pipe->size - (pipe->read_index - pipe->write_index);
    a00206f8:	f94007e0 	ldr	x0, [sp, #8]
    a00206fc:	f9400401 	ldr	x1, [x0, #8]
    a0020700:	f94007e0 	ldr	x0, [sp, #8]
    a0020704:	f9401002 	ldr	x2, [x0, #32]
    a0020708:	f94007e0 	ldr	x0, [sp, #8]
    a002070c:	f9400c00 	ldr	x0, [x0, #24]
    a0020710:	cb000040 	sub	x0, x2, x0
    a0020714:	8b000020 	add	x0, x1, x0
    a0020718:	f9002fe0 	str	x0, [sp, #88]
	}

	k_spin_unlock(&pipe->lock, key);
    a002071c:	f94007e0 	ldr	x0, [sp, #8]
    a0020720:	9100a000 	add	x0, x0, #0x28
    a0020724:	f9001fe0 	str	x0, [sp, #56]
    a0020728:	b94023e0 	ldr	w0, [sp, #32]
    a002072c:	b9001be0 	str	w0, [sp, #24]
	arch_irq_unlock(key.key);
    a0020730:	b9401be0 	ldr	w0, [sp, #24]
    a0020734:	b90037e0 	str	w0, [sp, #52]
	write_daif(key);
    a0020738:	b94037e0 	ldr	w0, [sp, #52]
    a002073c:	f90017e0 	str	x0, [sp, #40]
MAKE_REG_HELPER(daif)
    a0020740:	f94017e0 	ldr	x0, [sp, #40]
    a0020744:	d51b4220 	msr	daif, x0
    a0020748:	d503201f 	nop
}
    a002074c:	d503201f 	nop
}
    a0020750:	d503201f 	nop

out:
	return res;
    a0020754:	f9402fe0 	ldr	x0, [sp, #88]
}
    a0020758:	910183ff 	add	sp, sp, #0x60
    a002075c:	d65f03c0 	ret

00000000a0020760 <z_vrfy_k_pipe_read_avail>:

#ifdef CONFIG_USERSPACE
size_t z_vrfy_k_pipe_read_avail(struct k_pipe *pipe)
{
    a0020760:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a0020764:	910003fd 	mov	x29, sp
    a0020768:	f9000fe0 	str	x0, [sp, #24]
	Z_OOPS(Z_SYSCALL_OBJ(pipe, K_OBJ_PIPE));
    a002076c:	f9400fe0 	ldr	x0, [sp, #24]
    a0020770:	97fff0ae 	bl	a001ca28 <z_object_find>
    a0020774:	52800003 	mov	w3, #0x0                   	// #0
    a0020778:	52800082 	mov	w2, #0x4                   	// #4
    a002077c:	f9400fe1 	ldr	x1, [sp, #24]
    a0020780:	97fff9fe 	bl	a001ef78 <z_obj_validation_check>
    a0020784:	7100001f 	cmp	w0, #0x0
    a0020788:	1a9f07e0 	cset	w0, ne  // ne = any
    a002078c:	39063fe0 	strb	w0, [sp, #399]
    a0020790:	39463fe0 	ldrb	w0, [sp, #399]
    a0020794:	7100001f 	cmp	w0, #0x0
    a0020798:	39463fe0 	ldrb	w0, [sp, #399]
    a002079c:	7100001f 	cmp	w0, #0x0
    a00207a0:	540000c0 	b.eq	a00207b8 <z_vrfy_k_pipe_read_avail+0x58>  // b.none
    a00207a4:	f0000120 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00207a8:	913f8000 	add	x0, x0, #0xfe0
    a00207ac:	f9400800 	ldr	x0, [x0, #16]
    a00207b0:	f9408400 	ldr	x0, [x0, #264]
    a00207b4:	97ffa269 	bl	a0009158 <arch_syscall_oops>

	return z_impl_k_pipe_read_avail(pipe);
    a00207b8:	f9400fe0 	ldr	x0, [sp, #24]
    a00207bc:	97ffff9e 	bl	a0020634 <z_impl_k_pipe_read_avail>
}
    a00207c0:	a8d97bfd 	ldp	x29, x30, [sp], #400
    a00207c4:	d65f03c0 	ret

00000000a00207c8 <z_mrsh_k_pipe_read_avail>:
#include <syscalls/kernel.h>

extern size_t z_vrfy_k_pipe_read_avail(struct k_pipe * pipe);
uintptr_t z_mrsh_k_pipe_read_avail(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a00207c8:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a00207cc:	910003fd 	mov	x29, sp
    a00207d0:	f90027e0 	str	x0, [sp, #72]
    a00207d4:	f90023e1 	str	x1, [sp, #64]
    a00207d8:	f9001fe2 	str	x2, [sp, #56]
    a00207dc:	f9001be3 	str	x3, [sp, #48]
    a00207e0:	f90017e4 	str	x4, [sp, #40]
    a00207e4:	f90013e5 	str	x5, [sp, #32]
    a00207e8:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a00207ec:	f0000120 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00207f0:	913f8000 	add	x0, x0, #0xfe0
    a00207f4:	f9400800 	ldr	x0, [x0, #16]
    a00207f8:	f9400fe1 	ldr	x1, [sp, #24]
    a00207fc:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	size_t ret = z_vrfy_k_pipe_read_avail(*(struct k_pipe **)&arg0)
    a0020800:	910123e0 	add	x0, sp, #0x48
    a0020804:	f9400000 	ldr	x0, [x0]
    a0020808:	97ffffd6 	bl	a0020760 <z_vrfy_k_pipe_read_avail>
    a002080c:	f9002fe0 	str	x0, [sp, #88]
;
	_current->syscall_frame = NULL;
    a0020810:	f0000120 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0020814:	913f8000 	add	x0, x0, #0xfe0
    a0020818:	f9400800 	ldr	x0, [x0, #16]
    a002081c:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a0020820:	f9402fe0 	ldr	x0, [sp, #88]
}
    a0020824:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a0020828:	d65f03c0 	ret

00000000a002082c <z_impl_k_pipe_write_avail>:
#include <syscalls/k_pipe_read_avail_mrsh.c>
#endif

size_t z_impl_k_pipe_write_avail(struct k_pipe *pipe)
{
    a002082c:	d10183ff 	sub	sp, sp, #0x60
    a0020830:	f90007e0 	str	x0, [sp, #8]
	size_t res;
	k_spinlock_key_t key;

	/* Buffer and size are fixed. No need to spin. */
	if (pipe->buffer == NULL || pipe->size == 0U) {
    a0020834:	f94007e0 	ldr	x0, [sp, #8]
    a0020838:	f9400000 	ldr	x0, [x0]
    a002083c:	f100001f 	cmp	x0, #0x0
    a0020840:	540000a0 	b.eq	a0020854 <z_impl_k_pipe_write_avail+0x28>  // b.none
    a0020844:	f94007e0 	ldr	x0, [sp, #8]
    a0020848:	f9400400 	ldr	x0, [x0, #8]
    a002084c:	f100001f 	cmp	x0, #0x0
    a0020850:	54000061 	b.ne	a002085c <z_impl_k_pipe_write_avail+0x30>  // b.any
		res = 0;
    a0020854:	f9002fff 	str	xzr, [sp, #88]
		goto out;
    a0020858:	14000040 	b	a0020958 <z_impl_k_pipe_write_avail+0x12c>
	}

	key = k_spin_lock(&pipe->lock);
    a002085c:	f94007e0 	ldr	x0, [sp, #8]
    a0020860:	9100a000 	add	x0, x0, #0x28
    a0020864:	f9002be0 	str	x0, [sp, #80]
    a0020868:	d53b4220 	mrs	x0, daif
    a002086c:	f90027e0 	str	x0, [sp, #72]
    a0020870:	f94027e0 	ldr	x0, [sp, #72]
    a0020874:	d503201f 	nop
	key = read_daif();
    a0020878:	b90047e0 	str	w0, [sp, #68]
	__asm__ volatile ("msr DAIFSet, %0"
    a002087c:	d50342df 	msr	daifset, #0x2
}
    a0020880:	d503201f 	nop
	return key;
    a0020884:	b94047e0 	ldr	w0, [sp, #68]
	k.key = arch_irq_lock();
    a0020888:	b90013e0 	str	w0, [sp, #16]
	return k;
    a002088c:	b94013e0 	ldr	w0, [sp, #16]
    a0020890:	b90023e0 	str	w0, [sp, #32]

	if (pipe->write_index == pipe->read_index) {
    a0020894:	f94007e0 	ldr	x0, [sp, #8]
    a0020898:	f9401001 	ldr	x1, [x0, #32]
    a002089c:	f94007e0 	ldr	x0, [sp, #8]
    a00208a0:	f9400c00 	ldr	x0, [x0, #24]
    a00208a4:	eb00003f 	cmp	x1, x0
    a00208a8:	54000101 	b.ne	a00208c8 <z_impl_k_pipe_write_avail+0x9c>  // b.any
		res = pipe->size - pipe->bytes_used;
    a00208ac:	f94007e0 	ldr	x0, [sp, #8]
    a00208b0:	f9400401 	ldr	x1, [x0, #8]
    a00208b4:	f94007e0 	ldr	x0, [sp, #8]
    a00208b8:	f9400800 	ldr	x0, [x0, #16]
    a00208bc:	cb000020 	sub	x0, x1, x0
    a00208c0:	f9002fe0 	str	x0, [sp, #88]
    a00208c4:	14000017 	b	a0020920 <z_impl_k_pipe_write_avail+0xf4>
	} else if (pipe->write_index < pipe->read_index) {
    a00208c8:	f94007e0 	ldr	x0, [sp, #8]
    a00208cc:	f9401001 	ldr	x1, [x0, #32]
    a00208d0:	f94007e0 	ldr	x0, [sp, #8]
    a00208d4:	f9400c00 	ldr	x0, [x0, #24]
    a00208d8:	eb00003f 	cmp	x1, x0
    a00208dc:	54000102 	b.cs	a00208fc <z_impl_k_pipe_write_avail+0xd0>  // b.hs, b.nlast
		res = pipe->read_index - pipe->write_index;
    a00208e0:	f94007e0 	ldr	x0, [sp, #8]
    a00208e4:	f9400c01 	ldr	x1, [x0, #24]
    a00208e8:	f94007e0 	ldr	x0, [sp, #8]
    a00208ec:	f9401000 	ldr	x0, [x0, #32]
    a00208f0:	cb000020 	sub	x0, x1, x0
    a00208f4:	f9002fe0 	str	x0, [sp, #88]
    a00208f8:	1400000a 	b	a0020920 <z_impl_k_pipe_write_avail+0xf4>
	} else {
		res = pipe->size - (pipe->write_index - pipe->read_index);
    a00208fc:	f94007e0 	ldr	x0, [sp, #8]
    a0020900:	f9400401 	ldr	x1, [x0, #8]
    a0020904:	f94007e0 	ldr	x0, [sp, #8]
    a0020908:	f9400c02 	ldr	x2, [x0, #24]
    a002090c:	f94007e0 	ldr	x0, [sp, #8]
    a0020910:	f9401000 	ldr	x0, [x0, #32]
    a0020914:	cb000040 	sub	x0, x2, x0
    a0020918:	8b000020 	add	x0, x1, x0
    a002091c:	f9002fe0 	str	x0, [sp, #88]
	}

	k_spin_unlock(&pipe->lock, key);
    a0020920:	f94007e0 	ldr	x0, [sp, #8]
    a0020924:	9100a000 	add	x0, x0, #0x28
    a0020928:	f9001fe0 	str	x0, [sp, #56]
    a002092c:	b94023e0 	ldr	w0, [sp, #32]
    a0020930:	b9001be0 	str	w0, [sp, #24]
	arch_irq_unlock(key.key);
    a0020934:	b9401be0 	ldr	w0, [sp, #24]
    a0020938:	b90037e0 	str	w0, [sp, #52]
	write_daif(key);
    a002093c:	b94037e0 	ldr	w0, [sp, #52]
    a0020940:	f90017e0 	str	x0, [sp, #40]
MAKE_REG_HELPER(daif)
    a0020944:	f94017e0 	ldr	x0, [sp, #40]
    a0020948:	d51b4220 	msr	daif, x0
    a002094c:	d503201f 	nop
}
    a0020950:	d503201f 	nop
}
    a0020954:	d503201f 	nop

out:
	return res;
    a0020958:	f9402fe0 	ldr	x0, [sp, #88]
}
    a002095c:	910183ff 	add	sp, sp, #0x60
    a0020960:	d65f03c0 	ret

00000000a0020964 <z_vrfy_k_pipe_write_avail>:

#ifdef CONFIG_USERSPACE
size_t z_vrfy_k_pipe_write_avail(struct k_pipe *pipe)
{
    a0020964:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a0020968:	910003fd 	mov	x29, sp
    a002096c:	f9000fe0 	str	x0, [sp, #24]
	Z_OOPS(Z_SYSCALL_OBJ(pipe, K_OBJ_PIPE));
    a0020970:	f9400fe0 	ldr	x0, [sp, #24]
    a0020974:	97fff02d 	bl	a001ca28 <z_object_find>
    a0020978:	52800003 	mov	w3, #0x0                   	// #0
    a002097c:	52800082 	mov	w2, #0x4                   	// #4
    a0020980:	f9400fe1 	ldr	x1, [sp, #24]
    a0020984:	97fff97d 	bl	a001ef78 <z_obj_validation_check>
    a0020988:	7100001f 	cmp	w0, #0x0
    a002098c:	1a9f07e0 	cset	w0, ne  // ne = any
    a0020990:	39063fe0 	strb	w0, [sp, #399]
    a0020994:	39463fe0 	ldrb	w0, [sp, #399]
    a0020998:	7100001f 	cmp	w0, #0x0
    a002099c:	39463fe0 	ldrb	w0, [sp, #399]
    a00209a0:	7100001f 	cmp	w0, #0x0
    a00209a4:	540000c0 	b.eq	a00209bc <z_vrfy_k_pipe_write_avail+0x58>  // b.none
    a00209a8:	f0000120 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00209ac:	913f8000 	add	x0, x0, #0xfe0
    a00209b0:	f9400800 	ldr	x0, [x0, #16]
    a00209b4:	f9408400 	ldr	x0, [x0, #264]
    a00209b8:	97ffa1e8 	bl	a0009158 <arch_syscall_oops>

	return z_impl_k_pipe_write_avail(pipe);
    a00209bc:	f9400fe0 	ldr	x0, [sp, #24]
    a00209c0:	97ffff9b 	bl	a002082c <z_impl_k_pipe_write_avail>
}
    a00209c4:	a8d97bfd 	ldp	x29, x30, [sp], #400
    a00209c8:	d65f03c0 	ret

00000000a00209cc <z_mrsh_k_pipe_write_avail>:
#include <syscalls/kernel.h>

extern size_t z_vrfy_k_pipe_write_avail(struct k_pipe * pipe);
uintptr_t z_mrsh_k_pipe_write_avail(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a00209cc:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a00209d0:	910003fd 	mov	x29, sp
    a00209d4:	f90027e0 	str	x0, [sp, #72]
    a00209d8:	f90023e1 	str	x1, [sp, #64]
    a00209dc:	f9001fe2 	str	x2, [sp, #56]
    a00209e0:	f9001be3 	str	x3, [sp, #48]
    a00209e4:	f90017e4 	str	x4, [sp, #40]
    a00209e8:	f90013e5 	str	x5, [sp, #32]
    a00209ec:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a00209f0:	f0000120 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00209f4:	913f8000 	add	x0, x0, #0xfe0
    a00209f8:	f9400800 	ldr	x0, [x0, #16]
    a00209fc:	f9400fe1 	ldr	x1, [sp, #24]
    a0020a00:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	size_t ret = z_vrfy_k_pipe_write_avail(*(struct k_pipe **)&arg0)
    a0020a04:	910123e0 	add	x0, sp, #0x48
    a0020a08:	f9400000 	ldr	x0, [x0]
    a0020a0c:	97ffffd6 	bl	a0020964 <z_vrfy_k_pipe_write_avail>
    a0020a10:	f9002fe0 	str	x0, [sp, #88]
;
	_current->syscall_frame = NULL;
    a0020a14:	f0000120 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0020a18:	913f8000 	add	x0, x0, #0xfe0
    a0020a1c:	f9400800 	ldr	x0, [x0, #16]
    a0020a20:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a0020a24:	f9402fe0 	ldr	x0, [sp, #88]
}
    a0020a28:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a0020a2c:	d65f03c0 	ret

00000000a0020a30 <sys_dlist_init>:
{
    a0020a30:	d10043ff 	sub	sp, sp, #0x10
    a0020a34:	f90007e0 	str	x0, [sp, #8]
	list->head = (sys_dnode_t *)list;
    a0020a38:	f94007e0 	ldr	x0, [sp, #8]
    a0020a3c:	f94007e1 	ldr	x1, [sp, #8]
    a0020a40:	f9000001 	str	x1, [x0]
	list->tail = (sys_dnode_t *)list;
    a0020a44:	f94007e0 	ldr	x0, [sp, #8]
    a0020a48:	f94007e1 	ldr	x1, [sp, #8]
    a0020a4c:	f9000401 	str	x1, [x0, #8]
}
    a0020a50:	d503201f 	nop
    a0020a54:	910043ff 	add	sp, sp, #0x10
    a0020a58:	d65f03c0 	ret

00000000a0020a5c <sys_dlist_is_empty>:
{
    a0020a5c:	d10043ff 	sub	sp, sp, #0x10
    a0020a60:	f90007e0 	str	x0, [sp, #8]
	return list->head == list;
    a0020a64:	f94007e0 	ldr	x0, [sp, #8]
    a0020a68:	f9400000 	ldr	x0, [x0]
    a0020a6c:	f94007e1 	ldr	x1, [sp, #8]
    a0020a70:	eb00003f 	cmp	x1, x0
    a0020a74:	1a9f17e0 	cset	w0, eq  // eq = none
    a0020a78:	12001c00 	and	w0, w0, #0xff
}
    a0020a7c:	910043ff 	add	sp, sp, #0x10
    a0020a80:	d65f03c0 	ret

00000000a0020a84 <sys_dlist_peek_head>:
{
    a0020a84:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0020a88:	910003fd 	mov	x29, sp
    a0020a8c:	f9000fe0 	str	x0, [sp, #24]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    a0020a90:	f9400fe0 	ldr	x0, [sp, #24]
    a0020a94:	97fffff2 	bl	a0020a5c <sys_dlist_is_empty>
    a0020a98:	12001c00 	and	w0, w0, #0xff
    a0020a9c:	7100001f 	cmp	w0, #0x0
    a0020aa0:	54000081 	b.ne	a0020ab0 <sys_dlist_peek_head+0x2c>  // b.any
    a0020aa4:	f9400fe0 	ldr	x0, [sp, #24]
    a0020aa8:	f9400000 	ldr	x0, [x0]
    a0020aac:	14000002 	b	a0020ab4 <sys_dlist_peek_head+0x30>
    a0020ab0:	d2800000 	mov	x0, #0x0                   	// #0
}
    a0020ab4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0020ab8:	d65f03c0 	ret

00000000a0020abc <z_thread_malloc>:
{
    a0020abc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0020ac0:	910003fd 	mov	x29, sp
    a0020ac4:	f9000fe0 	str	x0, [sp, #24]
	return z_thread_aligned_alloc(0, size);
    a0020ac8:	f9400fe1 	ldr	x1, [sp, #24]
    a0020acc:	d2800000 	mov	x0, #0x0                   	// #0
    a0020ad0:	97ffeb05 	bl	a001b6e4 <z_thread_aligned_alloc>
}
    a0020ad4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0020ad8:	d65f03c0 	ret

00000000a0020adc <z_waitq_init>:
{
    a0020adc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0020ae0:	910003fd 	mov	x29, sp
    a0020ae4:	f9000fe0 	str	x0, [sp, #24]
	sys_dlist_init(&w->waitq);
    a0020ae8:	f9400fe0 	ldr	x0, [sp, #24]
    a0020aec:	97ffffd1 	bl	a0020a30 <sys_dlist_init>
}
    a0020af0:	d503201f 	nop
    a0020af4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0020af8:	d65f03c0 	ret

00000000a0020afc <z_waitq_head>:
{
    a0020afc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0020b00:	910003fd 	mov	x29, sp
    a0020b04:	f9000fe0 	str	x0, [sp, #24]
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
    a0020b08:	f9400fe0 	ldr	x0, [sp, #24]
    a0020b0c:	97ffffde 	bl	a0020a84 <sys_dlist_peek_head>
}
    a0020b10:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0020b14:	d65f03c0 	ret

00000000a0020b18 <z_obj_validation_check>:
{
    a0020b18:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    a0020b1c:	910003fd 	mov	x29, sp
    a0020b20:	f90017e0 	str	x0, [sp, #40]
    a0020b24:	f90013e1 	str	x1, [sp, #32]
    a0020b28:	b9001fe2 	str	w2, [sp, #28]
    a0020b2c:	b9001be3 	str	w3, [sp, #24]
	ret = z_object_validate(ko, otype, init);
    a0020b30:	b9401be2 	ldr	w2, [sp, #24]
    a0020b34:	b9401fe1 	ldr	w1, [sp, #28]
    a0020b38:	f94017e0 	ldr	x0, [sp, #40]
    a0020b3c:	97fff1e2 	bl	a001d2c4 <z_object_validate>
    a0020b40:	b9003fe0 	str	w0, [sp, #60]
	return ret;
    a0020b44:	b9403fe0 	ldr	w0, [sp, #60]
}
    a0020b48:	a8c47bfd 	ldp	x29, x30, [sp], #64
    a0020b4c:	d65f03c0 	ret

00000000a0020b50 <k_stack_init>:
#include <syscall_handler.h>
#include <kernel_internal.h>

void k_stack_init(struct k_stack *stack, stack_data_t *buffer,
		  uint32_t num_entries)
{
    a0020b50:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0020b54:	910003fd 	mov	x29, sp
    a0020b58:	f90017e0 	str	x0, [sp, #40]
    a0020b5c:	f90013e1 	str	x1, [sp, #32]
    a0020b60:	b9001fe2 	str	w2, [sp, #28]
	z_waitq_init(&stack->wait_q);
    a0020b64:	f94017e0 	ldr	x0, [sp, #40]
    a0020b68:	97ffffdd 	bl	a0020adc <z_waitq_init>
	stack->lock = (struct k_spinlock) {};
	stack->next = stack->base = buffer;
    a0020b6c:	f94017e0 	ldr	x0, [sp, #40]
    a0020b70:	f94013e1 	ldr	x1, [sp, #32]
    a0020b74:	f9000801 	str	x1, [x0, #16]
    a0020b78:	f94017e0 	ldr	x0, [sp, #40]
    a0020b7c:	f9400801 	ldr	x1, [x0, #16]
    a0020b80:	f94017e0 	ldr	x0, [sp, #40]
    a0020b84:	f9000c01 	str	x1, [x0, #24]
	stack->top = stack->base + num_entries;
    a0020b88:	f94017e0 	ldr	x0, [sp, #40]
    a0020b8c:	f9400801 	ldr	x1, [x0, #16]
    a0020b90:	b9401fe0 	ldr	w0, [sp, #28]
    a0020b94:	d37df000 	lsl	x0, x0, #3
    a0020b98:	8b000021 	add	x1, x1, x0
    a0020b9c:	f94017e0 	ldr	x0, [sp, #40]
    a0020ba0:	f9001001 	str	x1, [x0, #32]

	SYS_PORT_TRACING_OBJ_INIT(k_stack, stack);
	z_object_init(stack);
    a0020ba4:	f94017e0 	ldr	x0, [sp, #40]
    a0020ba8:	97fff21a 	bl	a001d410 <z_object_init>
}
    a0020bac:	d503201f 	nop
    a0020bb0:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0020bb4:	d65f03c0 	ret

00000000a0020bb8 <z_impl_k_stack_alloc_init>:

int32_t z_impl_k_stack_alloc_init(struct k_stack *stack, uint32_t num_entries)
{
    a0020bb8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a0020bbc:	910003fd 	mov	x29, sp
    a0020bc0:	f9000fe0 	str	x0, [sp, #24]
    a0020bc4:	b90017e1 	str	w1, [sp, #20]
	void *buffer;
	int32_t ret;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_stack, alloc_init, stack);

	buffer = z_thread_malloc(num_entries * sizeof(stack_data_t));
    a0020bc8:	b94017e0 	ldr	w0, [sp, #20]
    a0020bcc:	d37df000 	lsl	x0, x0, #3
    a0020bd0:	97ffffbb 	bl	a0020abc <z_thread_malloc>
    a0020bd4:	f90013e0 	str	x0, [sp, #32]
	if (buffer != NULL) {
    a0020bd8:	f94013e0 	ldr	x0, [sp, #32]
    a0020bdc:	f100001f 	cmp	x0, #0x0
    a0020be0:	54000140 	b.eq	a0020c08 <z_impl_k_stack_alloc_init+0x50>  // b.none
		k_stack_init(stack, buffer, num_entries);
    a0020be4:	b94017e2 	ldr	w2, [sp, #20]
    a0020be8:	f94013e1 	ldr	x1, [sp, #32]
    a0020bec:	f9400fe0 	ldr	x0, [sp, #24]
    a0020bf0:	97ffffd8 	bl	a0020b50 <k_stack_init>
		stack->flags = K_STACK_FLAG_ALLOC;
    a0020bf4:	f9400fe0 	ldr	x0, [sp, #24]
    a0020bf8:	52800021 	mov	w1, #0x1                   	// #1
    a0020bfc:	3900a001 	strb	w1, [x0, #40]
		ret = (int32_t)0;
    a0020c00:	b9002fff 	str	wzr, [sp, #44]
    a0020c04:	14000003 	b	a0020c10 <z_impl_k_stack_alloc_init+0x58>
	} else {
		ret = -ENOMEM;
    a0020c08:	12800160 	mov	w0, #0xfffffff4            	// #-12
    a0020c0c:	b9002fe0 	str	w0, [sp, #44]
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_stack, alloc_init, stack, ret);

	return ret;
    a0020c10:	b9402fe0 	ldr	w0, [sp, #44]
}
    a0020c14:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0020c18:	d65f03c0 	ret

00000000a0020c1c <z_vrfy_k_stack_alloc_init>:

#ifdef CONFIG_USERSPACE
static inline int32_t z_vrfy_k_stack_alloc_init(struct k_stack *stack,
					      uint32_t num_entries)
{
    a0020c1c:	a9a17bfd 	stp	x29, x30, [sp, #-496]!
    a0020c20:	910003fd 	mov	x29, sp
    a0020c24:	f9000fe0 	str	x0, [sp, #24]
    a0020c28:	b90017e1 	str	w1, [sp, #20]
	Z_OOPS(Z_SYSCALL_OBJ_NEVER_INIT(stack, K_OBJ_STACK));
    a0020c2c:	f9400fe0 	ldr	x0, [sp, #24]
    a0020c30:	97ffef7e 	bl	a001ca28 <z_object_find>
    a0020c34:	12800003 	mov	w3, #0xffffffff            	// #-1
    a0020c38:	52800102 	mov	w2, #0x8                   	// #8
    a0020c3c:	f9400fe1 	ldr	x1, [sp, #24]
    a0020c40:	97ffffb6 	bl	a0020b18 <z_obj_validation_check>
    a0020c44:	7100001f 	cmp	w0, #0x0
    a0020c48:	1a9f07e0 	cset	w0, ne  // ne = any
    a0020c4c:	3907bbe0 	strb	w0, [sp, #494]
    a0020c50:	3947bbe0 	ldrb	w0, [sp, #494]
    a0020c54:	7100001f 	cmp	w0, #0x0
    a0020c58:	3947bbe0 	ldrb	w0, [sp, #494]
    a0020c5c:	7100001f 	cmp	w0, #0x0
    a0020c60:	540000c0 	b.eq	a0020c78 <z_vrfy_k_stack_alloc_init+0x5c>  // b.none
    a0020c64:	f0000120 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0020c68:	913f8000 	add	x0, x0, #0xfe0
    a0020c6c:	f9400800 	ldr	x0, [x0, #16]
    a0020c70:	f9408400 	ldr	x0, [x0, #264]
    a0020c74:	97ffa139 	bl	a0009158 <arch_syscall_oops>
	Z_OOPS(Z_SYSCALL_VERIFY(num_entries > 0));
    a0020c78:	b94017e0 	ldr	w0, [sp, #20]
    a0020c7c:	7100001f 	cmp	w0, #0x0
    a0020c80:	1a9f17e0 	cset	w0, eq  // eq = none
    a0020c84:	3907bfe0 	strb	w0, [sp, #495]
    a0020c88:	3947bfe0 	ldrb	w0, [sp, #495]
    a0020c8c:	7100001f 	cmp	w0, #0x0
    a0020c90:	3947bfe0 	ldrb	w0, [sp, #495]
    a0020c94:	7100001f 	cmp	w0, #0x0
    a0020c98:	540000c0 	b.eq	a0020cb0 <z_vrfy_k_stack_alloc_init+0x94>  // b.none
    a0020c9c:	f0000120 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0020ca0:	913f8000 	add	x0, x0, #0xfe0
    a0020ca4:	f9400800 	ldr	x0, [x0, #16]
    a0020ca8:	f9408400 	ldr	x0, [x0, #264]
    a0020cac:	97ffa12b 	bl	a0009158 <arch_syscall_oops>
	return z_impl_k_stack_alloc_init(stack, num_entries);
    a0020cb0:	b94017e1 	ldr	w1, [sp, #20]
    a0020cb4:	f9400fe0 	ldr	x0, [sp, #24]
    a0020cb8:	97ffffc0 	bl	a0020bb8 <z_impl_k_stack_alloc_init>
}
    a0020cbc:	a8df7bfd 	ldp	x29, x30, [sp], #496
    a0020cc0:	d65f03c0 	ret

00000000a0020cc4 <z_mrsh_k_stack_alloc_init>:
#include <syscalls/kernel.h>

extern int32_t z_vrfy_k_stack_alloc_init(struct k_stack * stack, uint32_t num_entries);
uintptr_t z_mrsh_k_stack_alloc_init(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a0020cc4:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a0020cc8:	910003fd 	mov	x29, sp
    a0020ccc:	f90027e0 	str	x0, [sp, #72]
    a0020cd0:	f90023e1 	str	x1, [sp, #64]
    a0020cd4:	f9001fe2 	str	x2, [sp, #56]
    a0020cd8:	f9001be3 	str	x3, [sp, #48]
    a0020cdc:	f90017e4 	str	x4, [sp, #40]
    a0020ce0:	f90013e5 	str	x5, [sp, #32]
    a0020ce4:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a0020ce8:	f0000120 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0020cec:	913f8000 	add	x0, x0, #0xfe0
    a0020cf0:	f9400800 	ldr	x0, [x0, #16]
    a0020cf4:	f9400fe1 	ldr	x1, [sp, #24]
    a0020cf8:	f9008401 	str	x1, [x0, #264]
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int32_t ret = z_vrfy_k_stack_alloc_init(*(struct k_stack **)&arg0, *(uint32_t*)&arg1)
    a0020cfc:	910123e0 	add	x0, sp, #0x48
    a0020d00:	f9400002 	ldr	x2, [x0]
    a0020d04:	910103e0 	add	x0, sp, #0x40
    a0020d08:	b9400000 	ldr	w0, [x0]
    a0020d0c:	2a0003e1 	mov	w1, w0
    a0020d10:	aa0203e0 	mov	x0, x2
    a0020d14:	97ffffc2 	bl	a0020c1c <z_vrfy_k_stack_alloc_init>
    a0020d18:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a0020d1c:	f0000120 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0020d20:	913f8000 	add	x0, x0, #0xfe0
    a0020d24:	f9400800 	ldr	x0, [x0, #16]
    a0020d28:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a0020d2c:	b9805fe0 	ldrsw	x0, [sp, #92]
}
    a0020d30:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a0020d34:	d65f03c0 	ret

00000000a0020d38 <k_stack_cleanup>:
#include <syscalls/k_stack_alloc_init_mrsh.c>
#endif

int k_stack_cleanup(struct k_stack *stack)
{
    a0020d38:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0020d3c:	910003fd 	mov	x29, sp
    a0020d40:	f9000fe0 	str	x0, [sp, #24]
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_stack, cleanup, stack);

	CHECKIF(z_waitq_head(&stack->wait_q) != NULL) {
    a0020d44:	f9400fe0 	ldr	x0, [sp, #24]
    a0020d48:	97ffff6d 	bl	a0020afc <z_waitq_head>
    a0020d4c:	f100001f 	cmp	x0, #0x0
    a0020d50:	54000060 	b.eq	a0020d5c <k_stack_cleanup+0x24>  // b.none
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_stack, cleanup, stack, -EAGAIN);

		return -EAGAIN;
    a0020d54:	12800140 	mov	w0, #0xfffffff5            	// #-11
    a0020d58:	14000012 	b	a0020da0 <k_stack_cleanup+0x68>
	}

	if ((stack->flags & K_STACK_FLAG_ALLOC) != (uint8_t)0) {
    a0020d5c:	f9400fe0 	ldr	x0, [sp, #24]
    a0020d60:	3940a000 	ldrb	w0, [x0, #40]
    a0020d64:	12000000 	and	w0, w0, #0x1
    a0020d68:	7100001f 	cmp	w0, #0x0
    a0020d6c:	54000180 	b.eq	a0020d9c <k_stack_cleanup+0x64>  // b.none
		k_free(stack->base);
    a0020d70:	f9400fe0 	ldr	x0, [sp, #24]
    a0020d74:	f9400800 	ldr	x0, [x0, #16]
    a0020d78:	97ffea47 	bl	a001b694 <k_free>
		stack->base = NULL;
    a0020d7c:	f9400fe0 	ldr	x0, [sp, #24]
    a0020d80:	f900081f 	str	xzr, [x0, #16]
		stack->flags &= ~K_STACK_FLAG_ALLOC;
    a0020d84:	f9400fe0 	ldr	x0, [sp, #24]
    a0020d88:	3940a000 	ldrb	w0, [x0, #40]
    a0020d8c:	121f7800 	and	w0, w0, #0xfffffffe
    a0020d90:	12001c01 	and	w1, w0, #0xff
    a0020d94:	f9400fe0 	ldr	x0, [sp, #24]
    a0020d98:	3900a001 	strb	w1, [x0, #40]
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_stack, cleanup, stack, 0);

	return 0;
    a0020d9c:	52800000 	mov	w0, #0x0                   	// #0
}
    a0020da0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0020da4:	d65f03c0 	ret

00000000a0020da8 <z_impl_k_stack_push>:

int z_impl_k_stack_push(struct k_stack *stack, stack_data_t data)
{
    a0020da8:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
    a0020dac:	910003fd 	mov	x29, sp
    a0020db0:	f9000fe0 	str	x0, [sp, #24]
    a0020db4:	f9000be1 	str	x1, [sp, #16]
	struct k_thread *first_pending_thread;
	int ret = 0;
    a0020db8:	b9009fff 	str	wzr, [sp, #156]
	k_spinlock_key_t key = k_spin_lock(&stack->lock);
    a0020dbc:	f9400fe0 	ldr	x0, [sp, #24]
    a0020dc0:	91004000 	add	x0, x0, #0x10
    a0020dc4:	f90047e0 	str	x0, [sp, #136]
    a0020dc8:	d53b4220 	mrs	x0, daif
    a0020dcc:	f90043e0 	str	x0, [sp, #128]
    a0020dd0:	f94043e0 	ldr	x0, [sp, #128]
    a0020dd4:	d503201f 	nop
	key = read_daif();
    a0020dd8:	b9007fe0 	str	w0, [sp, #124]
	__asm__ volatile ("msr DAIFSet, %0"
    a0020ddc:	d50342df 	msr	daifset, #0x2
}
    a0020de0:	d503201f 	nop
	return key;
    a0020de4:	b9407fe0 	ldr	w0, [sp, #124]
	k.key = arch_irq_lock();
    a0020de8:	b90023e0 	str	w0, [sp, #32]
	return k;
    a0020dec:	b94023e0 	ldr	w0, [sp, #32]
    a0020df0:	b90033e0 	str	w0, [sp, #48]

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_stack, push, stack);

	CHECKIF(stack->next == stack->top) {
    a0020df4:	f9400fe0 	ldr	x0, [sp, #24]
    a0020df8:	f9400c01 	ldr	x1, [x0, #24]
    a0020dfc:	f9400fe0 	ldr	x0, [sp, #24]
    a0020e00:	f9401000 	ldr	x0, [x0, #32]
    a0020e04:	eb00003f 	cmp	x1, x0
    a0020e08:	54000081 	b.ne	a0020e18 <z_impl_k_stack_push+0x70>  // b.any
		ret = -ENOMEM;
    a0020e0c:	12800160 	mov	w0, #0xfffffff4            	// #-12
    a0020e10:	b9009fe0 	str	w0, [sp, #156]
		goto out;
    a0020e14:	14000029 	b	a0020eb8 <z_impl_k_stack_push+0x110>
	}

	first_pending_thread = z_unpend_first_thread(&stack->wait_q);
    a0020e18:	f9400fe0 	ldr	x0, [sp, #24]
    a0020e1c:	97ffdb83 	bl	a0017c28 <z_unpend_first_thread>
    a0020e20:	f9004be0 	str	x0, [sp, #144]

	if (first_pending_thread != NULL) {
    a0020e24:	f9404be0 	ldr	x0, [sp, #144]
    a0020e28:	f100001f 	cmp	x0, #0x0
    a0020e2c:	54000320 	b.eq	a0020e90 <z_impl_k_stack_push+0xe8>  // b.none
		z_thread_return_value_set_with_data(first_pending_thread,
    a0020e30:	f9400be0 	ldr	x0, [sp, #16]
    a0020e34:	f9404be1 	ldr	x1, [sp, #144]
    a0020e38:	f9003be1 	str	x1, [sp, #112]
    a0020e3c:	b9006fff 	str	wzr, [sp, #108]
    a0020e40:	f90033e0 	str	x0, [sp, #96]
    a0020e44:	f9403be0 	ldr	x0, [sp, #112]
    a0020e48:	f9002fe0 	str	x0, [sp, #88]
    a0020e4c:	b9406fe0 	ldr	w0, [sp, #108]
    a0020e50:	b90057e0 	str	w0, [sp, #84]
	thread->swap_retval = value;
    a0020e54:	b94057e1 	ldr	w1, [sp, #84]
    a0020e58:	f9402fe0 	ldr	x0, [sp, #88]
    a0020e5c:	b9011001 	str	w1, [x0, #272]
}
    a0020e60:	d503201f 	nop
	thread->base.swap_data = data;
    a0020e64:	f9403be0 	ldr	x0, [sp, #112]
    a0020e68:	f94033e1 	ldr	x1, [sp, #96]
    a0020e6c:	f9001001 	str	x1, [x0, #32]
}
    a0020e70:	d503201f 	nop
						   0, (void *)data);

		z_ready_thread(first_pending_thread);
    a0020e74:	f9404be0 	ldr	x0, [sp, #144]
    a0020e78:	97ffd89e 	bl	a00170f0 <z_ready_thread>
		z_reschedule(&stack->lock, key);
    a0020e7c:	f9400fe0 	ldr	x0, [sp, #24]
    a0020e80:	91004000 	add	x0, x0, #0x10
    a0020e84:	b94033e1 	ldr	w1, [sp, #48]
    a0020e88:	97ffdca5 	bl	a001811c <z_reschedule>
		goto end;
    a0020e8c:	14000019 	b	a0020ef0 <z_impl_k_stack_push+0x148>
	} else {
		*(stack->next) = data;
    a0020e90:	f9400fe0 	ldr	x0, [sp, #24]
    a0020e94:	f9400c00 	ldr	x0, [x0, #24]
    a0020e98:	f9400be1 	ldr	x1, [sp, #16]
    a0020e9c:	f9000001 	str	x1, [x0]
		stack->next++;
    a0020ea0:	f9400fe0 	ldr	x0, [sp, #24]
    a0020ea4:	f9400c00 	ldr	x0, [x0, #24]
    a0020ea8:	91002001 	add	x1, x0, #0x8
    a0020eac:	f9400fe0 	ldr	x0, [sp, #24]
    a0020eb0:	f9000c01 	str	x1, [x0, #24]
		goto out;
    a0020eb4:	d503201f 	nop
	}

out:
	k_spin_unlock(&stack->lock, key);
    a0020eb8:	f9400fe0 	ldr	x0, [sp, #24]
    a0020ebc:	91004000 	add	x0, x0, #0x10
    a0020ec0:	f90027e0 	str	x0, [sp, #72]
    a0020ec4:	b94033e0 	ldr	w0, [sp, #48]
    a0020ec8:	b9002be0 	str	w0, [sp, #40]
	arch_irq_unlock(key.key);
    a0020ecc:	b9402be0 	ldr	w0, [sp, #40]
    a0020ed0:	b90047e0 	str	w0, [sp, #68]
	write_daif(key);
    a0020ed4:	b94047e0 	ldr	w0, [sp, #68]
    a0020ed8:	f9001fe0 	str	x0, [sp, #56]
MAKE_REG_HELPER(daif)
    a0020edc:	f9401fe0 	ldr	x0, [sp, #56]
    a0020ee0:	d51b4220 	msr	daif, x0
    a0020ee4:	d503201f 	nop
}
    a0020ee8:	d503201f 	nop
}
    a0020eec:	d503201f 	nop

end:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_stack, push, stack, ret);

	return ret;
    a0020ef0:	b9409fe0 	ldr	w0, [sp, #156]
}
    a0020ef4:	a8ca7bfd 	ldp	x29, x30, [sp], #160
    a0020ef8:	d65f03c0 	ret

00000000a0020efc <z_vrfy_k_stack_push>:

#ifdef CONFIG_USERSPACE
static inline int z_vrfy_k_stack_push(struct k_stack *stack, stack_data_t data)
{
    a0020efc:	a9a77bfd 	stp	x29, x30, [sp, #-400]!
    a0020f00:	910003fd 	mov	x29, sp
    a0020f04:	f9000fe0 	str	x0, [sp, #24]
    a0020f08:	f9000be1 	str	x1, [sp, #16]
	Z_OOPS(Z_SYSCALL_OBJ(stack, K_OBJ_STACK));
    a0020f0c:	f9400fe0 	ldr	x0, [sp, #24]
    a0020f10:	97ffeec6 	bl	a001ca28 <z_object_find>
    a0020f14:	52800003 	mov	w3, #0x0                   	// #0
    a0020f18:	52800102 	mov	w2, #0x8                   	// #8
    a0020f1c:	f9400fe1 	ldr	x1, [sp, #24]
    a0020f20:	97fffefe 	bl	a0020b18 <z_obj_validation_check>
    a0020f24:	7100001f 	cmp	w0, #0x0
    a0020f28:	1a9f07e0 	cset	w0, ne  // ne = any
    a0020f2c:	39063fe0 	strb	w0, [sp, #399]
    a0020f30:	39463fe0 	ldrb	w0, [sp, #399]
    a0020f34:	7100001f 	cmp	w0, #0x0
    a0020f38:	39463fe0 	ldrb	w0, [sp, #399]
    a0020f3c:	7100001f 	cmp	w0, #0x0
    a0020f40:	540000c0 	b.eq	a0020f58 <z_vrfy_k_stack_push+0x5c>  // b.none
    a0020f44:	f0000120 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0020f48:	913f8000 	add	x0, x0, #0xfe0
    a0020f4c:	f9400800 	ldr	x0, [x0, #16]
    a0020f50:	f9408400 	ldr	x0, [x0, #264]
    a0020f54:	97ffa081 	bl	a0009158 <arch_syscall_oops>

	return z_impl_k_stack_push(stack, data);
    a0020f58:	f9400be1 	ldr	x1, [sp, #16]
    a0020f5c:	f9400fe0 	ldr	x0, [sp, #24]
    a0020f60:	97ffff92 	bl	a0020da8 <z_impl_k_stack_push>
}
    a0020f64:	a8d97bfd 	ldp	x29, x30, [sp], #400
    a0020f68:	d65f03c0 	ret

00000000a0020f6c <z_mrsh_k_stack_push>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_stack_push(struct k_stack * stack, stack_data_t data);
uintptr_t z_mrsh_k_stack_push(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a0020f6c:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a0020f70:	910003fd 	mov	x29, sp
    a0020f74:	f90027e0 	str	x0, [sp, #72]
    a0020f78:	f90023e1 	str	x1, [sp, #64]
    a0020f7c:	f9001fe2 	str	x2, [sp, #56]
    a0020f80:	f9001be3 	str	x3, [sp, #48]
    a0020f84:	f90017e4 	str	x4, [sp, #40]
    a0020f88:	f90013e5 	str	x5, [sp, #32]
    a0020f8c:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a0020f90:	f0000120 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0020f94:	913f8000 	add	x0, x0, #0xfe0
    a0020f98:	f9400800 	ldr	x0, [x0, #16]
    a0020f9c:	f9400fe1 	ldr	x1, [sp, #24]
    a0020fa0:	f9008401 	str	x1, [x0, #264]
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_stack_push(*(struct k_stack **)&arg0, *(stack_data_t*)&arg1)
    a0020fa4:	910123e0 	add	x0, sp, #0x48
    a0020fa8:	f9400002 	ldr	x2, [x0]
    a0020fac:	910103e0 	add	x0, sp, #0x40
    a0020fb0:	f9400000 	ldr	x0, [x0]
    a0020fb4:	aa0003e1 	mov	x1, x0
    a0020fb8:	aa0203e0 	mov	x0, x2
    a0020fbc:	97ffffd0 	bl	a0020efc <z_vrfy_k_stack_push>
    a0020fc0:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a0020fc4:	f0000120 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0020fc8:	913f8000 	add	x0, x0, #0xfe0
    a0020fcc:	f9400800 	ldr	x0, [x0, #16]
    a0020fd0:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a0020fd4:	b9805fe0 	ldrsw	x0, [sp, #92]
}
    a0020fd8:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a0020fdc:	d65f03c0 	ret

00000000a0020fe0 <z_impl_k_stack_pop>:
#include <syscalls/k_stack_push_mrsh.c>
#endif

int z_impl_k_stack_pop(struct k_stack *stack, stack_data_t *data,
		       k_timeout_t timeout)
{
    a0020fe0:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
    a0020fe4:	910003fd 	mov	x29, sp
    a0020fe8:	f90017e0 	str	x0, [sp, #40]
    a0020fec:	f90013e1 	str	x1, [sp, #32]
    a0020ff0:	f9000fe2 	str	x2, [sp, #24]
	k_spinlock_key_t key;
	int result;

	key = k_spin_lock(&stack->lock);
    a0020ff4:	f94017e0 	ldr	x0, [sp, #40]
    a0020ff8:	91004000 	add	x0, x0, #0x10
    a0020ffc:	f9004be0 	str	x0, [sp, #144]
    a0021000:	d53b4220 	mrs	x0, daif
    a0021004:	f90047e0 	str	x0, [sp, #136]
    a0021008:	f94047e0 	ldr	x0, [sp, #136]
    a002100c:	d503201f 	nop
	key = read_daif();
    a0021010:	b90087e0 	str	w0, [sp, #132]
	__asm__ volatile ("msr DAIFSet, %0"
    a0021014:	d50342df 	msr	daifset, #0x2
}
    a0021018:	d503201f 	nop
	return key;
    a002101c:	b94087e0 	ldr	w0, [sp, #132]
	k.key = arch_irq_lock();
    a0021020:	b9003be0 	str	w0, [sp, #56]
	return k;
    a0021024:	b9403be0 	ldr	w0, [sp, #56]
    a0021028:	b9004be0 	str	w0, [sp, #72]

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_stack, pop, stack, timeout);

	if (likely(stack->next > stack->base)) {
    a002102c:	f94017e0 	ldr	x0, [sp, #40]
    a0021030:	f9400c01 	ldr	x1, [x0, #24]
    a0021034:	f94017e0 	ldr	x0, [sp, #40]
    a0021038:	f9400800 	ldr	x0, [x0, #16]
    a002103c:	eb00003f 	cmp	x1, x0
    a0021040:	1a9f97e0 	cset	w0, hi  // hi = pmore
    a0021044:	12001c00 	and	w0, w0, #0xff
    a0021048:	92401c00 	and	x0, x0, #0xff
    a002104c:	f100001f 	cmp	x0, #0x0
    a0021050:	54000360 	b.eq	a00210bc <z_impl_k_stack_pop+0xdc>  // b.none
		stack->next--;
    a0021054:	f94017e0 	ldr	x0, [sp, #40]
    a0021058:	f9400c00 	ldr	x0, [x0, #24]
    a002105c:	d1002001 	sub	x1, x0, #0x8
    a0021060:	f94017e0 	ldr	x0, [sp, #40]
    a0021064:	f9000c01 	str	x1, [x0, #24]
		*data = *(stack->next);
    a0021068:	f94017e0 	ldr	x0, [sp, #40]
    a002106c:	f9400c00 	ldr	x0, [x0, #24]
    a0021070:	f9400001 	ldr	x1, [x0]
    a0021074:	f94013e0 	ldr	x0, [sp, #32]
    a0021078:	f9000001 	str	x1, [x0]
		k_spin_unlock(&stack->lock, key);
    a002107c:	f94017e0 	ldr	x0, [sp, #40]
    a0021080:	91004000 	add	x0, x0, #0x10
    a0021084:	f9003fe0 	str	x0, [sp, #120]
    a0021088:	b9404be0 	ldr	w0, [sp, #72]
    a002108c:	b90043e0 	str	w0, [sp, #64]
	arch_irq_unlock(key.key);
    a0021090:	b94043e0 	ldr	w0, [sp, #64]
    a0021094:	b90077e0 	str	w0, [sp, #116]
	write_daif(key);
    a0021098:	b94077e0 	ldr	w0, [sp, #116]
    a002109c:	f90037e0 	str	x0, [sp, #104]
MAKE_REG_HELPER(daif)
    a00210a0:	f94037e0 	ldr	x0, [sp, #104]
    a00210a4:	d51b4220 	msr	daif, x0
    a00210a8:	d503201f 	nop
}
    a00210ac:	d503201f 	nop
}
    a00210b0:	d503201f 	nop

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_stack, pop, stack, timeout, 0);

		return 0;
    a00210b4:	52800000 	mov	w0, #0x0                   	// #0
    a00210b8:	1400002a 	b	a0021160 <z_impl_k_stack_pop+0x180>
	}

	SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_stack, pop, stack, timeout);

	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    a00210bc:	f9400fe0 	ldr	x0, [sp, #24]
    a00210c0:	d2800001 	mov	x1, #0x0                   	// #0
    a00210c4:	eb01001f 	cmp	x0, x1
    a00210c8:	54000221 	b.ne	a002110c <z_impl_k_stack_pop+0x12c>  // b.any
		k_spin_unlock(&stack->lock, key);
    a00210cc:	f94017e0 	ldr	x0, [sp, #40]
    a00210d0:	91004000 	add	x0, x0, #0x10
    a00210d4:	f90033e0 	str	x0, [sp, #96]
    a00210d8:	b9404be0 	ldr	w0, [sp, #72]
    a00210dc:	b90033e0 	str	w0, [sp, #48]
	arch_irq_unlock(key.key);
    a00210e0:	b94033e0 	ldr	w0, [sp, #48]
    a00210e4:	b9005fe0 	str	w0, [sp, #92]
	write_daif(key);
    a00210e8:	b9405fe0 	ldr	w0, [sp, #92]
    a00210ec:	f9002be0 	str	x0, [sp, #80]
    a00210f0:	f9402be0 	ldr	x0, [sp, #80]
    a00210f4:	d51b4220 	msr	daif, x0
    a00210f8:	d503201f 	nop
}
    a00210fc:	d503201f 	nop
}
    a0021100:	d503201f 	nop

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_stack, pop, stack, timeout, -EBUSY);

		return -EBUSY;
    a0021104:	128001e0 	mov	w0, #0xfffffff0            	// #-16
    a0021108:	14000016 	b	a0021160 <z_impl_k_stack_pop+0x180>
	}

	result = z_pend_curr(&stack->lock, key, &stack->wait_q, timeout);
    a002110c:	f94017e0 	ldr	x0, [sp, #40]
    a0021110:	91004000 	add	x0, x0, #0x10
    a0021114:	f94017e1 	ldr	x1, [sp, #40]
    a0021118:	f9400fe3 	ldr	x3, [sp, #24]
    a002111c:	aa0103e2 	mov	x2, x1
    a0021120:	b9404be1 	ldr	w1, [sp, #72]
    a0021124:	97ffda7e 	bl	a0017b1c <z_pend_curr>
    a0021128:	b9009fe0 	str	w0, [sp, #156]
	if (result == -EAGAIN) {
    a002112c:	b9409fe0 	ldr	w0, [sp, #156]
    a0021130:	31002c1f 	cmn	w0, #0xb
    a0021134:	54000061 	b.ne	a0021140 <z_impl_k_stack_pop+0x160>  // b.any
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_stack, pop, stack, timeout, -EAGAIN);

		return -EAGAIN;
    a0021138:	12800140 	mov	w0, #0xfffffff5            	// #-11
    a002113c:	14000009 	b	a0021160 <z_impl_k_stack_pop+0x180>
	}

	*data = (stack_data_t)_current->base.swap_data;
    a0021140:	d0000120 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0021144:	913f8000 	add	x0, x0, #0xfe0
    a0021148:	f9400800 	ldr	x0, [x0, #16]
    a002114c:	f9401000 	ldr	x0, [x0, #32]
    a0021150:	aa0003e1 	mov	x1, x0
    a0021154:	f94013e0 	ldr	x0, [sp, #32]
    a0021158:	f9000001 	str	x1, [x0]

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_stack, pop, stack, timeout, 0);

	return 0;
    a002115c:	52800000 	mov	w0, #0x0                   	// #0
}
    a0021160:	a8ca7bfd 	ldp	x29, x30, [sp], #160
    a0021164:	d65f03c0 	ret

00000000a0021168 <z_vrfy_k_stack_pop>:

#ifdef CONFIG_USERSPACE
static inline int z_vrfy_k_stack_pop(struct k_stack *stack,
				     stack_data_t *data, k_timeout_t timeout)
{
    a0021168:	d10983ff 	sub	sp, sp, #0x260
    a002116c:	a9007bfd 	stp	x29, x30, [sp]
    a0021170:	910003fd 	mov	x29, sp
    a0021174:	f90017e0 	str	x0, [sp, #40]
    a0021178:	f90013e1 	str	x1, [sp, #32]
    a002117c:	f9000fe2 	str	x2, [sp, #24]
	Z_OOPS(Z_SYSCALL_OBJ(stack, K_OBJ_STACK));
    a0021180:	f94017e0 	ldr	x0, [sp, #40]
    a0021184:	97ffee29 	bl	a001ca28 <z_object_find>
    a0021188:	52800003 	mov	w3, #0x0                   	// #0
    a002118c:	52800102 	mov	w2, #0x8                   	// #8
    a0021190:	f94017e1 	ldr	x1, [sp, #40]
    a0021194:	97fffe61 	bl	a0020b18 <z_obj_validation_check>
    a0021198:	7100001f 	cmp	w0, #0x0
    a002119c:	1a9f07e0 	cset	w0, ne  // ne = any
    a00211a0:	39097be0 	strb	w0, [sp, #606]
    a00211a4:	39497be0 	ldrb	w0, [sp, #606]
    a00211a8:	7100001f 	cmp	w0, #0x0
    a00211ac:	39497be0 	ldrb	w0, [sp, #606]
    a00211b0:	7100001f 	cmp	w0, #0x0
    a00211b4:	540000c0 	b.eq	a00211cc <z_vrfy_k_stack_pop+0x64>  // b.none
    a00211b8:	d0000120 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00211bc:	913f8000 	add	x0, x0, #0xfe0
    a00211c0:	f9400800 	ldr	x0, [x0, #16]
    a00211c4:	f9408400 	ldr	x0, [x0, #264]
    a00211c8:	97ff9fe4 	bl	a0009158 <arch_syscall_oops>
	Z_OOPS(Z_SYSCALL_MEMORY_WRITE(data, sizeof(stack_data_t)));
    a00211cc:	52800022 	mov	w2, #0x1                   	// #1
    a00211d0:	d2800101 	mov	x1, #0x8                   	// #8
    a00211d4:	f94013e0 	ldr	x0, [sp, #32]
    a00211d8:	97ffa9a5 	bl	a000b86c <arch_buffer_validate>
    a00211dc:	7100001f 	cmp	w0, #0x0
    a00211e0:	1a9f07e0 	cset	w0, ne  // ne = any
    a00211e4:	39097fe0 	strb	w0, [sp, #607]
    a00211e8:	39497fe0 	ldrb	w0, [sp, #607]
    a00211ec:	7100001f 	cmp	w0, #0x0
    a00211f0:	39497fe0 	ldrb	w0, [sp, #607]
    a00211f4:	7100001f 	cmp	w0, #0x0
    a00211f8:	540000c0 	b.eq	a0021210 <z_vrfy_k_stack_pop+0xa8>  // b.none
    a00211fc:	d0000120 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0021200:	913f8000 	add	x0, x0, #0xfe0
    a0021204:	f9400800 	ldr	x0, [x0, #16]
    a0021208:	f9408400 	ldr	x0, [x0, #264]
    a002120c:	97ff9fd3 	bl	a0009158 <arch_syscall_oops>
	return z_impl_k_stack_pop(stack, data, timeout);
    a0021210:	f9400fe2 	ldr	x2, [sp, #24]
    a0021214:	f94013e1 	ldr	x1, [sp, #32]
    a0021218:	f94017e0 	ldr	x0, [sp, #40]
    a002121c:	97ffff71 	bl	a0020fe0 <z_impl_k_stack_pop>
}
    a0021220:	a9407bfd 	ldp	x29, x30, [sp]
    a0021224:	910983ff 	add	sp, sp, #0x260
    a0021228:	d65f03c0 	ret

00000000a002122c <z_mrsh_k_stack_pop>:
#include <syscalls/kernel.h>

extern int z_vrfy_k_stack_pop(struct k_stack * stack, stack_data_t * data, k_timeout_t timeout);
uintptr_t z_mrsh_k_stack_pop(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a002122c:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a0021230:	910003fd 	mov	x29, sp
    a0021234:	f90027e0 	str	x0, [sp, #72]
    a0021238:	f90023e1 	str	x1, [sp, #64]
    a002123c:	f9001fe2 	str	x2, [sp, #56]
    a0021240:	f9001be3 	str	x3, [sp, #48]
    a0021244:	f90017e4 	str	x4, [sp, #40]
    a0021248:	f90013e5 	str	x5, [sp, #32]
    a002124c:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a0021250:	d0000120 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0021254:	913f8000 	add	x0, x0, #0xfe0
    a0021258:	f9400800 	ldr	x0, [x0, #16]
    a002125c:	f9400fe1 	ldr	x1, [sp, #24]
    a0021260:	f9008401 	str	x1, [x0, #264]
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	int ret = z_vrfy_k_stack_pop(*(struct k_stack **)&arg0, *(stack_data_t **)&arg1, *(k_timeout_t*)&arg2)
    a0021264:	910123e0 	add	x0, sp, #0x48
    a0021268:	f9400003 	ldr	x3, [x0]
    a002126c:	910103e0 	add	x0, sp, #0x40
    a0021270:	f9400001 	ldr	x1, [x0]
    a0021274:	9100e3e0 	add	x0, sp, #0x38
    a0021278:	f9400002 	ldr	x2, [x0]
    a002127c:	aa0303e0 	mov	x0, x3
    a0021280:	97ffffba 	bl	a0021168 <z_vrfy_k_stack_pop>
    a0021284:	b9005fe0 	str	w0, [sp, #92]
;
	_current->syscall_frame = NULL;
    a0021288:	d0000120 	adrp	x0, a0047000 <data_compute+0x7df0>
    a002128c:	913f8000 	add	x0, x0, #0xfe0
    a0021290:	f9400800 	ldr	x0, [x0, #16]
    a0021294:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a0021298:	b9805fe0 	ldrsw	x0, [sp, #92]
}
    a002129c:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a00212a0:	d65f03c0 	ret

00000000a00212a4 <z_obj_validation_check>:
{
    a00212a4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    a00212a8:	910003fd 	mov	x29, sp
    a00212ac:	f90017e0 	str	x0, [sp, #40]
    a00212b0:	f90013e1 	str	x1, [sp, #32]
    a00212b4:	b9001fe2 	str	w2, [sp, #28]
    a00212b8:	b9001be3 	str	w3, [sp, #24]
	ret = z_object_validate(ko, otype, init);
    a00212bc:	b9401be2 	ldr	w2, [sp, #24]
    a00212c0:	b9401fe1 	ldr	w1, [sp, #28]
    a00212c4:	f94017e0 	ldr	x0, [sp, #40]
    a00212c8:	97ffefff 	bl	a001d2c4 <z_object_validate>
    a00212cc:	b9003fe0 	str	w0, [sp, #60]
	return ret;
    a00212d0:	b9403fe0 	ldr	w0, [sp, #60]
}
    a00212d4:	a8c47bfd 	ldp	x29, x30, [sp], #64
    a00212d8:	d65f03c0 	ret

00000000a00212dc <validate_any_object>:
#include <kernel.h>
#include <syscall_handler.h>
#include <kernel_structs.h>

static struct z_object *validate_any_object(const void *obj)
{
    a00212dc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a00212e0:	910003fd 	mov	x29, sp
    a00212e4:	f9000fe0 	str	x0, [sp, #24]
	struct z_object *ko;
	int ret;

	ko = z_object_find(obj);
    a00212e8:	f9400fe0 	ldr	x0, [sp, #24]
    a00212ec:	97ffedcf 	bl	a001ca28 <z_object_find>
    a00212f0:	f90017e0 	str	x0, [sp, #40]

	/* This can be any kernel object and it doesn't have to be
	 * initialized
	 */
	ret = z_object_validate(ko, K_OBJ_ANY, _OBJ_INIT_ANY);
    a00212f4:	52800022 	mov	w2, #0x1                   	// #1
    a00212f8:	52800001 	mov	w1, #0x0                   	// #0
    a00212fc:	f94017e0 	ldr	x0, [sp, #40]
    a0021300:	97ffeff1 	bl	a001d2c4 <z_object_validate>
    a0021304:	b90027e0 	str	w0, [sp, #36]
	if (ret != 0) {
    a0021308:	b94027e0 	ldr	w0, [sp, #36]
    a002130c:	7100001f 	cmp	w0, #0x0
    a0021310:	54000060 	b.eq	a002131c <validate_any_object+0x40>  // b.none
#ifdef CONFIG_LOG
		z_dump_object_error(ret, obj, ko, K_OBJ_ANY);
#endif
		return NULL;
    a0021314:	d2800000 	mov	x0, #0x0                   	// #0
    a0021318:	14000002 	b	a0021320 <validate_any_object+0x44>
	}

	return ko;
    a002131c:	f94017e0 	ldr	x0, [sp, #40]
}
    a0021320:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0021324:	d65f03c0 	ret

00000000a0021328 <z_vrfy_k_object_access_grant>:
 * To avoid double z_object_find() lookups, we don't call the implementation
 * function, but call a level deeper.
 */
static inline void z_vrfy_k_object_access_grant(const void *object,
						struct k_thread *thread)
{
    a0021328:	d10843ff 	sub	sp, sp, #0x210
    a002132c:	a9007bfd 	stp	x29, x30, [sp]
    a0021330:	910003fd 	mov	x29, sp
    a0021334:	f9000fe0 	str	x0, [sp, #24]
    a0021338:	f9000be1 	str	x1, [sp, #16]
	struct z_object *ko;

	Z_OOPS(Z_SYSCALL_OBJ_INIT(thread, K_OBJ_THREAD));
    a002133c:	f9400be0 	ldr	x0, [sp, #16]
    a0021340:	97ffedba 	bl	a001ca28 <z_object_find>
    a0021344:	52800023 	mov	w3, #0x1                   	// #1
    a0021348:	52800122 	mov	w2, #0x9                   	// #9
    a002134c:	f9400be1 	ldr	x1, [sp, #16]
    a0021350:	97ffffd5 	bl	a00212a4 <z_obj_validation_check>
    a0021354:	7100001f 	cmp	w0, #0x0
    a0021358:	1a9f07e0 	cset	w0, ne  // ne = any
    a002135c:	39081be0 	strb	w0, [sp, #518]
    a0021360:	39481be0 	ldrb	w0, [sp, #518]
    a0021364:	7100001f 	cmp	w0, #0x0
    a0021368:	39481be0 	ldrb	w0, [sp, #518]
    a002136c:	7100001f 	cmp	w0, #0x0
    a0021370:	540000c0 	b.eq	a0021388 <z_vrfy_k_object_access_grant+0x60>  // b.none
    a0021374:	d0000120 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0021378:	913f8000 	add	x0, x0, #0xfe0
    a002137c:	f9400800 	ldr	x0, [x0, #16]
    a0021380:	f9408400 	ldr	x0, [x0, #264]
    a0021384:	97ff9f75 	bl	a0009158 <arch_syscall_oops>
	ko = validate_any_object(object);
    a0021388:	f9400fe0 	ldr	x0, [sp, #24]
    a002138c:	97ffffd4 	bl	a00212dc <validate_any_object>
    a0021390:	f90107e0 	str	x0, [sp, #520]
	Z_OOPS(Z_SYSCALL_VERIFY_MSG(ko != NULL, "object %p access denied",
    a0021394:	f94107e0 	ldr	x0, [sp, #520]
    a0021398:	f100001f 	cmp	x0, #0x0
    a002139c:	1a9f17e0 	cset	w0, eq  // eq = none
    a00213a0:	39081fe0 	strb	w0, [sp, #519]
    a00213a4:	39481fe0 	ldrb	w0, [sp, #519]
    a00213a8:	7100001f 	cmp	w0, #0x0
    a00213ac:	39481fe0 	ldrb	w0, [sp, #519]
    a00213b0:	7100001f 	cmp	w0, #0x0
    a00213b4:	540000c0 	b.eq	a00213cc <z_vrfy_k_object_access_grant+0xa4>  // b.none
    a00213b8:	d0000120 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00213bc:	913f8000 	add	x0, x0, #0xfe0
    a00213c0:	f9400800 	ldr	x0, [x0, #16]
    a00213c4:	f9408400 	ldr	x0, [x0, #264]
    a00213c8:	97ff9f64 	bl	a0009158 <arch_syscall_oops>
				    object));
	z_thread_perms_set(ko, thread);
    a00213cc:	f9400be1 	ldr	x1, [sp, #16]
    a00213d0:	f94107e0 	ldr	x0, [sp, #520]
    a00213d4:	97ffef04 	bl	a001cfe4 <z_thread_perms_set>
}
    a00213d8:	d503201f 	nop
    a00213dc:	a9407bfd 	ldp	x29, x30, [sp]
    a00213e0:	910843ff 	add	sp, sp, #0x210
    a00213e4:	d65f03c0 	ret

00000000a00213e8 <z_mrsh_k_object_access_grant>:
#include <syscalls/kobject.h>

extern void z_vrfy_k_object_access_grant(const void * object, struct k_thread * thread);
uintptr_t z_mrsh_k_object_access_grant(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a00213e8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a00213ec:	910003fd 	mov	x29, sp
    a00213f0:	f90027e0 	str	x0, [sp, #72]
    a00213f4:	f90023e1 	str	x1, [sp, #64]
    a00213f8:	f9001fe2 	str	x2, [sp, #56]
    a00213fc:	f9001be3 	str	x3, [sp, #48]
    a0021400:	f90017e4 	str	x4, [sp, #40]
    a0021404:	f90013e5 	str	x5, [sp, #32]
    a0021408:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a002140c:	d0000120 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0021410:	913f8000 	add	x0, x0, #0xfe0
    a0021414:	f9400800 	ldr	x0, [x0, #16]
    a0021418:	f9400fe1 	ldr	x1, [sp, #24]
    a002141c:	f9008401 	str	x1, [x0, #264]
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_object_access_grant(*(const void **)&arg0, *(struct k_thread **)&arg1)
    a0021420:	910123e0 	add	x0, sp, #0x48
    a0021424:	f9400002 	ldr	x2, [x0]
    a0021428:	910103e0 	add	x0, sp, #0x40
    a002142c:	f9400000 	ldr	x0, [x0]
    a0021430:	aa0003e1 	mov	x1, x0
    a0021434:	aa0203e0 	mov	x0, x2
    a0021438:	97ffffbc 	bl	a0021328 <z_vrfy_k_object_access_grant>
;
	_current->syscall_frame = NULL;
    a002143c:	d0000120 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0021440:	913f8000 	add	x0, x0, #0xfe0
    a0021444:	f9400800 	ldr	x0, [x0, #16]
    a0021448:	f900841f 	str	xzr, [x0, #264]
	return 0;
    a002144c:	d2800000 	mov	x0, #0x0                   	// #0
}
    a0021450:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a0021454:	d65f03c0 	ret

00000000a0021458 <z_vrfy_k_object_release>:
#include <syscalls/k_object_access_grant_mrsh.c>

static inline void z_vrfy_k_object_release(const void *object)
{
    a0021458:	a9a57bfd 	stp	x29, x30, [sp, #-432]!
    a002145c:	910003fd 	mov	x29, sp
    a0021460:	f9000fe0 	str	x0, [sp, #24]
	struct z_object *ko;

	ko = validate_any_object((void *)object);
    a0021464:	f9400fe0 	ldr	x0, [sp, #24]
    a0021468:	97ffff9d 	bl	a00212dc <validate_any_object>
    a002146c:	f900d3e0 	str	x0, [sp, #416]
	Z_OOPS(Z_SYSCALL_VERIFY_MSG(ko != NULL, "object %p access denied",
    a0021470:	f940d3e0 	ldr	x0, [sp, #416]
    a0021474:	f100001f 	cmp	x0, #0x0
    a0021478:	1a9f17e0 	cset	w0, eq  // eq = none
    a002147c:	3906bfe0 	strb	w0, [sp, #431]
    a0021480:	3946bfe0 	ldrb	w0, [sp, #431]
    a0021484:	7100001f 	cmp	w0, #0x0
    a0021488:	3946bfe0 	ldrb	w0, [sp, #431]
    a002148c:	7100001f 	cmp	w0, #0x0
    a0021490:	540000c0 	b.eq	a00214a8 <z_vrfy_k_object_release+0x50>  // b.none
    a0021494:	d0000120 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0021498:	913f8000 	add	x0, x0, #0xfe0
    a002149c:	f9400800 	ldr	x0, [x0, #16]
    a00214a0:	f9408400 	ldr	x0, [x0, #264]
    a00214a4:	97ff9f2d 	bl	a0009158 <arch_syscall_oops>
				    (void *)object));
	z_thread_perms_clear(ko, _current);
    a00214a8:	d0000120 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00214ac:	913f8000 	add	x0, x0, #0xfe0
    a00214b0:	f9400800 	ldr	x0, [x0, #16]
    a00214b4:	aa0003e1 	mov	x1, x0
    a00214b8:	f940d3e0 	ldr	x0, [sp, #416]
    a00214bc:	97ffeef4 	bl	a001d08c <z_thread_perms_clear>
}
    a00214c0:	d503201f 	nop
    a00214c4:	a8db7bfd 	ldp	x29, x30, [sp], #432
    a00214c8:	d65f03c0 	ret

00000000a00214cc <z_mrsh_k_object_release>:
#include <syscalls/kobject.h>

extern void z_vrfy_k_object_release(const void * object);
uintptr_t z_mrsh_k_object_release(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a00214cc:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    a00214d0:	910003fd 	mov	x29, sp
    a00214d4:	f90027e0 	str	x0, [sp, #72]
    a00214d8:	f90023e1 	str	x1, [sp, #64]
    a00214dc:	f9001fe2 	str	x2, [sp, #56]
    a00214e0:	f9001be3 	str	x3, [sp, #48]
    a00214e4:	f90017e4 	str	x4, [sp, #40]
    a00214e8:	f90013e5 	str	x5, [sp, #32]
    a00214ec:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a00214f0:	d0000120 	adrp	x0, a0047000 <data_compute+0x7df0>
    a00214f4:	913f8000 	add	x0, x0, #0xfe0
    a00214f8:	f9400800 	ldr	x0, [x0, #16]
    a00214fc:	f9400fe1 	ldr	x1, [sp, #24]
    a0021500:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	z_vrfy_k_object_release(*(const void **)&arg0)
    a0021504:	910123e0 	add	x0, sp, #0x48
    a0021508:	f9400000 	ldr	x0, [x0]
    a002150c:	97ffffd3 	bl	a0021458 <z_vrfy_k_object_release>
;
	_current->syscall_frame = NULL;
    a0021510:	d0000120 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0021514:	913f8000 	add	x0, x0, #0xfe0
    a0021518:	f9400800 	ldr	x0, [x0, #16]
    a002151c:	f900841f 	str	xzr, [x0, #264]
	return 0;
    a0021520:	d2800000 	mov	x0, #0x0                   	// #0
}
    a0021524:	a8c57bfd 	ldp	x29, x30, [sp], #80
    a0021528:	d65f03c0 	ret

00000000a002152c <z_vrfy_k_object_alloc>:
#include <syscalls/k_object_release_mrsh.c>

static inline void *z_vrfy_k_object_alloc(enum k_objects otype)
{
    a002152c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    a0021530:	910003fd 	mov	x29, sp
    a0021534:	b9001fe0 	str	w0, [sp, #28]
	return z_impl_k_object_alloc(otype);
    a0021538:	b9401fe0 	ldr	w0, [sp, #28]
    a002153c:	97ffece3 	bl	a001c8c8 <z_impl_k_object_alloc>
}
    a0021540:	a8c27bfd 	ldp	x29, x30, [sp], #32
    a0021544:	d65f03c0 	ret

00000000a0021548 <z_mrsh_k_object_alloc>:
#include <syscalls/kobject.h>

extern void * z_vrfy_k_object_alloc(enum k_objects otype);
uintptr_t z_mrsh_k_object_alloc(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
		uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, void *ssf)
{
    a0021548:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    a002154c:	910003fd 	mov	x29, sp
    a0021550:	f90027e0 	str	x0, [sp, #72]
    a0021554:	f90023e1 	str	x1, [sp, #64]
    a0021558:	f9001fe2 	str	x2, [sp, #56]
    a002155c:	f9001be3 	str	x3, [sp, #48]
    a0021560:	f90017e4 	str	x4, [sp, #40]
    a0021564:	f90013e5 	str	x5, [sp, #32]
    a0021568:	f9000fe6 	str	x6, [sp, #24]
	_current->syscall_frame = ssf;
    a002156c:	d0000120 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0021570:	913f8000 	add	x0, x0, #0xfe0
    a0021574:	f9400800 	ldr	x0, [x0, #16]
    a0021578:	f9400fe1 	ldr	x1, [sp, #24]
    a002157c:	f9008401 	str	x1, [x0, #264]
	(void) arg1;	/* unused */
	(void) arg2;	/* unused */
	(void) arg3;	/* unused */
	(void) arg4;	/* unused */
	(void) arg5;	/* unused */
	void * ret = z_vrfy_k_object_alloc(*(enum k_objects*)&arg0)
    a0021580:	910123e0 	add	x0, sp, #0x48
    a0021584:	b9400000 	ldr	w0, [x0]
    a0021588:	97ffffe9 	bl	a002152c <z_vrfy_k_object_alloc>
    a002158c:	f9002fe0 	str	x0, [sp, #88]
;
	_current->syscall_frame = NULL;
    a0021590:	d0000120 	adrp	x0, a0047000 <data_compute+0x7df0>
    a0021594:	913f8000 	add	x0, x0, #0xfe0
    a0021598:	f9400800 	ldr	x0, [x0, #16]
    a002159c:	f900841f 	str	xzr, [x0, #264]
	return (uintptr_t) ret;
    a00215a0:	f9402fe0 	ldr	x0, [sp, #88]
}
    a00215a4:	a8c67bfd 	ldp	x29, x30, [sp], #96
    a00215a8:	d65f03c0 	ret

00000000a00215ac <z_object_gperf_find>:
    a00215ac:	d3483c02 	ubfx	x2, x0, #8, #8
    a00215b0:	90000021 	adrp	x1, a0025000 <_k_syscall_table+0x7c8>
    a00215b4:	910d7021 	add	x1, x1, #0x35c
    a00215b8:	38626822 	ldrb	w2, [x1, x2]
    a00215bc:	71000c5f 	cmp	w2, #0x3
    a00215c0:	54000188 	b.hi	a00215f0 <z_object_gperf_find+0x44>  // b.pmore
    a00215c4:	93407c43 	sxtw	x3, w2
    a00215c8:	d2800284 	mov	x4, #0x14                  	// #20
    a00215cc:	d00003c1 	adrp	x1, a009b000 <twom1000.10>
    a00215d0:	9102d021 	add	x1, x1, #0xb4
    a00215d4:	9ba47c42 	umull	x2, w2, w4
    a00215d8:	9b047c63 	mul	x3, x3, x4
    a00215dc:	f8636823 	ldr	x3, [x1, x3]
    a00215e0:	8b020021 	add	x1, x1, x2
    a00215e4:	eb03001f 	cmp	x0, x3
    a00215e8:	9a9f0020 	csel	x0, x1, xzr, eq  // eq = none
    a00215ec:	d65f03c0 	ret
    a00215f0:	d2800000 	mov	x0, #0x0                   	// #0
    a00215f4:	17fffffe 	b	a00215ec <z_object_gperf_find+0x40>

00000000a00215f8 <z_object_gperf_wordlist_foreach>:
    a00215f8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    a00215fc:	910003fd 	mov	x29, sp
    a0021600:	a90153f3 	stp	x19, x20, [sp, #16]
    a0021604:	d00003d3 	adrp	x19, a009b000 <twom1000.10>
    a0021608:	9102d273 	add	x19, x19, #0xb4
    a002160c:	a9025bf5 	stp	x21, x22, [sp, #32]
    a0021610:	aa0003f5 	mov	x21, x0
    a0021614:	aa0103f6 	mov	x22, x1
    a0021618:	52800094 	mov	w20, #0x4                   	// #4
    a002161c:	f9400260 	ldr	x0, [x19]
    a0021620:	b4000080 	cbz	x0, a0021630 <z_object_gperf_wordlist_foreach+0x38>
    a0021624:	aa1603e1 	mov	x1, x22
    a0021628:	aa1303e0 	mov	x0, x19
    a002162c:	d63f02a0 	blr	x21
    a0021630:	91005273 	add	x19, x19, #0x14
    a0021634:	71000694 	subs	w20, w20, #0x1
    a0021638:	54ffff21 	b.ne	a002161c <z_object_gperf_wordlist_foreach+0x24>  // b.any
    a002163c:	a94153f3 	ldp	x19, x20, [sp, #16]
    a0021640:	a9425bf5 	ldp	x21, x22, [sp, #32]
    a0021644:	a8c37bfd 	ldp	x29, x30, [sp], #48
    a0021648:	d65f03c0 	ret

00000000a002164c <_kobject_text_area_end>:
	...
